---
title: Uso avanzado de las tablas de descriptores
description: En las secciones siguientes se proporciona información sobre el uso avanzado de las tablas de descriptores.
ms.assetid: BB0CA29C-65CB-48B1-8351-EE13CC470B54
ms.date: 05/31/2018
ms.localizationpriority: high
ms.topic: article
ms.openlocfilehash: 79dad6914cff07726c2d40ed2ee27cccb6a0cf1e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104423"
---
# <a name="advanced-use-of-descriptor-tables"></a><span data-ttu-id="051b4-103">Uso avanzado de las tablas de descriptores</span><span class="sxs-lookup"><span data-stu-id="051b4-103">Advanced use of Descriptor Tables</span></span>

<span data-ttu-id="051b4-104">En las secciones siguientes se proporciona información sobre el uso avanzado de las tablas de descriptores.</span><span class="sxs-lookup"><span data-stu-id="051b4-104">The following sections provide information about the advanced use of descriptor tables.</span></span>

-   [<span data-ttu-id="051b4-105">Cambiar las entradas de la tabla de descriptores entre las llamadas de representación</span><span class="sxs-lookup"><span data-stu-id="051b4-105">Changing Descriptor Table Entries between Rendering Calls</span></span>](#changing-descriptor-table-entries-between-rendering-calls)
-   [<span data-ttu-id="051b4-106">Indexación fuera de los límites</span><span class="sxs-lookup"><span data-stu-id="051b4-106">Out of Bounds Indexing</span></span>](#out-of-bounds-indexing)
-   [<span data-ttu-id="051b4-107">Derivados del sombreador e indexación divergente</span><span class="sxs-lookup"><span data-stu-id="051b4-107">Shader Derivatives and Divergent Indexing</span></span>](#shader-derivatives-and-divergent-indexing)
-   [<span data-ttu-id="051b4-108">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="051b4-108">Related topics</span></span>](#related-topics)

## <a name="changing-descriptor-table-entries-between-rendering-calls"></a><span data-ttu-id="051b4-109">Cambiar las entradas de la tabla de descriptores entre las llamadas de representación</span><span class="sxs-lookup"><span data-stu-id="051b4-109">Changing Descriptor Table Entries between Rendering Calls</span></span>

<span data-ttu-id="051b4-110">Una vez que el comando muestra una lista de las tablas de descriptores establecidas en una cola para su ejecución, la aplicación no debe editar desde la CPU las partes de los montones descriptores a los que puede hacer referencia la GPU hasta que la aplicación sepa que la GPU ha terminado de usar las referencias.</span><span class="sxs-lookup"><span data-stu-id="051b4-110">After command lists that set descriptor tables have been submitted to a queue for execution, the application must not edit from the CPU the portions of descriptor heaps that the GPU might reference until the application knows that the GPU has finished using the references.</span></span>

<span data-ttu-id="051b4-111">La finalización del trabajo se puede determinar en un estrecho límite mediante las barreras de API para realizar un seguimiento del progreso de la GPU, o mecanismos más generales como esperar para ver que se ha enviado la representación a la pantalla, lo que se adapte a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="051b4-111">Work completion can be determined at a tight bound using API fences for tracking GPU progress, or more coarse mechanisms like waiting to see that rendering has been sent to display - whatever suits the application.</span></span> <span data-ttu-id="051b4-112">Si una aplicación sabe que solo se tendrá acceso a un subconjunto de la región a la que apunta una tabla de descriptores (por ejemplo, debido al control de flujo en el sombreador), los otros descriptores sin referencia todavía se pueden cambiar.</span><span class="sxs-lookup"><span data-stu-id="051b4-112">If an application knows that only a subset of the region a descriptor table points to will be accessed (say due to flow control in the shader), the other unreferenced descriptors are still free to be changed.</span></span> <span data-ttu-id="051b4-113">Si una aplicación necesita cambiar entre diferentes tablas de descriptores entre las llamadas de representación, existen varios enfoques entre los que la aplicación puede elegir:</span><span class="sxs-lookup"><span data-stu-id="051b4-113">If an application needs to switch between different descriptor tables between rendering calls, there are a few approaches the application can choose from:</span></span>

-   <span data-ttu-id="051b4-114">Control de versiones de tabla de descriptor: crear (o reutilizar) una tabla de descriptores independiente para cada colección de descriptores única a la que se va a hacer referencia mediante una lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="051b4-114">Descriptor Table Versioning: Create (or reuse) a separate descriptor table for every unique collection of descriptors that is to be referenced by a command list.</span></span> <span data-ttu-id="051b4-115">Al editar y volver a usar áreas previamente rellenadas en montones de descriptores, las aplicaciones deben asegurarse primero de que la GPU ha terminado de usar cualquier parte de un montón de descriptores que se recicle.</span><span class="sxs-lookup"><span data-stu-id="051b4-115">When editing and reusing previously populated areas on descriptor heaps, applications must first ensure that the GPU has finished using any portion of a descriptor heap that will be recycled.</span></span>
-   <span data-ttu-id="051b4-116">Indexación dinámica: las aplicaciones pueden organizar objetos que varíen en Draw/dispatch (o incluso variar dentro de un dibujo) en un intervalo de un montón de descriptores, definir una tabla de descriptores que abarque todos ellos y, desde el sombreador, usar la indexación dinámica de la tabla durante la ejecución del sombreador para seleccionar el objeto que se va a usar.</span><span class="sxs-lookup"><span data-stu-id="051b4-116">Dynamic Indexing: Applications can arrange objects that vary across draw/dispatch (or even vary within a draw) in a range of a descriptor heap, define a descriptor table that spans all of them, and from the shader, use dynamic indexing of the table during shader execution to select which object to use.</span></span>
-   <span data-ttu-id="051b4-117">Colocar los descriptores en la firma raíz directamente.</span><span class="sxs-lookup"><span data-stu-id="051b4-117">Putting descriptors in the root signature directly.</span></span> <span data-ttu-id="051b4-118">Solo se puede administrar un número muy pequeño de descriptores de esta manera, ya que el espacio de la firma raíz es limitado.</span><span class="sxs-lookup"><span data-stu-id="051b4-118">Only a very small number of descriptors can be managed this way because root signature space is limited.</span></span>

<span data-ttu-id="051b4-119">La implicación de usar el control de versiones de la tabla de descriptores es que la memoria de descriptor de un montón de descriptores debe grabarse a través de cada conjunto de descriptores único al que se hace referencia en la canalización de gráficos para cada lista de comandos que se puede ejecutar, poner en cola para su ejecución o grabarse en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="051b4-119">The implication of using descriptor table versioning is that descriptor memory out of a descriptor heap must be burned through for every unique set of descriptors referenced by the graphics pipeline for every command list that could be either executing, queued for execution, or being recorded at any given time.</span></span>

<span data-ttu-id="051b4-120">D3D12 deja la responsabilidad de administrar el control de versiones en la aplicación para los tipos de objeto administrados mediante montones de descriptor y tablas de descriptores.</span><span class="sxs-lookup"><span data-stu-id="051b4-120">D3D12 leaves the responsibility of managing versioning to the application for the object types managed via descriptor heaps and descriptor tables.</span></span> <span data-ttu-id="051b4-121">Una ventaja de esto es que las aplicaciones pueden optar por reutilizar el contenido de la tabla de descriptores lo máximo posible en lugar de definir siempre una nueva versión de la tabla de descriptores para cada envío de la lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="051b4-121">One benefit of this is that applications can choose to reuse descriptor table contents as much as possible rather than always defining a new descriptor table version for every command list submission.</span></span> <span data-ttu-id="051b4-122">La firma raíz es un espacio que el controlador D3D12 de forma automática.</span><span class="sxs-lookup"><span data-stu-id="051b4-122">The root signature is a space that the D3D12 driver automatically versions.</span></span>

<span data-ttu-id="051b4-123">La capacidad de enlazar varias tablas de descriptores a la firma raíz (y, por tanto, a la canalización) a la vez permite a las aplicaciones agrupar y cambiar conjuntos de referencias de descriptores en diferentes frecuencias si se desea.</span><span class="sxs-lookup"><span data-stu-id="051b4-123">The ability to bind multiple descriptor tables to the root signature (and thus to the pipeline) at a time allows applications to group and switch sets of descriptor references at different frequencies if desired.</span></span> <span data-ttu-id="051b4-124">Por ejemplo, una aplicación podría usar un número pequeño (quizás solo uno) de grandes tablas de descriptores estáticos que rara vez cambian, o en qué regiones de la memoria del montón del descriptor subyacente se están llenando según sea necesario, con el uso de la indexación dinámica del sombreador para seleccionar las texturas.</span><span class="sxs-lookup"><span data-stu-id="051b4-124">For example, an application could use a small number (perhaps just one) of large static descriptor tables that rarely change, or in which regions in the underlying descriptor heap memory are being populated as needed, with the use of dynamic indexing from the shader to select textures.</span></span> <span data-ttu-id="051b4-125">Al mismo tiempo, la aplicación podría mantener otra clase de recursos en los que el conjunto al que hace referencia cada llamada a Draw se cambie de la CPU mediante la técnica de control de versiones de la tabla de descriptores.</span><span class="sxs-lookup"><span data-stu-id="051b4-125">At the same time, the application could maintain another class of resources where the set referenced by each draw call is switched from the CPU using the descriptor table versioning technique.</span></span>

## <a name="out-of-bounds-indexing"></a><span data-ttu-id="051b4-126">Indexación fuera de los límites</span><span class="sxs-lookup"><span data-stu-id="051b4-126">Out of Bounds Indexing</span></span>

<span data-ttu-id="051b4-127">Fuera de los límites, la indización de cualquier tabla de descriptores del sombreador da como resultado un acceso a memoria en gran medida, lo que incluye la posibilidad de leer la memoria en proceso arbitraria como si fuera un descriptor de estado de hardware y vivir con la consecuencia de lo que hace el hardware.</span><span class="sxs-lookup"><span data-stu-id="051b4-127">Out of bounds indexing of any descriptor table from the shader results in a largely undefined memory access, including the possibility of reading arbitrary in-process memory as if it is a hardware state descriptor and living with the consequence of what the hardware does with that.</span></span> <span data-ttu-id="051b4-128">Esto podría producir un restablecimiento del dispositivo, pero no bloqueará Windows.</span><span class="sxs-lookup"><span data-stu-id="051b4-128">This could produce a device reset, but will not crash Windows.</span></span>

## <a name="shader-derivatives-and-divergent-indexing"></a><span data-ttu-id="051b4-129">Derivados del sombreador e indexación divergente</span><span class="sxs-lookup"><span data-stu-id="051b4-129">Shader Derivatives and Divergent Indexing</span></span>

<span data-ttu-id="051b4-130">Si las invocaciones del sombreador de píxeles que se ejecutan en una marca de 2x2 (para admitir cálculos derivados) eligen índices de textura diferentes para muestrear de una tabla de descriptores, además, si la configuración de muestra seleccionada y la textura de un píxel determinado requieren un cálculo de LOD de derivados de coordenadas de textura, el hardware se realiza de forma independiente por cada búsqueda de textura en la marca de 2x2. , que afectará al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="051b4-130">If pixel shader invocations that are executing in a 2x2 stamp (to support derivative calculations) choose different texture indices to sample from out of a descriptor table, and if the selected sampler configuration and texture for any given pixel requires an LOD calculation from texture coordinate derivatives, then the LOD calculation and texture sampling process is done by the hardware independently for each texture lookup in the 2x2 stamp, which will impact performance.</span></span>

## <a name="related-topics"></a><span data-ttu-id="051b4-131">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="051b4-131">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="051b4-132">Tablas de descriptores</span><span class="sxs-lookup"><span data-stu-id="051b4-132">Descriptor Tables</span></span>](descriptor-tables.md)
</dt> </dl>

 

 




