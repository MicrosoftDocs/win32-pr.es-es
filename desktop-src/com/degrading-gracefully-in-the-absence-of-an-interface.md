---
title: Degradación correcta de la ausencia de una interfaz
description: Dado que es posible que un control no admita ninguna interfaz que no sea IUnknown, un contenedor tiene que degradarse correctamente cuando encuentra la ausencia de una interfaz determinada.
ms.assetid: 1b833900-2357-4b39-b88d-5ee6321f488e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 26618e00f2d959cccfd7ab4d2948fac9c1a3f020
ms.sourcegitcommit: 85688bbfbe5b121bc05ddf112d54c23a469dfbc0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/29/2020
ms.locfileid: "105704889"
---
# <a name="degrading-gracefully-in-the-absence-of-an-interface"></a>Degradación correcta de la ausencia de una interfaz

Dado que es posible que un control no admita ninguna interfaz que no sea [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), un contenedor tiene que degradarse correctamente cuando encuentra la ausencia de una interfaz determinada.

Uno podría cuestionar la utilidad de un control con nada más que [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown). Pero tenga en cuenta las ventajas que recibe un control del entorno de programación visual de un contenedor (como VB) cuando el contenedor reconoce el objeto como un control:

-   En un cuadro de herramientas aparece un botón para el objeto.
-   Puede crear un objeto arrastrándolo desde el cuadro de herramientas hasta un formulario.
-   Puede asignar al objeto un nombre que se reconozca en el entorno de programación visual.
-   El mismo nombre en (3) anterior se puede usar inmediatamente en la escritura de cualquier otro código para los controles del mismo formulario (o incluso un formulario diferente).
-   El contenedor puede proporcionar automáticamente puntos de entrada de código para cualquier evento disponible en ese objeto.
-   El contenedor proporciona su propia interfaz de usuario de exploración de propiedades para las propiedades disponibles.

Cuando un objeto no se reconoce como un control, puede que pierda todas estas características de integración muy eficaces y ventajosas. Por ejemplo, en Visual Basic 4,0 es muy difícil integrar realmente algún objeto aleatorio que no sea un control en el sentido completo, pero puede seguir teniendo propiedades y eventos. Dado que la idea de Visual Basic 4 de un control es muy restrictiva, el objeto no obtiene ninguna de las características de integración anteriores. Pero incluso un control con [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), donde la mera duración del control determina la existencia de algún recurso, debe ser capaz de obtener las funcionalidades de integración descritas anteriormente.

Dado que las herramientas actuales requieren un gran conjunto de interfaces de control para obtener una ventaja, los controles suelen pasar a una excesiva implementación, de modo que contienen más código del que realmente necesitan. Los controles que podrían ser 7K pueden acabar siendo 25.000, que es un problema de gran rendimiento en áreas como Internet. Esto también ha provocado la percepción de que solo se puede implementar un control con una herramienta como el CDK debido a la complejidad de la implementación de todas las interfaces, y esto tiene implicaciones cuando se requiere un archivo DLL de gran tamaño como OC30.DLL para este tipo de control, lo que aumenta el espacio de trabajo. Si no se necesitan todas las interfaces, esto abre muchos desarrolladores para escribir controles muy pequeños y claros con OLE directamente o con otras herramientas, lo que minimiza la sobrecarga de cada control.

Este es el motivo por el que este apéndice reconoce un control como cualquier objeto con un CLSID y una interfaz [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) . Incluso con nada más que IUnknown, un contenedor con un entorno de programación debe ser capaz de proporcionar al menos características \# 3 y) la entrada del registro, gana \# 1 y \# 2. Si el objeto proporciona [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer) (y, por lo general, [**IProvideClassInfo**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo) ) para algún conjunto de eventos, gana \# 5 y, si admite **IDispatch** para propiedades y métodos, gana \# 6, así como una mejor integración de código en el contenedor.

En Resumen, un objeto debe ser capaz de implementar tan solo **IDispatch** y un conjunto de eventos expuesto a través de [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer) para obtener todas las características visuales anteriores.

Teniendo esto en cuenta, en la tabla siguiente se describe lo que puede hacer un contenedor en ausencia de cualquier interfaz posible. Tenga en cuenta que solo se enumeran las interfaces que el contenedor obtendrá directamente a través de [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)). Otras interfaces, como [**IOleInPlaceActiveObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleinplaceactiveobject), se obtienen a través de otros medios.



| Interfaz                                                                                                             | Significado de la ausencia de interfaz                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)<br/>                                                                       | El control no tiene objetos visuales que se dibujarán por sí mismo, por lo que no tiene ninguna extensión definitiva que proporcionar. En tiempo de ejecución, el contenedor simplemente no intenta dibujar nada cuando esta interfaz no está presente. En tiempo de diseño, el contenedor debe dibujar al menos algún tipo de rectángulo predeterminado con un nombre en él para este tipo de control, por lo que un usuario de un entorno de programación visual puede seleccionar el objeto y desproteger sus propiedades, métodos y eventos que existen. Controlar la ausencia de [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) es fundamental para una buena compatibilidad con la programación visual.<br/> |
| [**IOleObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleobject)<br/>                                                                           | El control no necesita el sitio de ningún tipo, ni participa en ninguna negociación del diseño del objeto incrustado. Cualquier información (como las extensiones de control) que un contenedor podría esperar de esta interfaz se debe rellenar con los valores predeterminados proporcionados por el contenedor.<br/>                                                                                                                                                                                                                                                                                                       |
| [**IOleInPlaceObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleinplaceobject)<br/>                                                             | El control no pasa a estar activo (como una etiqueta) y, por lo tanto, nunca intenta activar de esta manera. Su única activación puede ser sus páginas de propiedades.<br/>                                                                                                                                                                                                                                                                                                                                                                                                            |
| [**IOleControl**](/windows/desktop/api/OCIdl/nn-ocidl-iolecontrol)<br/>                                                                         | El control no tiene ningún mnemotécnico y no se usa ninguna propiedad de ambiente y no se tiene cuidado si el contenedor omite los eventos. En ausencia de esta interfaz, el contenedor simplemente no llama a sus métodos.<br/>                                                                                                                                                                                                                                                                                                                                                                         |
| [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject)<br/>                                                                         | El control no proporciona ningún conjunto de propiedades ni representaciones visuales que se puedan almacenar en caché, por lo que el contenedor elegiría almacenar en caché alguna presentación predeterminada en ausencia de esta interfaz (compatibilidad con CF \_ METAFILEPICT, específicamente) y deshabilitar cualquier funcionalidad relacionada con el conjunto de propiedades.<br/>                                                                                                                                                                                                                                                                            |
| **IDispatch**<br/>                                                                                              | El control no tiene propiedades ni métodos personalizados. No es necesario que el contenedor intente mostrar ninguna propiedad de control en este caso y no debe permitir llamadas a métodos personalizados que el contenedor no reconozca como perteneciente a sus propios controles extendidos (que pueden admitir métodos y propiedades). Como los controles extendidos suelen delegar ciertas llamadas **IDispatch** al control, un control extendido no debe esperar que el control tenga **IDispatch** .<br/>                                                                                          |
| [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer)<br/>                                             | El control no tiene eventos, por lo que el contenedor no tiene que pensar en controlar ninguno.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [**IProvideClassInfo**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo)<br/> [**IProvideClassInfo2**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo2)<br/> | El control no tiene información de tipo o eventos, o el contenedor debe ir a la información de tipo del control a través de las entradas del registro del control. La existencia de esta interfaz es una optimización.<br/>                                                                                                                                                                                                                                                                                                                                            |
| [**ISpecifyPropertyPages**](/windows/desktop/api/OCIdl/nn-ocidl-ispecifypropertypages)<br/>                                                     | El control no tiene páginas de propiedades, por lo que si el contenedor tiene una interfaz de usuario que los invocaría, el contenedor debe deshabilitar esa interfaz de usuario.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| [**IPerPropertyBrowsing**](/windows/desktop/api/OCIdl/nn-ocidl-iperpropertybrowsing)<br/>                                                       | El control no tiene ningún nombre para mostrar, no hay cadenas ni valores predeterminados y ninguna asignación de propiedad a página. Esta interfaz se usa casi siempre para generar la interfaz de usuario del contenedor, por lo que estos elementos de la interfaz de usuario se deshabilitarían en ausencia de esta interfaz.<br/>                                                                                                                                                                                                                                                                                                 |
| IPersist\*<br/>                                                                                                 | El control no tiene ningún estado persistente para hablar de, por lo que el contenedor no tiene que preocuparse de guardar ningún dato específico del control. Por supuesto, el contenedor guarda su propia información sobre el control en su propio formulario o documento, pero el propio control no tiene nada que contribuir a esa información.<br/>                                                                                                                                                                                                                                                        |
| [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache)<br/> [**IOleCache2**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache2)<br/>                                 | El objeto no admite el almacenamiento en caché. Un contenedor todavía puede admitir el almacenamiento en caché creando simplemente una memoria caché de datos mediante [**CreateDataCache**](/windows/desktop/api/ObjBase/nf-objbase-createdatacache).<br/>                                                                                                                                                                                                                                                                                                                                                                                                    |



 

## <a name="related-topics"></a>Temas relacionados

<dl> <dt>

[Contenedores](containers.md)
</dt> </dl>

 

 





