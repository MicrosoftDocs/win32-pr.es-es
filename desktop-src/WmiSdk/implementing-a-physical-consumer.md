---
description: Un consumidor físico es un objeto COM que implementa la interfaz IWbemUnboundObjectSink.
ms.assetid: 497457dc-61ca-4527-89fd-2af0383de5e9
ms.tgt_platform: multiple
title: Implementar un consumidor físico
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: af0a9530ed7a98ce19b3b39f2f5a1fe52f3b0631
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105716560"
---
# <a name="implementing-a-physical-consumer"></a><span data-ttu-id="81a09-103">Implementar un consumidor físico</span><span class="sxs-lookup"><span data-stu-id="81a09-103">Implementing a Physical Consumer</span></span>

<span data-ttu-id="81a09-104">Un consumidor físico es un objeto COM que implementa la interfaz [**IWbemUnboundObjectSink**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) .</span><span class="sxs-lookup"><span data-stu-id="81a09-104">A physical consumer is a COM object that implements the [**IWbemUnboundObjectSink**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) interface.</span></span> <span data-ttu-id="81a09-105">WMI carga el consumidor físico y pasa los eventos a través de **IWbemUnboundObjectSink** en respuesta a uno o más eventos, tal y como se define en el consumidor lógico asociado.</span><span class="sxs-lookup"><span data-stu-id="81a09-105">WMI loads your physical consumer and passes events through **IWbemUnboundObjectSink** in response to one or more events, as defined by the associated logical consumer.</span></span> <span data-ttu-id="81a09-106">Los consumidores permanentes tienen requisitos de seguridad especiales.</span><span class="sxs-lookup"><span data-stu-id="81a09-106">Permanent consumers have special security requirements.</span></span> <span data-ttu-id="81a09-107">Para obtener más información, consulte [protección de eventos WMI](securing-wmi-events.md).</span><span class="sxs-lookup"><span data-stu-id="81a09-107">For more information, see [Securing WMI Events](securing-wmi-events.md).</span></span>

<span data-ttu-id="81a09-108">En el procedimiento siguiente se describe cómo implementar un consumidor físico para un consumidor de eventos permanente.</span><span class="sxs-lookup"><span data-stu-id="81a09-108">The following procedure describes how to implement a physical consumer for a permanent event consumer.</span></span>

<span data-ttu-id="81a09-109">**Para implementar un consumidor físico para un consumidor de eventos permanente**</span><span class="sxs-lookup"><span data-stu-id="81a09-109">**To implement a physical consumer for a permanent event consumer**</span></span>

1.  <span data-ttu-id="81a09-110">Cree un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="81a09-110">Create a COM object.</span></span>

    <span data-ttu-id="81a09-111">Debe implementar un consumidor físico como un servidor local o remoto mediante el protocolo COM.</span><span class="sxs-lookup"><span data-stu-id="81a09-111">You must implement a physical consumer as a local or remote server using the COM protocol.</span></span>

2.  <span data-ttu-id="81a09-112">Determine si desea admitir la notificación de eventos sincrónicos o asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="81a09-112">Determine if you want to support synchronous or asynchronous event notification.</span></span>

    <span data-ttu-id="81a09-113">Con la notificación de eventos asincrónicos, el subproceso de envío no está relacionado con el subproceso receptor.</span><span class="sxs-lookup"><span data-stu-id="81a09-113">With asynchronous event notification, the sending thread is unrelated to the receiving thread.</span></span> <span data-ttu-id="81a09-114">Por lo tanto, ni WMI ni el proveedor de eventos se bloquean mientras WMI entrega una notificación a cualquier consumidor registrado para recibir el evento.</span><span class="sxs-lookup"><span data-stu-id="81a09-114">Therefore, neither WMI nor the event provider gets blocked while WMI delivers a notification to any consumer registered to receive the event.</span></span> <span data-ttu-id="81a09-115">El inconveniente de la entrega asincrónica es que se produce un cambio de contexto entre el momento en que el proveedor genera el evento y el momento en que el consumidor recibe el evento.</span><span class="sxs-lookup"><span data-stu-id="81a09-115">The disadvantage to asynchronous delivery is that a context switch occurs between the time the provider produces the event and the time the consumer receives the event.</span></span> <span data-ttu-id="81a09-116">Para obtener más información sobre cómo trabajar de forma asincrónica, vea el tema sobre [aspectos básicos de com](../com/guide.md) en la sección com del kit de desarrollo de software (SDK) de Microsoft Windows.</span><span class="sxs-lookup"><span data-stu-id="81a09-116">For more information about working asynchronously, see the [COM Fundamentals](../com/guide.md) topic in the COM section of the Microsoft Windows Software Development Kit (SDK).</span></span> <span data-ttu-id="81a09-117">Para obtener más información acerca de los cambios de contexto, vea el tema [cambios de contexto](../procthread/context-switches.md) en la sección archivos dll, procesos y subprocesos del Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="81a09-117">For more information about context switches, see the [Context Switches](../procthread/context-switches.md) topic in the DLLs, Processes, and Threads section of the Windows SDK.</span></span>

    > [!Note]  
    > <span data-ttu-id="81a09-118">Dado que la devolución de llamada al receptor podría no devolverse en el mismo nivel de autenticación que requiere el cliente, se recomienda usar semisincrónico en lugar de la comunicación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="81a09-118">Because the callback to the sink might not be returned at the same authentication level as the client requires, it is recommended that you use semisynchronous instead of asynchronous communication.</span></span> <span data-ttu-id="81a09-119">Para obtener más información, consulte [llamar a un método](calling-a-method.md).</span><span class="sxs-lookup"><span data-stu-id="81a09-119">For more information, see [Calling a Method](calling-a-method.md).</span></span>

     

    <span data-ttu-id="81a09-120">Con la notificación sincrónica, WMI entrega la notificación en el mismo subproceso que el proveedor de eventos utiliza para entregar el evento a WMI.</span><span class="sxs-lookup"><span data-stu-id="81a09-120">With synchronous notification, WMI delivers the notification on the same thread that the event provider used to deliver the event to WMI.</span></span> <span data-ttu-id="81a09-121">En este caso, cuando un proveedor de eventos envía una notificación, WMI bloquea el proveedor de eventos hasta que WMI entrega la notificación.</span><span class="sxs-lookup"><span data-stu-id="81a09-121">In this case, when an event provider sends a notification, the event provider is blocked by WMI until WMI delivers the notification.</span></span> <span data-ttu-id="81a09-122">Solo si el consumidor es extremadamente rápido y puede procesar un evento en 100 microsegundos o menos, debe considerar la posibilidad de admitir la notificación sincrónica.</span><span class="sxs-lookup"><span data-stu-id="81a09-122">Only if your consumer is extremely fast and can process an event in 100 microseconds or less should you consider supporting synchronous notification.</span></span> <span data-ttu-id="81a09-123">Los consumidores sincrónicos que tardan demasiado tiempo en procesar eventos pueden ralentizar gravemente la entrega de eventos a todos los demás consumidores.</span><span class="sxs-lookup"><span data-stu-id="81a09-123">Synchronous consumers that take too long to process events can seriously slow the delivery of events to all other consumers.</span></span> <span data-ttu-id="81a09-124">Además, pueden bloquear involuntariamente el proveedor.</span><span class="sxs-lookup"><span data-stu-id="81a09-124">Furthermore, they can inadvertently block the provider.</span></span> <span data-ttu-id="81a09-125">Para obtener más información, vea [enlazar un filtro de eventos con un consumidor lógico](binding-an-event-filter-with-a-logical-consumer.md).</span><span class="sxs-lookup"><span data-stu-id="81a09-125">For more information, see [Binding an Event Filter with a Logical Consumer](binding-an-event-filter-with-a-logical-consumer.md).</span></span>

3.  <span data-ttu-id="81a09-126">Implemente la función [**IWbemUnboundObjectSink:: IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) .</span><span class="sxs-lookup"><span data-stu-id="81a09-126">Implement the [**IWbemUnboundObjectSink::IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function.</span></span>

    <span data-ttu-id="81a09-127">WMI utiliza la función [**IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) para pasar los punteros y eventos necesarios al consumidor físico para las comunicaciones sincrónicas y asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="81a09-127">WMI uses the [**IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function to pass the necessary pointers and events to your physical consumer for both synchronous and asynchronous communications.</span></span> <span data-ttu-id="81a09-128">La implementación de **IndicateToConsumer** debe contener todo el código necesario para responder a un evento.</span><span class="sxs-lookup"><span data-stu-id="81a09-128">Your implementation of **IndicateToConsumer** should contain all of the necessary code to respond to an event.</span></span>

    <span data-ttu-id="81a09-129">A diferencia de un consumidor de eventos temporal, no es necesario llamar a la interfaz [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) para ponerse en contacto con WMI.</span><span class="sxs-lookup"><span data-stu-id="81a09-129">Unlike a temporary event consumer, you do not need to call the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface to contact WMI.</span></span> <span data-ttu-id="81a09-130">En su lugar, WMI busca un puntero al consumidor a través del proveedor del consumidor de eventos.</span><span class="sxs-lookup"><span data-stu-id="81a09-130">Instead, WMI locates a pointer to your consumer through the event consumer provider.</span></span> <span data-ttu-id="81a09-131">Para obtener más información, consulte [escribir un proveedor de consumidor de eventos](writing-an-event-consumer-provider.md).</span><span class="sxs-lookup"><span data-stu-id="81a09-131">For more information, see [Writing an Event Consumer Provider](writing-an-event-consumer-provider.md).</span></span>

    <span data-ttu-id="81a09-132">Sin embargo, si desea volver a llamar a WMI, use las interfaces [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) y [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) .</span><span class="sxs-lookup"><span data-stu-id="81a09-132">However, if you wish to call back into WMI, use the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) and [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) interfaces.</span></span> <span data-ttu-id="81a09-133">El método tradicional para conectarse a WMI es durante el proceso de inicialización del objeto COM.</span><span class="sxs-lookup"><span data-stu-id="81a09-133">The traditional method for connecting to WMI is during the initialization process of your COM object.</span></span> <span data-ttu-id="81a09-134">Para obtener más información, vea [crear una aplicación o un script WMI](creating-a-wmi-application-or-script.md).</span><span class="sxs-lookup"><span data-stu-id="81a09-134">For more information, see [Creating a WMI Application or Script](creating-a-wmi-application-or-script.md).</span></span>

    <span data-ttu-id="81a09-135">Si implementa el consumidor físico como un servidor COM en proceso y se conecta a WMI independientemente del proceso de inicialización, debe usar el identificador de clase **CLSID \_ WbemAdministrativeLocator** para tener acceso a la interfaz [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) en la llamada a [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="81a09-135">If you implement your physical consumer as an in-process COM server and connect to WMI separately from the initialization process, you must use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface in the call to [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

    <span data-ttu-id="81a09-136">En el ejemplo siguiente se muestra cómo usar el identificador de clase **CLSID \_ WbemAdministrativeLocator** para tener acceso a la interfaz [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) .</span><span class="sxs-lookup"><span data-stu-id="81a09-136">The following example shows how to use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface.</span></span>

    ```C++
    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, 0, 
        CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc);
    ```

    

    <span data-ttu-id="81a09-137">La interfaz [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) obtiene el puntero de espacio de nombres inicial a WMI en un equipo host determinado.</span><span class="sxs-lookup"><span data-stu-id="81a09-137">The [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface obtains the initial namespace pointer to WMI on a particular host computer.</span></span> <span data-ttu-id="81a09-138">Si no se usa el identificador **\_ WbemAdministrativeLocator CLSID** en la llamada a [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) , se producirá un error de "acceso denegado".</span><span class="sxs-lookup"><span data-stu-id="81a09-138">Failure to use the **CLSID\_WbemAdministrativeLocator** identifier in the [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) call results in an "access denied" error.</span></span>

    <span data-ttu-id="81a09-139">En circunstancias normales, WMI envía eventos asincrónicos al cliente de uno en uno.</span><span class="sxs-lookup"><span data-stu-id="81a09-139">Under usual circumstances, WMI delivers asynchronous events to the client one at a time.</span></span> <span data-ttu-id="81a09-140">Sin embargo, si un cliente no puede recibir notificaciones de eventos asincrónicas tan pronto como llegan los eventos, WMI comienza a procesar automáticamente los eventos en una sola llamada.</span><span class="sxs-lookup"><span data-stu-id="81a09-140">However, if a client cannot receive asynchronous event notifications as fast as the events arrive, WMI starts to automatically batch events into a single call.</span></span> <span data-ttu-id="81a09-141">El procesamiento por lotes automático ayuda a que los tiempos de ida y vuelta sean un problema, como suele ser el caso de los escenarios de alto rendimiento.</span><span class="sxs-lookup"><span data-stu-id="81a09-141">Automatic batching helps if the round-trip times are a problem, as is often the case in high-throughput scenarios.</span></span> <span data-ttu-id="81a09-142">Sin embargo, el procesamiento por lotes no mejora el rendimiento del sistema si el ancho de banda del cliente o de la red es erróneo.</span><span class="sxs-lookup"><span data-stu-id="81a09-142">However, batching does not improve system performance if the client or the network bandwidth are at fault.</span></span>

 

 
