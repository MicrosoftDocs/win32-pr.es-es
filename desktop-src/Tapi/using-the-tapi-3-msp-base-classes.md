---
description: En el procedimiento siguiente se describe cómo implementar un MSP mediante la versión 2,1 de ATL o la versión 3,0 de ATL y las clases base de MSP.
ms.assetid: 7485c34a-3c8a-412f-9cb9-8eb895084292
title: Uso de las clases base de TAPI 3 MSP
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: eb8ad4fd160cf0fc4c7dd682a44f3a4ff0bcec25
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105688586"
---
# <a name="using-the-tapi-3-msp-base-classes"></a>Uso de las clases base de TAPI 3 MSP

En el procedimiento siguiente se describe cómo implementar un MSP mediante la versión 2,1 de ATL o la versión 3,0 de ATL y las clases base de MSP. Para obtener más información y una lista de bibliotecas y encabezados, consulte [las clases base de TAPI 3 MSP](tapi-3-msp-base-classes.md). En el contenido de este tema se supone que el desarrollador está familiarizado con ATL y COM, y que tiene experiencia en la implementación de archivos DLL COM mediante ATL.

**Para implementar y MSP con ATL 2,1 o ATL 3,0**

1.  Cree un archivo IDL para su MSP. Este archivo define un CLSID para su MSP. Declare la "coclase" de MSP como implementación de la interfaz [**ITMSPAddress**](/windows/desktop/api/msp/nn-msp-itmspaddress) y declare esta interfaz como la interfaz predeterminada en el objeto de clase. Para la definición de **ITMSPAddress**, importe el archivo "MSP. idl". Incluya su "coclass" de MSP en una biblioteca de tipos para su MSP. Si su MSP es compatible con interfaces privadas (personalizadas), defina aquí y inclúyalo en la biblioteca de tipos. El siguiente ejemplo de código es un archivo IDL tal y como se ha descrito anteriormente, sin interfaces personalizadas.

    ``` syntax
    import "msp.idl";
    [
          uuid(4DDB6D35-3BC1-11d2-86F2-006008B0E5D2),
          version(2.0),
          helpstring("Wave MSP 2.0 Type Library")
    ]
    library WAVEMSPLib
    {
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(4DDB6D36-3BC1-11d2-86F2-006008B0E5D2),
    helpstring("Wave MSP Class")
    ]
    coclass WaveMSP
    {
    [default] interface ITMSPAddress;
    };
    };
    ```

2.  Modifique su TSP para anunciar el CLSID de su MSP cuando Tapi3.dll lo solicite. Asegúrese de que (1) el TSP puede negociar TAPI \_ VERSION3 \_ 0 o superior en la función TSPI [**TSPI \_ lineNegotiateTSPIVersion**](/windows/win32/api/tspi/nf-tspi-tspi_linenegotiatetspiversion), (2) la estructura de TSP [**LINEDEVCAPS**](/windows/win32/api/tapi/ns-tapi-linedevcaps) tiene la marca LINEDEVCAPFLAGS \_ MSP establecida en el miembro **DWDEVCAPFLAGS** y (3) el TSP devuelve el CLSID de MSP en la función TSPI TSPI [**\_ lineMSPIdentify**](/windows/win32/api/tspi/nf-tspi-tspi_linemspidentify). Debe ser el mismo CLSID especificado en el archivo IDL; por ejemplo, la segunda línea "UUID" en el archivo IDL de ejemplo del paso anterior.
3.  Compile la aplicación de ejemplo MSPBase, que se encuentra en el kit de desarrollo de software (SDK) de la plataforma, para crear la biblioteca MSPBaseSample. lib.
4.  Vincule el archivo DLL de MSP con la biblioteca MSPBaseSample. lib.
5.  Incluya Mspbase. h desde las definiciones de clase base de SDK para MSP.
6.  Implemente las exportaciones de DLL (por ejemplo, DllMain). Microsoft Visual C++ los generará automáticamente. En DllMain, en la Asociación del proceso de DLL \_ \_ y \_ \_ la desasociación de procesos dll, respectivamente, use las macros **MSPLOGREGISTER** y **MSPLOGDEREGISTER** para habilitar las características de registro para el archivo dll. Especifique el nombre de la DLL en la llamada **MSPLOGDEREGISTER** .
7.  Use la macro LOG, definida en Msplog. h, para generar mensajes de seguimiento de la misma manera que las clases base. Defina el símbolo de preprocesador MSPLOG para incluir el registro en el archivo DLL; déjelo sin definir para compilar un archivo DLL que no tenga registro.
8.  Derive una clase de CMSPAddress que implemente direcciones para el MSP. Declare un mapa de objetos ATL global que indique a ATL que cree una instancia de la clase de dirección cuando se le pida que **cocree** el CLSID que especificó en el archivo IDL. Además, derive la clase address de la plantilla de ATL **CComCoClass** e incluya una declaración declare \_ Registry \_ RESOURCEID en la clase Address. Construya un script de recursos y un archivo de encabezado correspondientes, como para cualquier otro archivo DLL COM de ATL.
9.  Implemente las invalidaciones de CMSPAddress necesarias para la clase Address. Para [**MSPAddressAddRef**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressaddref) y [**MSPAddressRelease**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressrelease), llame a las plantillas de función auxiliares proporcionadas. En el caso de [**GetCallMediaTypes**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-getcallmediatypes), solo tiene que devolver un mapa de bits **DWORD** con todos los TAPIMEDIAMODES ORed compatibles con MSP juntos. Para [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) y [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall), devuelva e \_ NOTIMPL y compile y vincule su MSP en este momento. Ahora, compruebe que puede registrar y crear instancias de MSP desde las aplicaciones TAPI 3, pero no crear llamadas correctamente.
10. Derive una clase de CMSPCallMultiGraph para implementar los objetos de llamada MSP. Puede que desee derivar de [**CMSPCallBase**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallbase) en lugar de [**CMSPCallMultiGraph**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallmultigraph) si el modelo Filter-Graph-per-Stream no se ajusta a sus requisitos; Esto aumentará la complejidad de la tarea (en la redacción de este documento, todos los MSP derivan objetos de llamada directamente de **CMSPCallMultiGraph**). En el objeto address, implemente [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) y [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall) para crear y cerrar el tipo específico de objeto de llamada mediante las plantillas de función auxiliares proporcionadas. En el objeto de llamada, invalide [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) para devolver E \_ NOTIMPL. Invalide [**MSPCallAddRef**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcalladdref) y [**MSPCallRelease**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcallrelease) de forma idéntica a los métodos de dirección correspondientes. Una vez más, debería poder compilar y vincular el MSP; ahora debería poder crear y cerrar llamadas, pero las llamadas no realizarán ningún flujo útil.
11. Derive una clase de CMSPStream para implementar los objetos de secuencia MSP. En el objeto de llamada, implemente [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) para crear e inicializar el objeto de secuencia (normalmente mediante una llamada a la función **CreateInstance** de ATL seguida por el **\_ InternalQueryInterface** de ATL para [**ITStream**](/windows/win32/api/tapi3if/nn-tapi3if-itstream) seguido de una llamada a **init** en el objeto de secuencia). Para admitir un número fijo de flujos (esto es común para los MSP que no admiten la modificación de configuraciones de secuencia por otros puntos de conexión en la llamada), invalide **init**, [**CreateStream (**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-createstream)y [**RemoveStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-removestream) en el objeto de llamada. (La llamada **init** crea todas las secuencias inicialmente y **CreateStream (** y **RemoveStream** devuelven los códigos de error de TAPI adecuados para evitar que la aplicación cree o quite secuencias). De lo contrario, invalide el método **init** de la llamada para crear una configuración inicial predeterminada de secuencias mediante los tipos de medios solicitados para la llamada. Al crear cualquier objeto de secuencia predeterminado en el método **init** de la llamada, use el método auxiliar [**InternalCreateStream**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-internalcreatestream) .
12. Implemente el objeto de secuencia. La única invalidación necesaria es el método [**Get \_ Name**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-get_name) , que simplemente devuelve un nombre descriptivo para la secuencia. Además, tendrá que reemplazar otros métodos. El hecho de que los métodos que se van a invalidar dependan de la implementación y de la decisión de realizar las distintas tareas implicadas en la creación y deconstrucción del gráfico de filtros. Estas tareas incluyen la creación de los filtros, códecs, etc. de "transporte" adecuados, y su inserción y eliminación de los gráficos de filtros en los momentos adecuados. También tendrá que usar la interfaz [**ITTerminalControl**](/windows/desktop/api/Termmgr/nn-termmgr-itterminalcontrol) en los objetos de terminal para conectar los terminales seleccionados a las secuencias. Puede que desee invalidar [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal) y [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) en el objeto de flujo para limitar las configuraciones de terminal que aceptarán las secuencias; limitar cada flujo a un único terminal simplificará especialmente la construcción de los gráficos de filtros, pero sacrificará la funcionalidad de la aplicación, como la vista previa de vídeo. En función de la implementación, colocará el código de la construcción, la desconstrucción y la conexión de terminal en los métodos [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**Initialize**](/windows/desktop/api/msp/nf-msp-itmspaddress-initialize), [**Shutdown**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdown), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)y [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , o en sus propios métodos basados en la comunicación de TSP privado. Tenga en cuenta que una secuencia sin terminales seleccionados debe realizar un seguimiento del estado del gráfico deseado; una llamada a **StartStream** seguida por una llamada a **SelectTerminal** en este tipo de flujo debe dar como resultado un flujo de datos. Invalide la mayoría de estos métodos para asegurarse de que la construcción, la desconstrucción, la conexión y la desconexión correctas se producen en cada caso en función del estado de la secuencia.
13. Implemente la comunicación de TSP. Invalide [**CMSPAddress:: ReceiveTSPAddressData**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-receivetspaddressdata) y/o [**CMSPCallBase:: ReceiveTSPCallData**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-receivetspcalldata)y/o llamando a [**postEvent**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-postevent) en el objeto Address o [**HandleStreamEvent**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-handlestreamevent) en el objeto Call (desde los objetos Call o Stream).
14. Use postEvent en el objeto Address o HandleStreamEvent en el objeto Call (desde los objetos Call o Stream) para enviar eventos multimedia de llamada a la aplicación a través de Tapi3.dll. Normalmente lo hará en el objeto de flujo, en métodos invalidados, incluidos los métodos [**ProcessGraphEvent**](/windows/desktop/api/Mspstrm/nf-mspstrm-cmspstream-processgraphevent), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)y [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , en función de cómo implemente las secuencias.
15. Implemente cualquier interfaz privada o subsecuencias que desee en los objetos existentes (dirección, llamada y secuencia). Normalmente no hay ninguno. Tenga en cuenta que al implementar las interfaces privadas, especifique el LIBId de la biblioteca de tipos desde el archivo IDL. Es decir, los programadores de aplicaciones deben usar la biblioteca de tipos MSP al usar las interfaces personalizadas. Las interfaces MSP estándar, implementadas en las clases base de MSP, usan el LIBInte Tapi3.dll y, por tanto, son accesibles para todas las aplicaciones TAPI 3.
16. Si implementa objetos de terminal estáticos o dinámicos específicos de MSP o reemplazos para los terminales estáticos predeterminados (no típicos), puede usar las clases base de terminal proporcionadas. Tendrá que reemplazar varios métodos en el objeto address para proporcionar métodos alternativos o adicionales para crear objetos de terminal.
17. Implemente la interfaz IObjectSafety en la dirección, la llamada, la secuencia y los objetos de terminal. Para usar el [asignador de envío](dispatch-mapper.md) para consultar interfaces en los objetos MSP, marque los objetos como seguros para el scripting en estas interfaces. Para ello, implemente la interfaz **IObjectSafety** en el objeto. Si se deriva de **CMSPObjectSafetyImpl** (una clase auxiliar que se proporciona en Msputils. h) y se agrega **IOBJECTSAFETY** al mapa com ATL de la clase \_ , los objetos estarán seguros para el scripting en todas las interfaces que exponen. Tenga en cuenta que el uso del asignador de envío en objetos MSP podría ser implícito. La dirección MSP y la llamada MSP se agregan mediante la dirección TAPI y los objetos de llamada TAPI. Si se usa el asignador de envío en los objetos TAPI para consultar las interfaces expuestas por los objetos MSP agregados, se consultarán los objetos MSP agregados para la seguridad de las interfaces solicitadas.

 

 
