---
title: Diferencias de IRIS GL y OpenGL
description: Diferencias de IRIS GL y OpenGL
ms.assetid: 1682bcbb-3bfb-4ea3-9ba9-4f4654238169
keywords:
- Diferencias de OpenGL,IRIS GL
- Porte de IRIS GL, diferencias de OpenGL
- porting from IRIS GL,OpenGL differences
- porte a OpenGL desde IRIS GL, diferencias de IRIS GL
- Porte openGL desde IRIS GL, diferencias de IRIS GL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 369b4945757dd092e969fb87c41f9804aaff8fe7
ms.sourcegitcommit: b32433cc0394159c7263809ae67615ab5792d40d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/30/2021
ms.locfileid: "113119300"
---
# <a name="iris-gl-and-opengl-differences"></a><span data-ttu-id="c728d-108">Diferencias de IRIS GL y OpenGL</span><span class="sxs-lookup"><span data-stu-id="c728d-108">IRIS GL and OpenGL Differences</span></span>

<span data-ttu-id="c728d-109">En este apéndice se enumeran las diferencias entre OpenGL e IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-109">This appendix lists the differences between OpenGL and IRIS GL.</span></span> <span data-ttu-id="c728d-110">Se da un término para cada diferencia, seguido de una descripción.</span><span class="sxs-lookup"><span data-stu-id="c728d-110">A term for each difference is given, followed by a description.</span></span>



| <span data-ttu-id="c728d-111">Término</span><span class="sxs-lookup"><span data-stu-id="c728d-111">Term</span></span>                                     | <span data-ttu-id="c728d-112">Descripción</span><span class="sxs-lookup"><span data-stu-id="c728d-112">Description</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="c728d-113">ajuste de acumulación</span><span class="sxs-lookup"><span data-stu-id="c728d-113">accumulation wrapping</span></span>                | <span data-ttu-id="c728d-114">La operación de búfer de acumulación de OpenGL no se define cuando los valores de componente superan 1,0 o bajan por debajo de 1,0.</span><span class="sxs-lookup"><span data-stu-id="c728d-114">The OpenGL accumulation buffer operation is not defined when component values exceed 1.0 or drop below 1.0.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="c728d-115">líneas suavizadas</span><span class="sxs-lookup"><span data-stu-id="c728d-115">antialiased lines</span></span>                    | <span data-ttu-id="c728d-116">OpenGL contrae líneas suavizadas.</span><span class="sxs-lookup"><span data-stu-id="c728d-116">OpenGL stipples antialiased lines.</span></span> <span data-ttu-id="c728d-117">IRIS GL no lo hace.</span><span class="sxs-lookup"><span data-stu-id="c728d-117">IRIS GL does not.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="c728d-118">arc</span><span class="sxs-lookup"><span data-stu-id="c728d-118">arc</span></span>                                  | <span data-ttu-id="c728d-119">OpenGL admite arcos en su biblioteca de utilidades.</span><span class="sxs-lookup"><span data-stu-id="c728d-119">OpenGL supports arcs in its utility library.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="c728d-120">listas de atributos</span><span class="sxs-lookup"><span data-stu-id="c728d-120">attribute lists</span></span>                      | <span data-ttu-id="c728d-121">Los atributos que insertan los atributos push de IRIS GL difieren de cualquiera de los conjuntos de atributos que inserta openGL glPushAttrib .</span><span class="sxs-lookup"><span data-stu-id="c728d-121">The attributes pushed by the IRIS GL pushattributes differ from any of the attribute sets pushed by the OpenGL glPushAttrib .</span></span> <span data-ttu-id="c728d-122">Sin embargo, dado que todos los estados OpenGL se pueden leer, puede implementar cualquier semántica de inserción o pop deseada mediante OpenGL.</span><span class="sxs-lookup"><span data-stu-id="c728d-122">Since all OpenGL states can be read back, however, you can implement any desired push/pop semantics using OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="c728d-123">escalado automático de textura</span><span class="sxs-lookup"><span data-stu-id="c728d-123">automatic texture scaling</span></span>            | <span data-ttu-id="c728d-124">La interfaz de textura OpenGL no admite el escalado automático de imágenes a dimensiones de potencia de dos.</span><span class="sxs-lookup"><span data-stu-id="c728d-124">The OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions.</span></span> <span data-ttu-id="c728d-125">Sin embargo, GLU admite el escalado de imágenes.</span><span class="sxs-lookup"><span data-stu-id="c728d-125">However, the GLU supports image scaling.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="c728d-126">Bbox</span><span class="sxs-lookup"><span data-stu-id="c728d-126">bbox</span></span>                                 | <span data-ttu-id="c728d-127">OpenGL no admite la ejecución condicional de listas para mostrar.</span><span class="sxs-lookup"><span data-stu-id="c728d-127">OpenGL doesn't support conditional execution of display lists.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="c728d-128">callfunc</span><span class="sxs-lookup"><span data-stu-id="c728d-128">callfunc</span></span>                             | <span data-ttu-id="c728d-129">OpenGL no admite la devolución de llamada desde listas para mostrar.</span><span class="sxs-lookup"><span data-stu-id="c728d-129">OpenGL doesn't support callback from display lists.</span></span> <span data-ttu-id="c728d-130">Tenga en cuenta que IRIS GL tampoco admite esta funcionalidad, cuando el cliente y el servidor están en distintas plataformas.</span><span class="sxs-lookup"><span data-stu-id="c728d-130">Note that IRIS GL doesn't support this functionality either, when client and server are on different platforms.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="c728d-131">circle</span><span class="sxs-lookup"><span data-stu-id="c728d-131">circle</span></span>                               | <span data-ttu-id="c728d-132">OpenGL admite círculos con glu.</span><span class="sxs-lookup"><span data-stu-id="c728d-132">OpenGL supports circles with the GLU.</span></span> <span data-ttu-id="c728d-133">En OpenGL, tanto los círculos como los arcos (discos y discos parciales) pueden tener huecos.</span><span class="sxs-lookup"><span data-stu-id="c728d-133">In OpenGL both circles and arcs (disks and partial disks) can have holes.</span></span> <span data-ttu-id="c728d-134">Además, puede cambiar la subdivisión de las primitivas en OpenGL, cuyas normales de superficie están disponibles para la iluminación.</span><span class="sxs-lookup"><span data-stu-id="c728d-134">In addition, you can change subdivision of the primitives in OpenGL, whose surface normals are available for lighting.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="c728d-135">opciones clear</span><span class="sxs-lookup"><span data-stu-id="c728d-135">clear options</span></span>                        | <span data-ttu-id="c728d-136">OpenGL borra realmente los búferes.</span><span class="sxs-lookup"><span data-stu-id="c728d-136">OpenGL actually clears buffers.</span></span> <span data-ttu-id="c728d-137">No se aplican las operaciones de píxeles especificadas actualmente, como la combinación y logicop, independientemente de sus modos.</span><span class="sxs-lookup"><span data-stu-id="c728d-137">It doesn't apply currently specified pixel operations, such as blending and logicop, regardless of their modes.</span></span> <span data-ttu-id="c728d-138">Para borrar el uso de estas características, debe representar un polígono de tamaño de ventana.</span><span class="sxs-lookup"><span data-stu-id="c728d-138">To clear using such features, you must render a window-size polygon.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="c728d-139">líneas cerradas</span><span class="sxs-lookup"><span data-stu-id="c728d-139">closed lines</span></span>                         | <span data-ttu-id="c728d-140">OpenGL representa todas las líneas con alias de un solo ancho, de modo que las líneas de proceso no comparten píxeles.</span><span class="sxs-lookup"><span data-stu-id="c728d-140">OpenGL renders all single-width aliased lines such that abutting lines share no pixels.</span></span> <span data-ttu-id="c728d-141">Esto significa que no se dibuja el último píxel de una línea independiente.</span><span class="sxs-lookup"><span data-stu-id="c728d-141">This means that the last pixel of an independent line is not drawn.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="c728d-142">color/marca normal</span><span class="sxs-lookup"><span data-stu-id="c728d-142">color/normal flag</span></span>                    | <span data-ttu-id="c728d-143">La iluminación OpenGL está habilitada o deshabilitada explícitamente.</span><span class="sxs-lookup"><span data-stu-id="c728d-143">OpenGL lighting is explicitly enabled or disabled.</span></span> <span data-ttu-id="c728d-144">Cuando se habilita, es efectivo independientemente del orden en el que se especifican los colores y las normales.</span><span class="sxs-lookup"><span data-stu-id="c728d-144">When enabled, it is effective regardless of the order in which colors and normals are specified.</span></span> <span data-ttu-id="c728d-145">No se puede habilitar o deshabilitar la iluminación entre los comandos glBegin y glEnd de OpenGL.</span><span class="sxs-lookup"><span data-stu-id="c728d-145">You cannot enable or disable lighting between OpenGL glBegin and glEnd commands.</span></span> <span data-ttu-id="c728d-146">Para deshabilitar la iluminación entre glBegin y glEnd, especifique cero reflexión de ambiente, difuso y material especular y, a continuación, establezca la emisión del material en el color deseado.</span><span class="sxs-lookup"><span data-stu-id="c728d-146">To disable lighting between glBegin and glEnd, specify zero ambient, diffuse, and specular material reflectance, and then set the material emission to the desired color.</span></span>                                                                                                                                                                                                                                                            |
| <span data-ttu-id="c728d-147">Polígonos cóncavos</span><span class="sxs-lookup"><span data-stu-id="c728d-147">concave polygons</span></span>                     | <span data-ttu-id="c728d-148">La API básica de OpenGL no controla los polígonos cóncavos, pero glu admite la descomponeción de contornos cóncavos que no se intersecan por sí solos en triángulos.</span><span class="sxs-lookup"><span data-stu-id="c728d-148">The core OpenGL API doesn't handle concave polygons, but the GLU supports decomposing concave, non-self-intersecting contours into triangles.</span></span> <span data-ttu-id="c728d-149">Estos triángulos se pueden dibujar inmediatamente o devolverse.</span><span class="sxs-lookup"><span data-stu-id="c728d-149">These triangles can either be drawn immediately or returned.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="c728d-150">color calculado actual</span><span class="sxs-lookup"><span data-stu-id="c728d-150">current computed color</span></span>               | <span data-ttu-id="c728d-151">OpenGL no tiene ningún equivalente a un color calculado actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-151">OpenGL has no equivalent to a current computed color.</span></span> <span data-ttu-id="c728d-152">Si usa OpenGL como motor de iluminación, puede usar comentarios para obtener los colores generados por los cálculos de iluminación.</span><span class="sxs-lookup"><span data-stu-id="c728d-152">If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="c728d-153">posición de gráficos actual</span><span class="sxs-lookup"><span data-stu-id="c728d-153">current graphics position</span></span>            | <span data-ttu-id="c728d-154">OpenGL no mantiene una posición de gráficos actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-154">OpenGL doesn't maintain a current graphics position.</span></span> <span data-ttu-id="c728d-155">Los comandos GL de IRIS que dependen de la posición de gráficos actual, como líneas relativas y polígonos, no se incluyen en OpenGL.</span><span class="sxs-lookup"><span data-stu-id="c728d-155">IRIS GL commands that depend on current graphics position, such as relative lines and polygons, are not included in OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="c728d-156">curvas</span><span class="sxs-lookup"><span data-stu-id="c728d-156">curves</span></span>                               | <span data-ttu-id="c728d-157">OpenGL no admite curvas IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-157">OpenGL does not support IRIS GL curves.</span></span> <span data-ttu-id="c728d-158">Se recomienda el uso de curvas DE LABS.</span><span class="sxs-lookup"><span data-stu-id="c728d-158">Use of NURBS curves is recommended.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="c728d-159">defs/binds</span><span class="sxs-lookup"><span data-stu-id="c728d-159">defs/binds</span></span>                           | <span data-ttu-id="c728d-160">OpenGL no tiene el concepto de objetos de material, luz o textura; solo de propiedades de material, luz y textura.</span><span class="sxs-lookup"><span data-stu-id="c728d-160">OpenGL doesn't have the concept of material, light, or texture objects; only of material, light, and texture properties.</span></span> <span data-ttu-id="c728d-161">Sin embargo, puede usar listas para mostrar para crear sus propios objetos.</span><span class="sxs-lookup"><span data-stu-id="c728d-161">You can use display lists to create their own objects, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="c728d-162">depthcue</span><span class="sxs-lookup"><span data-stu-id="c728d-162">depthcue</span></span>                             | <span data-ttu-id="c728d-163">OpenGL no proporciona compatibilidad directa con la indicación de profundidad, pero su compatibilidad con el sonido es una funcionalidad más general que se puede usar fácilmente para emular la función depthcue de IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-163">OpenGL provides no direct support for depth cueing, but its fog support is a more general capability that you can easily use to emulate the IRIS GL depthcue function.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="c728d-164">edición de la lista de visualización</span><span class="sxs-lookup"><span data-stu-id="c728d-164">display list editing</span></span>                 | <span data-ttu-id="c728d-165">Las listas de visualización de OpenGL no se pueden editar y destruir de forma solo.</span><span class="sxs-lookup"><span data-stu-id="c728d-165">OpenGL display lists can't be editedonly created and destroyed.</span></span> <span data-ttu-id="c728d-166">Sin embargo, dado que puede especificar nombres de lista para mostrar, puede volver a definir listas de presentación individuales en una jerarquía.</span><span class="sxs-lookup"><span data-stu-id="c728d-166">Because you can specify display list names, however, you can redefine individual display lists in a hierarchy.</span></span> <span data-ttu-id="c728d-167">Las listas de visualización de OpenGL están diseñadas para el almacenamiento en caché de datos, no para la administración de bases de datos.</span><span class="sxs-lookup"><span data-stu-id="c728d-167">OpenGL display lists are designed for data caching, not for database management.</span></span> <span data-ttu-id="c728d-168">Se garantiza que se almacenen en el servidor en entornos cliente/servidor, por lo que no están limitados por el ancho de banda de red durante la ejecución.</span><span class="sxs-lookup"><span data-stu-id="c728d-168">They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.</span></span> <span data-ttu-id="c728d-169">Se puede llamar a las listas de visualización de OpenGL entre los comandos glBegin y glEnd, por lo que la jerarquía de la lista de presentación se puede hacer lo suficientemente bien como para que, en efecto, se pueda editar.</span><span class="sxs-lookup"><span data-stu-id="c728d-169">OpenGL display lists can be called between glBegin and glEnd commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.</span></span>                                                                                              |
| <span data-ttu-id="c728d-170">comprobación de errores</span><span class="sxs-lookup"><span data-stu-id="c728d-170">error checking</span></span>                       | <span data-ttu-id="c728d-171">OpenGL comprueba si hay errores con más cuidado que IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-171">OpenGL checks for errors more carefully than IRIS GL.</span></span> <span data-ttu-id="c728d-172">Por ejemplo, todas las funciones de OpenGL que no se aceptan entre glBegin y glEnd se detectan como errores y no tienen ningún otro efecto.</span><span class="sxs-lookup"><span data-stu-id="c728d-172">For example, all OpenGL functions that are not accepted between glBegin and glEnd are detected as errors, and have no other effect.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="c728d-173">valores devueltos de error</span><span class="sxs-lookup"><span data-stu-id="c728d-173">error return values</span></span>                  | <span data-ttu-id="c728d-174">Cuando un comando OpenGL que devuelve un valor detecta un error, siempre devuelve cero.</span><span class="sxs-lookup"><span data-stu-id="c728d-174">When an OpenGL command that returns a value detects an error, it always returns zero.</span></span> <span data-ttu-id="c728d-175">Los comandos OpenGL que devuelven datos a través de punteros pasados no hacen ningún cambio en el contenido de la matriz si se detecta un error.</span><span class="sxs-lookup"><span data-stu-id="c728d-175">OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="c728d-176">efectos secundarios de error</span><span class="sxs-lookup"><span data-stu-id="c728d-176">error side effects</span></span>                   | <span data-ttu-id="c728d-177">Cuando un comando OpenGL produce un error, su único efecto secundario es actualizar la marca de error al valor adecuado.</span><span class="sxs-lookup"><span data-stu-id="c728d-177">When an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value.</span></span> <span data-ttu-id="c728d-178">No se realiza ningún otro cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="c728d-178">No other state changes are made.</span></span> <span data-ttu-id="c728d-179">(Una excepción es OUT \_ Of \_ MEMORY error, which is fatal.)</span><span class="sxs-lookup"><span data-stu-id="c728d-179">(An exception is the OUT\_OF\_MEMORY error, which is fatal.)</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="c728d-180">feedback</span><span class="sxs-lookup"><span data-stu-id="c728d-180">feedback</span></span>                             | <span data-ttu-id="c728d-181">Los comentarios están estandarizados en OpenGL para que no cambien de máquina a máquina.</span><span class="sxs-lookup"><span data-stu-id="c728d-181">Feedback is standardized in OpenGL so it doesn't change from machine to machine.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="c728d-182">fuentes y cadenas</span><span class="sxs-lookup"><span data-stu-id="c728d-182">fonts and strings</span></span>                    | <span data-ttu-id="c728d-183">OpenGL requiere que los glifos de caracteres se manipulen como listas de visualización individuales.</span><span class="sxs-lookup"><span data-stu-id="c728d-183">OpenGL requires character glyphs to be manipulated as individual display lists.</span></span> <span data-ttu-id="c728d-184">Proporciona una función de llamada de lista para mostrar que acepta una lista de nombres de lista para mostrar, cada nombre representado como 1, 2 o 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="c728d-184">It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes.</span></span> <span data-ttu-id="c728d-185">La función glCallLists agrega un desplazamiento especificado por separado a cada nombre de lista para mostrar antes de la llamada, lo que permite que las listas de nombres de lista para mostrar se traten como cadenas.</span><span class="sxs-lookup"><span data-stu-id="c728d-185">The glCallLists function adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings.</span></span> <span data-ttu-id="c728d-186">Este mecanismo proporciona toda la funcionalidad de las fuentes IRIS GL y mucho más.</span><span class="sxs-lookup"><span data-stu-id="c728d-186">This mechanism provides all the functionality of IRIS GL fonts, and considerably more.</span></span> <span data-ttu-id="c728d-187">Por ejemplo, los caracteres compuestos por triángulos se pueden manipular fácilmente.</span><span class="sxs-lookup"><span data-stu-id="c728d-187">For example, characters comprised of triangles can be easily manipulated.</span></span>                                                                                                                  |
| <span data-ttu-id="c728d-188">frontbuffer</span><span class="sxs-lookup"><span data-stu-id="c728d-188">frontbuffer</span></span>                          | <span data-ttu-id="c728d-189">IRIS GL tiene reglas complejas para la representación en el búfer front en modo de búfer único.</span><span class="sxs-lookup"><span data-stu-id="c728d-189">IRIS GL has complex rules for rendering to the front buffer in single buffer mode.</span></span> <span data-ttu-id="c728d-190">OpenGL controla la representación en el búfer front de una manera sencilla.</span><span class="sxs-lookup"><span data-stu-id="c728d-190">OpenGL handles rendering to the front buffer in a straightforward way.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="c728d-191">polígonos de huecos</span><span class="sxs-lookup"><span data-stu-id="c728d-191">hollow polygons</span></span>                      | <span data-ttu-id="c728d-192">Puede usar la capacidad de galería de símbolos OpenGL para representar polígonos vacíos.</span><span class="sxs-lookup"><span data-stu-id="c728d-192">You can use the OpenGL stencil capacity to render hollow polygons.</span></span> <span data-ttu-id="c728d-193">OpenGL no admite otros medios para crear polígonos vacíos.</span><span class="sxs-lookup"><span data-stu-id="c728d-193">OpenGL doesn't support other means for creating hollow polygons.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="c728d-194">fijación de índices</span><span class="sxs-lookup"><span data-stu-id="c728d-194">index clamping</span></span>                       | <span data-ttu-id="c728d-195">Siempre que sea posible, OpenGL trata los índices de color y galería de símbolos como campos de bits en lugar de números.</span><span class="sxs-lookup"><span data-stu-id="c728d-195">Where possible, OpenGL treats color and stencil indexes as bit fields rather than numbers.</span></span> <span data-ttu-id="c728d-196">Por lo tanto, los índices se enmascaran, en lugar de fijarse, en el intervalo admitido del búfer de fotogramas.</span><span class="sxs-lookup"><span data-stu-id="c728d-196">Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="c728d-197">colores enteros</span><span class="sxs-lookup"><span data-stu-id="c728d-197">integer colors</span></span>                       | <span data-ttu-id="c728d-198">Los componentes de color entero con signo (rojo, verde, azul o alfa) se asignan de forma lineal a los puntos flotantes para que el entero más negativo se asigne a 1,0 y el entero más positivo se asigne a 1,0.</span><span class="sxs-lookup"><span data-stu-id="c728d-198">Signed integer color components (red, green, blue, or alpha) are mapped in linear fashion to floating points so that the most negative integer maps to 1.0 and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="c728d-199">Esta asignación se produce cuando se especifica el color antes de que OpenGL reemplace el color actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-199">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span> <span data-ttu-id="c728d-200">Los componentes de color entero sin signo se asignan linealmente a puntos flotantes para que 0 se asigne a 0,0 y el entero más grande se asigne a 1,0.</span><span class="sxs-lookup"><span data-stu-id="c728d-200">Unsigned integer color components are mapped linearly to floating points so that 0 maps to 0.0 and the largest integer maps to 1.0.</span></span> <span data-ttu-id="c728d-201">Esta asignación se produce cuando se especifica el color antes de que OpenGL reemplace el color actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-201">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span>                                                                                                                                               |
| <span data-ttu-id="c728d-202">normales de enteros</span><span class="sxs-lookup"><span data-stu-id="c728d-202">integer normals</span></span>                      | <span data-ttu-id="c728d-203">Los componentes normales enteros se asignan igual que los componentes de color con signo.</span><span class="sxs-lookup"><span data-stu-id="c728d-203">Integer normal components are mapped just like signed color components.</span></span> <span data-ttu-id="c728d-204">El entero más negativo se asigna a 1,0 y el entero más positivo se asigna a 1,0.</span><span class="sxs-lookup"><span data-stu-id="c728d-204">The most negative integer maps to 1.0, and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="c728d-205">fragmentos de píxeles.</span><span class="sxs-lookup"><span data-stu-id="c728d-205">pixel fragments.</span></span> <span data-ttu-id="c728d-206">Los píxeles dibujados por glDrawPixels o glCopyPixels siempre se rasterizan y se convierten en fragmentos.</span><span class="sxs-lookup"><span data-stu-id="c728d-206">Pixels drawn by glDrawPixels or glCopyPixels are always rasterized and converted to fragments.</span></span> <span data-ttu-id="c728d-207">Los fragmentos resultantes se texturan, se agrupan en búfer, se mezclan, y así sucesivamente, como si se hubieran generado a partir de puntos geométricos.</span><span class="sxs-lookup"><span data-stu-id="c728d-207">The resulting fragments are textured, fogged, depth buffered, blended, and so on, just as if they were generated from geometric points.</span></span> <span data-ttu-id="c728d-208">Los datos de fragmentos que no proporcionan los píxeles de origen se aumentan a partir de la posición de trama actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-208">Fragment data that isn't provided by the source pixels is augmented from the current raster position.</span></span> <span data-ttu-id="c728d-209">Por ejemplo, los píxeles RGBA toman la posición del trama Z y las coordenadas de textura.</span><span class="sxs-lookup"><span data-stu-id="c728d-209">For example, RGBA pixels take the raster position Z and texture coordinates.</span></span> <span data-ttu-id="c728d-210">Los píxeles de profundidad toman las coordenadas de color y textura de la posición del trama.</span><span class="sxs-lookup"><span data-stu-id="c728d-210">Depth pixels take the raster position color and texture coordinates.</span></span> |
| <span data-ttu-id="c728d-211">Invariación</span><span class="sxs-lookup"><span data-stu-id="c728d-211">invariance</span></span>                           | <span data-ttu-id="c728d-212">OpenGL garantiza una cierta coherencia que IRIS GL no tiene.</span><span class="sxs-lookup"><span data-stu-id="c728d-212">OpenGL guarantees a certain consistency that IRIS GL doesn't.</span></span> <span data-ttu-id="c728d-213">Por ejemplo, OpenGL garantiza que las secuencias de código idénticas enviadas al mismo sistema, que solo difieren en la función de combinación especificada, generarán los mismos fragmentos de píxeles.</span><span class="sxs-lookup"><span data-stu-id="c728d-213">For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the specified blending function, will generate the same pixel fragments.</span></span> <span data-ttu-id="c728d-214">(Los fragmentos difieren, sin embargo, si la mezcla está habilitada y, a continuación, deshabilitada).</span><span class="sxs-lookup"><span data-stu-id="c728d-214">(The fragments differ, however, if blending is enabled and then disabled.)</span></span>                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="c728d-215">ecuación de iluminación</span><span class="sxs-lookup"><span data-stu-id="c728d-215">lighting equation</span></span>                    | <span data-ttu-id="c728d-216">La ecuación de iluminación openGL difiere ligeramente de la ecuación GL de IRIS.</span><span class="sxs-lookup"><span data-stu-id="c728d-216">The OpenGL lighting equation differs slightly from the IRIS GL equation.</span></span> <span data-ttu-id="c728d-217">OpenGL admite la atenuación independiente para cada fuente de luz, en lugar de una sola atenuación para todas las fuentes de luz, como IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-217">OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources like IRIS GL.</span></span> <span data-ttu-id="c728d-218">OpenGL ajusta la ecuación para que se atenúan todas las contribuciones de iluminación ambiental, difusa y especular.</span><span class="sxs-lookup"><span data-stu-id="c728d-218">OpenGL adjusts the equation so that ambient, diffuse, and specular lighting contributions are all attenuated.</span></span> <span data-ttu-id="c728d-219">Además, OpenGL permite especificar colores independientes para las intensidades ambientales, difusas y especulares de las fuentes de luz, así como para la reflexión ambiental, difusa y especular de los materiales.</span><span class="sxs-lookup"><span data-stu-id="c728d-219">Also, OpenGL allows you to specify separate colors for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials.</span></span> <span data-ttu-id="c728d-220">Todos los colores claros y de material de OpenGL incluyen alfa.</span><span class="sxs-lookup"><span data-stu-id="c728d-220">All OpenGL light and material colors include alpha.</span></span> <span data-ttu-id="c728d-221">Al establecer el exponente especular en cero, no se gana la iluminación especular en OpenGL.</span><span class="sxs-lookup"><span data-stu-id="c728d-221">Setting the specular exponent to zero does not defeat specular lighting in OpenGL.</span></span>    |
| <span data-ttu-id="c728d-222">mapw</span><span class="sxs-lookup"><span data-stu-id="c728d-222">mapw</span></span>                                 | <span data-ttu-id="c728d-223">Las utilidades OpenGL admiten la asignación entre coordenadas de objeto y ventana.</span><span class="sxs-lookup"><span data-stu-id="c728d-223">OpenGL utilities support mapping between object and window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="c728d-224">modo de matriz</span><span class="sxs-lookup"><span data-stu-id="c728d-224">matrix mode</span></span>                          | <span data-ttu-id="c728d-225">Cuando las funciones ortoto, ortoto2, perspectiva y ventana de IRIS GL funcionan en una matriz determinada, todas las operaciones de matriz OpenGL funcionan en la matriz actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-225">Where the IRIS GL ortho, ortho2, perspective, and window functions operate on a particular matrix, all OpenGL matrix operations work on the current matrix.</span></span> <span data-ttu-id="c728d-226">Todas las operaciones de matriz OpenGL excepto glLoadIdentity y glLoadMatrix multiplican la matriz actual en lugar de reemplazarla (al igual que orto, orto2, perspectiva y ventana en IRIS GL).</span><span class="sxs-lookup"><span data-stu-id="c728d-226">All OpenGL matrix operations except glLoadIdentity and glLoadMatrix multiply the current matrix rather than replacing it (as do ortho, ortho2, perspective, and window in the IRIS GL).</span></span>                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="c728d-227">mipmaps, generación automática</span><span class="sxs-lookup"><span data-stu-id="c728d-227">mipmaps, automatic generation</span></span>        | <span data-ttu-id="c728d-228">La interfaz de textura OpenGL no admite la generación automática de imágenes mipmap.</span><span class="sxs-lookup"><span data-stu-id="c728d-228">The OpenGL texture interface does not support automatic generation of mipmap images.</span></span> <span data-ttu-id="c728d-229">Sin embargo, glu admite la generación automática de imágenes mipmap para texturas 1D y 2D.</span><span class="sxs-lookup"><span data-stu-id="c728d-229">However, the GLU supports the automatic generation of mipmap images for both 1-D and 2-D textures.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="c728d-230">move/draw/pmove/pdraw/pclos</span><span class="sxs-lookup"><span data-stu-id="c728d-230">move/draw/pmove/pdraw/pclos</span></span>          | <span data-ttu-id="c728d-231">OpenGL solo admite gráficos de estilo Begin/End, ya que no mantiene una posición de gráficos actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-231">OpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position.</span></span> <span data-ttu-id="c728d-232">Sin embargo, OpenGL acepta la especificación de parámetros escalares de los comandos antiguos de movimiento y dibujo para todos los comandos relacionados con vértices.</span><span class="sxs-lookup"><span data-stu-id="c728d-232">The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="c728d-233">Modo mprojection</span><span class="sxs-lookup"><span data-stu-id="c728d-233">mprojection mode</span></span>                     | <span data-ttu-id="c728d-234">IRIS GL no transforma la geometría por la matriz modelview mientras está en modo de matriz de proyección.</span><span class="sxs-lookup"><span data-stu-id="c728d-234">IRIS GL doesn't transform geometry by the modelview matrix while in projection matrix mode.</span></span> <span data-ttu-id="c728d-235">OpenGL siempre se transforma por la vista de modelo y la matriz de proyección, independientemente del modo de matriz.</span><span class="sxs-lookup"><span data-stu-id="c728d-235">OpenGL always transforms by both the modelview and the projection matrix, regardless of matrix mode.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="c728d-236">dibujo de varios búferes</span><span class="sxs-lookup"><span data-stu-id="c728d-236">multi-buffer drawing</span></span>                 | <span data-ttu-id="c728d-237">OpenGL se representa individualmente en cada búfer de color, en lugar de calcular un valor de color único, nuevo, en función del contenido de un búfer de color y escribirlo en todos los búferes de color habilitados, como lo hace IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-237">OpenGL renders to each color buffer individually, rather than computing a single, new, color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL does.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="c728d-238">Nurbs</span><span class="sxs-lookup"><span data-stu-id="c728d-238">NURBS</span></span>                                | <span data-ttu-id="c728d-239">OpenGL es compatible con GLUBS con una combinación de funcionalidad básica (evaluadores) y compatibilidad con GLU.</span><span class="sxs-lookup"><span data-stu-id="c728d-239">OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support.</span></span> <span data-ttu-id="c728d-240">Se admiten todas las funcionalidades de IRIS GL LOBS.</span><span class="sxs-lookup"><span data-stu-id="c728d-240">All IRIS GL NURBS capabilities are supported.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="c728d-241">modo de polígono antiguo</span><span class="sxs-lookup"><span data-stu-id="c728d-241">old polygon mode</span></span>                     | <span data-ttu-id="c728d-242">Los polígonos OpenGL con alias siempre tienen muestras de punto.</span><span class="sxs-lookup"><span data-stu-id="c728d-242">Aliased OpenGL polygons are always point-sampled.</span></span> <span data-ttu-id="c728d-243">No se admite el modo de compatibilidad de polígonos de IRIS GL, donde los píxeles fuera del perímetro del polígono se incluyen en su rasterización.</span><span class="sxs-lookup"><span data-stu-id="c728d-243">IRIS GL's polygon compatibility mode, where pixels outside the polygon perimeter are included in its rasterization, is not supported.</span></span> <span data-ttu-id="c728d-244">Si el código usa este modo de polígono, probablemente sea para rectángulos.</span><span class="sxs-lookup"><span data-stu-id="c728d-244">If your code uses this polygon mode, it is probably for rectangles.</span></span> <span data-ttu-id="c728d-245">Los rectángulos de modo polígono antiguos aparecen un píxel más ancho y superior.</span><span class="sxs-lookup"><span data-stu-id="c728d-245">Old polygon mode rectangles appear one pixel wider and higher.</span></span>                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="c728d-246">formatos de color empaquetados</span><span class="sxs-lookup"><span data-stu-id="c728d-246">packed color formats</span></span>                 | <span data-ttu-id="c728d-247">OpenGL acepta colores como componentes de 8 bits, pero estos componentes se tratan como una matriz de bytes en lugar de como bytes empaquetados en palabras más grandes.</span><span class="sxs-lookup"><span data-stu-id="c728d-247">OpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words.</span></span> <span data-ttu-id="c728d-248">Al fomentar la indexación de matrices en lugar de cambiar, OpenGL promueve la programación invariable de endian.</span><span class="sxs-lookup"><span data-stu-id="c728d-248">By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.</span></span> <span data-ttu-id="c728d-249">Del mismo modo que IRIS GL acepta colores empaquetados para la representación geométrica y en píxeles, OpenGL acepta matrices de componentes de color para la representación geométrica y en píxeles.</span><span class="sxs-lookup"><span data-stu-id="c728d-249">Just as IRIS GL accepts packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.</span></span>                                                                                                                                                                                                                                                              |
| <span data-ttu-id="c728d-250">Parches</span><span class="sxs-lookup"><span data-stu-id="c728d-250">patches</span></span>                              | <span data-ttu-id="c728d-251">OpenGL no admite revisiones de IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-251">OpenGL doesn't support IRIS GL patches.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="c728d-252">máscara de escritura de color por bit</span><span class="sxs-lookup"><span data-stu-id="c728d-252">per-bit color writemask</span></span>              | <span data-ttu-id="c728d-253">Las máscaras de escritura OpenGL para los componentes de color habilitan o deshabilitan los cambios en todo el componente (rojo, verde, azul o alfa), no en bits individuales de componentes.</span><span class="sxs-lookup"><span data-stu-id="c728d-253">OpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components.</span></span> <span data-ttu-id="c728d-254">Tenga en cuenta que las máscaras de escritura por bit se admiten tanto para índices de color como para índices de galería de símbolos.</span><span class="sxs-lookup"><span data-stu-id="c728d-254">Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="c728d-255">máscara de escritura por profundidad de bits</span><span class="sxs-lookup"><span data-stu-id="c728d-255">per-bit depth writemask</span></span>              | <span data-ttu-id="c728d-256">Las máscaras de escritura openGL para los componentes de profundidad habilitan o deshabilitan los cambios en todo el componente, no en los bits individuales del componente de profundidad.</span><span class="sxs-lookup"><span data-stu-id="c728d-256">OpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="c728d-257">Elegir</span><span class="sxs-lookup"><span data-stu-id="c728d-257">pick</span></span>                                 | <span data-ttu-id="c728d-258">La biblioteca de la utilidad OpenGL incluye compatibilidad para generar una matriz de selección.</span><span class="sxs-lookup"><span data-stu-id="c728d-258">The OpenGL Utility library includes support for generating a pick matrix.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="c728d-259">coordenadas de píxeles</span><span class="sxs-lookup"><span data-stu-id="c728d-259">pixel coordinates</span></span>                    | <span data-ttu-id="c728d-260">En OpenGL e IRIS GL, el origen del sistema de coordenadas de una ventana está en la esquina inferior izquierda.</span><span class="sxs-lookup"><span data-stu-id="c728d-260">In both OpenGL and IRIS GL, the origin of a window's coordinate system is at its lower left corner.</span></span> <span data-ttu-id="c728d-261">Sin embargo, OpenGL coloca el origen en la esquina inferior izquierda de este píxel, mientras que IRIS GL lo coloca en el centro del píxel inferior izquierdo.</span><span class="sxs-lookup"><span data-stu-id="c728d-261">OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL places it at the center of the lower left pixel.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="c728d-262">zoom de píxeles</span><span class="sxs-lookup"><span data-stu-id="c728d-262">pixel zoom</span></span>                           | <span data-ttu-id="c728d-263">Los factores de zoom negativos de OpenGL reflejan la posición actual de los gráficos.</span><span class="sxs-lookup"><span data-stu-id="c728d-263">OpenGL negative zoom factors reflect about the current graphics position.</span></span> <span data-ttu-id="c728d-264">IRIS GL no define el funcionamiento de los factores de zoom negativos y, en su lugar, proporciona los modos de reflexión RIGHT TO LEFT y \_ \_ TOP TO \_ \_ BOTTOM.</span><span class="sxs-lookup"><span data-stu-id="c728d-264">IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT\_TO\_LEFT and TOP\_TO\_BOTTOM reflection pixmodes.</span></span> <span data-ttu-id="c728d-265">Estos modos de reflexión se reflejan en contexto, en lugar de en la posición de trama actual.</span><span class="sxs-lookup"><span data-stu-id="c728d-265">These reflection modes reflect in place, rather than about the current raster position.</span></span> <span data-ttu-id="c728d-266">OpenGL no define los modos de reflexión.</span><span class="sxs-lookup"><span data-stu-id="c728d-266">OpenGL doesn't define reflection modes.</span></span>                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="c728d-267">modemode</span><span class="sxs-lookup"><span data-stu-id="c728d-267">pixmode</span></span>                              | <span data-ttu-id="c728d-268">Las transferencias de píxeles OpenGL funcionan en componentes de color individuales, en lugar de en grupos empaquetados de cuatro componentes de 8 bits, al igual que IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-268">OpenGL pixel transfers operate on individual color components, rather than on packed groups of four 8-bit components as does IRIS GL.</span></span> <span data-ttu-id="c728d-269">Aunque OpenGL proporciona una funcionalidad de píxeles considerablemente mayor que IRIS GL, no admite construcciones de color empaquetado y no permite reasignar componentes de color (rojo a verde, rojo a azul, etc.) durante las operaciones de copia de píxeles.</span><span class="sxs-lookup"><span data-stu-id="c728d-269">While OpenGL provides substantially more pixel capability than IRIS GL, it doesn't support packed color constructs, and it doesn't enable color components to be reassigned (red to green, red to blue, and so on) during pixel copy operations.</span></span>                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="c728d-270">polf/poly</span><span class="sxs-lookup"><span data-stu-id="c728d-270">polf/poly</span></span>                            | <span data-ttu-id="c728d-271">OpenGL no proporciona compatibilidad directa con listas de vértices que no sea mostrar listas.</span><span class="sxs-lookup"><span data-stu-id="c728d-271">OpenGL provides no direct support for vertex lists other than display lists.</span></span> <span data-ttu-id="c728d-272">Sin embargo, las funciones como polf y poly se pueden implementar fácilmente mediante la API OpenGL.</span><span class="sxs-lookup"><span data-stu-id="c728d-272">Functions like polf and poly can be implemented easily using the OpenGL API, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="c728d-273">vértice de provocación de polígono</span><span class="sxs-lookup"><span data-stu-id="c728d-273">polygon provoking vertex</span></span>             | <span data-ttu-id="c728d-274">Los polígonos GL de IRIS sombreados planos toman el color del último vértice especificado, mientras que los polígonos OpenGL toman el color del primer vértice especificado.</span><span class="sxs-lookup"><span data-stu-id="c728d-274">Flat shaded IRIS GL polygons take the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="c728d-275">polygon stipple</span><span class="sxs-lookup"><span data-stu-id="c728d-275">polygon stipple</span></span>                      | <span data-ttu-id="c728d-276">Con IRIS GL, el patrón detippla de polígono es relativo a la pantalla.</span><span class="sxs-lookup"><span data-stu-id="c728d-276">With IRIS GL the polygon stipple pattern is relative to the screen.</span></span> <span data-ttu-id="c728d-277">Con OpenGL es relativo a una ventana.</span><span class="sxs-lookup"><span data-stu-id="c728d-277">With OpenGL it is relative to a window.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="c728d-278">recuento de vértices de polígono</span><span class="sxs-lookup"><span data-stu-id="c728d-278">polygon vertex count</span></span>                 | <span data-ttu-id="c728d-279">No hay ningún límite en el número de vértices entre glBegin y glEnd con OpenGL, incluso para glBegin(POLYGON).</span><span class="sxs-lookup"><span data-stu-id="c728d-279">There is no limit to the number of vertices between glBegin and glEnd with OpenGL, even for glBegin(POLYGON ).</span></span> <span data-ttu-id="c728d-280">Con IRIS GL, los polígonos se limitan a no más de 255 vértices.</span><span class="sxs-lookup"><span data-stu-id="c728d-280">With IRIS GL, polygons are limited to no more than 255 vertices.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="c728d-281">readdisplay</span><span class="sxs-lookup"><span data-stu-id="c728d-281">readdisplay</span></span>                          | <span data-ttu-id="c728d-282">Leer píxeles fuera de los límites de la ventana es correctamente una funcionalidad del sistema de ventanas, en lugar de una funcionalidad de representación.</span><span class="sxs-lookup"><span data-stu-id="c728d-282">Reading pixels outside window boundaries is properly a window system capability, rather than a rendering capability.</span></span> <span data-ttu-id="c728d-283">Use funciones de Windows para reemplazar el comando readdisplay de IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-283">Use Windows functions to replace the IRIS GL readdisplay command.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="c728d-284">relative move/draw/pmove/pdraw/pclos</span><span class="sxs-lookup"><span data-stu-id="c728d-284">relative move/draw/pmove/pdraw/pclos</span></span> | <span data-ttu-id="c728d-285">OpenGL no mantiene una posición de gráficos actual y, por tanto, no admite operaciones de vértice relativas.</span><span class="sxs-lookup"><span data-stu-id="c728d-285">OpenGL doesn't maintain a current graphics position, and therefore doesn't support relative vertex operations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="c728d-286">RGBA logicop()</span><span class="sxs-lookup"><span data-stu-id="c728d-286">RGBA logicop()</span></span>                       | <span data-ttu-id="c728d-287">OpenGL no admite operaciones lógicas en búferes RGBA.</span><span class="sxs-lookup"><span data-stu-id="c728d-287">OpenGL does not support logical operations on RGBA buffers.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="c728d-288">sbox()</span><span class="sxs-lookup"><span data-stu-id="c728d-288">sbox()</span></span>                               | <span data-ttu-id="c728d-289">sbox es una primitiva del rectángulo IRIS GL que solo está bien definida si se transforma sin rotación.</span><span class="sxs-lookup"><span data-stu-id="c728d-289">sbox is an IRIS GL rectangle primitive that is well-defined only if transformed without rotation.</span></span> <span data-ttu-id="c728d-290">Está diseñado para representarse más rápido que los rectángulos estándar.</span><span class="sxs-lookup"><span data-stu-id="c728d-290">It is designed to be rendered faster than standard rectangles.</span></span> <span data-ttu-id="c728d-291">Aunque OpenGL no admite este tipo de primitiva, se puede optimizar para representar rectángulos muy rápidamente cuando las matrices y otros modos están en estados que simplifican los cálculos.</span><span class="sxs-lookup"><span data-stu-id="c728d-291">While OpenGL doesn't support such a primitive, it can be tuned to render rectangles very quickly when the matrices and other modes are in states that simplify calculations.</span></span>                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="c728d-292">argumentos escalares</span><span class="sxs-lookup"><span data-stu-id="c728d-292">scalar arguments</span></span>                     | <span data-ttu-id="c728d-293">Todos los comandos OpenGL que se aceptan entre glBegin y glEnd tienen puntos de entrada que aceptan argumentos escalares.</span><span class="sxs-lookup"><span data-stu-id="c728d-293">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept scalar arguments.</span></span> <span data-ttu-id="c728d-294">Por ejemplo, glColor4f (rojo, verde, azul, alfa).</span><span class="sxs-lookup"><span data-stu-id="c728d-294">For example, glColor4f (red, green, blue, alpha ).</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="c728d-295">Tijera</span><span class="sxs-lookup"><span data-stu-id="c728d-295">scissor</span></span>                              | <span data-ttu-id="c728d-296">La función glScissor de OpenGL no realiza un seguimiento de la ventanilla.</span><span class="sxs-lookup"><span data-stu-id="c728d-296">The OpenGL glScissor function doesn't track the viewport.</span></span> <span data-ttu-id="c728d-297">El comando de ventanilla IRIS GL actualiza automáticamente el scrmask.</span><span class="sxs-lookup"><span data-stu-id="c728d-297">The IRIS GL viewport command automatically updates the scrmask.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="c728d-298">scrbox()</span><span class="sxs-lookup"><span data-stu-id="c728d-298">scrbox()</span></span>                             | <span data-ttu-id="c728d-299">OpenGL no admite el cálculo de rectángulos de selección.</span><span class="sxs-lookup"><span data-stu-id="c728d-299">OpenGL doesn't support bounding box computation.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="c728d-300">scrsubdivide()</span><span class="sxs-lookup"><span data-stu-id="c728d-300">scrsubdivide()</span></span>                       | <span data-ttu-id="c728d-301">OpenGL no admite la subdivisión de pantalla.</span><span class="sxs-lookup"><span data-stu-id="c728d-301">OpenGL doesn't support screen subdivision.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="c728d-302">modo de matriz única</span><span class="sxs-lookup"><span data-stu-id="c728d-302">single matrix mode</span></span>                   | <span data-ttu-id="c728d-303">OpenGL siempre mantiene dos matrices: ModelView y Projection.</span><span class="sxs-lookup"><span data-stu-id="c728d-303">OpenGL always maintains two matrices: ModelView and Projection.</span></span> <span data-ttu-id="c728d-304">Aunque una implementación de OpenGL puede consolidarla en una sola matriz por motivos de rendimiento, siempre debe presentar el modelo de dos matrices al programador.</span><span class="sxs-lookup"><span data-stu-id="c728d-304">While an OpenGL implementation can consolidate these into a single matrix for performance reasons, it must always present the two-matrix model to the programmer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| <span data-ttu-id="c728d-305">modo de subpixel</span><span class="sxs-lookup"><span data-stu-id="c728d-305">subpixel mode</span></span>                        | <span data-ttu-id="c728d-306">Toda la representación de OpenGL es el modo de subpíxel posicionadosubpixel siempre está on.</span><span class="sxs-lookup"><span data-stu-id="c728d-306">All OpenGL rendering is subpixel positionedsubpixel mode is always on.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="c728d-307">swaptmesh()</span><span class="sxs-lookup"><span data-stu-id="c728d-307">swaptmesh()</span></span>                          | <span data-ttu-id="c728d-308">OpenGL no admite la funcionalidad swaptmesh.</span><span class="sxs-lookup"><span data-stu-id="c728d-308">OpenGL doesn't support the swaptmesh capability.</span></span> <span data-ttu-id="c728d-309">Sin embargo, ofrece dos tipos de mallas de triángulo: una que se corresponde con el comportamiento predeterminado de "franja" de IRIS GL y otra que se corresponde con la llamada a swaptmesh antes del tercero y todos los vértices posteriores al usar IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="c728d-309">It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling swaptmesh prior to the third and all subsequent vertices when using IRIS GL.</span></span>                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="c728d-310">argumentos vectoriales</span><span class="sxs-lookup"><span data-stu-id="c728d-310">vector arguments</span></span>                     | <span data-ttu-id="c728d-311">Todos los comandos OpenGL que se aceptan entre glBegin y glEnd tienen puntos de entrada que aceptan argumentos vectoriales.</span><span class="sxs-lookup"><span data-stu-id="c728d-311">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept vector arguments.</span></span> <span data-ttu-id="c728d-312">Por ejemplo, glColor4fv .</span><span class="sxs-lookup"><span data-stu-id="c728d-312">For example, glColor4fv .</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="c728d-313">administración de ventanas</span><span class="sxs-lookup"><span data-stu-id="c728d-313">window management</span></span>                    | <span data-ttu-id="c728d-314">OpenGL no incluye comandos del sistema de ventana.</span><span class="sxs-lookup"><span data-stu-id="c728d-314">OpenGL includes no window system commands.</span></span> <span data-ttu-id="c728d-315">Siempre se admite como una extensión de una ventana o sistema operativo que incluye funcionalidad para el control de dispositivos y ventanas.</span><span class="sxs-lookup"><span data-stu-id="c728d-315">It is always supported as an extension to a window or operating system that includes capability for device and window control.</span></span> <span data-ttu-id="c728d-316">Cada extensión proporciona un mecanismo específico del sistema para crear, destruir y manipular contextos de representación de OpenGL.</span><span class="sxs-lookup"><span data-stu-id="c728d-316">Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts.</span></span> <span data-ttu-id="c728d-317">Por ejemplo, la extensión OpenGL para el sistema de ventanas X (GLX) incluye aproximadamente 10 comandos para este propósito.</span><span class="sxs-lookup"><span data-stu-id="c728d-317">For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.</span></span> <span data-ttu-id="c728d-318">OpenGL no implementa comandos IRIS GL como gconfig y drawmode.</span><span class="sxs-lookup"><span data-stu-id="c728d-318">IRIS GL commands such as gconfig and drawmode are not implemented by OpenGL.</span></span>                                                                                                                                                                            |
| <span data-ttu-id="c728d-319">desplazamiento de ventana</span><span class="sxs-lookup"><span data-stu-id="c728d-319">window offset</span></span>                        | <span data-ttu-id="c728d-320">IRIS GL devuelve las posiciones de la ventanilla y los caracteres en las coordenadas de la pantalla, en lugar de las de la ventana.</span><span class="sxs-lookup"><span data-stu-id="c728d-320">IRIS GL returns viewport and character positions in screen, rather than window, coordinates.</span></span> <span data-ttu-id="c728d-321">OpenGL siempre usa coordenadas de ventana.</span><span class="sxs-lookup"><span data-stu-id="c728d-321">OpenGL always uses window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="c728d-322">Representación de z</span><span class="sxs-lookup"><span data-stu-id="c728d-322">z rendering</span></span>                          | <span data-ttu-id="c728d-323">OpenGL no admite la representación de colores en el búfer de profundidad.</span><span class="sxs-lookup"><span data-stu-id="c728d-323">OpenGL doesn't support rendering colors to the depth buffer.</span></span> <span data-ttu-id="c728d-324">Permite búferes de color adicionales, que se pueden implementar con la misma memoria que se usa para los búferes de profundidad en otras configuraciones de ventana.</span><span class="sxs-lookup"><span data-stu-id="c728d-324">It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurations.</span></span> <span data-ttu-id="c728d-325">Pero estos búferes de color adicionales no pueden compartir memoria con el búfer de profundidad en ninguna configuración única.</span><span class="sxs-lookup"><span data-stu-id="c728d-325">But these additional color buffers cannot share memory with the depth buffer in any single configuration.</span></span>                                                                                                                                                                                                                                                                                                                                          |



 

 

 




