---
description: La protección de flujo de control (CFG) es una característica de seguridad de plataforma altamente optimizada que se creó para combatir vulnerabilidades de daños en la memoria.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Protección de flujo de control
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91cf97a648443135e7fee666ea4c259b1c32104e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "104156869"
---
# <a name="control-flow-guard"></a><span data-ttu-id="e9091-103">Protección de flujo de control</span><span class="sxs-lookup"><span data-stu-id="e9091-103">Control Flow Guard</span></span>

## <a name="what-is-control-flow-guard"></a><span data-ttu-id="e9091-104">¿Qué es la protección de flujo de control?</span><span class="sxs-lookup"><span data-stu-id="e9091-104">What is Control Flow Guard?</span></span>

<span data-ttu-id="e9091-105">La protección de flujo de control (CFG) es una característica de seguridad de plataforma altamente optimizada que se creó para combatir vulnerabilidades de daños en la memoria.</span><span class="sxs-lookup"><span data-stu-id="e9091-105">Control Flow Guard (CFG) is a highly-optimized platform security feature that was created to combat memory corruption vulnerabilities.</span></span> <span data-ttu-id="e9091-106">Al colocar restricciones estrictas en el lugar desde el que una aplicación puede ejecutar código, resulta mucho más difícil para los ataques ejecutar código arbitrario a través de vulnerabilidades como desbordamientos del búfer.</span><span class="sxs-lookup"><span data-stu-id="e9091-106">By placing tight restrictions on where an application can execute code from, it makes it much harder for exploits to execute arbitrary code through vulnerabilities such as buffer overflows.</span></span> <span data-ttu-id="e9091-107">CFG amplía las tecnologías de mitigación de vulnerabilidades anteriores, como [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)y [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span><span class="sxs-lookup"><span data-stu-id="e9091-107">CFG extends previous exploit mitigation technologies such as [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md), and [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span></span>

<span data-ttu-id="e9091-108">Esta característica está disponible en Microsoft Visual Studio 2015 y se ejecuta en las versiones de Windows "compatibles con CFG": las versiones x86 y x64 para Desktop y Server de Windows 10 y Windows 8.1 Update (KB3000850).</span><span class="sxs-lookup"><span data-stu-id="e9091-108">This feature is available in Microsoft Visual Studio 2015, and runs on "CFG-Aware" versions of Windows—the x86 and x64 releases for Desktop and Server of Windows 10 and Windows 8.1 Update (KB3000850).</span></span>

<span data-ttu-id="e9091-109">Recomendamos encarecidamente que los desarrolladores habiliten CFG para sus aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="e9091-109">We strongly encourage developers to enable CFG for their applications.</span></span> <span data-ttu-id="e9091-110">No tiene que habilitar CFG para todas las partes del código, ya que se ejecutará correctamente una combinación de CFG habilitada y el código no compatible con CFG.</span><span class="sxs-lookup"><span data-stu-id="e9091-110">You don't have to enable CFG for every part of your code, as a mixture of CFG enabled and non-CFG enabled code will execute fine.</span></span> <span data-ttu-id="e9091-111">Pero si no se habilita CFG para todo el código, pueden abrirse brechas en la protección.</span><span class="sxs-lookup"><span data-stu-id="e9091-111">But failing to enable CFG for all code can open gaps in the protection.</span></span> <span data-ttu-id="e9091-112">Además, el código habilitado para CFG funciona correctamente en las versiones de Windows que no son compatibles con CFG y, por lo tanto, es totalmente compatible con ellos.</span><span class="sxs-lookup"><span data-stu-id="e9091-112">Furthermore, CFG enabled code works fine on "CFG-Unaware" versions of Windows and is therefore fully compatible with them.</span></span>

## <a name="how-can-i-enable-cfg"></a><span data-ttu-id="e9091-113">¿Cómo se puede habilitar CFG?</span><span class="sxs-lookup"><span data-stu-id="e9091-113">How Can I Enable CFG?</span></span>

<span data-ttu-id="e9091-114">En la mayoría de los casos, no es necesario cambiar el código fuente.</span><span class="sxs-lookup"><span data-stu-id="e9091-114">In most cases, there is no need to change source code.</span></span> <span data-ttu-id="e9091-115">Lo único que tiene que hacer es agregar una opción al proyecto de Visual Studio 2015 y el compilador y el vinculador habilitarán CFG.</span><span class="sxs-lookup"><span data-stu-id="e9091-115">All you have to do is add an option to your Visual Studio 2015 project, and the compiler and linker will enable CFG.</span></span>

<span data-ttu-id="e9091-116">El método más sencillo consiste en ir a propiedades de **configuración del proyecto \| generación de \| \| \| código C/C++** y elegir **sí (/Guard: CF)** para la protección de flujo de control.</span><span class="sxs-lookup"><span data-stu-id="e9091-116">The simplest method is to navigate to **Project \| Properties \| Configuration Properties \| C/C++ \| Code Generation** and choose **Yes (/guard:cf)** for Control Flow Guard.</span></span>

![propiedad cfg en Visual Studio](images/cfg-vs.png)

<span data-ttu-id="e9091-118">Como alternativa, agregue **/Guard: CF** a propiedades de **configuración del proyecto \| Opciones de configuración de línea de \| \| \| comandos \| de C/C++** (para el compilador) y **/Guard: CF** a propiedades de configuración propiedades de la **línea de \| \| \| comandos del vinculador \| \| opciones adicionales** (para el vinculador).</span><span class="sxs-lookup"><span data-stu-id="e9091-118">Alternatively, add **/guard:cf** to **Project \| Properties \| Configuration Properties \| C/C++ \| Command Line \| Additional Options** (for the compiler) and **/guard:cf** to **Project \| Properties \| Configuration Properties \| Linker \| Command Line \| Additional Options** (for the linker).</span></span>

![propiedad cfg del compilador](images/cfg-compiler.png)![propiedad cfg para el vinculador](images/cfg-linker.png)

<span data-ttu-id="e9091-121">Consulte [/Guard (habilitar protección de flujo de control)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) para obtener información adicional.</span><span class="sxs-lookup"><span data-stu-id="e9091-121">See [/guard (Enable Control Flow Guard)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) for additional info.</span></span>

<span data-ttu-id="e9091-122">Si va a compilar el proyecto desde la línea de comandos, puede Agregar las mismas opciones.</span><span class="sxs-lookup"><span data-stu-id="e9091-122">If you are building your project from the command line, you can add the same options.</span></span> <span data-ttu-id="e9091-123">Por ejemplo, si va a compilar un proyecto denominado test. cpp, use **cl/Guard: CF test. cpp/Link/Guard: CF**.</span><span class="sxs-lookup"><span data-stu-id="e9091-123">For example, if you are compiling a project called test.cpp, use **cl /guard:cf test.cpp /link /guard:cf**.</span></span>

<span data-ttu-id="e9091-124">También tiene la opción de controlar dinámicamente el conjunto de direcciones de destino de iCall que se considera válidas en CFG mediante [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) desde la API de administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="e9091-124">You also have the option of dynamically controlling the set of icall target addresses that are considered valid by CFG using the [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) from the Memory Management API.</span></span> <span data-ttu-id="e9091-125">Se puede usar la misma API para especificar si las páginas no son válidas o son destinos válidos para CFG.</span><span class="sxs-lookup"><span data-stu-id="e9091-125">The same API can be used to specify whether pages are invalid or valid targets for CFG.</span></span> <span data-ttu-id="e9091-126">De forma predeterminada, las funciones [**VirtualProtect (**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) y [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) tratarán una región específica de páginas ejecutables y confirmadas como destinos de llamada indirecta válidos.</span><span class="sxs-lookup"><span data-stu-id="e9091-126">The [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) and [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) functions will by default treat a specified region of executable and committed pages as valid indirect call targets.</span></span> <span data-ttu-id="e9091-127">Es posible invalidar este comportamiento (por ejemplo, al implementar un compilador Just-in-Time) mediante la especificación de **destinos de página \_ \_ no válidos** al llamar a **VirtualAlloc** o los destinos de la **página \_ no se \_ \_ actualizan** al llamar a **VirtualProtect (** , tal y como se detalla en las constantes de [**protección de memoria**](/windows/desktop/Memory/memory-protection-constants).</span><span class="sxs-lookup"><span data-stu-id="e9091-127">It is possible to override this behavior, such as when implementing a Just-in-Time compiler, by specifying **PAGE\_TARGETS\_INVALID** when calling **VirtualAlloc** or **PAGE\_TARGETS\_NO\_UPDATE** when calling **VirtualProtect** as detailed under [**Memory Protection Constants**](/windows/desktop/Memory/memory-protection-constants).</span></span>

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a><span data-ttu-id="e9091-128">¿Cómo se puede saber que un archivo binario está en la protección del flujo de control?</span><span class="sxs-lookup"><span data-stu-id="e9091-128">How Do I Tell That a Binary is under Control Flow Guard?</span></span>

<span data-ttu-id="e9091-129">Ejecute la [herramienta DUMPBIN](/cpp/build/reference/dumpbin-reference) (incluida en la instalación de visual Studio 2015) desde el símbolo del sistema de Visual Studio con las opciones */headers* y */loadconfig* : **dumpbin/headers/loadconfig test.exe**.</span><span class="sxs-lookup"><span data-stu-id="e9091-129">Run the [dumpbin tool](/cpp/build/reference/dumpbin-reference) (included in the Visual Studio 2015 installation) from the Visual Studio command prompt with the */headers* and */loadconfig* options: **dumpbin /headers /loadconfig test.exe**.</span></span> <span data-ttu-id="e9091-130">La salida de un archivo binario en CFG debe mostrar que los valores de encabezado incluyen "Guard", y que los valores de configuración de carga incluyen "CF instrumentado" y "tabla de FID presente".</span><span class="sxs-lookup"><span data-stu-id="e9091-130">The output for a binary under CFG should show that the header values include "Guard", and that the load config values include "CF Instrumented" and "FID table present".</span></span>

![salida de DUMPBIN/headers](images/cfg-dumpbin-headers.png)

![resultado de DUMPBIN/loadconfig](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a><span data-ttu-id="e9091-133">¿Cómo funciona CFG realmente?</span><span class="sxs-lookup"><span data-stu-id="e9091-133">How Does CFG Really Work?</span></span>

<span data-ttu-id="e9091-134">A menudo, las vulnerabilidades de software se aprovechan al proporcionar datos poco probables, inusuales o extremos a un programa en ejecución.</span><span class="sxs-lookup"><span data-stu-id="e9091-134">Software vulnerabilities are often exploited by providing unlikely, unusual, or extreme data to a running program.</span></span> <span data-ttu-id="e9091-135">Por ejemplo, un atacante puede aprovechar una vulnerabilidad de desbordamiento de búfer al proporcionar más información a un programa de la esperada, con lo que se ejecuta en exceso el área reservada por el programa para contener una respuesta.</span><span class="sxs-lookup"><span data-stu-id="e9091-135">For example, an attacker can exploit a buffer overflow vulnerability by providing more input to a program than expected, thereby over-running the area reserved by the program to hold a response.</span></span> <span data-ttu-id="e9091-136">Esto podría dañar la memoria adyacente que puede contener un puntero de función.</span><span class="sxs-lookup"><span data-stu-id="e9091-136">This could corrupt adjacent memory that may hold a function pointer.</span></span> <span data-ttu-id="e9091-137">Cuando el programa llama a través de esta función, puede saltar a una ubicación no deseada especificada por el atacante.</span><span class="sxs-lookup"><span data-stu-id="e9091-137">When the program calls through this function it may then jump to an unintended location specified by the attacker.</span></span>

<span data-ttu-id="e9091-138">Sin embargo, una combinación potente de compatibilidad de compilación y en tiempo de ejecución de CFG implementa la integridad del flujo de control que se restringe estrictamente donde se pueden ejecutar instrucciones de llamadas indirectas.</span><span class="sxs-lookup"><span data-stu-id="e9091-138">However, a potent combination of compile and run-time support from CFG implements control flow integrity that tightly restricts where indirect call instructions can execute.</span></span>

<span data-ttu-id="e9091-139">El compilador hace lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="e9091-139">The compiler does the following:</span></span>

1.  <span data-ttu-id="e9091-140">Agrega comprobaciones de seguridad ligeras al código compilado.</span><span class="sxs-lookup"><span data-stu-id="e9091-140">Adds lightweight security checks to the compiled code.</span></span>
2.  <span data-ttu-id="e9091-141">Identifica el conjunto de funciones de la aplicación que son destinos válidos para las llamadas indirectas.</span><span class="sxs-lookup"><span data-stu-id="e9091-141">Identifies the set of functions in the application that are valid targets for indirect calls.</span></span>

<span data-ttu-id="e9091-142">Compatibilidad en tiempo de ejecución, proporcionada por el kernel de Windows:</span><span class="sxs-lookup"><span data-stu-id="e9091-142">The runtime support, provided by the Windows kernel:</span></span>

1.  <span data-ttu-id="e9091-143">Mantiene eficazmente el estado que identifica los destinos de llamada indirecta válidos.</span><span class="sxs-lookup"><span data-stu-id="e9091-143">Efficiently maintains state that identifies valid indirect call targets.</span></span>
2.  <span data-ttu-id="e9091-144">Implementa la lógica que comprueba que un destino de llamada indirecto es válido.</span><span class="sxs-lookup"><span data-stu-id="e9091-144">Implements the logic that verifies that an indirect call target is valid.</span></span>

<span data-ttu-id="e9091-145">Para ilustrar:</span><span class="sxs-lookup"><span data-stu-id="e9091-145">To illustrate:</span></span>

![pseudocódigo de cfg](images/cfg-pseudocode.jpg)

<span data-ttu-id="e9091-147">Cuando se produce un error en una comprobación de CFG en tiempo de ejecución, Windows finaliza inmediatamente el programa, con lo que se interrumpe cualquier ataque que intente llamar indirectamente a una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e9091-147">When a CFG check fails at runtime, Windows immediately terminates the program, thus breaking any exploit that attempts to indirectly call an invalid address.</span></span>

 

 
