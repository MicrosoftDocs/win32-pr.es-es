---
title: Reglas de punto flotante (Direct3D 11)
description: Direct3D 11 admite varias representaciones de punto flotante. Todos los cálculos de punto flotante operan en un subconjunto definido de las reglas de punto flotante de precisión única de IEEE 754 32 bits.
ms.assetid: 33F21BD0-FDF8-4D35-95C0-0A3920814CB6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d83c87db0daa69c0393d0399ece5bdb6cf01d519
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/20/2020
ms.locfileid: "104420827"
---
# <a name="floating-point-rules-direct3d-11"></a><span data-ttu-id="a38be-104">Reglas de punto flotante (Direct3D 11)</span><span class="sxs-lookup"><span data-stu-id="a38be-104">Floating-point rules (Direct3D 11)</span></span>

<span data-ttu-id="a38be-105">Direct3D 11 admite varias representaciones de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="a38be-105">Direct3D 11 supports several floating-point representations.</span></span> <span data-ttu-id="a38be-106">Todos los cálculos de punto flotante operan en un subconjunto definido de las reglas de punto flotante de precisión única de IEEE 754 32 bits.</span><span class="sxs-lookup"><span data-stu-id="a38be-106">All floating-point computations operate under a defined subset of the IEEE 754 32-bit single precision floating-point rules.</span></span>

-   [<span data-ttu-id="a38be-107">reglas de punto flotante de 32 bits</span><span class="sxs-lookup"><span data-stu-id="a38be-107">32-bit floating-point rules</span></span>](#32-bit-floating-point-rules)
    -   [<span data-ttu-id="a38be-108">Reglas IEEE-754 aceptadas</span><span class="sxs-lookup"><span data-stu-id="a38be-108">Honored IEEE-754 rules</span></span>](#honored-ieee-754-rules)
    -   [<span data-ttu-id="a38be-109">Desviaciones o requisitos adicionales de las reglas IEEE-754</span><span class="sxs-lookup"><span data-stu-id="a38be-109">Deviations or additional requirements from IEEE-754 rules</span></span>](#deviations-or-additional-requirements-from-ieee-754-rules)
-   [<span data-ttu-id="a38be-110">reglas de punto flotante de 64 bits (precisión doble)</span><span class="sxs-lookup"><span data-stu-id="a38be-110">64-bit (double precision) floating point rules</span></span>](#64-bit-double-precision-floating-point-rules)
-   [<span data-ttu-id="a38be-111">reglas de punto flotante de 16 bits</span><span class="sxs-lookup"><span data-stu-id="a38be-111">16-bit floating-point rules</span></span>](#16-bit-floating-point-rules)
-   [<span data-ttu-id="a38be-112">reglas de punto flotante de 11 bits y de 10 bits</span><span class="sxs-lookup"><span data-stu-id="a38be-112">11-bit and 10-bit floating-point rules</span></span>](#11-bit-and-10-bit-floating-point-rules)
-   [<span data-ttu-id="a38be-113">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="a38be-113">Related topics</span></span>](#related-topics)

## <a name="32-bit-floating-point-rules"></a><span data-ttu-id="a38be-114">reglas de punto flotante de 32 bits</span><span class="sxs-lookup"><span data-stu-id="a38be-114">32-bit floating-point rules</span></span>

<span data-ttu-id="a38be-115">Hay dos conjuntos de reglas: los que cumplen con IEEE-754 y los que se desvían del estándar.</span><span class="sxs-lookup"><span data-stu-id="a38be-115">There are two sets of rules: those that conform to IEEE-754, and those that deviate from the standard.</span></span>

### <a name="honored-ieee-754-rules"></a><span data-ttu-id="a38be-116">Reglas IEEE-754 aceptadas</span><span class="sxs-lookup"><span data-stu-id="a38be-116">Honored IEEE-754 rules</span></span>

<span data-ttu-id="a38be-117">Algunas de estas reglas son una opción única en la que IEEE-754 ofrece opciones.</span><span class="sxs-lookup"><span data-stu-id="a38be-117">Some of these rules are a single option where IEEE-754 offers choices.</span></span>

-   <span data-ttu-id="a38be-118">La división por 0 produce +/-INF, excepto 0/0, que tiene como resultado NaN.</span><span class="sxs-lookup"><span data-stu-id="a38be-118">Divide by 0 produces +/- INF, except 0/0 which results in NaN.</span></span>
-   <span data-ttu-id="a38be-119">el registro de (+/-) 0 produce-INF.</span><span class="sxs-lookup"><span data-stu-id="a38be-119">log of (+/-) 0 produces -INF.</span></span> <span data-ttu-id="a38be-120">el registro de un valor negativo (distinto de-0) genera NaN.</span><span class="sxs-lookup"><span data-stu-id="a38be-120">log of a negative value (other than -0) produces NaN.</span></span>
-   <span data-ttu-id="a38be-121">La raíz cuadrada recíproca (RSQ) o la raíz cuadrada (sqrt) de un número negativo produce NaN.</span><span class="sxs-lookup"><span data-stu-id="a38be-121">Reciprocal square root (rsq) or square root (sqrt) of a negative number produces NaN.</span></span> <span data-ttu-id="a38be-122">La excepción es-0; sqrt (-0) produce-0 y RSQ (-0) produce-INF.</span><span class="sxs-lookup"><span data-stu-id="a38be-122">The exception is -0; sqrt(-0) produces -0, and rsq(-0) produces -INF.</span></span>
-   <span data-ttu-id="a38be-123">INF-INF = NaN</span><span class="sxs-lookup"><span data-stu-id="a38be-123">INF - INF = NaN</span></span>
-   <span data-ttu-id="a38be-124">(+/-) INF/(+/-) INF = NaN</span><span class="sxs-lookup"><span data-stu-id="a38be-124">(+/-)INF / (+/-)INF = NaN</span></span>
-   <span data-ttu-id="a38be-125">(+/-) INF \* 0 = Nan</span><span class="sxs-lookup"><span data-stu-id="a38be-125">(+/-)INF \* 0 = NaN</span></span>
-   <span data-ttu-id="a38be-126">NaN (cualquier OP) any-Value = NaN</span><span class="sxs-lookup"><span data-stu-id="a38be-126">NaN (any OP) any-value = NaN</span></span>
-   <span data-ttu-id="a38be-127">Las comparaciones EQ, GT, GE, LT y LE, cuando uno o ambos operandos es NaN devuelve **false**.</span><span class="sxs-lookup"><span data-stu-id="a38be-127">The comparisons EQ, GT, GE, LT, and LE, when either or both operands is NaN returns **FALSE**.</span></span>
-   <span data-ttu-id="a38be-128">Las comparaciones omiten el signo de 0 (por lo que + 0 es igual a-0).</span><span class="sxs-lookup"><span data-stu-id="a38be-128">Comparisons ignore the sign of 0 (so +0 equals -0).</span></span>
-   <span data-ttu-id="a38be-129">La comparación NE, cuando uno o ambos operandos son NaN, devuelve **true**.</span><span class="sxs-lookup"><span data-stu-id="a38be-129">The comparison NE, when either or both operands is NaN returns **TRUE**.</span></span>
-   <span data-ttu-id="a38be-130">Las comparaciones de cualquier valor que no sea NaN con +/-INF devuelven el resultado correcto.</span><span class="sxs-lookup"><span data-stu-id="a38be-130">Comparisons of any non-NaN value against +/- INF return the correct result.</span></span>

### <a name="deviations-or-additional-requirements-from-ieee-754-rules"></a><span data-ttu-id="a38be-131">Desviaciones o requisitos adicionales de las reglas IEEE-754</span><span class="sxs-lookup"><span data-stu-id="a38be-131">Deviations or additional requirements from IEEE-754 rules</span></span>

-   <span data-ttu-id="a38be-132">IEEE-754 requiere operaciones de punto flotante para producir un resultado que es el valor representable más cercano a un resultado infinitamente preciso, conocido como de redondeo a la más cercana.</span><span class="sxs-lookup"><span data-stu-id="a38be-132">IEEE-754 requires floating-point operations to produce a result that is the nearest representable value to an infinitely-precise result, known as round-to-nearest-even.</span></span> <span data-ttu-id="a38be-133">Direct3D 11 define el mismo requisito: las operaciones de punto flotante de 32 bits producen un resultado que se encuentra dentro del 0,5 de la unidad (ULP) del resultado infinitamente preciso.</span><span class="sxs-lookup"><span data-stu-id="a38be-133">Direct3D 11 defines the same requirement: 32-bit floating-point operations produce a result that is within 0.5 unit-last-place (ULP) of the infinitely-precise result.</span></span> <span data-ttu-id="a38be-134">Esto significa que, por ejemplo, se permite que el hardware trunque los resultados en 32 bits en lugar de realizar una operación de ida y vuelta más cercana, ya que esto daría como resultado un error de como máximo 0,5 ULP. Esta regla solo se aplica a la suma, resta y multiplicación.</span><span class="sxs-lookup"><span data-stu-id="a38be-134">This means that, for example, hardware is allowed to truncate results to 32-bit rather than perform round-to-nearest-even, as that would result in error of at most 0.5 ULP.This rule applies only to addition, subtraction, and multiplication.</span></span>
-   <span data-ttu-id="a38be-135">No se admiten excepciones de punto flotante, bits de estado ni capturas.</span><span class="sxs-lookup"><span data-stu-id="a38be-135">There is no support for floating-point exceptions, status bits or traps.</span></span>
-   <span data-ttu-id="a38be-136">Las decimales se vacían en cero con signo en la entrada y la salida de cualquier operación matemática de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="a38be-136">Denorms are flushed to sign-preserved zero on input and output of any floating-point mathematical operation.</span></span> <span data-ttu-id="a38be-137">Se realizan excepciones para cualquier operación de movimiento de datos o de e/s que no manipule los datos.</span><span class="sxs-lookup"><span data-stu-id="a38be-137">Exceptions are made for any I/O or data movement operation that doesn't manipulate the data.</span></span>
-   <span data-ttu-id="a38be-138">Los Estados que contienen valores de punto flotante, como viewport MinDepth/MaxDepth, valores BorderColor, se pueden proporcionar como valores de desnormativo y se pueden vaciar o no antes de que el hardware los use.</span><span class="sxs-lookup"><span data-stu-id="a38be-138">States that contain floating-point values, such as Viewport MinDepth/MaxDepth, BorderColor values, may be provided as denorm values and may or may not be flushed before the hardware uses them.</span></span>
-   <span data-ttu-id="a38be-139">Las operaciones min o Max vacían las desnormativas para la comparación, pero el resultado se puede vaciar o no.</span><span class="sxs-lookup"><span data-stu-id="a38be-139">Min or max operations flush denorms for comparison, but the result may or may not be denorm flushed.</span></span>
-   <span data-ttu-id="a38be-140">La entrada de NaN en una operación siempre produce NaN en la salida.</span><span class="sxs-lookup"><span data-stu-id="a38be-140">NaN input to an operation always produces NaN on output.</span></span> <span data-ttu-id="a38be-141">Pero no es necesario que el patrón de bits exacto del NaN siga siendo el mismo (a menos que la operación sea una instrucción de movimiento sin procesar, que no modifica los datos).</span><span class="sxs-lookup"><span data-stu-id="a38be-141">But the exact bit pattern of the NaN is not required to stay the same (unless the operation is a raw move instruction - which doesn't alter data.)</span></span>
-   <span data-ttu-id="a38be-142">Las operaciones min o Max para las que solo un operando es NaN devuelven el otro operando como el resultado (en oposición a las reglas de comparación que hemos visto anteriormente).</span><span class="sxs-lookup"><span data-stu-id="a38be-142">Min or max operations for which only one operand is NaN return the other operand as the result (contrary to comparison rules we looked at earlier).</span></span> <span data-ttu-id="a38be-143">Se trata de una regla de 754R de IEEE.</span><span class="sxs-lookup"><span data-stu-id="a38be-143">This is a IEEE 754R rule.</span></span>

    <span data-ttu-id="a38be-144">La especificación IEEE-754R para las operaciones de punto flotante min y Max indica que si una de las entradas a min o Max es un valor QNaN silencioso, el resultado de la operación es el otro parámetro.</span><span class="sxs-lookup"><span data-stu-id="a38be-144">The IEEE-754R specification for floating point min and max operations states that if one of the inputs to min or max is a quiet QNaN value, the result of the operation is the other parameter.</span></span> <span data-ttu-id="a38be-145">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="a38be-145">For example:</span></span>

    ```C++
    min(x,QNaN) == min(QNaN,x) == x (same for max)
    ```

    

    <span data-ttu-id="a38be-146">Una revisión de la especificación IEEE-754R adoptó un comportamiento diferente para min y Max cuando una entrada es un valor SNaN de "Signaling" frente a un valor QNaN:</span><span class="sxs-lookup"><span data-stu-id="a38be-146">A revision of the IEEE-754R specification adopted a different behavior for min and max when one input is a "signaling" SNaN value versus a QNaN value:</span></span>

    ```C++
    min(x,SNaN) == min(SNaN,x) == QNaN (same for max)
     
    ```

    

    <span data-ttu-id="a38be-147">Por lo general, Direct3D sigue los estándares de aritmética: IEEE-754 y IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="a38be-147">Generally, Direct3D follows the standards for arithmetic: IEEE-754 and IEEE-754R.</span></span> <span data-ttu-id="a38be-148">Pero en este caso, tenemos una desviación.</span><span class="sxs-lookup"><span data-stu-id="a38be-148">But in this case, we have a deviation.</span></span>

    <span data-ttu-id="a38be-149">Las reglas aritméticas en Direct3D 10 y versiones posteriores no hacen ninguna distinción entre los valores NaN y de señalización insilenciosos (QNaN frente a SNaN).</span><span class="sxs-lookup"><span data-stu-id="a38be-149">The arithmetic rules in Direct3D 10 and later don't make any distinctions between quiet and signaling NaN values (QNaN versus SNaN).</span></span> <span data-ttu-id="a38be-150">Todos los valores NaN se controlan de la misma manera.</span><span class="sxs-lookup"><span data-stu-id="a38be-150">All NaN values are handled the same way.</span></span> <span data-ttu-id="a38be-151">En el caso de min y Max, el comportamiento de Direct3D para cualquier valor NaN es como el modo en que QNaN se controla en la definición de IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="a38be-151">In the case of min and max, the Direct3D behavior for any NaN value is like how QNaN is handled in the IEEE-754R definition.</span></span> <span data-ttu-id="a38be-152">(Por integridad: si ambas entradas son NaN, se devuelve cualquier valor NaN).</span><span class="sxs-lookup"><span data-stu-id="a38be-152">(For completeness - if both inputs are NaN, any NaN value is returned.)</span></span>

-   <span data-ttu-id="a38be-153">Otra regla de IEEE 754R es que min (-0, + 0) = = min (+ 0,-0) = =-0 y Max (-0, + 0) = = Max (+ 0,-0) = = + 0, que respeta el signo, a diferencia de las reglas de comparación de cero con signo (como vimos anteriormente).</span><span class="sxs-lookup"><span data-stu-id="a38be-153">Another IEEE 754R rule is that min(-0,+0) == min(+0,-0) == -0, and max(-0,+0) == max(+0,-0) == +0, which honors the sign, in contrast to the comparison rules for signed zero (as we saw earlier).</span></span> <span data-ttu-id="a38be-154">Direct3D recomienda el comportamiento de IEEE 754R aquí, pero no lo aplica. se permite que el resultado de comparar ceros sea dependiente del orden de los parámetros, mediante una comparación que omite los signos.</span><span class="sxs-lookup"><span data-stu-id="a38be-154">Direct3D recommends the IEEE 754R behavior here, but doesn't enforce it; it is permissible for the result of comparing zeros to be dependent on the order of parameters, using a comparison that ignores the signs.</span></span>
-   <span data-ttu-id="a38be-155">x \* 1.0 f siempre produce x (excepto desnormalización).</span><span class="sxs-lookup"><span data-stu-id="a38be-155">x\*1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="a38be-156">x/1.0 f siempre produce x (excepto desnormalización).</span><span class="sxs-lookup"><span data-stu-id="a38be-156">x/1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="a38be-157">x +/-0.0 f siempre da como resultado x (excepto desnormalización desactivada).</span><span class="sxs-lookup"><span data-stu-id="a38be-157">x +/- 0.0f always results in x (except denorm flushed).</span></span> <span data-ttu-id="a38be-158">Pero-0 + 0 = + 0.</span><span class="sxs-lookup"><span data-stu-id="a38be-158">But -0 + 0 = +0.</span></span>
-   <span data-ttu-id="a38be-159">Las operaciones con fusibles (como Mad, DP3) producen resultados que no son menos precisos que los peores pedidos de evaluación en serie de la evaluación de la expansión sin fusibles de la operación.</span><span class="sxs-lookup"><span data-stu-id="a38be-159">Fused operations (such as mad, dp3) produce results that are no less accurate than the worst possible serial ordering of evaluation of the unfused expansion of the operation.</span></span> <span data-ttu-id="a38be-160">La definición del peor orden posible, con fines de tolerancia, no es una definición fija para una operación fusionada determinada; depende de los valores concretos de las entradas.</span><span class="sxs-lookup"><span data-stu-id="a38be-160">The definition of the worst possible ordering, for the purpose of tolerance, is not a fixed definition for a given fused operation; it depends on the particular values of the inputs.</span></span> <span data-ttu-id="a38be-161">En los pasos individuales de la expansión sin fusibles se les permite una tolerancia ULP permitida (o, para las instrucciones que Direct3D llama con una tolerancia más LAX que 1 ULP, se permite la tolerancia más LAX).</span><span class="sxs-lookup"><span data-stu-id="a38be-161">The individual steps in the unfused expansion are each allowed 1 ULP tolerance (or for any instructions Direct3D calls out with a more lax tolerance than 1 ULP, the more lax tolerance is allowed).</span></span>
-   <span data-ttu-id="a38be-162">Las operaciones con fusibles se adhieren a las mismas reglas NaN que las operaciones sin fusibles.</span><span class="sxs-lookup"><span data-stu-id="a38be-162">Fused operations adhere to the same NaN rules as non-fused operations.</span></span>
-   <span data-ttu-id="a38be-163">sqrt y RCP tienen 1 tolerancia ULP.</span><span class="sxs-lookup"><span data-stu-id="a38be-163">sqrt and rcp have 1 ULP tolerance.</span></span> <span data-ttu-id="a38be-164">Las instrucciones de raíz cuadrada recíproca y recíproca del sombreador, [**RCP**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) y [**RSQ**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), tienen su propio requisito de precisión relajada independiente.</span><span class="sxs-lookup"><span data-stu-id="a38be-164">The shader reciprocal and reciprocal square-root instructions, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) and [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), have their own separate relaxed precision requirement.</span></span>
-   <span data-ttu-id="a38be-165">Multiplique y divida cada operación en el nivel de precisión de punto flotante de 32 bits (precisión de 0,5 ULP para multiplicar, 1,0 ULP para recíproco).</span><span class="sxs-lookup"><span data-stu-id="a38be-165">Multiply and divide each operate at the 32-bit floating-point precision level (accuracy to 0.5 ULP for multiply, 1.0 ULP for reciprocal).</span></span> <span data-ttu-id="a38be-166">Si x/y se implementa directamente, los resultados deben tener una precisión mayor o igual que un método de dos pasos.</span><span class="sxs-lookup"><span data-stu-id="a38be-166">If x/y is implemented directly, results must be of greater or equal accuracy than a two-step method.</span></span>

## <a name="64-bit-double-precision-floating-point-rules"></a><span data-ttu-id="a38be-167">reglas de punto flotante de 64 bits (precisión doble)</span><span class="sxs-lookup"><span data-stu-id="a38be-167">64-bit (double precision) floating point rules</span></span>

<span data-ttu-id="a38be-168">Los controladores de hardware y de pantalla admiten opcionalmente el punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="a38be-168">Hardware and display drivers optionally support double-precision floating-point.</span></span> <span data-ttu-id="a38be-169">Para indicar la compatibilidad, al llamar a [**ID3D11Device:: CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) con la [**característica de D3D11 \_ \_ Double**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), el controlador establece **DoublePrecisionFloatShaderOps** de datos de características de [**D3D11 \_ \_ \_**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) en true.</span><span class="sxs-lookup"><span data-stu-id="a38be-169">To indicate support, when you call [**ID3D11Device::CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) with [**D3D11\_FEATURE\_DOUBLES**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), the driver sets **DoublePrecisionFloatShaderOps** of [**D3D11\_FEATURE\_DATA\_DOUBLES**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) to TRUE.</span></span> <span data-ttu-id="a38be-170">A continuación, el controlador y el hardware deben admitir todas las instrucciones de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="a38be-170">The driver and hardware must then support all double-precision floating-point instructions.</span></span>

<span data-ttu-id="a38be-171">Las instrucciones de doble precisión siguen los requisitos de comportamiento de IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="a38be-171">Double-precision instructions follow IEEE 754R behavior requirements.</span></span>

<span data-ttu-id="a38be-172">La compatibilidad con la generación de valores desnormalizados es necesaria para los datos de precisión doble (comportamiento de vaciado a cero).</span><span class="sxs-lookup"><span data-stu-id="a38be-172">Support for generation of denormalized values is required for double-precision data (no flush-to-zero behavior).</span></span> <span data-ttu-id="a38be-173">Del mismo modo, las instrucciones no leen los datos no normalizados como cero con signo, respetan el valor de desnormativo.</span><span class="sxs-lookup"><span data-stu-id="a38be-173">Likewise, instructions don't read denormalized data as a signed zero, they honor the denorm value.</span></span>

## <a name="16-bit-floating-point-rules"></a><span data-ttu-id="a38be-174">reglas de punto flotante de 16 bits</span><span class="sxs-lookup"><span data-stu-id="a38be-174">16-bit floating-point rules</span></span>

<span data-ttu-id="a38be-175">Direct3D 11 también admite representaciones de 16 bits de números de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="a38be-175">Direct3D 11 also supports 16-bit representations of floating-point numbers.</span></span>

<span data-ttu-id="a38be-176">Formato:</span><span class="sxs-lookup"><span data-stu-id="a38be-176">Format:</span></span>

-   <span data-ttu-id="a38be-177">1 bit (s) de signo en la posición de bit de MSB</span><span class="sxs-lookup"><span data-stu-id="a38be-177">1 sign bit (s)in the MSB bit position</span></span>
-   <span data-ttu-id="a38be-178">5 bits de exponente sesgado (e)</span><span class="sxs-lookup"><span data-stu-id="a38be-178">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="a38be-179">10 bits de fracción (f), con un bit oculto adicional</span><span class="sxs-lookup"><span data-stu-id="a38be-179">10 bits of fraction (f), with an additional hidden bit</span></span>

<span data-ttu-id="a38be-180">Un valor float16 (v) sigue estas reglas:</span><span class="sxs-lookup"><span data-stu-id="a38be-180">A float16 value (v) follows these rules:</span></span>

-   <span data-ttu-id="a38be-181">Si e = = 31 y f! = 0, v es NaN independientemente de s</span><span class="sxs-lookup"><span data-stu-id="a38be-181">if e == 31 and f != 0, then v is NaN regardless of s</span></span>
-   <span data-ttu-id="a38be-182">Si e = = 31 y f = = 0, v = (-1) s \* Infinity (infinito firmado)</span><span class="sxs-lookup"><span data-stu-id="a38be-182">if e == 31 and f == 0, then v = (-1)s\*infinity (signed infinity)</span></span>
-   <span data-ttu-id="a38be-183">Si e está entre 0 y 31, v = (-1) s \* 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="a38be-183">if e is between 0 and 31, then v = (-1)s\*2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="a38be-184">Si e = = 0 y f! = 0, v = (-1) s \* 2 (e-14) \* (0. f) (números desnormalizados)</span><span class="sxs-lookup"><span data-stu-id="a38be-184">if e == 0 and f != 0, then v = (-1)s\*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="a38be-185">Si e = = 0 y f = = 0, v = (-1) s \* 0 (con signo de cero)</span><span class="sxs-lookup"><span data-stu-id="a38be-185">if e == 0 and f == 0, then v = (-1)s\*0 (signed zero)</span></span>

<span data-ttu-id="a38be-186">las reglas de punto flotante de 32 bits también contienen números de punto flotante de 16 bits, ajustados para el diseño de bits descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="a38be-186">32-bit floating-point rules also hold for 16-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="a38be-187">Las excepciones son:</span><span class="sxs-lookup"><span data-stu-id="a38be-187">Exceptions to this include:</span></span>

-   <span data-ttu-id="a38be-188">Precisión: las operaciones no confundidas en los números de punto flotante de 16 bits producen un resultado que es el valor representable más cercano a un resultado infinitamente preciso (redondear a más cercano incluso, por IEEE-754, aplicado a valores de 16 bits).</span><span class="sxs-lookup"><span data-stu-id="a38be-188">Precision: Unfused operations on 16-bit floating-point numbers produce a result that is the nearest representable value to an infinitely-precise result (round to nearest even, per IEEE-754, applied to 16-bit values).</span></span> <span data-ttu-id="a38be-189">las reglas de punto flotante de 32 bits se adhieren a una tolerancia ULP, las reglas de punto flotante de 16 bits se adhieren a 0,5 ULP para operaciones no confundidas y 0,6 ULP para operaciones con fusibles.</span><span class="sxs-lookup"><span data-stu-id="a38be-189">32-bit floating-point rules adhere to 1 ULP tolerance, 16-bit floating-point rules adhere to 0.5 ULP for unfused operations, and 0.6 ULP for fused operations.</span></span>
-   <span data-ttu-id="a38be-190">los números de punto flotante de 16 bits conservan las desnormativas.</span><span class="sxs-lookup"><span data-stu-id="a38be-190">16-bit floating-point numbers preserve denorms.</span></span>

## <a name="11-bit-and-10-bit-floating-point-rules"></a><span data-ttu-id="a38be-191">reglas de punto flotante de 11 bits y de 10 bits</span><span class="sxs-lookup"><span data-stu-id="a38be-191">11-bit and 10-bit floating-point rules</span></span>

<span data-ttu-id="a38be-192">Direct3D 11 también admite formatos de punto flotante de 11 bits y de 10 bits.</span><span class="sxs-lookup"><span data-stu-id="a38be-192">Direct3D 11 also supports 11-bit and 10-bit floating-point formats.</span></span>

<span data-ttu-id="a38be-193">Formato:</span><span class="sxs-lookup"><span data-stu-id="a38be-193">Format:</span></span>

-   <span data-ttu-id="a38be-194">Bit sin signo</span><span class="sxs-lookup"><span data-stu-id="a38be-194">No sign bit</span></span>
-   <span data-ttu-id="a38be-195">5 bits de exponente sesgado (e)</span><span class="sxs-lookup"><span data-stu-id="a38be-195">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="a38be-196">6 bits de fracción (f) para un formato de 11 bits, 5 bits de fracción (f) para un formato de 10 bits, con un bit oculto adicional en cualquier caso.</span><span class="sxs-lookup"><span data-stu-id="a38be-196">6 bits of fraction (f) for an 11-bit format, 5 bits of fraction (f) for a 10-bit format, with an additional hidden bit in either case.</span></span>

<span data-ttu-id="a38be-197">Un valor de float11/float10 (v) sigue las siguientes reglas:</span><span class="sxs-lookup"><span data-stu-id="a38be-197">A float11/float10 value (v) follows the following rules:</span></span>

-   <span data-ttu-id="a38be-198">Si e = = 31 y f! = 0, v es NaN</span><span class="sxs-lookup"><span data-stu-id="a38be-198">if e == 31 and f != 0, then v is NaN</span></span>
-   <span data-ttu-id="a38be-199">Si e = = 31 y f = = 0, v = + infinito</span><span class="sxs-lookup"><span data-stu-id="a38be-199">if e == 31 and f == 0, then v = +infinity</span></span>
-   <span data-ttu-id="a38be-200">Si e está entre 0 y 31, v = 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="a38be-200">if e is between 0 and 31, then v = 2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="a38be-201">Si e = = 0 y f! = 0, v = \* 2 (e-14) \* (0. f) (números desnormalizados)</span><span class="sxs-lookup"><span data-stu-id="a38be-201">if e == 0 and f != 0, then v = \*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="a38be-202">Si e = = 0 y f = = 0, v = 0 (cero)</span><span class="sxs-lookup"><span data-stu-id="a38be-202">if e == 0 and f == 0, then v = 0 (zero)</span></span>

<span data-ttu-id="a38be-203">las reglas de punto flotante de 32 bits también contienen números de punto flotante de 11 bits y 10 bits, ajustados para el diseño de bits descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="a38be-203">32-bit floating-point rules also hold for 11-bit and 10-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="a38be-204">Entre las excepciones se incluyen:</span><span class="sxs-lookup"><span data-stu-id="a38be-204">Exceptions include:</span></span>

-   <span data-ttu-id="a38be-205">Precisión: las reglas de punto flotante de 32 bits se adhieren a 0,5 ULP.</span><span class="sxs-lookup"><span data-stu-id="a38be-205">Precision: 32-bit floating-point rules adhere to 0.5 ULP.</span></span>
-   <span data-ttu-id="a38be-206">los números de punto flotante de 10/11 bits conservan las desnormativas.</span><span class="sxs-lookup"><span data-stu-id="a38be-206">10/11-bit floating-point numbers preserve denorms.</span></span>
-   <span data-ttu-id="a38be-207">Cualquier operación que daría como resultado un número menor que cero se fija en cero.</span><span class="sxs-lookup"><span data-stu-id="a38be-207">Any operation that would result in a number less than zero is clamped to zero.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a38be-208">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="a38be-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a38be-209">Recursos</span><span class="sxs-lookup"><span data-stu-id="a38be-209">Resources</span></span>](overviews-direct3d-11-resources.md)
</dt> <dt>

[<span data-ttu-id="a38be-210">Texturas</span><span class="sxs-lookup"><span data-stu-id="a38be-210">Textures</span></span>](overviews-direct3d-11-resources-textures.md)
</dt> </dl>

 

 