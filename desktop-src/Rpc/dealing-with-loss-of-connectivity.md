---
title: Tratamiento de la pérdida de conectividad
description: Tratamiento de la pérdida de conectividad
ms.assetid: a90fcb5a-773e-4c21-bf6c-c3519ec13a09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: de8e7a8088cfe09a4c4026c16cc3dc5ea36b3430
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/20/2020
ms.locfileid: "103792801"
---
# <a name="dealing-with-loss-of-connectivity"></a><span data-ttu-id="61bde-103">Tratamiento de la pérdida de conectividad</span><span class="sxs-lookup"><span data-stu-id="61bde-103">Dealing with Loss of Connectivity</span></span>

<span data-ttu-id="61bde-104">Una vez finalizada una llamada RPC, la conexión no está cerrada; está marcado como libre.</span><span class="sxs-lookup"><span data-stu-id="61bde-104">After an RPC call completes the connection is not closed; it is marked as free.</span></span> <span data-ttu-id="61bde-105">Como tal, el servidor puede quedar inactivo o se puede perder la conectividad de red durante o entre llamadas, mientras que una conexión se encuentra en el grupo.</span><span class="sxs-lookup"><span data-stu-id="61bde-105">As such, the server can go down or network connectivity can be lost during or between calls, while a connection is sitting in the pool.</span></span> <span data-ttu-id="61bde-106">Como cuestión de la Directiva, el tiempo de ejecución de RPC vuelve a intentar esas llamadas solo si se cumplen las dos condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="61bde-106">As a matter of policy, the RPC run time re-attempts those calls only if the following two conditions are met:</span></span>

-   <span data-ttu-id="61bde-107">Es posible que el servidor no pueda ejecutar la llamada o que la llamada sea idempotente.</span><span class="sxs-lookup"><span data-stu-id="61bde-107">The server cannot possibly execute the call, or the call is idempotent.</span></span>
-   <span data-ttu-id="61bde-108">El cliente puede implementar reintentos de una manera eficaz.</span><span class="sxs-lookup"><span data-stu-id="61bde-108">The client can implement retries in a performance-efficient manner.</span></span>

<span data-ttu-id="61bde-109">Los párrafos siguientes expanden y aclaran las dos condiciones.</span><span class="sxs-lookup"><span data-stu-id="61bde-109">The following paragraphs expand and clarify the two conditions.</span></span>

<span data-ttu-id="61bde-110">Una llamada idempotente es una llamada que se puede ejecutar más de una vez en el servidor sin efectos secundarios no deseados.</span><span class="sxs-lookup"><span data-stu-id="61bde-110">An idempotent call is a call that can be executed more than once on the server without undesirable side effects.</span></span> <span data-ttu-id="61bde-111">Por ejemplo, tener una llamada RPC que consulta el saldo en el Banco para una cuenta determinada es idempotente.</span><span class="sxs-lookup"><span data-stu-id="61bde-111">For example, having an RPC call that queries the balance in the bank for a given account is idempotent.</span></span> <span data-ttu-id="61bde-112">Si esta llamada se ejecuta dos veces debido a la pérdida de conectividad, no se produce ningún daño.</span><span class="sxs-lookup"><span data-stu-id="61bde-112">If this call is executed twice due to loss of connectivity, no harm is done.</span></span> <span data-ttu-id="61bde-113">Otro ejemplo de una llamada idempotente es el cambio de la dirección de un cliente en una base de datos.</span><span class="sxs-lookup"><span data-stu-id="61bde-113">Another example of an idempotent call is changing the address of a customer in a database.</span></span> <span data-ttu-id="61bde-114">La ejecución dos veces es correcta, ya que la segunda ejecución reemplaza simplemente la dirección actual con la misma dirección.</span><span class="sxs-lookup"><span data-stu-id="61bde-114">Executing twice is fine, since the second execution simply replaces the already-current address with the same address.</span></span> <span data-ttu-id="61bde-115">Una operación como "reste 50 dólares de la cuenta XYZ" no es idempotente.</span><span class="sxs-lookup"><span data-stu-id="61bde-115">An operation like "subtract fifty dollars from account xyz" is not idempotent.</span></span> <span data-ttu-id="61bde-116">La pérdida de conectividad de red no debe producir varias ejecuciones de este tipo de llamada.</span><span class="sxs-lookup"><span data-stu-id="61bde-116">Loss of network connectivity should not result in multiple executions of such a call.</span></span>

<span data-ttu-id="61bde-117">Para que sea segura, el tiempo de ejecución de RPC trata todas las llamadas como no idempotente.</span><span class="sxs-lookup"><span data-stu-id="61bde-117">To be safe, the RPC run time treats all calls as non-idempotent.</span></span> <span data-ttu-id="61bde-118">El \[ \] atributo idempotente no es compatible con [**ncacn \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp)y se omite.</span><span class="sxs-lookup"><span data-stu-id="61bde-118">The \[idempotent\] attribute is not supported for [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp), and is ignored.</span></span> <span data-ttu-id="61bde-119">Como tal, la primera condición de la lista anterior se reduce al *servidor que no puede ejecutar la llamada*.</span><span class="sxs-lookup"><span data-stu-id="61bde-119">As such, the first condition in the preceding list is reduced to *the server that cannot possibly execute the call*.</span></span>

<span data-ttu-id="61bde-120">En muchos casos, el tiempo de ejecución de RPC no puede determinar de forma concluyente que la llamada no se ha ejecutado en el servidor.</span><span class="sxs-lookup"><span data-stu-id="61bde-120">In many cases the RPC run time is unable to conclusively determine the call was not already executed on the server.</span></span> <span data-ttu-id="61bde-121">En estos casos, el cliente no volverá a intentar ejecutar la llamada.</span><span class="sxs-lookup"><span data-stu-id="61bde-121">In such cases, the client will not retry executing the call.</span></span>

<span data-ttu-id="61bde-122">En los siguientes ejemplos se muestra Cuándo el tiempo de ejecución de RPC o no vuelve a intentar una llamada:</span><span class="sxs-lookup"><span data-stu-id="61bde-122">The following examples illustrate when the RPC run time does or does not retry a call:</span></span>

-   <span data-ttu-id="61bde-123">Se reiniciará un servidor.</span><span class="sxs-lookup"><span data-stu-id="61bde-123">A server is rebooted.</span></span>

    <span data-ttu-id="61bde-124">Se realiza una llamada RPC sencilla sin seguridad en una interfaz en la que no se ha realizado ninguna llamada anterior después del reinicio.</span><span class="sxs-lookup"><span data-stu-id="61bde-124">A simple, no-security RPC call is made on an interface on which no previous call has been made after the reboot.</span></span> <span data-ttu-id="61bde-125">Dado que no se realizó ninguna llamada en esta interfaz, el tiempo de ejecución de RPC intenta negociar primero el uso de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="61bde-125">Since no calls were made on this interface, the RPC run time first attempts to negotiate use of the interface.</span></span> <span data-ttu-id="61bde-126">Envía un paquete mediante una conexión en el grupo.</span><span class="sxs-lookup"><span data-stu-id="61bde-126">It sends a packet using a connection in the pool.</span></span> <span data-ttu-id="61bde-127">Desde que se reinició el servidor y la conexión ya no es válida, devuelve un error.</span><span class="sxs-lookup"><span data-stu-id="61bde-127">Since the server was rebooted, and the connection is no longer valid, it returns an error.</span></span> <span data-ttu-id="61bde-128">Dado que el tiempo de ejecución de RPC del cliente todavía no ha empezado a enviar los datos para la llamada real, el cliente determina que el servidor no pudo haberse ejecutado en esos datos.</span><span class="sxs-lookup"><span data-stu-id="61bde-128">Since the client side RPC run time has not yet started sending the data for the actual call, the client determines that the server could not possibly have executed on those data.</span></span> <span data-ttu-id="61bde-129">Por lo tanto, cierra la conexión y busca otra conexión en el grupo.</span><span class="sxs-lookup"><span data-stu-id="61bde-129">Therefore, it closes the connection and looks for another connection in the pool.</span></span> <span data-ttu-id="61bde-130">Si no encuentra una conexión, se abre una nueva conexión y se intenta negociar de nuevo el uso de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="61bde-130">If it cannot find a connection, it opens a new connection and tries to negotiate use of the interface again.</span></span> <span data-ttu-id="61bde-131">Si esto se realiza correctamente, se realiza la llamada (es decir, se realiza un reintento, porque el error se detectó antes de que se iniciara la llamada).</span><span class="sxs-lookup"><span data-stu-id="61bde-131">If this succeeds, the call is made (that is, a retry is made, because the failure was detected before the call was started).</span></span>

-   <span data-ttu-id="61bde-132">Se realiza una llamada RPC con seguridad de nivel de privacidad (cifrado) en una conexión con un contexto de seguridad ya negociado.</span><span class="sxs-lookup"><span data-stu-id="61bde-132">An RPC call with privacy-level security (encryption) is made on a connection with an already-negotiated security context.</span></span>

    <span data-ttu-id="61bde-133">Para garantizar un rendimiento eficaz, el tiempo de ejecución de RPC cifra el paquete serializado insertado (sobre los datos de texto no cifrado).</span><span class="sxs-lookup"><span data-stu-id="61bde-133">To ensure efficient performance, the RPC run time encrypts the marshaled packet inline (over the clear text data).</span></span> <span data-ttu-id="61bde-134">Si se produce un error al intentar enviar los datos, el tiempo de ejecución de RPC no puede reintentar la llamada, ya que los datos de texto no cifrados se han sobrescrito con los datos cifrados y no pueden volver a cifrar los datos con un nuevo contexto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="61bde-134">If the attempt to send the data fails, the RPC run time cannot retry the call, since the clear text data have been overwritten with the encrypted data, and it cannot re-encrypt the data with a new security context.</span></span> <span data-ttu-id="61bde-135">Por lo tanto, no se realiza ningún reintento.</span><span class="sxs-lookup"><span data-stu-id="61bde-135">Therefore, no retry is made.</span></span>

-   <span data-ttu-id="61bde-136">Se produce un error en el envío de un fragmento que no es el primero.</span><span class="sxs-lookup"><span data-stu-id="61bde-136">The sending of a non-first fragment fails.</span></span>

    <span data-ttu-id="61bde-137">No se realiza el reintento, ya que el tiempo de ejecución de RPC puede optar por descartar el contenido del primer fragmento una vez que se ha completado y no tiene forma de reintentar el envío del primer fragmento.</span><span class="sxs-lookup"><span data-stu-id="61bde-137">Retry is not made, since the RPC run time may choose to discard the contents of the first fragment once it is complete, and has no way to retry sending the first fragment.</span></span>

-   <span data-ttu-id="61bde-138">Se envía la solicitud RPC.</span><span class="sxs-lookup"><span data-stu-id="61bde-138">The RPC request is sent.</span></span>

    <span data-ttu-id="61bde-139">El servidor anula la conexión.</span><span class="sxs-lookup"><span data-stu-id="61bde-139">The server aborts the connection.</span></span> <span data-ttu-id="61bde-140">No se intenta ningún reintento, ya que RPC no puede discernir si el servidor recibió la llamada y comenzó a ejecutarla.</span><span class="sxs-lookup"><span data-stu-id="61bde-140">No retry is attempted, since RPC cannot discern whether the server received the call and started executing it.</span></span>

<span data-ttu-id="61bde-141">Si el servidor utiliza un extremo dinámico, RPC no volverá a resolver el punto de conexión durante los reintentos.</span><span class="sxs-lookup"><span data-stu-id="61bde-141">If the server uses a dynamic endpoint, RPC will not re-resolve the endpoint during retries.</span></span> <span data-ttu-id="61bde-142">Esto significa que, si un servidor se apaga y vuelve a aparecer, puede residir en un punto de conexión diferente, y RPC no volverá a resolver de forma transparente el punto de conexión cuando se vuelva a intentar una llamada.</span><span class="sxs-lookup"><span data-stu-id="61bde-142">This means that if a server is brought down and comes back up, it may reside on a different endpoint, and RPC will not transparently re-resolve the endpoint when a call is retried.</span></span> <span data-ttu-id="61bde-143">Para forzar la nueva resolución del punto de conexión, el cliente RPC debe llamar a [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) antes de Reintentar una llamada.</span><span class="sxs-lookup"><span data-stu-id="61bde-143">To force re-resolving of the endpoint, the RPC client should calling [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) before it retries a call.</span></span>

<span data-ttu-id="61bde-144">En muchos de estos casos, si un cliente RPC puede determinar si una llamada es idempotente o si mantiene los datos descartados por RPC, puede optar por crear un mecanismo de reintento en la parte superior de RPC.</span><span class="sxs-lookup"><span data-stu-id="61bde-144">In many of these cases, if an RPC client can determine whether a call is idempotent, or if it keeps data that RPC discards, it may choose to build a retry mechanism on top of RPC.</span></span>

> [!Note]  
> <span data-ttu-id="61bde-145">Si el servidor es un clúster y los distintos nodos del clúster ejecutan versiones diferentes del software de servidor, un reintento de RPC puede destinar la llamada en un nodo diferente del clúster en caso de conmutación por error y potencialmente en una versión diferente del servidor.</span><span class="sxs-lookup"><span data-stu-id="61bde-145">If the server is a cluster, and the different nodes of the cluster run different versions of the server software, an RPC retry may land the call on a different node of the cluster in the case of failover, and potentially on a different version of the server.</span></span> <span data-ttu-id="61bde-146">En estos escenarios de implementación, asegúrese de que el cliente no se base en una versión concreta del software de servidor para ejecutar una llamada determinada.</span><span class="sxs-lookup"><span data-stu-id="61bde-146">In such deployment scenarios, make sure the client does not rely on a particular version of the server software to execute a given call.</span></span> <span data-ttu-id="61bde-147">Si lo hace, el cliente debe crear un mecanismo sobre RPC que detecte y controle dichas condiciones.</span><span class="sxs-lookup"><span data-stu-id="61bde-147">If it does, the client should build a mechanism on top of RPC that detects and handles such conditions.</span></span>

 

 

 