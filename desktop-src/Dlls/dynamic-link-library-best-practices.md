---
description: La creación de archivos dll presenta una serie de desafíos para los desarrolladores.
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Procedimientos recomendados de la biblioteca Dynamic-Link
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 88aba0999f3d0825c6d2f4df3afe09d766a82232
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105669707"
---
# <a name="dynamic-link-library-best-practices"></a><span data-ttu-id="7e10b-103">Procedimientos recomendados de la biblioteca Dynamic-Link</span><span class="sxs-lookup"><span data-stu-id="7e10b-103">Dynamic-Link Library Best Practices</span></span>

<span data-ttu-id="7e10b-104">\* \* Actualizado: \* \*</span><span class="sxs-lookup"><span data-stu-id="7e10b-104">\*\*Updated: \*\*</span></span>

-   <span data-ttu-id="7e10b-105">17 de mayo de 2006</span><span class="sxs-lookup"><span data-stu-id="7e10b-105">May 17, 2006</span></span>

<span data-ttu-id="7e10b-106">**API importantes**</span><span class="sxs-lookup"><span data-stu-id="7e10b-106">**Important APIs**</span></span>

-   [<span data-ttu-id="7e10b-107">**DllMain**</span><span class="sxs-lookup"><span data-stu-id="7e10b-107">**DllMain**</span></span>](dllmain.md)
-   [<span data-ttu-id="7e10b-108">**LoadLibraryEx**</span><span class="sxs-lookup"><span data-stu-id="7e10b-108">**LoadLibraryEx**</span></span>](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [<span data-ttu-id="7e10b-109">**CreateProcess**</span><span class="sxs-lookup"><span data-stu-id="7e10b-109">**CreateProcess**</span></span>](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

<span data-ttu-id="7e10b-110">La creación de archivos dll presenta una serie de desafíos para los desarrolladores.</span><span class="sxs-lookup"><span data-stu-id="7e10b-110">Creating DLLs presents a number of challenges for developers.</span></span> <span data-ttu-id="7e10b-111">Los archivos dll no tienen control de versiones aplicado por el sistema.</span><span class="sxs-lookup"><span data-stu-id="7e10b-111">DLLs do not have system-enforced versioning.</span></span> <span data-ttu-id="7e10b-112">Cuando existen varias versiones de un archivo DLL en un sistema, la facilidad de sobrescribirse junto con la falta de un esquema de control de versiones crea conflictos de dependencias y API.</span><span class="sxs-lookup"><span data-stu-id="7e10b-112">When multiple versions of a DLL exist on a system, the ease of being overwritten coupled with the lack of a versioning schema creates dependency and API conflicts.</span></span> <span data-ttu-id="7e10b-113">La complejidad en el entorno de desarrollo, la implementación del cargador y las dependencias de DLL han creado fragilidad en el orden de carga y el comportamiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="7e10b-113">Complexity in the development environment, the loader implementation, and the DLL dependencies has created fragility in load order and application behavior.</span></span> <span data-ttu-id="7e10b-114">Por último, muchas aplicaciones se basan en archivos dll y tienen conjuntos complejos de dependencias que se deben respetar para que las aplicaciones funcionen correctamente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-114">Lastly, many applications rely on DLLs and have complex sets of dependencies that must be honored for the applications to function properly.</span></span> <span data-ttu-id="7e10b-115">En este documento se proporcionan directrices para que los desarrolladores de archivos DLL ayuden a crear archivos dll más sólidos, portátiles y extensibles.</span><span class="sxs-lookup"><span data-stu-id="7e10b-115">This document provides guidelines for DLL developers to help in building more robust, portable, and extensible DLLs.</span></span>

<span data-ttu-id="7e10b-116">Una sincronización incorrecta en [**DllMain**](dllmain.md) puede hacer que una aplicación se interbloquee o tenga acceso a datos o código en un archivo dll no inicializado.</span><span class="sxs-lookup"><span data-stu-id="7e10b-116">Improper synchronization within [**DllMain**](dllmain.md) can cause an application to deadlock or access data or code in an uninitialized DLL.</span></span> <span data-ttu-id="7e10b-117">Llamar a determinadas funciones desde **DllMain** provoca estos problemas.</span><span class="sxs-lookup"><span data-stu-id="7e10b-117">Calling certain functions from within **DllMain** causes such problems.</span></span>

![¿Qué ocurre cuando se carga una biblioteca?](images/fig1.png)

## <a name="general-best-practices"></a><span data-ttu-id="7e10b-119">Procedimientos recomendados generales</span><span class="sxs-lookup"><span data-stu-id="7e10b-119">General Best Practices</span></span>

<span data-ttu-id="7e10b-120">Se llama a [**DllMain**](dllmain.md) mientras se mantiene el bloqueo del cargador.</span><span class="sxs-lookup"><span data-stu-id="7e10b-120">[**DllMain**](dllmain.md) is called while the loader-lock is held.</span></span> <span data-ttu-id="7e10b-121">Por lo tanto, se imponen restricciones significativas en las funciones a las que se puede llamar en **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="7e10b-121">Therefore, significant restrictions are imposed on the functions that can be called within **DllMain**.</span></span> <span data-ttu-id="7e10b-122">Como tal, **DllMain** está diseñada para realizar tareas de inicialización mínimas, mediante el uso de un pequeño subconjunto de Microsoft® Windows® API.</span><span class="sxs-lookup"><span data-stu-id="7e10b-122">As such, **DllMain** is designed to perform minimal initialization tasks, by using a small subset of the Microsoft® Windows® API.</span></span> <span data-ttu-id="7e10b-123">No se puede llamar a ninguna función de **DllMain** que intente adquirir directa o indirectamente el bloqueo del cargador.</span><span class="sxs-lookup"><span data-stu-id="7e10b-123">You cannot call any function in **DllMain** that directly or indirectly tries to acquire the loader lock.</span></span> <span data-ttu-id="7e10b-124">De lo contrario, introducirá la posibilidad de que la aplicación se bloquee o se bloquee.</span><span class="sxs-lookup"><span data-stu-id="7e10b-124">Otherwise, you will introduce the possibility that your application deadlocks or crashes.</span></span> <span data-ttu-id="7e10b-125">Un error en una implementación de **DllMain** puede poner en peligro todo el proceso y todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="7e10b-125">An error in a **DllMain** implementation can jeopardize the entire process and all of its threads.</span></span>

<span data-ttu-id="7e10b-126">La opción [**DllMain**](dllmain.md) ideal sería simplemente un código auxiliar vacío.</span><span class="sxs-lookup"><span data-stu-id="7e10b-126">The ideal [**DllMain**](dllmain.md) would be just an empty stub.</span></span> <span data-ttu-id="7e10b-127">Sin embargo, dada la complejidad de muchas aplicaciones, suele ser demasiado restrictiva.</span><span class="sxs-lookup"><span data-stu-id="7e10b-127">However, given the complexity of many applications, this is generally too restrictive.</span></span> <span data-ttu-id="7e10b-128">Una buena regla general para **DllMain** es posponer la máxima inicialización posible.</span><span class="sxs-lookup"><span data-stu-id="7e10b-128">A good rule of thumb for **DllMain** is to postpone as much initialization as possible.</span></span> <span data-ttu-id="7e10b-129">La inicialización diferida aumenta la solidez de la aplicación, ya que esta inicialización no se realiza mientras se mantiene el bloqueo del cargador.</span><span class="sxs-lookup"><span data-stu-id="7e10b-129">Lazy initialization increases robustness of the application because this initialization is not performed while the loader lock is held.</span></span> <span data-ttu-id="7e10b-130">Además, la inicialización diferida le permite usar de forma segura mucho más la API de Windows.</span><span class="sxs-lookup"><span data-stu-id="7e10b-130">Also, lazy initialization enables you to safely use much more of the Windows API.</span></span>

<span data-ttu-id="7e10b-131">No se pueden posponer algunas tareas de inicialización.</span><span class="sxs-lookup"><span data-stu-id="7e10b-131">Some initialization tasks cannot be postponed.</span></span> <span data-ttu-id="7e10b-132">Por ejemplo, una DLL que depende de un archivo de configuración debería no cargarse si el archivo tiene un formato incorrecto o contiene elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="7e10b-132">For example, a DLL that depends on a configuration file should fail to load if the file is malformed or contains garbage.</span></span> <span data-ttu-id="7e10b-133">Para este tipo de inicialización, el archivo DLL debe intentar la acción y producir un error rápido en lugar de desperdiciar recursos mediante la finalización de otro trabajo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-133">For this type of initialization, the DLL should attempt the action and fail quickly rather than waste resources by completing other work.</span></span>

<span data-ttu-id="7e10b-134">Nunca debe realizar las siguientes tareas desde [**DllMain**](dllmain.md):</span><span class="sxs-lookup"><span data-stu-id="7e10b-134">You should never perform the following tasks from within [**DllMain**](dllmain.md):</span></span>

-   <span data-ttu-id="7e10b-135">Llame a [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) o [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (ya sea directa o indirectamente).</span><span class="sxs-lookup"><span data-stu-id="7e10b-135">Call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (either directly or indirectly).</span></span> <span data-ttu-id="7e10b-136">Esto puede producir un interbloqueo o un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-136">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="7e10b-137">Llame a [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)o [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (directa o indirectamente).</span><span class="sxs-lookup"><span data-stu-id="7e10b-137">Call [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw), or [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (either directly or indirectly).</span></span> <span data-ttu-id="7e10b-138">Esto puede producir un interbloqueo o un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-138">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="7e10b-139">Sincronizar con otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="7e10b-139">Synchronize with other threads.</span></span> <span data-ttu-id="7e10b-140">Esto puede producir un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-140">This can cause a deadlock.</span></span>
-   <span data-ttu-id="7e10b-141">Adquiera un objeto de sincronización que sea propiedad del código que está esperando para adquirir el bloqueo del cargador.</span><span class="sxs-lookup"><span data-stu-id="7e10b-141">Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock.</span></span> <span data-ttu-id="7e10b-142">Esto puede producir un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-142">This can cause a deadlock.</span></span>
-   <span data-ttu-id="7e10b-143">Inicialice los subprocesos COM mediante [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="7e10b-143">Initialize COM threads by using [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="7e10b-144">En determinadas condiciones, esta función puede llamar a [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span><span class="sxs-lookup"><span data-stu-id="7e10b-144">Under certain conditions, this function can call [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span>
-   <span data-ttu-id="7e10b-145">Llame a las funciones del registro.</span><span class="sxs-lookup"><span data-stu-id="7e10b-145">Call the registry functions.</span></span> <span data-ttu-id="7e10b-146">Estas funciones se implementan en Advapi32.dll.</span><span class="sxs-lookup"><span data-stu-id="7e10b-146">These functions are implemented in Advapi32.dll.</span></span> <span data-ttu-id="7e10b-147">Si Advapi32.dll no se inicializa antes que el archivo DLL, el archivo DLL puede tener acceso a la memoria sin inicializar y provocar el bloqueo del proceso.</span><span class="sxs-lookup"><span data-stu-id="7e10b-147">If Advapi32.dll is not initialized before your DLL, the DLL can access uninitialized memory and cause the process to crash.</span></span>
-   <span data-ttu-id="7e10b-148">Llame a [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span><span class="sxs-lookup"><span data-stu-id="7e10b-148">Call [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span></span> <span data-ttu-id="7e10b-149">La creación de un proceso puede cargar otro archivo DLL.</span><span class="sxs-lookup"><span data-stu-id="7e10b-149">Creating a process can load another DLL.</span></span>
-   <span data-ttu-id="7e10b-150">Llame a [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span><span class="sxs-lookup"><span data-stu-id="7e10b-150">Call [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="7e10b-151">Salir de un subproceso durante la desasociación de DLL puede provocar que se vuelva a adquirir el bloqueo del cargador, lo que provocaría un interbloqueo o un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-151">Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</span></span>
-   <span data-ttu-id="7e10b-152">Llame a [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span><span class="sxs-lookup"><span data-stu-id="7e10b-152">Call [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span></span> <span data-ttu-id="7e10b-153">La creación de un subproceso puede funcionar si no se sincroniza con otros subprocesos, pero es arriesgado.</span><span class="sxs-lookup"><span data-stu-id="7e10b-153">Creating a thread can work if you do not synchronize with other threads, but it is risky.</span></span>
-   <span data-ttu-id="7e10b-154">Cree una canalización con nombre u otro objeto con nombre (solo Windows 2000).</span><span class="sxs-lookup"><span data-stu-id="7e10b-154">Create a named pipe or other named object (Windows 2000 only).</span></span> <span data-ttu-id="7e10b-155">En Windows 2000, los objetos con nombre se proporcionan mediante el Terminal Services DLL.</span><span class="sxs-lookup"><span data-stu-id="7e10b-155">In Windows 2000, named objects are provided by the Terminal Services DLL.</span></span> <span data-ttu-id="7e10b-156">Si no se inicializa este archivo DLL, las llamadas a la DLL pueden provocar que el proceso se bloquee.</span><span class="sxs-lookup"><span data-stu-id="7e10b-156">If this DLL is not initialized, calls to the DLL can cause the process to crash.</span></span>
-   <span data-ttu-id="7e10b-157">Utilice la función de administración de memoria de la Run-Time de C dinámica (CRT).</span><span class="sxs-lookup"><span data-stu-id="7e10b-157">Use the memory management function from the dynamic C Run-Time (CRT).</span></span> <span data-ttu-id="7e10b-158">Si el archivo DLL de CRT no se ha inicializado, las llamadas a estas funciones pueden provocar el bloqueo del proceso.</span><span class="sxs-lookup"><span data-stu-id="7e10b-158">If the CRT DLL is not initialized, calls to these functions can cause the process to crash.</span></span>
-   <span data-ttu-id="7e10b-159">Llamar a funciones en User32.dll o Gdi32.dll.</span><span class="sxs-lookup"><span data-stu-id="7e10b-159">Call functions in User32.dll or Gdi32.dll.</span></span> <span data-ttu-id="7e10b-160">Algunas funciones cargan otro archivo DLL, que no se puede inicializar.</span><span class="sxs-lookup"><span data-stu-id="7e10b-160">Some functions load another DLL, which may not be initialized.</span></span>
-   <span data-ttu-id="7e10b-161">Usar código administrado.</span><span class="sxs-lookup"><span data-stu-id="7e10b-161">Use managed code.</span></span>

<span data-ttu-id="7e10b-162">Las siguientes tareas se pueden realizar con seguridad en **DllMain**:</span><span class="sxs-lookup"><span data-stu-id="7e10b-162">The following tasks are safe to perform within **DllMain**:</span></span>

-   <span data-ttu-id="7e10b-163">Inicializar miembros y estructuras de datos estáticos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="7e10b-163">Initialize static data structures and members at compile time.</span></span>
-   <span data-ttu-id="7e10b-164">Cree e inicialice objetos de sincronización.</span><span class="sxs-lookup"><span data-stu-id="7e10b-164">Create and initialize synchronization objects.</span></span>
-   <span data-ttu-id="7e10b-165">Asigne memoria e inicialice estructuras de datos dinámicos (evitando las funciones enumeradas anteriormente).</span><span class="sxs-lookup"><span data-stu-id="7e10b-165">Allocate memory and initialize dynamic data structures (avoiding the functions listed above.)</span></span>
-   <span data-ttu-id="7e10b-166">Configurar el almacenamiento local de subprocesos (TLS).</span><span class="sxs-lookup"><span data-stu-id="7e10b-166">Set up thread local storage (TLS).</span></span>
-   <span data-ttu-id="7e10b-167">Abrir, leer y escribir en archivos.</span><span class="sxs-lookup"><span data-stu-id="7e10b-167">Open, read from, and write to files.</span></span>
-   <span data-ttu-id="7e10b-168">Llamar a funciones en Kernel32.dll (excepto las funciones enumeradas anteriormente).</span><span class="sxs-lookup"><span data-stu-id="7e10b-168">Call functions in Kernel32.dll (except the functions that are listed above).</span></span>
-   <span data-ttu-id="7e10b-169">Establezca punteros globales en NULL y salga de la inicialización de los miembros dinámicos.</span><span class="sxs-lookup"><span data-stu-id="7e10b-169">Set global pointers to NULL, putting off the initialization of dynamic members.</span></span> <span data-ttu-id="7e10b-170">En Microsoft Windows Vista™, puede usar las funciones de inicialización únicas para asegurarse de que un bloque de código se ejecuta solo una vez en un entorno multiproceso.</span><span class="sxs-lookup"><span data-stu-id="7e10b-170">In Microsoft Windows Vista™, you can use the one-time initialization functions to ensure that a block of code is executed only once in a multithreaded environment.</span></span>

## <a name="deadlocks-caused-by-lock-order-inversion"></a><span data-ttu-id="7e10b-171">Interbloqueos causados por la inversión del orden de bloqueo</span><span class="sxs-lookup"><span data-stu-id="7e10b-171">Deadlocks Caused by Lock Order Inversion</span></span>

<span data-ttu-id="7e10b-172">Cuando se implementa código que utiliza varios objetos de sincronización, como bloqueos, es fundamental respetar el orden de los bloqueos.</span><span class="sxs-lookup"><span data-stu-id="7e10b-172">When you are implementing code that uses multiple synchronization objects such as locks, it is vital to respect lock order.</span></span> <span data-ttu-id="7e10b-173">Cuando es necesario adquirir más de un bloqueo a la vez, debe definir una prioridad explícita que se llame una jerarquía de bloqueos o un orden de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-173">When it is necessary to acquire more than one lock at a time, you must define an explicit precedence that is called a lock hierarchy or lock order.</span></span> <span data-ttu-id="7e10b-174">Por ejemplo, si se adquiere el bloqueo A antes de bloquear B en algún lugar del código, y el bloqueo B se adquiere antes que el bloque C en otro lugar del código, el orden de bloqueo es a, B, C y este orden debe seguirse en todo el código.</span><span class="sxs-lookup"><span data-stu-id="7e10b-174">For example, if lock A is acquired before lock B somewhere in the code, and lock B is acquired before lock C elsewhere in the code, then the lock order is A, B, C and this order should be followed throughout the code.</span></span> <span data-ttu-id="7e10b-175">La inversión del orden de bloqueo se produce cuando no se sigue el orden de bloqueo; por ejemplo, si se adquiere el bloqueo B antes de bloquear un. la inversion del orden de bloqueo puede producir interbloqueos difíciles de depurar.</span><span class="sxs-lookup"><span data-stu-id="7e10b-175">Lock order inversion occurs when the locking order is not followed—for example, if lock B is acquired before lock A. Lock order inversion can cause deadlocks that are difficult to debug.</span></span> <span data-ttu-id="7e10b-176">Para evitar estos problemas, todos los subprocesos deben adquirir bloqueos en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="7e10b-176">To avoid such problems, all threads must acquire locks in the same order.</span></span>

<span data-ttu-id="7e10b-177">Es importante tener en cuenta que el cargador llama a [**DllMain**](dllmain.md) con el bloqueo del cargador ya adquirido, por lo que el bloqueo del cargador debe tener la prioridad más alta en la jerarquía de bloqueos.</span><span class="sxs-lookup"><span data-stu-id="7e10b-177">It is important to note that the loader calls [**DllMain**](dllmain.md) with the loader lock already acquired, so the loader lock should have the highest precedence in the locking hierarchy.</span></span> <span data-ttu-id="7e10b-178">Tenga en cuenta también que el código solo tiene que adquirir los bloqueos necesarios para la sincronización correcta; no tiene que adquirir cada bloqueo único que se define en la jerarquía.</span><span class="sxs-lookup"><span data-stu-id="7e10b-178">Also note that code only has to acquire the locks it requires for proper synchronization; it does not have to acquire every single lock that is defined in the hierarchy.</span></span> <span data-ttu-id="7e10b-179">Por ejemplo, si una sección de código solo requiere bloqueos A y C para la sincronización correcta, el código debe adquirir el bloqueo A antes de adquirir el bloqueo C; no es necesario que el código también adquiera el bloqueo B. Además, el código DLL no puede adquirir explícitamente el bloqueo del cargador.</span><span class="sxs-lookup"><span data-stu-id="7e10b-179">For example, if a section of code requires only locks A and C for proper synchronization, then the code should acquire lock A before it acquires lock C; it is not necessary for the code to also acquire lock B. Furthermore, DLL code cannot explicitly acquire the loader lock.</span></span> <span data-ttu-id="7e10b-180">Si el código debe llamar a una API como [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) que pueda adquirir indirectamente el bloqueo del cargador y el código también debe adquirir un bloqueo privado, el código debe llamar a **GetModuleFileName** antes de adquirir el bloqueo P, lo que garantiza que se respete el orden de carga.</span><span class="sxs-lookup"><span data-stu-id="7e10b-180">If the code must call an API such as [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) that can indirectly acquire the loader lock and the code must also acquire a private lock, then the code should call **GetModuleFileName** before it acquires lock P, thus ensuring that load order is respected.</span></span>

<span data-ttu-id="7e10b-181">En la ilustración 2 se muestra un ejemplo que ilustra la inversión del orden de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-181">Figure 2 is an example that illustrates lock order inversion.</span></span> <span data-ttu-id="7e10b-182">Considere una DLL cuyo subproceso principal contiene [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="7e10b-182">Consider a DLL whose main thread contains [**DllMain**](dllmain.md).</span></span> <span data-ttu-id="7e10b-183">El cargador de la biblioteca adquiere el bloqueo de cargador L y, a continuación, llama a **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="7e10b-183">The library loader acquires the loader lock L and then calls into **DllMain**.</span></span> <span data-ttu-id="7e10b-184">El subproceso principal crea los objetos de sincronización a, B y G para serializar el acceso a sus estructuras de datos y, a continuación, intenta adquirir el bloqueo G. Un subproceso de trabajo que ya ha adquirido correctamente el bloqueo G llama a una función como GetModuleHandle que intenta adquirir el bloqueo del cargador L. Por lo tanto, el subproceso de trabajo se bloquea en L y el subproceso principal se bloquea en G, lo que produce un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-184">The main thread creates synchronization objects A, B, and G to serialize access to its data structures and then tries to acquire lock G. A worker thread that has already successfully acquired lock G then calls a function such as GetModuleHandle that attempts to acquire the loader lock L. Thus, the worker thread is blocked on L and the main thread is blocked on G, resulting in a deadlock.</span></span>

![interbloqueo causado por la inversión del orden de bloqueo](images/fig2.png)

<span data-ttu-id="7e10b-186">Para evitar interbloqueos causados por la inversion del orden de bloqueo, todos los subprocesos deben intentar adquirir objetos de sincronización en el orden de carga definido en todo momento.</span><span class="sxs-lookup"><span data-stu-id="7e10b-186">To prevent deadlocks that are caused by lock order inversion, all threads should attempt to acquire synchronization objects in the defined load order at all times.</span></span>

## <a name="best-practices-for-synchronization"></a><span data-ttu-id="7e10b-187">Prácticas recomendadas para la sincronización</span><span class="sxs-lookup"><span data-stu-id="7e10b-187">Best Practices for Synchronization</span></span>

<span data-ttu-id="7e10b-188">Considere un archivo DLL que crea subprocesos de trabajo como parte de su inicialización.</span><span class="sxs-lookup"><span data-stu-id="7e10b-188">Consider a DLL that creates worker threads as part of its initialization.</span></span> <span data-ttu-id="7e10b-189">Tras la limpieza de archivos DLL, es necesario sincronizar con todos los subprocesos de trabajo para asegurarse de que las estructuras de datos están en un estado coherente y, a continuación, terminar los subprocesos de trabajo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-189">Upon DLL cleanup, it is necessary to synchronize with all the worker threads to ensure that the data structures are in a consistent state and then terminate the worker threads.</span></span> <span data-ttu-id="7e10b-190">En la actualidad, no hay ninguna manera sencilla de resolver por completo el problema de la sincronización y el cierre correctos de los archivos dll en un entorno multiproceso.</span><span class="sxs-lookup"><span data-stu-id="7e10b-190">Today, there is no straightforward way to completely solve the problem of cleanly synchronizing and shutting down DLLs in a multithreaded environment.</span></span> <span data-ttu-id="7e10b-191">En esta sección se describen las prácticas recomendadas actuales para la sincronización de subprocesos durante el cierre de DLL.</span><span class="sxs-lookup"><span data-stu-id="7e10b-191">This section describes the current best practices for thread synchronizing during DLL shutdown.</span></span>

<span data-ttu-id="7e10b-192">Sincronización de subprocesos en [**DllMain**](dllmain.md) durante la salida del proceso</span><span class="sxs-lookup"><span data-stu-id="7e10b-192">Thread Synchronization in [**DllMain**](dllmain.md) during Process Exit</span></span>

-   <span data-ttu-id="7e10b-193">En el momento en que se llama a [**DllMain**](dllmain.md) al salir del proceso, todos los subprocesos del proceso se han limpiado forzosamente y existe la posibilidad de que el espacio de direcciones sea incoherente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-193">By the time [**DllMain**](dllmain.md) is called at process exit, all the process’s threads have been forcibly cleaned up and there is a chance that the address space is inconsistent.</span></span> <span data-ttu-id="7e10b-194">En este caso, no es necesaria la sincronización.</span><span class="sxs-lookup"><span data-stu-id="7e10b-194">Synchronization is not required in this case.</span></span> <span data-ttu-id="7e10b-195">En otras palabras, el controlador de \_ desasociación de procesos de dll ideal \_ está vacío.</span><span class="sxs-lookup"><span data-stu-id="7e10b-195">In other words, the ideal DLL\_PROCESS\_DETACH handler is empty.</span></span>
-   <span data-ttu-id="7e10b-196">Windows Vista garantiza que las estructuras de datos principales (variables de entorno, directorio actual, montón de procesos, etc.) se encuentran en un estado coherente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-196">Windows Vista ensures that core data structures (environment variables, current directory, process heap, and so on) are in a consistent state.</span></span> <span data-ttu-id="7e10b-197">Sin embargo, se pueden dañar otras estructuras de datos, por lo que la limpieza de la memoria no es segura.</span><span class="sxs-lookup"><span data-stu-id="7e10b-197">However, other data structures can be corrupted, so cleaning memory is not safe.</span></span>
-   <span data-ttu-id="7e10b-198">El estado persistente que debe guardarse debe vaciarse en el almacenamiento permanente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-198">Persistent state that needs to be saved must be flushed to permanent storage.</span></span>

<span data-ttu-id="7e10b-199">Sincronización de subprocesos en **DllMain** para \_ desasociar el subproceso dll \_ durante la descarga de dll</span><span class="sxs-lookup"><span data-stu-id="7e10b-199">Thread Synchronization in **DllMain** for DLL\_THREAD\_DETACH during DLL Unload</span></span>

-   <span data-ttu-id="7e10b-200">Cuando se descarga el archivo DLL, no se produce el espacio de direcciones.</span><span class="sxs-lookup"><span data-stu-id="7e10b-200">When the DLL is unloaded, the address space is not thrown away.</span></span> <span data-ttu-id="7e10b-201">Por lo tanto, se espera que el archivo DLL realice un cierre correcto.</span><span class="sxs-lookup"><span data-stu-id="7e10b-201">Therefore, the DLL is expected to perform a clean shutdown.</span></span> <span data-ttu-id="7e10b-202">Esto incluye la sincronización de subprocesos, los identificadores abiertos, el estado persistente y los recursos asignados.</span><span class="sxs-lookup"><span data-stu-id="7e10b-202">This includes thread synchronization, open handles, persistent state, and allocated resources.</span></span>
-   <span data-ttu-id="7e10b-203">La sincronización de subprocesos es complicada porque esperar a que los subprocesos salgan en [**DllMain**](dllmain.md) puede producir un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-203">Thread synchronization is tricky because waiting on threads to exit in [**DllMain**](dllmain.md) can cause a deadlock.</span></span> <span data-ttu-id="7e10b-204">Por ejemplo, el archivo DLL A contiene el bloqueo del cargador.</span><span class="sxs-lookup"><span data-stu-id="7e10b-204">For example, DLL A holds the loader lock.</span></span> <span data-ttu-id="7e10b-205">Indica al subproceso T que salga y espera a que el subproceso se cierre.</span><span class="sxs-lookup"><span data-stu-id="7e10b-205">It signals thread T to exit and waits for the thread to exit.</span></span> <span data-ttu-id="7e10b-206">El subproceso T se cierra y el cargador intenta adquirir el bloqueo del cargador para llamar a **DllMain** de la dll a de la \_ desasociación de subprocesos dll \_ .</span><span class="sxs-lookup"><span data-stu-id="7e10b-206">Thread T exits and the loader tries to acquire the loader lock to call into DLL A’s **DllMain** with DLL\_THREAD\_DETACH.</span></span> <span data-ttu-id="7e10b-207">Esto provoca un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-207">This causes a deadlock.</span></span> <span data-ttu-id="7e10b-208">Para minimizar el riesgo de un interbloqueo:</span><span class="sxs-lookup"><span data-stu-id="7e10b-208">To minimize the risk of a deadlock:</span></span>
    -   <span data-ttu-id="7e10b-209">El archivo DLL A obtiene \_ un \_ mensaje de desasociación de subprocesos dll en su [**DllMain**](dllmain.md) y establece un evento para el subproceso T, señalando su salida.</span><span class="sxs-lookup"><span data-stu-id="7e10b-209">DLL A gets a DLL\_THREAD\_DETACH message in its [**DllMain**](dllmain.md) and sets an event for thread T, signaling it to exit.</span></span>
    -   <span data-ttu-id="7e10b-210">Thread T finaliza su tarea actual, se convierte en un estado coherente, señala a la DLL A y espera infinitamente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-210">Thread T finishes its current task, brings itself to a consistent state, signals DLL A, and waits infinitely.</span></span> <span data-ttu-id="7e10b-211">Tenga en cuenta que las rutinas de comprobación de coherencia deben seguir las mismas restricciones que [**DllMain**](dllmain.md) para evitar el interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="7e10b-211">Note that the consistency-checking routines should follow the same restrictions as [**DllMain**](dllmain.md) to avoid deadlocking.</span></span>
    -   <span data-ttu-id="7e10b-212">El archivo DLL A termina T y sabe que está en un estado coherente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-212">DLL A terminates T, knowing that it is in a consistent state.</span></span>

<span data-ttu-id="7e10b-213">Si se descarga un archivo DLL una vez que se han creado todos los subprocesos, pero antes de que empiecen a ejecutarse, los subprocesos pueden bloquearse.</span><span class="sxs-lookup"><span data-stu-id="7e10b-213">If a DLL is unloaded after all its threads have been created, but before they begin executing, the threads may crash.</span></span> <span data-ttu-id="7e10b-214">Si el archivo DLL crea subprocesos en su **DllMain** como parte de su inicialización, es posible que algunos subprocesos no hayan finalizado la inicialización y que el \_ mensaje de \_ adjuntar el subproceso dll todavía esté esperando a entregarse al archivo dll.</span><span class="sxs-lookup"><span data-stu-id="7e10b-214">If the DLL created threads in its **DllMain** as part of its initialization, some threads may not have finished initialization and their DLL\_THREAD\_ATTACH message is still waiting to be delivered to the DLL.</span></span> <span data-ttu-id="7e10b-215">En esta situación, si se descarga el archivo DLL, comenzará a terminar los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="7e10b-215">In this situation, if the DLL is unloaded, it will begin terminating threads.</span></span> <span data-ttu-id="7e10b-216">Sin embargo, algunos subprocesos pueden bloquearse detrás del bloqueo del cargador.</span><span class="sxs-lookup"><span data-stu-id="7e10b-216">However, some threads may be blocked behind the loader lock.</span></span> <span data-ttu-id="7e10b-217">Los \_ \_ mensajes adjuntos del subproceso de la dll se procesan después de que se haya desasignado el archivo dll, lo que provoca el bloqueo del proceso.</span><span class="sxs-lookup"><span data-stu-id="7e10b-217">Their DLL\_THREAD\_ATTACH messages are processed after the DLL has been unmapped, causing the process to crash.</span></span>

## <a name="recommendations"></a><span data-ttu-id="7e10b-218">Recomendaciones</span><span class="sxs-lookup"><span data-stu-id="7e10b-218">Recommendations</span></span>

<span data-ttu-id="7e10b-219">Se recomiendan las siguientes directrices:</span><span class="sxs-lookup"><span data-stu-id="7e10b-219">The following are recommended guidelines:</span></span>

-   <span data-ttu-id="7e10b-220">Utilice comprobador de aplicaciones para detectar los errores más comunes en [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="7e10b-220">Use Application Verifier to catch the most common errors in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="7e10b-221">Si usa un bloqueo privado dentro de [**DllMain**](dllmain.md), defina una jerarquía de bloqueo y úsela de forma coherente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-221">If using a private lock inside [**DllMain**](dllmain.md), define a locking hierarchy and use it consistently.</span></span> <span data-ttu-id="7e10b-222">El bloqueo del cargador debe estar en la parte inferior de esta jerarquía.</span><span class="sxs-lookup"><span data-stu-id="7e10b-222">The loader lock must be at the bottom of this hierarchy.</span></span>
-   <span data-ttu-id="7e10b-223">Compruebe que no haya ninguna llamada que dependa de otra DLL que no se haya cargado todavía completamente.</span><span class="sxs-lookup"><span data-stu-id="7e10b-223">Verify that no calls depend on another DLL that may not have been fully loaded yet.</span></span>
-   <span data-ttu-id="7e10b-224">Realice inicializaciones simples de forma estática en tiempo de compilación, en lugar de en [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="7e10b-224">Perform simple initializations statically at compile time, rather than in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="7e10b-225">Postergue cualquier llamada en [**DllMain**](dllmain.md) que pueda esperar hasta más adelante.</span><span class="sxs-lookup"><span data-stu-id="7e10b-225">Defer any calls in [**DllMain**](dllmain.md) that can wait until later.</span></span>
-   <span data-ttu-id="7e10b-226">Diferir las tareas de inicialización que pueden esperar hasta más adelante.</span><span class="sxs-lookup"><span data-stu-id="7e10b-226">Defer initialization tasks that can wait until later.</span></span> <span data-ttu-id="7e10b-227">Ciertas condiciones de error se deben detectar pronto para que la aplicación pueda controlar correctamente los errores.</span><span class="sxs-lookup"><span data-stu-id="7e10b-227">Certain error conditions must be detected early so that the application can handle errors gracefully.</span></span> <span data-ttu-id="7e10b-228">Sin embargo, hay contrapartidas entre esta detección temprana y la pérdida de solidez que puede derivar de ella.</span><span class="sxs-lookup"><span data-stu-id="7e10b-228">However, there are tradeoffs between this early detection and the loss of robustness that can result from it.</span></span> <span data-ttu-id="7e10b-229">La desconcesión de la inicialización suele ser mejor.</span><span class="sxs-lookup"><span data-stu-id="7e10b-229">Deferring initialization is often best.</span></span>

 

 
