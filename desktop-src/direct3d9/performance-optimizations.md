---
description: Cada desarrollador que crea aplicaciones en tiempo real que usan gráficos 3D se preocupa de la optimización del rendimiento. En esta sección se proporcionan instrucciones para obtener el mejor rendimiento del código.
ms.assetid: 074f848e-4a42-48a2-adf7-4026b8967413
title: Optimizaciones de rendimiento (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4d42be994522f0d83e36387b1a5866b3eee10df3
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/06/2021
ms.locfileid: "104494272"
---
# <a name="performance-optimizations-direct3d-9"></a><span data-ttu-id="92322-104">Optimizaciones de rendimiento (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="92322-104">Performance Optimizations (Direct3D 9)</span></span>

<span data-ttu-id="92322-105">Cada desarrollador que crea aplicaciones en tiempo real que usan gráficos 3D se preocupa de la optimización del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="92322-105">Every developer who creates real-time applications that use 3D graphics is concerned about performance optimization.</span></span> <span data-ttu-id="92322-106">En esta sección se proporcionan instrucciones para obtener el mejor rendimiento del código.</span><span class="sxs-lookup"><span data-stu-id="92322-106">This section provides guidelines for getting the best performance from your code.</span></span>

-   [<span data-ttu-id="92322-107">Sugerencias generales de rendimiento</span><span class="sxs-lookup"><span data-stu-id="92322-107">General Performance Tips</span></span>](#general-performance-tips)
-   [<span data-ttu-id="92322-108">Bases de datos y selección</span><span class="sxs-lookup"><span data-stu-id="92322-108">Databases and Culling</span></span>](#databases-and-culling)
-   [<span data-ttu-id="92322-109">Procesamiento por lotes de primitivas</span><span class="sxs-lookup"><span data-stu-id="92322-109">Batching Primitives</span></span>](#batching-primitives)
-   [<span data-ttu-id="92322-110">Sugerencias de iluminación</span><span class="sxs-lookup"><span data-stu-id="92322-110">Lighting Tips</span></span>](#lighting-tips)
-   [<span data-ttu-id="92322-111">Tamaño de textura</span><span class="sxs-lookup"><span data-stu-id="92322-111">Texture Size</span></span>](#texture-size)
-   [<span data-ttu-id="92322-112">Transformaciones de matriz</span><span class="sxs-lookup"><span data-stu-id="92322-112">Matrix Transforms</span></span>](#matrix-transforms)
-   [<span data-ttu-id="92322-113">Usar texturas dinámicas</span><span class="sxs-lookup"><span data-stu-id="92322-113">Using Dynamic Textures</span></span>](#using-dynamic-textures)
-   [<span data-ttu-id="92322-114">Usar búferes dinámicos de vértices y de índices</span><span class="sxs-lookup"><span data-stu-id="92322-114">Using Dynamic Vertex and Index Buffers</span></span>](#using-dynamic-vertex-and-index-buffers)
-   [<span data-ttu-id="92322-115">Usar mallas</span><span class="sxs-lookup"><span data-stu-id="92322-115">Using Meshes</span></span>](#using-meshes)
-   [<span data-ttu-id="92322-116">Rendimiento del búfer Z</span><span class="sxs-lookup"><span data-stu-id="92322-116">Z-Buffer Performance</span></span>](#z-buffer-performance)

## <a name="general-performance-tips"></a><span data-ttu-id="92322-117">Sugerencias generales de rendimiento</span><span class="sxs-lookup"><span data-stu-id="92322-117">General Performance Tips</span></span>

-   <span data-ttu-id="92322-118">Desactive solo cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="92322-118">Clear only when you must.</span></span>
-   <span data-ttu-id="92322-119">Minimizar los cambios de estado y agrupar los cambios de estado restantes.</span><span class="sxs-lookup"><span data-stu-id="92322-119">Minimize state changes and group the remaining state changes.</span></span>
-   <span data-ttu-id="92322-120">Use texturas más pequeñas, si puede hacerlo.</span><span class="sxs-lookup"><span data-stu-id="92322-120">Use smaller textures, if you can do so.</span></span>
-   <span data-ttu-id="92322-121">Dibuje objetos de la escena de delante a atrás.</span><span class="sxs-lookup"><span data-stu-id="92322-121">Draw objects in your scene from front to back.</span></span>
-   <span data-ttu-id="92322-122">Use bandas de triángulo en lugar de listas y ventiladores.</span><span class="sxs-lookup"><span data-stu-id="92322-122">Use triangle strips instead of lists and fans.</span></span> <span data-ttu-id="92322-123">Para un rendimiento óptimo de la caché de vértices, organice las tiras para volver a usar los vértices de triángulo antes, en lugar de más adelante</span><span class="sxs-lookup"><span data-stu-id="92322-123">For optimal vertex cache performance, arrange strips to reuse triangle vertices sooner, rather than later.</span></span>
-   <span data-ttu-id="92322-124">Degradar correctamente los efectos especiales que requieren una cuota desproporcionada de recursos del sistema.</span><span class="sxs-lookup"><span data-stu-id="92322-124">Gracefully degrade special effects that require a disproportionate share of system resources.</span></span>
-   <span data-ttu-id="92322-125">Pruebe constantemente el rendimiento de su aplicación.</span><span class="sxs-lookup"><span data-stu-id="92322-125">Constantly test your application's performance.</span></span>
-   <span data-ttu-id="92322-126">Minimice los modificadores de búfer de vértices.</span><span class="sxs-lookup"><span data-stu-id="92322-126">Minimize vertex buffer switches.</span></span>
-   <span data-ttu-id="92322-127">Use búferes de vértices estáticos siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="92322-127">Use static vertex buffers where possible.</span></span>
-   <span data-ttu-id="92322-128">Use un búfer de vértices estáticos grande por FVF para los objetos estáticos, en lugar de uno por cada objeto.</span><span class="sxs-lookup"><span data-stu-id="92322-128">Use one large static vertex buffer per FVF for static objects, rather than one per object.</span></span>
-   <span data-ttu-id="92322-129">Si la aplicación necesita acceso aleatorio al búfer de vértices en la memoria AGP, elija un tamaño de formato de vértice que sea un múltiplo de 32 bytes.</span><span class="sxs-lookup"><span data-stu-id="92322-129">If your application needs random access into the vertex buffer in AGP memory, choose a vertex format size that is a multiple of 32 bytes.</span></span> <span data-ttu-id="92322-130">En caso contrario, seleccione el formato más pequeño adecuado.</span><span class="sxs-lookup"><span data-stu-id="92322-130">Otherwise, select the smallest appropriate format.</span></span>
-   <span data-ttu-id="92322-131">Dibuje utilizando primitivos indizados.</span><span class="sxs-lookup"><span data-stu-id="92322-131">Draw using indexed primitives.</span></span> <span data-ttu-id="92322-132">Esto puede permitir un almacenamiento en caché de vértices más eficaz en el hardware.</span><span class="sxs-lookup"><span data-stu-id="92322-132">This can allow for more efficient vertex caching within hardware.</span></span>
-   <span data-ttu-id="92322-133">Si el formato de búfer de profundidad contiene un canal de estarcido, borre siempre los canales de profundidad y estarcido al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="92322-133">If the depth buffer format contains a stencil channel, always clear the depth and stencil channels at the same time.</span></span>
-   <span data-ttu-id="92322-134">Combine la instrucción del sombreador y la salida de datos siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="92322-134">Combine the shader instruction and the data output where possible.</span></span> <span data-ttu-id="92322-135">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="92322-135">For example:</span></span>
    ```
    // Rather than doing a multiply and add, and then output the data with 
    //   two instructions:
    mad r2, r1, v0, c0
    mov oD0, r2

    // Combine both in a single instruction, because this eliminates an  
    //   additional register copy.
    mad oD0, r1, v0, c0 
    ```

    

## <a name="databases-and-culling"></a><span data-ttu-id="92322-136">Bases de datos y selección</span><span class="sxs-lookup"><span data-stu-id="92322-136">Databases and Culling</span></span>

<span data-ttu-id="92322-137">Crear una base de datos confiable de los objetos de su mundo es clave para un rendimiento excelente en Direct3D.</span><span class="sxs-lookup"><span data-stu-id="92322-137">Building a reliable database of the objects in your world is key to excellent performance in Direct3D.</span></span> <span data-ttu-id="92322-138">Es más importante que las mejoras en la rasterización o el hardware.</span><span class="sxs-lookup"><span data-stu-id="92322-138">It is more important than improvements to rasterization or hardware.</span></span>

<span data-ttu-id="92322-139">Debe mantener el número de polígonos más bajo que puede administrar.</span><span class="sxs-lookup"><span data-stu-id="92322-139">You should maintain the lowest polygon count you can possibly manage.</span></span> <span data-ttu-id="92322-140">Diseño para un número de polígonos bajos mediante la creación de modelos de poco polígono desde el principio.</span><span class="sxs-lookup"><span data-stu-id="92322-140">Design for a low polygon count by building low-polygon models from the start.</span></span> <span data-ttu-id="92322-141">Agregue polígonos si puede hacerlo sin sacrificar el rendimiento más adelante en el proceso de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="92322-141">Add polygons if you can do so without sacrificing performance later in the development process.</span></span> <span data-ttu-id="92322-142">Recuerde que los polígonos más rápidos son los que no dibuja.</span><span class="sxs-lookup"><span data-stu-id="92322-142">Remember, the fastest polygons are the ones you don't draw.</span></span>

## <a name="batching-primitives"></a><span data-ttu-id="92322-143">Procesamiento por lotes de primitivas</span><span class="sxs-lookup"><span data-stu-id="92322-143">Batching Primitives</span></span>

<span data-ttu-id="92322-144">Para obtener el mejor rendimiento de representación durante la ejecución, intente trabajar con primitivas en lotes y mantenga el número de cambios de estado de representación lo más bajo posible.</span><span class="sxs-lookup"><span data-stu-id="92322-144">To get the best rendering performance during execution, try to work with primitives in batches and keep the number of render-state changes as low as possible.</span></span> <span data-ttu-id="92322-145">Por ejemplo, si tiene un objeto con dos texturas, agrupe los triángulos que usan la primera textura y siga con el estado de representación necesario para cambiar la textura.</span><span class="sxs-lookup"><span data-stu-id="92322-145">For example, if you have an object with two textures, group the triangles that use the first texture and follow them with the necessary render state to change the texture.</span></span> <span data-ttu-id="92322-146">A continuación, agrupe todos los triángulos que usan la segunda textura.</span><span class="sxs-lookup"><span data-stu-id="92322-146">Then group all the triangles that use the second texture.</span></span> <span data-ttu-id="92322-147">La compatibilidad de hardware más sencilla con Direct3D se llama con lotes de Estados de representación y lotes de primitivas a través de la capa de abstracción de hardware (HAL).</span><span class="sxs-lookup"><span data-stu-id="92322-147">The simplest hardware support for Direct3D is called with batches of render states and batches of primitives through the hardware abstraction layer (HAL).</span></span> <span data-ttu-id="92322-148">Cuanto más eficaz es el procesamiento por lotes de las instrucciones, se realizan menos llamadas a HAL durante la ejecución.</span><span class="sxs-lookup"><span data-stu-id="92322-148">The more effectively the instructions are batched, the fewer HAL calls are performed during execution.</span></span>

## <a name="lighting-tips"></a><span data-ttu-id="92322-149">Sugerencias de iluminación</span><span class="sxs-lookup"><span data-stu-id="92322-149">Lighting Tips</span></span>

<span data-ttu-id="92322-150">Dado que las luces agregan un costo por vértice a cada fotograma representado, puede mejorar significativamente el rendimiento si tiene cuidado al usarlos en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="92322-150">Because lights add a per-vertex cost to each rendered frame, you can improve performance significantly by being careful about how you use them in your application.</span></span> <span data-ttu-id="92322-151">La mayoría de las siguientes sugerencias se derivan de la maximización, "el código más rápido es código al que nunca se llama".</span><span class="sxs-lookup"><span data-stu-id="92322-151">Most of the following tips derive from the maxim, "the fastest code is code that is never called."</span></span>

-   <span data-ttu-id="92322-152">Use el menor número posible de fuentes de luz.</span><span class="sxs-lookup"><span data-stu-id="92322-152">Use as few light sources as possible.</span></span> <span data-ttu-id="92322-153">Para aumentar el nivel de iluminación general, por ejemplo, use la luz ambiente en lugar de agregar una nueva fuente de luz.</span><span class="sxs-lookup"><span data-stu-id="92322-153">To increase the overall lighting level, for example, use the ambient light instead of adding a new light source.</span></span>
-   <span data-ttu-id="92322-154">Las luces direccionales son más eficaces que las luces de punto o los focos.</span><span class="sxs-lookup"><span data-stu-id="92322-154">Directional lights are more efficient than point lights or spotlights.</span></span> <span data-ttu-id="92322-155">En el caso de las luces direccionales, la dirección de la luz es fija y no tiene que calcularse por vértices.</span><span class="sxs-lookup"><span data-stu-id="92322-155">For directional lights, the direction to the light is fixed and doesn't need to be calculated on a per-vertex basis.</span></span>
-   <span data-ttu-id="92322-156">Los focos pueden ser más eficaces que las luces puntuales, ya que el área fuera del cono de luz se calcula rápidamente.</span><span class="sxs-lookup"><span data-stu-id="92322-156">Spotlights can be more efficient than point lights, because the area outside the cone of light is calculated quickly.</span></span> <span data-ttu-id="92322-157">Si los focos son más eficientes o no dependen de la cantidad de la escena que está iluminada por el foco.</span><span class="sxs-lookup"><span data-stu-id="92322-157">Whether spotlights are more efficient or not depends on how much of your scene is lit by the spotlight.</span></span>
-   <span data-ttu-id="92322-158">Use el parámetro de intervalo para limitar las luces a las partes de la escena que debe iluminar.</span><span class="sxs-lookup"><span data-stu-id="92322-158">Use the range parameter to limit your lights to only the parts of the scene you need to illuminate.</span></span> <span data-ttu-id="92322-159">Todos los tipos de luz salen bastante pronto cuando están fuera del intervalo.</span><span class="sxs-lookup"><span data-stu-id="92322-159">All the light types exit fairly early when they are out of range.</span></span>
-   <span data-ttu-id="92322-160">Los reflejos especulares casi duplican el costo de una luz.</span><span class="sxs-lookup"><span data-stu-id="92322-160">Specular highlights almost double the cost of a light.</span></span> <span data-ttu-id="92322-161">Úselos solo cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="92322-161">Use them only when you must.</span></span> <span data-ttu-id="92322-162">Establezca el estado de representación de SPECULARENABLE de D3DRS \_ en 0, el valor predeterminado, siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="92322-162">Set the D3DRS\_SPECULARENABLE render state to 0, the default value, whenever possible.</span></span> <span data-ttu-id="92322-163">Al definir materiales, debe establecer el valor de potencia especular en cero para desactivar las iluminaciones especulares para ese material. simplemente establecer el color especular en 0, 0, 0 no es suficiente.</span><span class="sxs-lookup"><span data-stu-id="92322-163">When defining materials, you must set the specular power value to zero to turn off specular highlights for that material; just setting the specular color to 0,0,0 is not enough.</span></span>

## <a name="texture-size"></a><span data-ttu-id="92322-164">Tamaño de textura</span><span class="sxs-lookup"><span data-stu-id="92322-164">Texture Size</span></span>

<span data-ttu-id="92322-165">El rendimiento de la asignación de texturas depende en gran medida de la velocidad de la memoria.</span><span class="sxs-lookup"><span data-stu-id="92322-165">Texture-mapping performance is heavily dependent on the speed of memory.</span></span> <span data-ttu-id="92322-166">Hay varias maneras de maximizar el rendimiento de la memoria caché de las texturas de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="92322-166">There are a number of ways to maximize the cache performance of your application's textures.</span></span>

-   <span data-ttu-id="92322-167">Mantenga las texturas reducidas.</span><span class="sxs-lookup"><span data-stu-id="92322-167">Keep the textures small.</span></span> <span data-ttu-id="92322-168">Cuanto más pequeñas sean las texturas, más posibilidades tendrán de mantenerse en la caché secundaria de la CPU principal.</span><span class="sxs-lookup"><span data-stu-id="92322-168">The smaller the textures are, the better chance they have of being maintained in the main CPU's secondary cache.</span></span>
-   <span data-ttu-id="92322-169">No cambie las texturas por primitivos.</span><span class="sxs-lookup"><span data-stu-id="92322-169">Do not change the textures on a per-primitive basis.</span></span> <span data-ttu-id="92322-170">Intente mantener los polígonos agrupados por orden de las texturas que usan.</span><span class="sxs-lookup"><span data-stu-id="92322-170">Try to keep polygons grouped in order of the textures they use.</span></span>
-   <span data-ttu-id="92322-171">Utilice texturas cuadradas siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="92322-171">Use square textures whenever possible.</span></span> <span data-ttu-id="92322-172">Las texturas cuyas dimensiones son 256x256 son las más rápidas.</span><span class="sxs-lookup"><span data-stu-id="92322-172">Textures whose dimensions are 256x256 are the fastest.</span></span> <span data-ttu-id="92322-173">Si la aplicación usa cuatro texturas de 128x128, por ejemplo, intente asegurarse de que usan la misma paleta y colocarlas en una sola textura de 256x256.</span><span class="sxs-lookup"><span data-stu-id="92322-173">If your application uses four 128x128 textures, for example, try to ensure that they use the same palette and place them all into one 256x256 texture.</span></span> <span data-ttu-id="92322-174">Esta técnica también reduce la cantidad de intercambio de textura.</span><span class="sxs-lookup"><span data-stu-id="92322-174">This technique also reduces the amount of texture swapping.</span></span> <span data-ttu-id="92322-175">Por supuesto, no debe utilizar texturas de 256x256 a menos que la aplicación requiera una gran texturización porque, como se mencionó, las texturas deben mantenerse lo más pequeñas posible.</span><span class="sxs-lookup"><span data-stu-id="92322-175">Of course, you should not use 256x256 textures unless your application requires that much texturing because, as mentioned, textures should be kept as small as possible.</span></span>

## <a name="matrix-transforms"></a><span data-ttu-id="92322-176">Transformaciones de matriz</span><span class="sxs-lookup"><span data-stu-id="92322-176">Matrix Transforms</span></span>

<span data-ttu-id="92322-177">Direct3D usa el mundo y las matrices de vistas que se establecen para configurar varias estructuras de datos internas.</span><span class="sxs-lookup"><span data-stu-id="92322-177">Direct3D uses the world and view matrices that you set to configure several internal data structures.</span></span> <span data-ttu-id="92322-178">Cada vez que se establece un nuevo mundo o una matriz de vistas, el sistema vuelve a calcular las estructuras internas asociadas.</span><span class="sxs-lookup"><span data-stu-id="92322-178">Each time you set a new world or view matrix, the system recalculates the associated internal structures.</span></span> <span data-ttu-id="92322-179">Establecer estas matrices con frecuencia (por ejemplo, miles de veces por fotograma) es un proceso que consume mucho tiempo.</span><span class="sxs-lookup"><span data-stu-id="92322-179">Setting these matrices frequently - for example, thousands of times per frame - is computationally time-consuming.</span></span> <span data-ttu-id="92322-180">Puede minimizar el número de cálculos necesarios concatenando el mundo y ver las matrices en una matriz de vista mundial que establezca como la matriz universal y, a continuación, estableciendo la matriz de la vista en la identidad.</span><span class="sxs-lookup"><span data-stu-id="92322-180">You can minimize the number of required calculations by concatenating your world and view matrices into a world-view matrix that you set as the world matrix, and then setting the view matrix to the identity.</span></span> <span data-ttu-id="92322-181">Mantenga copias en caché de matrices de todo el mundo y vistas para que pueda modificar, concatenar y restablecer la matriz universal según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="92322-181">Keep cached copies of individual world and view matrices so that you can modify, concatenate, and reset the world matrix as needed.</span></span> <span data-ttu-id="92322-182">Para mayor claridad en esta documentación, los ejemplos de Direct3D raramente emplean esta optimización.</span><span class="sxs-lookup"><span data-stu-id="92322-182">For clarity in this documentation, Direct3D samples rarely employ this optimization.</span></span>

## <a name="using-dynamic-textures"></a><span data-ttu-id="92322-183">Usar texturas dinámicas</span><span class="sxs-lookup"><span data-stu-id="92322-183">Using Dynamic Textures</span></span>

<span data-ttu-id="92322-184">Para averiguar si el controlador admite texturas dinámicas, Compruebe la \_ marca de D3DCAPS2 DYNAMICTEXTURES de la estructura [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) .</span><span class="sxs-lookup"><span data-stu-id="92322-184">To find out if the driver supports dynamic textures, check the D3DCAPS2\_DYNAMICTEXTURES flag of the [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) structure.</span></span>

<span data-ttu-id="92322-185">Tenga en cuenta lo siguiente al trabajar con texturas dinámicas.</span><span class="sxs-lookup"><span data-stu-id="92322-185">Keep the following things in mind when working with dynamic textures.</span></span>

-   <span data-ttu-id="92322-186">No se pueden administrar.</span><span class="sxs-lookup"><span data-stu-id="92322-186">They cannot be managed.</span></span> <span data-ttu-id="92322-187">Por ejemplo, el grupo no se puede \_ administrar D3DPOOL.</span><span class="sxs-lookup"><span data-stu-id="92322-187">For example, their pool cannot be D3DPOOL\_MANAGED.</span></span>
-   <span data-ttu-id="92322-188">Las texturas dinámicas se pueden bloquear, incluso si se crean en el \_ valor predeterminado de D3DPOOL.</span><span class="sxs-lookup"><span data-stu-id="92322-188">Dynamic textures can be locked, even if they are created in D3DPOOL\_DEFAULT.</span></span>
-   <span data-ttu-id="92322-189">D3DLOCK \_ discard es una marca de bloqueo válida para las texturas dinámicas.</span><span class="sxs-lookup"><span data-stu-id="92322-189">D3DLOCK\_DISCARD is a valid lock flag for dynamic textures.</span></span>

<span data-ttu-id="92322-190">Es aconsejable crear solo una textura dinámica por formato y, posiblemente, por tamaño.</span><span class="sxs-lookup"><span data-stu-id="92322-190">It is a good idea to create only one dynamic texture per format and possibly per size.</span></span> <span data-ttu-id="92322-191">No se recomiendan los mapas MIP, los cubos y los volúmenes dinámicos debido a la sobrecarga adicional en el bloqueo de todos los niveles.</span><span class="sxs-lookup"><span data-stu-id="92322-191">Dynamic mipmaps, cubes, and volumes are not recommended because of the additional overhead in locking every level.</span></span> <span data-ttu-id="92322-192">En el caso de los mapas MIP, D3DLOCK \_ solo se permite en el nivel superior.</span><span class="sxs-lookup"><span data-stu-id="92322-192">For mipmaps, D3DLOCK\_DISCARD is allowed only on the top level.</span></span> <span data-ttu-id="92322-193">Todos los niveles se descartan bloqueando solo el nivel superior.</span><span class="sxs-lookup"><span data-stu-id="92322-193">All levels are discarded by locking just the top level.</span></span> <span data-ttu-id="92322-194">Este comportamiento es el mismo para los volúmenes y los cubos.</span><span class="sxs-lookup"><span data-stu-id="92322-194">This behavior is the same for volumes and cubes.</span></span> <span data-ttu-id="92322-195">En el caso de los cubos, el nivel superior y la esfera 0 están bloqueados.</span><span class="sxs-lookup"><span data-stu-id="92322-195">For cubes, the top level and face 0 are locked.</span></span>

<span data-ttu-id="92322-196">En el siguiente pseudocódigo se muestra un ejemplo del uso de una textura dinámica.</span><span class="sxs-lookup"><span data-stu-id="92322-196">The following pseudocode shows an example of using a dynamic texture.</span></span>


```
DrawProceduralTexture(pTex)
{
    // pTex should not be very small because overhead of 
    //   calling driver every D3DLOCK_DISCARD will not 
    //   justify the performance gain. Experimentation is encouraged.
    pTex->Lock(D3DLOCK_DISCARD);
    <Overwrite *entire* texture>
    pTex->Unlock();
    pDev->SetTexture();
    pDev->DrawPrimitive();
}
```



## <a name="using-dynamic-vertex-and-index-buffers"></a><span data-ttu-id="92322-197">Usar búferes dinámicos de vértices y de índices</span><span class="sxs-lookup"><span data-stu-id="92322-197">Using Dynamic Vertex and Index Buffers</span></span>

<span data-ttu-id="92322-198">Bloquear un búfer de vértices estático mientras el procesador de gráficos usa el búfer puede tener una penalización significativa del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="92322-198">Locking a static vertex buffer while the graphics processor is using the buffer can have a significant performance penalty.</span></span> <span data-ttu-id="92322-199">La llamada de bloqueo debe esperar hasta que el procesador de gráficos termine de leer los datos de vértices o índices del búfer antes de poder volver a la aplicación que realiza la llamada, un retraso significativo.</span><span class="sxs-lookup"><span data-stu-id="92322-199">The lock call must wait until the graphics processor is finished reading vertex or index data from the buffer before it can return to the calling application, a significant delay.</span></span> <span data-ttu-id="92322-200">El bloqueo y la representación de un búfer estático varias veces por fotograma también impide que el procesador de gráficos almacene en búfer comandos de representación, ya que debe finalizar los comandos antes de devolver el puntero de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="92322-200">Locking and then rendering from a static buffer several times per frame also prevents the graphics processor from buffering rendering commands, since it must finish commands before returning the lock pointer.</span></span> <span data-ttu-id="92322-201">Sin comandos almacenados en búfer, el procesador de gráficos permanece inactivo hasta que la aplicación termina de llenar el búfer de vértices o el búfer de índice y emite un comando de representación.</span><span class="sxs-lookup"><span data-stu-id="92322-201">Without buffered commands, the graphics processor remains idle until after the application is finished filling the vertex buffer or index buffer and issues a rendering command.</span></span>

<span data-ttu-id="92322-202">Idealmente, los datos de vértices o índices nunca cambiarían, pero esto no siempre es posible.</span><span class="sxs-lookup"><span data-stu-id="92322-202">Ideally the vertex or index data would never change, however this is not always possible.</span></span> <span data-ttu-id="92322-203">Hay muchas situaciones en las que la aplicación necesita cambiar los datos de vértices o índices en cada fotograma, quizás incluso varias veces por fotograma.</span><span class="sxs-lookup"><span data-stu-id="92322-203">There are many situations where the application needs to change vertex or index data every frame, perhaps even multiple times per frame.</span></span> <span data-ttu-id="92322-204">En estas situaciones, se debe crear el búfer de vértice o de índice con D3DUSAGE \_ Dynamic.</span><span class="sxs-lookup"><span data-stu-id="92322-204">For these situations, the vertex or index buffer should be created with D3DUSAGE\_DYNAMIC.</span></span> <span data-ttu-id="92322-205">Esta marca de uso hace que Direct3D optimice las operaciones frecuentes de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="92322-205">This usage flag causes Direct3D to optimize for frequent lock operations.</span></span> <span data-ttu-id="92322-206">D3DUSAGE \_ Dynamic solo es útil cuando el búfer se bloquea con frecuencia; los datos que permanecen constantes deben colocarse en un vértice o en un búfer de índice estático.</span><span class="sxs-lookup"><span data-stu-id="92322-206">D3DUSAGE\_DYNAMIC is only useful when the buffer is locked frequently; data that remains constant should be placed in a static vertex or index buffer.</span></span>

<span data-ttu-id="92322-207">Para obtener una mejora del rendimiento cuando se usan búferes de vértices dinámicos, la aplicación debe llamar a [**IDirect3DVertexBuffer9:: Lock**](/windows/desktop/api) o [**IDirect3DIndexBuffer9:: Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) con las marcas adecuadas.</span><span class="sxs-lookup"><span data-stu-id="92322-207">To receive a performance improvement when using dynamic vertex buffers, the application must call [**IDirect3DVertexBuffer9::Lock**](/windows/desktop/api) or [**IDirect3DIndexBuffer9::Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) with the appropriate flags.</span></span> <span data-ttu-id="92322-208">D3DLOCK \_ discard indica que la aplicación no necesita mantener los datos de índice o vértice antiguos en el búfer.</span><span class="sxs-lookup"><span data-stu-id="92322-208">D3DLOCK\_DISCARD indicates that the application does not need to keep the old vertex or index data in the buffer.</span></span> <span data-ttu-id="92322-209">Si el procesador de gráficos sigue usando el búfer cuando se llama a Lock con D3DLOCK \_ discard, se devuelve un puntero a una nueva región de memoria en lugar de los datos de búfer antiguos.</span><span class="sxs-lookup"><span data-stu-id="92322-209">If the graphics processor is still using the buffer when lock is called with D3DLOCK\_DISCARD, a pointer to a new region of memory is returned instead of the old buffer data.</span></span> <span data-ttu-id="92322-210">Esto permite que el procesador de gráficos siga usando los datos antiguos mientras la aplicación coloca los datos en el nuevo búfer.</span><span class="sxs-lookup"><span data-stu-id="92322-210">This allows the graphics processor to continue using the old data while the application places data in the new buffer.</span></span> <span data-ttu-id="92322-211">No se requiere ninguna administración de memoria adicional en la aplicación; el búfer antiguo se reutiliza o se destruye automáticamente cuando el procesador de gráficos finaliza con él.</span><span class="sxs-lookup"><span data-stu-id="92322-211">No additional memory management is required in the application; the old buffer is reused or destroyed automatically when the graphics processor is finished with it.</span></span> <span data-ttu-id="92322-212">Tenga en cuenta que el bloqueo de un búfer con D3DLOCK discard \_ siempre descarta todo el búfer, especificando un desplazamiento distinto de cero o un campo de tamaño limitado no conserva la información en las áreas desbloqueadas del búfer.</span><span class="sxs-lookup"><span data-stu-id="92322-212">Note that locking a buffer with D3DLOCK\_DISCARD always discards the entire buffer, specifying a nonzero offset or limited size field does not preserve information in unlocked areas of the buffer.</span></span>

<span data-ttu-id="92322-213">Hay casos en los que la cantidad de datos que la aplicación necesita almacenar por bloqueo es pequeña, como agregar cuatro vértices para representar un Sprite.</span><span class="sxs-lookup"><span data-stu-id="92322-213">There are cases where the amount of data the application needs to store per lock is small, such as adding four vertices to render a sprite.</span></span> <span data-ttu-id="92322-214">D3DLOCK \_ NOOVERWRITE indica que la aplicación no sobrescribirá los datos que ya se estén usando en el búfer dinámico.</span><span class="sxs-lookup"><span data-stu-id="92322-214">D3DLOCK\_NOOVERWRITE indicates that the application will not overwrite data already in use in the dynamic buffer.</span></span> <span data-ttu-id="92322-215">La llamada de bloqueo devolverá un puntero a los datos antiguos, lo que permite a la aplicación agregar nuevos datos en regiones no utilizadas del búfer de vértice o de índice.</span><span class="sxs-lookup"><span data-stu-id="92322-215">The lock call will return a pointer to the old data, allowing the application to add new data in unused regions of the vertex or index buffer.</span></span> <span data-ttu-id="92322-216">La aplicación no debe modificar los vértices ni los índices usados en una operación de dibujo, ya que el procesador de gráficos aún podría usarlos.</span><span class="sxs-lookup"><span data-stu-id="92322-216">The application should not modify vertices or indices used in a draw operation as they might still be in use by the graphics processor.</span></span> <span data-ttu-id="92322-217">A continuación, la aplicación debe usar D3DLOCK \_ discard después de que el búfer dinámico esté lleno para recibir una nueva región de memoria, descartando los datos de vértice o de vértice antiguos una vez finalizado el procesador de gráficos.</span><span class="sxs-lookup"><span data-stu-id="92322-217">The application should then use D3DLOCK\_DISCARD after the dynamic buffer is full to receive a new region of memory, discarding the old vertex or index data after the graphics processor is finished.</span></span>

<span data-ttu-id="92322-218">El mecanismo de consulta asincrónico es útil para determinar si el procesador de gráficos sigue usando los vértices.</span><span class="sxs-lookup"><span data-stu-id="92322-218">The asynchronous query mechanism is useful to determine if vertices are still in use by the graphics processor.</span></span> <span data-ttu-id="92322-219">Emita una consulta de tipo D3DQUERYTYPE \_ Event después de la última llamada a DrawPrimitive que usa los vértices.</span><span class="sxs-lookup"><span data-stu-id="92322-219">Issue a query of type D3DQUERYTYPE\_EVENT after the last DrawPrimitive call that uses the vertices.</span></span> <span data-ttu-id="92322-220">Los vértices ya no se usan cuando [**IDirect3DQuery9:: GetData**](/windows/desktop/api) devuelve S \_ correctos.</span><span class="sxs-lookup"><span data-stu-id="92322-220">The vertices are no longer in use when [**IDirect3DQuery9::GetData**](/windows/desktop/api) returns S\_OK.</span></span> <span data-ttu-id="92322-221">Si se bloquea un búfer con D3DLOCK \_ discard o ninguna marca, siempre se garantiza que los vértices estén sincronizados correctamente con el procesador de gráficos; sin embargo, el uso de Lock sin marcas incurrirá en la penalización del rendimiento que se ha descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="92322-221">Locking a buffer with D3DLOCK\_DISCARD or no flags will always guarantee the vertices are synchronized properly with the graphics processor, however using lock without flags will incur the performance penalty described earlier.</span></span> <span data-ttu-id="92322-222">Otras llamadas API como [**IDirect3DDevice9:: BeginScene**](/windows/desktop/api), [**IDirect3DDevice9:: EndScene**](/windows/desktop/api)y [**IDirect3DDevice9::P reenviados**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) no garantizan que el procesador de gráficos termine de usar los vértices.</span><span class="sxs-lookup"><span data-stu-id="92322-222">Other API calls such as [**IDirect3DDevice9::BeginScene**](/windows/desktop/api), [**IDirect3DDevice9::EndScene**](/windows/desktop/api), and [**IDirect3DDevice9::Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) do not guarantee the graphics processor is finished using vertices.</span></span>

<span data-ttu-id="92322-223">A continuación se muestran las formas de usar búferes dinámicos y las marcas de bloqueo apropiadas.</span><span class="sxs-lookup"><span data-stu-id="92322-223">Below are ways to use dynamic buffers and the proper lock flags.</span></span>


```
    // USAGE STYLE 1
    // Discard the entire vertex buffer and refill with thousands of vertices.
    // Might contain multiple objects and/or require multiple DrawPrimitive 
    //   calls separated by state changes, etc.
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // Discard and refill the used portion of the vertex buffer.
    CONST DWORD dwLockFlags = D3DLOCK_DISCARD;
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( 0, 0, &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, nNumberOfVertices/3)
```




```
    // USAGE STYLE 2
    // Reusing one vertex buffer for multiple objects
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // No overwrite will be used if the vertices can fit into 
    //   the space remaining in the vertex buffer.
    DWORD dwLockFlags = D3DLOCK_NOOVERWRITE;
    
    // Check to see if the entire vertex buffer has been used up yet.
    if( m_nNextVertexData > m_nSizeOfVB - nSizeOfData )
    {
        // No space remains. Start over from the beginning 
        //   of the vertex buffer.
        dwLockFlags = D3DLOCK_DISCARD;
        m_nNextVertexData = 0;
    }
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( (UINT)m_nNextVertexData, nSizeOfData, 
               &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 
               m_nNextVertexData/m_nVertexStride, nNumberOfVertices/3)
 
    // Advance to the next position in the vertex buffer.
    m_nNextVertexData += nSizeOfData;
```



## <a name="using-meshes"></a><span data-ttu-id="92322-224">Usar mallas</span><span class="sxs-lookup"><span data-stu-id="92322-224">Using Meshes</span></span>

<span data-ttu-id="92322-225">Puede optimizar las mallas mediante triángulos indizados de Direct3D en lugar de bandas triangulares indizadas.</span><span class="sxs-lookup"><span data-stu-id="92322-225">You can optimize meshes by using Direct3D indexed triangles instead of indexed triangle strips.</span></span> <span data-ttu-id="92322-226">El hardware detectará que el 95 por ciento de triángulos sucesivos forman tiras y se ajustan en consecuencia.</span><span class="sxs-lookup"><span data-stu-id="92322-226">The hardware will discover that 95 percent of successive triangles actually form strips and adjust accordingly.</span></span> <span data-ttu-id="92322-227">Muchos controladores lo hacen también para hardware más antiguo.</span><span class="sxs-lookup"><span data-stu-id="92322-227">Many drivers do this for older hardware also.</span></span>

<span data-ttu-id="92322-228">Los objetos de malla de D3DX pueden tener cada triángulo, o una esfera, etiquetada con un valor DWORD, denominado el atributo de esa superficie.</span><span class="sxs-lookup"><span data-stu-id="92322-228">D3DX mesh objects can have each triangle, or face, tagged with a DWORD, called the attribute of that face.</span></span> <span data-ttu-id="92322-229">La semántica del valor DWORD es definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="92322-229">The semantics of the DWORD are user-defined.</span></span> <span data-ttu-id="92322-230">D3DX los usa para clasificar la malla en subconjuntos.</span><span class="sxs-lookup"><span data-stu-id="92322-230">They are used by D3DX to classify the mesh into subsets.</span></span> <span data-ttu-id="92322-231">La aplicación establece atributos por caras mediante la llamada a [**ID3DXMesh:: LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) .</span><span class="sxs-lookup"><span data-stu-id="92322-231">The application sets per-face attributes using the [**ID3DXMesh::LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) call.</span></span> <span data-ttu-id="92322-232">El método [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md) tiene una opción para agrupar los vértices de malla y las caras en atributos mediante la opción D3DXMESHOPT de \_ ATTRSORT.</span><span class="sxs-lookup"><span data-stu-id="92322-232">The [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) method has an option to group the mesh vertices and faces on attributes using the D3DXMESHOPT\_ATTRSORT option.</span></span> <span data-ttu-id="92322-233">Cuando se hace esto, el objeto de malla calcula una tabla de atributos que la aplicación puede obtener llamando a [**ID3DXBaseMesh:: GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span><span class="sxs-lookup"><span data-stu-id="92322-233">When this is done, the mesh object calculates an attribute table that can be obtained by the application by calling [**ID3DXBaseMesh::GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span></span> <span data-ttu-id="92322-234">Esta llamada devuelve 0 si la malla no está ordenada por atributos.</span><span class="sxs-lookup"><span data-stu-id="92322-234">This call returns 0 if the mesh is not sorted by attributes.</span></span> <span data-ttu-id="92322-235">No hay ninguna manera de que una aplicación establezca una tabla de atributos porque se genera mediante el método **ID3DXMesh:: Optimize** .</span><span class="sxs-lookup"><span data-stu-id="92322-235">There is no way for an application to set an attribute table because it is generated by the **ID3DXMesh::Optimize** method.</span></span> <span data-ttu-id="92322-236">El orden de los atributos distingue los datos, por lo que si la aplicación sabe que una malla está ordenada por atributos, sigue siendo necesario llamar a **ID3DXMesh:: Optimize** para generar la tabla de atributos.</span><span class="sxs-lookup"><span data-stu-id="92322-236">The attribute sort is data sensitive, so if the application knows that a mesh is attribute sorted, it still needs to call **ID3DXMesh::Optimize** to generate the attribute table.</span></span>

<span data-ttu-id="92322-237">En los temas siguientes se describen los distintos atributos de una malla.</span><span class="sxs-lookup"><span data-stu-id="92322-237">The following topics describe the different attributes of a mesh.</span></span>

### <a name="attribute-id"></a><span data-ttu-id="92322-238">IDENTIFICADOR de atributo</span><span class="sxs-lookup"><span data-stu-id="92322-238">Attribute ID</span></span>

<span data-ttu-id="92322-239">Un identificador de atributo es un valor que asocia un grupo de caras con un grupo de atributos.</span><span class="sxs-lookup"><span data-stu-id="92322-239">An attribute id is a value that associates a group of faces with an attribute group.</span></span> <span data-ttu-id="92322-240">Este identificador describe el subconjunto de caras [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) debe dibujar.</span><span class="sxs-lookup"><span data-stu-id="92322-240">This id describes which subset of faces [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) should draw.</span></span> <span data-ttu-id="92322-241">Los identificadores de atributo se especifican para las caras en el búfer de atributo.</span><span class="sxs-lookup"><span data-stu-id="92322-241">Attribute ids are specified for the faces in the attribute buffer.</span></span> <span data-ttu-id="92322-242">Los valores reales de los identificadores de atributo pueden ser cualquier cosa que quepa en 32 bits, pero es habitual usar de 0 a n, donde n es el número de atributos.</span><span class="sxs-lookup"><span data-stu-id="92322-242">The actual values of the attribute ids can be anything that fits in 32 bits, but it is common to use 0 to n where n is the number of attributes.</span></span>

### <a name="attribute-buffer"></a><span data-ttu-id="92322-243">Búfer de atributo</span><span class="sxs-lookup"><span data-stu-id="92322-243">Attribute Buffer</span></span>

<span data-ttu-id="92322-244">El búfer de atributo es una matriz de DWORDs (uno por cada tipo) que especifica a qué grupo de atributos pertenece cada una de ellas.</span><span class="sxs-lookup"><span data-stu-id="92322-244">The attribute buffer is an array of DWORDs (one per face) that specifies which attribute group each face belongs in.</span></span> <span data-ttu-id="92322-245">Este búfer se inicializa en cero en la creación de una malla, pero se rellena con las rutinas de carga o debe ser rellenado por el usuario si se desea más de un atributo con el identificador 0.</span><span class="sxs-lookup"><span data-stu-id="92322-245">This buffer is initialized to zero on creation of a mesh, but is either filled by the load routines or must be filled by the user if more than one attribute with id 0 is desired.</span></span> <span data-ttu-id="92322-246">Este búfer contiene la información que se usa para ordenar la malla en función de los atributos de [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md).</span><span class="sxs-lookup"><span data-stu-id="92322-246">This buffer contains the information that is used to sort the mesh based on attributes in [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md).</span></span> <span data-ttu-id="92322-247">Si no hay ninguna tabla de atributos, [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) examina este búfer para seleccionar las caras del atributo especificado que se van a dibujar.</span><span class="sxs-lookup"><span data-stu-id="92322-247">If no attribute table is present, [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) scans this buffer to select the faces of the given attribute to draw.</span></span>

### <a name="attribute-table"></a><span data-ttu-id="92322-248">Tabla de atributos</span><span class="sxs-lookup"><span data-stu-id="92322-248">Attribute Table</span></span>

<span data-ttu-id="92322-249">La tabla de atributos es una estructura que posee y mantiene la malla.</span><span class="sxs-lookup"><span data-stu-id="92322-249">The attribute table is a structure owned and maintained by the mesh.</span></span> <span data-ttu-id="92322-250">La única manera de generar una es mediante una llamada a [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md) con ordenación de atributos o una optimización más segura habilitada.</span><span class="sxs-lookup"><span data-stu-id="92322-250">The only way for one to be generated is by calling [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) with attribute sorting or stronger optimization enabled.</span></span> <span data-ttu-id="92322-251">La tabla de atributos se usa para iniciar rápidamente una única llamada primitiva de Draw a [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md).</span><span class="sxs-lookup"><span data-stu-id="92322-251">The attribute table is used to quickly initiate a single draw primitive call to [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md).</span></span> <span data-ttu-id="92322-252">El único otro uso es que el progreso de las mallas también mantiene esta estructura, por lo que es posible ver qué caras y vértices están activos en el nivel de detalle actual.</span><span class="sxs-lookup"><span data-stu-id="92322-252">The only other use is that progressing meshes also maintain this structure, so it is possible to see what faces and vertices are active at the current level of detail.</span></span>

## <a name="z-buffer-performance"></a><span data-ttu-id="92322-253">Rendimiento del búfer Z</span><span class="sxs-lookup"><span data-stu-id="92322-253">Z-Buffer Performance</span></span>

<span data-ttu-id="92322-254">Las aplicaciones pueden aumentar el rendimiento cuando se usa el almacenamiento en búfer z y el uso de texturas asegurándose de que las escenas se representan de delante a atrás.</span><span class="sxs-lookup"><span data-stu-id="92322-254">Applications can increase performance when using z-buffering and texturing by ensuring that scenes are rendered from front to back.</span></span> <span data-ttu-id="92322-255">Las primitivas almacenadas en búfer de z con textura se comprueban en el búfer z en función de la línea de exploración.</span><span class="sxs-lookup"><span data-stu-id="92322-255">Textured z-buffered primitives are pretested against the z-buffer on a scan line basis.</span></span> <span data-ttu-id="92322-256">Si un polígono representado previamente oculta una línea de exploración, el sistema la rechaza de forma rápida y eficaz.</span><span class="sxs-lookup"><span data-stu-id="92322-256">If a scan line is hidden by a previously rendered polygon, the system rejects it quickly and efficiently.</span></span> <span data-ttu-id="92322-257">El almacenamiento en búfer Z puede mejorar el rendimiento, pero la técnica es más útil cuando una escena dibuja los mismos píxeles más de una vez.</span><span class="sxs-lookup"><span data-stu-id="92322-257">Z-buffering can improve performance, but the technique is most useful when a scene draws the same pixels more than once.</span></span> <span data-ttu-id="92322-258">Esto es difícil de calcular exactamente, pero a menudo puede hacer una aproximación aproximada.</span><span class="sxs-lookup"><span data-stu-id="92322-258">This is difficult to calculate exactly, but you can often make a close approximation.</span></span> <span data-ttu-id="92322-259">Si los mismos píxeles se dibujan menos de dos veces, puede lograr el mejor rendimiento si desactiva el almacenamiento en búfer z y representa la escena de vuelta al principio.</span><span class="sxs-lookup"><span data-stu-id="92322-259">If the same pixels are drawn less than twice, you can achieve the best performance by turning z-buffering off and rendering the scene from back to front.</span></span>

## <a name="related-topics"></a><span data-ttu-id="92322-260">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="92322-260">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="92322-261">Sugerencias de programación</span><span class="sxs-lookup"><span data-stu-id="92322-261">Programming Tips</span></span>](programming-tips.md)
</dt> </dl>

 

 
