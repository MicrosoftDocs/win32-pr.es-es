---
title: Barreras de UAV y barreras de estado de recursos en DirectML
description: Describe las ventajas de la corrección de barreras y cómo puede trabajar con ellas en DirectML.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: 9bfc93d4fb28cff5d7d196287c6573e3e494d1d5
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/23/2019
ms.locfileid: "104549119"
---
# <a name="uav-barriers-and-resource-state-barriers-in-directml"></a><span data-ttu-id="417e9-103">Barreras de UAV y barreras de estado de recursos en DirectML</span><span class="sxs-lookup"><span data-stu-id="417e9-103">UAV barriers and resource state barriers in DirectML</span></span>

## <a name="unordered-access-view-uav-barrier-requirements"></a><span data-ttu-id="417e9-104">Requisitos de barrera de la vista de acceso desordenado (UAV)</span><span class="sxs-lookup"><span data-stu-id="417e9-104">Unordered Access View (UAV) barrier requirements</span></span>

### <a name="uav-barriers-in-direct3d-12"></a><span data-ttu-id="417e9-105">Barreras UAV en Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="417e9-105">UAV barriers in Direct3D 12</span></span>

<span data-ttu-id="417e9-106">En Direct3D 12, las distribuciones adyacentes del sombreador de cálculo dentro de la misma lista de comandos tienen permiso para ejecutarse en paralelo en la GPU, a menos que estén sincronizadas con una barrera de vista de acceso no ordenada (UAV) que intervenga.</span><span class="sxs-lookup"><span data-stu-id="417e9-106">In Direct3D 12, adjacent compute shader dispatches within the same command list are permitted to execute in parallel on the GPU unless they're synchronized with an intervening unordered access view (UAV) barrier.</span></span> <span data-ttu-id="417e9-107">Esto puede mejorar el rendimiento al aumentar el uso del hardware de la GPU.</span><span class="sxs-lookup"><span data-stu-id="417e9-107">This can improve performance by increasing utilization of GPU hardware.</span></span> <span data-ttu-id="417e9-108">Sin embargo, de forma predeterminada, sin el uso de una barrera UAV, la ejecución en paralelo de dos distribuidores adyacentes puede producir una condición de carrera si existe una dependencia de datos entre los dos envíos; o bien, si ambos envíos realizan escrituras UAV en las mismas regiones de memoria.</span><span class="sxs-lookup"><span data-stu-id="417e9-108">However, by default, without the use of a UAV barrier, the parallel execution of two adjacent dispatches can cause a race condition if there exists a data dependency between the two dispatches; or if both dispatches perform UAV writes to the same regions of memory.</span></span>

<span data-ttu-id="417e9-109">Una barrera UAV obliga a que todas las distribuciones enviadas previamente completen ejecución en la GPU antes de que puedan comenzar los envíos posteriores.</span><span class="sxs-lookup"><span data-stu-id="417e9-109">A UAV barrier forces all previously-submitted dispatches to complete exection on the GPU before subsequent dispatches may begin.</span></span> <span data-ttu-id="417e9-110">Las barreras de UAV se usan para sincronizar los envíos en la misma lista de comandos para evitar carreras de datos.</span><span class="sxs-lookup"><span data-stu-id="417e9-110">UAV barriers are used to synchronize between dispatches on the same command list to avoid data races.</span></span> <span data-ttu-id="417e9-111">Puede emitir una barrera UAV mediante el [método **ID3D12GraphicsCommandList:: ResourceBarrier**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).</span><span class="sxs-lookup"><span data-stu-id="417e9-111">You can issue a UAV barrier by using the [**ID3D12GraphicsCommandList::ResourceBarrier** method](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).</span></span>

### <a name="uav-barriers-in-directml"></a><span data-ttu-id="417e9-112">Barreras de UAV en DirectML</span><span class="sxs-lookup"><span data-stu-id="417e9-112">UAV barriers in DirectML</span></span>

<span data-ttu-id="417e9-113">En DirectML, los operadores se envían de una manera similar a la forma en que se envían los sombreadores de cálculo en Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="417e9-113">In DirectML, operators are dispatched in a way that's similar to the way compute shaders are dispatched in Direct3D 12.</span></span> <span data-ttu-id="417e9-114">Es decir, se permite que se ejecuten en paralelo los envíos de operadores adyacentes en la GPU, a menos que exista una barrera UAV intermedia entre ellos.</span><span class="sxs-lookup"><span data-stu-id="417e9-114">That is, adjacent dispatches of operators are permitted to execute in parallel on the GPU unless there exists an intervening UAV barrier between them.</span></span> <span data-ttu-id="417e9-115">Un modelo de aprendizaje automático típico contiene dependencias de datos entre sus operadores; por ejemplo, la salida de un operador se alimenta en la entrada de otro.</span><span class="sxs-lookup"><span data-stu-id="417e9-115">A typical machine learning model contains data dependencies between its operators; for instance, the output of one operator feeds into the input of another.</span></span> <span data-ttu-id="417e9-116">Por lo tanto, es importante usar barreras UAV para sincronizar correctamente los envíos.</span><span class="sxs-lookup"><span data-stu-id="417e9-116">It's therefore important to use UAV barriers to correctly synchronize dispatches.</span></span>

<span data-ttu-id="417e9-117">DirectML garantiza que solo se leerán los datos de entrada (y nunca se escribirán).</span><span class="sxs-lookup"><span data-stu-id="417e9-117">DirectML guarantees that it will only ever read from (and never write to) input tensors.</span></span> <span data-ttu-id="417e9-118">También garantiza que nunca fabricará escrituras en un tensores de salida fuera del intervalo del miembro [**DML_BUFFER_TENSOR_DESC:: TotalTensorSizeInBytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) de la tensores.</span><span class="sxs-lookup"><span data-stu-id="417e9-118">It also guarantees that it will never manufacture writes to an output tensor outside the range of the tensor's [**DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) member.</span></span> <span data-ttu-id="417e9-119">Esto significa que se puede hacer referencia a las dependencias de datos entre los operadores de DirectML mirando solo en los enlaces de entrada y salida de un operador.</span><span class="sxs-lookup"><span data-stu-id="417e9-119">This means that data dependencies between operators in DirectML can be reasoned about by looking only at an operator's input and output bindings.</span></span>

<span data-ttu-id="417e9-120">Por ejemplo, estas garantías permiten enviar dos operadores que enlazan la misma región de un recurso como entrada, sin tener que emitir una barrera UAV intermedia.</span><span class="sxs-lookup"><span data-stu-id="417e9-120">For example, these guarantees allow you to dispatch two operators that bind the same region of a resource as an input, without having to issue an intervening UAV barrier.</span></span> <span data-ttu-id="417e9-121">Esto siempre es seguro porque DirectML nunca escribe en los datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="417e9-121">This is always safe because DirectML never writes to input tensors.</span></span> <span data-ttu-id="417e9-122">Otro ejemplo sería que siempre es seguro enlazar los decenas de dos operadores simultáneos al mismo recurso de Direct3D 12 (siempre y cuando sus decenas no se superpongan), ya que DirectML nunca escribe fuera de los límites de un tensores (tal y como se define en **DML_BUFFER_TENSOR_DESC:: TotalTensorSizeInBytes**) de tensores.</span><span class="sxs-lookup"><span data-stu-id="417e9-122">As another example, it's always safe to bind the output tensors of two concurrent operator dispatches to the same Direct3D 12 resource (so long as their tensors don't overlap), because DirectML never writes outside the bounds of a tensor (as defined by the tensor's **DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**).</span></span>

<span data-ttu-id="417e9-123">Como las barreras de UAV son una forma de sincronización, el uso innecesario de barreras de UAV puede afectar negativamente al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="417e9-123">As UAV barriers are a form of synchronization, unnecessary use of UAV barriers might negatively impact performance.</span></span> <span data-ttu-id="417e9-124">Por lo tanto, es mejor usar el número mínimo de barreras UAV necesarias para sincronizar correctamente los envíos dentro de una lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="417e9-124">Therefore, it's best for you to use the minimum number of UAV barriers necessary to correctly synchronize the dispatches within a command list.</span></span>

### <a name="example-1"></a><span data-ttu-id="417e9-125">Ejemplo 1</span><span class="sxs-lookup"><span data-stu-id="417e9-125">Example 1</span></span>

<span data-ttu-id="417e9-126">En el ejemplo siguiente, la salida del operador de circunvolución se introduce en una activación de ReLU, seguida de una normalización por lotes.</span><span class="sxs-lookup"><span data-stu-id="417e9-126">In the following example, a convolution operator's output is fed into a ReLU activation, followed by a batch normalization.</span></span>

```console
    CONVOLUTION (conv1)
         |
  ACTIVATION_RELU (relu1)
         |
BATCH_NORMALIZATION (batch1)
```

<span data-ttu-id="417e9-127">Dado que existe una dependencia de datos entre los tres operadores, necesitará una barrera UAV entre cada envío sucesivo (consulte [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span><span class="sxs-lookup"><span data-stu-id="417e9-127">Since a data dependency exists between all three operators, you'll need a UAV barrier between each successive dispatch (see [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span></span>

1. <span data-ttu-id="417e9-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
2. <span data-ttu-id="417e9-129">`d3d12CommandList->ResourceBarrier(`**Barrera UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-129">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="417e9-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span></span>
4. <span data-ttu-id="417e9-131">`d3d12CommandList->ResourceBarrier(`**Barrera UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-131">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
5. <span data-ttu-id="417e9-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span></span>

### <a name="example-2"></a><span data-ttu-id="417e9-133">Ejemplo 2</span><span class="sxs-lookup"><span data-stu-id="417e9-133">Example 2</span></span>

```console
     MAX_POOLING (pool1)
        /    \
CONVOLUTION  CONVOLUTION
  (conv1)      (conv2)
        \    /
         JOIN (join1)
```

<span data-ttu-id="417e9-134">Aquí, la salida de la agrupación se introduce en dos convolución, cuyas salidas se concatenan con el operador de combinación.</span><span class="sxs-lookup"><span data-stu-id="417e9-134">Here the output of pooling is fed into two convolutions, whose outputs are then concatenated together using the JOIN operator.</span></span> <span data-ttu-id="417e9-135">Existe una dependencia de datos entre y y, así como `pool1` `conv1` `conv2` entre y y `conv1` `conv2` `join1` .</span><span class="sxs-lookup"><span data-stu-id="417e9-135">A data dependency exists between `pool1` and both `conv1` and `conv2`; as well as between both `conv1` and `conv2` and `join1`.</span></span> <span data-ttu-id="417e9-136">Esta es una manera válida de ejecutar este gráfico.</span><span class="sxs-lookup"><span data-stu-id="417e9-136">Here's one valid way to execute this graph.</span></span>

1. <span data-ttu-id="417e9-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span></span>
2. <span data-ttu-id="417e9-138">`d3d12CommandList->ResourceBarrier(`**Barrera UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-138">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="417e9-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
4. <span data-ttu-id="417e9-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`</span></span>
5. <span data-ttu-id="417e9-141">`d3d12CommandList->ResourceBarrier(`**Barrera UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-141">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
6. <span data-ttu-id="417e9-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`</span><span class="sxs-lookup"><span data-stu-id="417e9-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`</span></span>

<span data-ttu-id="417e9-143">En este caso, `conv1` y pueden `conv2` ejecutarse simultáneamente en la GPU, lo que puede mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="417e9-143">In this case, `conv1` and `conv2` are able to execute concurrently on the GPU, which may improve performance.</span></span>

## <a name="resource-barrier-state-requirements"></a><span data-ttu-id="417e9-144">Requisitos de estado de barrera de recursos</span><span class="sxs-lookup"><span data-stu-id="417e9-144">Resource barrier state requirements</span></span>

<span data-ttu-id="417e9-145">Como autor de la llamada, es su responsabilidad asegurarse de que todos los recursos de Direct3D 12 se encuentran en el estado de barrera de recursos correcto antes de ejecutar los envíos de DirectML en la GPU.</span><span class="sxs-lookup"><span data-stu-id="417e9-145">As the caller, it's your responsibility to ensure that all Direct3D 12 resources are in the correct resource barrier state prior to executing DirectML dispatches on the GPU.</span></span> <span data-ttu-id="417e9-146">DirectML no realiza ninguna barrera de transición en su nombre.</span><span class="sxs-lookup"><span data-stu-id="417e9-146">DirectML doesn't perform any transition barriers on your behalf.</span></span>

<span data-ttu-id="417e9-147">Antes de la ejecución de [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) en la GPU, debe pasar todos los recursos enlazados al estado **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** , o a un estado que se pueda promover implícitamente a **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, como **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="417e9-147">Prior to execution of [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="417e9-148">Una vez finalizada esta llamada, los recursos permanecen en el estado **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="417e9-148">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="417e9-149">Para obtener más información, vea [Binding in DirectML](dml-binding.md).</span><span class="sxs-lookup"><span data-stu-id="417e9-149">For more details, see [Binding in DirectML](dml-binding.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="417e9-150">Consulte también</span><span class="sxs-lookup"><span data-stu-id="417e9-150">See also</span></span>

* [<span data-ttu-id="417e9-151">Usar barreras de recursos para sincronizar los Estados de los recursos en Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="417e9-151">Using resource barriers to synchronize resource states in Direct3D 12</span></span>](/windows/desktop/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12)
* [<span data-ttu-id="417e9-152">Enlaces en DirectML</span><span class="sxs-lookup"><span data-stu-id="417e9-152">Binding in DirectML</span></span>](dml-binding.md)
