---
description: Puede realizar operaciones de E/S sincrónicas o asincrónicas (también denominadas superpuestas) en archivos, canalizaciones con nombre y dispositivos de comunicaciones serie.
ms.assetid: db44990e-5a0f-4153-8ff6-79dd7cda48af
title: Sincronización y entrada y salida superpuestas
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 13e462e4c2cffa3f1c9dee9bc33a7c75b910ce8139dbdfab9c190b4691c4b6bc
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/11/2021
ms.locfileid: "119975915"
---
# <a name="synchronization-and-overlapped-input-and-output"></a>Sincronización y entrada y salida superpuestas

Puede realizar operaciones de E/S sincrónicas o asincrónicas (también denominadas superpuestas) en archivos, canalizaciones con nombre y dispositivos de comunicaciones serie. Las [**funciones WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**ReadFile,**](/windows/win32/api/fileapi/nf-fileapi-readfile) [**DeviceIoControl,**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) [**WaitCommEvent,**](/windows/win32/api/winbase/nf-winbase-waitcommevent) [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)y [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) se pueden realizar de forma sincrónica o asincrónica. Las [**funciones ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex) [**y WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) solo se pueden realizar de forma asincrónica.

Cuando una función se ejecuta sincrónicamente, no se devuelve hasta que se ha completado la operación. Esto significa que la ejecución del subproceso que realiza la llamada se puede bloquear durante un período indefinido mientras espera a que finalice una operación que lleva mucho tiempo. Las funciones a las que se llama para la operación superpuesta pueden devolverse inmediatamente, aunque la operación no se haya completado. Esto permite ejecutar una operación de E/S que tarda mucho tiempo en ejecutarse en segundo plano mientras el subproceso que realiza la llamada es libre para realizar otras tareas. Por ejemplo, un único subproceso puede realizar operaciones de E/S simultáneas en distintos identificadores o incluso operaciones simultáneas de lectura y escritura en el mismo identificador.

Para sincronizar su ejecución con la finalización de la operación superpuesta, el subproceso que realiza la llamada usa la función [**GetOverlappedResult,**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) la función [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) o una de las funciones [de](wait-functions.md) espera para determinar cuándo se ha completado la operación superpuesta. También puede usar la macro [**HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) para sondear la finalización.

Para cancelar todas las operaciones de E/S asincrónicas pendientes, use la función [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) y proporcione una estructura [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) que especifique la solicitud que se cancelará. Use la [**función CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) para cancelar las operaciones de E/S asincrónicas pendientes emitidas por el subproceso de llamada para el identificador de archivo especificado.

Las operaciones superpuestas requieren un archivo, una canalización con nombre o un dispositivo de comunicaciones creado con la **marca FILE \_ FLAG \_ OVERLAPPED.** Cuando un subproceso llama a una función (como la función [**ReadFile)**](/windows/win32/api/fileapi/nf-fileapi-readfile) para realizar una operación superpuesta, el subproceso que realiza la llamada debe especificar un puntero a una [**estructura OVERLAPPED.**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) (Si este puntero es **NULL,** el valor devuelto de la función puede indicar incorrectamente que se completó la operación). Todos los miembros de la estructura **OVERLAPPED** deben inicializarse en cero, a menos que se utilice un evento para indicar la finalización de una operación de E/S. Si se usa un evento, el **miembro hEvent** de la estructura **OVERLAPPED** especifica un identificador para el objeto de evento asignado. El sistema establece el estado del objeto de evento en sin signo cuando se devuelve una llamada a la función de E/S antes de que se haya completado la operación. El sistema establece el estado del objeto de evento en señalado cuando se ha completado la operación. Solo se necesita un evento si habrá más de una operación de E/S pendiente al mismo tiempo. Si no se usa un evento, cada operación de E/S completada señalará el archivo, la canalización con nombre o el dispositivo de comunicaciones.

Cuando se llama a una función para realizar una operación superpuesta, la operación podría completarse antes de que se devuelva la función. Cuando esto sucede, los resultados se controlan como si la operación se hubiera realizado sincrónicamente. Sin embargo, si la operación no se completó, el valor devuelto de la función es **FALSE** y la función [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) devuelve **ERROR IO \_ \_ PENDING.**

Un subproceso puede administrar operaciones superpuestas mediante cualquiera de estos dos métodos:

-   Use las [**funciones GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) o [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) para esperar a que se complete la operación superpuesta. Si **se usa GetOverlappedResultEx,** el subproceso que realiza la llamada puede especificar un tiempo de espera para la operación superpuesta o realizar una espera de alerta.
-   Especifique un identificador para el objeto de evento de restablecimiento manual de la estructura [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) en una de las funciones de espera y, después, una vez que la función wait vuelva, llame a [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) o [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex). [](wait-functions.md) La función devuelve los resultados de la operación superpuesta completada y, para las funciones en las que esta información es adecuada, notifica el número real de bytes transferidos.

Al realizar varias operaciones superpuestas simultáneas en un único subproceso, el subproceso que realiza la llamada debe especificar una [**estructura OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) para cada operación. Cada **estructura OVERLAPPED** debe especificar un identificador para un objeto de evento de restablecimiento manual diferente. Para esperar a que se complete cualquiera de las operaciones superpuestas, el subproceso especifica todos los identificadores de eventos de restablecimiento manual como criterios de espera en una de las funciones de espera de varios [objetos](wait-functions.md). El valor devuelto de la función de espera de varios objetos indica qué objeto de evento de restablecimiento manual se señaló, por lo que el subproceso puede determinar qué operación superpuesta provocó que se completara la operación de espera.

Es más seguro usar un objeto de evento independiente para cada operación superpuesta, en lugar de especificar ningún objeto de evento o reutilizar el mismo objeto de evento para varias operaciones. Si no se especifica ningún objeto de evento en la estructura [**OVERLAPPED,**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) el sistema indica el estado del archivo, la canalización con nombre o el dispositivo de comunicaciones cuando se ha completado la operación superpuesta. Por lo tanto, puede especificar estos identificadores como objetos de sincronización en una función de espera, aunque su uso para este propósito puede ser difícil de administrar porque, al realizar operaciones superpuestas simultáneas en el mismo archivo, canalización con nombre o dispositivo de comunicaciones, no hay ninguna manera de saber qué operación ha provocado que se señale el estado del objeto.

Un subproceso no debe reutilizar un evento con la suposición de que el evento solo se señalará mediante la operación superpuesta de ese subproceso. Un evento se señala en el mismo subproceso que la operación superpuesta que se está completando. El uso del mismo evento en varios subprocesos puede dar lugar a una condición de carrera en la que el evento se señala correctamente para el subproceso cuya operación se completa primero y prematuramente para otros subprocesos que usan ese evento. A continuación, cuando se completa la siguiente operación superpuesta, el evento se señala de nuevo para todos los subprocesos que usan ese evento, y así sucesivamente hasta que se completan todas las operaciones superpuestas.

Para obtener ejemplos que muestran el uso de operaciones superpuestas, rutinas de finalización y la función [**GetOverlappedResult,**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) vea [Usar canalizaciones](../ipc/using-pipes.md).

**Windows Vista, Windows Server 2003 y Windows XP: **

Tenga cuidado al volver a usar estructuras [**OVERLAPPED.**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) Si las estructuras **OVERLAPPED** se reutilizan en varios subprocesos y se llama a [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) con el parámetro *bWait* establecido en **TRUE,** el subproceso que realiza la llamada debe asegurarse de que el evento asociado se señale antes de reutilizar la estructura. Esto se puede lograr mediante la función [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) después de llamar a **GetOverlappedResult** para forzar al subproceso a esperar hasta que se complete la operación. Tenga en cuenta que el objeto de evento debe ser un objeto de evento de restablecimiento manual. Si se usa un objeto de evento autoreset, llamar a **GetOverlappedResult** con el parámetro *bWait* establecido en **TRUE** hace que la función se bloquee indefinidamente. Este comportamiento cambió a partir de Windows 7 y Windows Server 2008 R2 para las aplicaciones que especifican Windows 7 como sistema operativo compatible en el manifiesto de aplicación. Para obtener más información, [vea Manifiestos de aplicación.](/previous-versions/windows/desktop/adrms_sdk/application-manifests)

## <a name="related-topics"></a>Temas relacionados

<dl> <dt>

[Conceptos de E/S](../fileio/i-o-concepts.md)
</dt> </dl>

 

 
