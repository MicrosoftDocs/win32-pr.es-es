---
description: Describe las consideraciones para el control de aplicaciones del almacenamiento en búfer de archivos, también conocido como entrada/salida (e/s) de archivo no almacenado en búfer.
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: Almacenamiento en búfer de archivo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "104278820"
---
# <a name="file-buffering"></a><span data-ttu-id="2fedb-103">Almacenamiento en búfer de archivo</span><span class="sxs-lookup"><span data-stu-id="2fedb-103">File Buffering</span></span>

<span data-ttu-id="2fedb-104">En este tema se tratan las distintas consideraciones para el control de aplicaciones del almacenamiento en búfer de archivos, también conocido como entrada/salida (e/s) de archivo no almacenado en búfer.</span><span class="sxs-lookup"><span data-stu-id="2fedb-104">This topic covers the various considerations for application control of file buffering, also known as unbuffered file input/output (I/O).</span></span> <span data-ttu-id="2fedb-105">El almacenamiento en búfer de archivos normalmente lo controla el sistema en segundo plano y se considera parte del [almacenamiento en caché](file-caching.md) de archivos dentro del sistema operativo Windows, a menos que se especifique lo contrario.</span><span class="sxs-lookup"><span data-stu-id="2fedb-105">File buffering is usually handled by the system behind the scenes and is considered part of [file caching](file-caching.md) within the Windows operating system unless otherwise specified.</span></span> <span data-ttu-id="2fedb-106">Aunque los términos *almacenamiento en caché y almacenamiento en* *búfer* se usan a veces indistintamente, en este tema se usa el término *almacenamiento en búfer* específicamente en el contexto de explicar cómo interactuar con los datos que no están almacenados en caché (almacenados en búfer) por el sistema, donde se encuentra en gran medida del control directo de las aplicaciones en modo usuario.</span><span class="sxs-lookup"><span data-stu-id="2fedb-106">Although the terms *caching* and *buffering* are sometimes used interchangeably, this topic uses the term *buffering* specifically in the context of explaining how to interact with data that is not being cached (buffered) by the system, where it is otherwise largely out of the direct control of user-mode applications.</span></span>

<span data-ttu-id="2fedb-107">Al abrir o crear un archivo con la función [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) , la marca de **archivo sin marca de almacenamiento en \_ \_ \_ búfer** puede especificarse para deshabilitar el almacenamiento en caché del sistema de los datos que se leen o se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="2fedb-107">When opening or creating a file with the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function, the **FILE\_FLAG\_NO\_BUFFERING** flag can be specified to disable system caching of data being read from or written to the file.</span></span> <span data-ttu-id="2fedb-108">Aunque esto proporciona un control directo y completo sobre el almacenamiento en búfer de e/s de datos, en el caso de archivos y dispositivos similares, se deben tener en cuenta los requisitos de alineación de datos.</span><span class="sxs-lookup"><span data-stu-id="2fedb-108">Although this gives complete and direct control over data I/O buffering, in the case of files and similar devices there are data alignment requirements that must be considered.</span></span>

> [!Note]  
> <span data-ttu-id="2fedb-109">Esta información de alineación se aplica a la e/s en dispositivos tales como archivos que admiten búsquedas y el concepto de punteros de posición de archivo (o *desplazamientos*).</span><span class="sxs-lookup"><span data-stu-id="2fedb-109">This alignment information applies to I/O on devices such as files that support seeking and the concept of file position pointers (or *offsets*).</span></span> <span data-ttu-id="2fedb-110">En el caso de los dispositivos que no buscan, como canalizaciones con nombre o dispositivos de comunicaciones, la desactivación del almacenamiento en búfer puede no requerir ninguna alineación determinada.</span><span class="sxs-lookup"><span data-stu-id="2fedb-110">For devices that do not seek, such as named pipes or communications devices, turning off buffering may not require any particular alignment.</span></span> <span data-ttu-id="2fedb-111">Las limitaciones o eficiencias que se puedan obtener mediante la alineación en ese caso dependen de la tecnología subyacente.</span><span class="sxs-lookup"><span data-stu-id="2fedb-111">Any limitations or efficiencies that may be gained by alignment in that case are dependent on the underlying technology.</span></span>

 

<span data-ttu-id="2fedb-112">En un ejemplo simple, la aplicación abriría un archivo para el acceso de escritura con la marca de **archivo sin marca de \_ almacenamiento en \_ \_ búfer** y, a continuación, realiza una llamada a la función [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) mediante un búfer de datos definido en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="2fedb-112">In a simple example, the application would open a file for write access with the **FILE\_FLAG\_NO\_BUFFERING** flag and then perform a call to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function using a data buffer defined within the application.</span></span> <span data-ttu-id="2fedb-113">Este búfer local es, en estas circunstancias, el único búfer de archivo que existe para esta operación.</span><span class="sxs-lookup"><span data-stu-id="2fedb-113">This local buffer is, in these circumstances, effectively the only file buffer that exists for this operation.</span></span> <span data-ttu-id="2fedb-114">Debido a la distribución del disco físico, al diseño de almacenamiento del sistema de archivos y al seguimiento de la posición del puntero de archivo de nivel de sistema, esta operación de escritura producirá un error a menos que los búferes de datos definidos localmente cumplan determinados criterios de alineación, que se describen en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="2fedb-114">Because of physical disk layout, file system storage layout, and system-level file pointer position tracking, this write operation will fail unless the locally-defined data buffers meet certain alignment criteria, discussed in the following section.</span></span>

> [!Note]  
> <span data-ttu-id="2fedb-115">La explicación del almacenamiento en caché no tiene en cuenta el almacenamiento en caché del hardware en el disco físico, que no se garantiza que esté dentro del control directo del sistema en ningún caso.</span><span class="sxs-lookup"><span data-stu-id="2fedb-115">Discussion of caching does not consider any hardware caching on the physical disk itself, which is not guaranteed to be within the direct control of the system in any case.</span></span> <span data-ttu-id="2fedb-116">Esto no tiene ningún efecto en los requisitos especificados en este tema.</span><span class="sxs-lookup"><span data-stu-id="2fedb-116">This has no effect on the requirements specified in this topic.</span></span>

 

<span data-ttu-id="2fedb-117">Para obtener más información sobre cómo la **marca de archivo \_ \_ sin \_ almacenamiento en búfer** interactúa con otras marcas relacionadas con la memoria caché, vea [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span><span class="sxs-lookup"><span data-stu-id="2fedb-117">For more information on how **FILE\_FLAG\_NO\_BUFFERING** interacts with other cache-related flags, see [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span>

## <a name="alignment-and-file-access-requirements"></a><span data-ttu-id="2fedb-118">Requisitos de alineación y acceso a archivos</span><span class="sxs-lookup"><span data-stu-id="2fedb-118">Alignment and File Access Requirements</span></span>

<span data-ttu-id="2fedb-119">Como se explicó anteriormente, una aplicación debe cumplir ciertos requisitos al trabajar con archivos abiertos **con \_ marca de archivo \_ sin almacenamiento en \_ búfer**.</span><span class="sxs-lookup"><span data-stu-id="2fedb-119">As previously discussed, an application must meet certain requirements when working with files opened with **FILE\_FLAG\_NO\_BUFFERING**.</span></span> <span data-ttu-id="2fedb-120">Se aplican las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="2fedb-120">The following specifics apply:</span></span>

-   <span data-ttu-id="2fedb-121">Los tamaños de acceso a archivos, incluido el desplazamiento opcional de archivo en la estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , si se especifica, deben ser para un número de bytes que sea un entero múltiplo del tamaño del sector del volumen.</span><span class="sxs-lookup"><span data-stu-id="2fedb-121">File access sizes, including the optional file offset in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, if specified, must be for a number of bytes that is an integer multiple of the volume sector size.</span></span> <span data-ttu-id="2fedb-122">Por ejemplo, si el tamaño del sector es de 512 bytes, una aplicación puede solicitar lecturas y escrituras de 512, 1.024, 1.536 o 2.048 bytes, pero no de 335, 981 o 7.171 bytes.</span><span class="sxs-lookup"><span data-stu-id="2fedb-122">For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1,024, 1,536, or 2,048 bytes, but not of 335, 981, or 7,171 bytes.</span></span>
-   <span data-ttu-id="2fedb-123">Las direcciones de búfer de acceso a archivos para las operaciones de lectura y escritura deben estar alineadas con el sector físico, lo que significa que están alineadas en las direcciones en memoria que son múltiplos enteros del tamaño de sector físico del volumen.</span><span class="sxs-lookup"><span data-stu-id="2fedb-123">File access buffer addresses for read and write operations should be physical sector-aligned, which means aligned on addresses in memory that are integer multiples of the volume's physical sector size.</span></span> <span data-ttu-id="2fedb-124">En función del disco, es posible que no se aplique este requisito.</span><span class="sxs-lookup"><span data-stu-id="2fedb-124">Depending on the disk, this requirement may not be enforced.</span></span>

<span data-ttu-id="2fedb-125">Los desarrolladores de aplicaciones deben tener en cuenta los nuevos tipos de dispositivos de almacenamiento que se incorporan en el mercado con un tamaño de sector de medios físicos de 4.096 bytes.</span><span class="sxs-lookup"><span data-stu-id="2fedb-125">Application developers should take note of new types of storage devices being introduced into the market with a physical media sector size of 4,096 bytes.</span></span> <span data-ttu-id="2fedb-126">El nombre del sector de estos dispositivos es "Advanced Format".</span><span class="sxs-lookup"><span data-stu-id="2fedb-126">The industry name for these devices is "Advanced Format".</span></span> <span data-ttu-id="2fedb-127">Como puede haber problemas de compatibilidad con la introducción directa de 4.096 bytes como unidad de direccionamiento para los medios, una solución de compatibilidad temporal consiste en introducir dispositivos que emulen un dispositivo de almacenamiento del sector de 512 bytes normal, pero que ofrecen información disponible sobre el verdadero tamaño del sector a través de los comandos estándar de ATA y SCSI.</span><span class="sxs-lookup"><span data-stu-id="2fedb-127">As there may be compatibility issues with directly introducing 4,096 bytes as the unit of addressing for the media, a temporary compatibility solution is to introduce devices that emulate a regular 512-byte sector storage device but make available information about the true sector size through standard ATA and SCSI commands.</span></span>

<span data-ttu-id="2fedb-128">Como resultado de esta emulación, en esencia hay dos tamaños de sector que los desarrolladores deben conocer:</span><span class="sxs-lookup"><span data-stu-id="2fedb-128">As a result of this emulation, there are in essence two sector sizes that developers will need to understand:</span></span>

-   <span data-ttu-id="2fedb-129">Sector lógico: unidad que se usa para el direccionamiento de bloque lógico para los medios.</span><span class="sxs-lookup"><span data-stu-id="2fedb-129">Logical Sector: The unit that is used for logical block addressing for the media.</span></span> <span data-ttu-id="2fedb-130">También podemos considerarla como la unidad más pequeña de escritura que el almacenamiento puede aceptar.</span><span class="sxs-lookup"><span data-stu-id="2fedb-130">We can also think of it as the smallest unit of write that the storage can accept.</span></span> <span data-ttu-id="2fedb-131">Esta es la "emulación".</span><span class="sxs-lookup"><span data-stu-id="2fedb-131">This is the "emulation".</span></span>
-   <span data-ttu-id="2fedb-132">Sector físico: unidad para la que se completan las operaciones de lectura y escritura en el dispositivo en una sola operación.</span><span class="sxs-lookup"><span data-stu-id="2fedb-132">Physical Sector: The unit for which read and write operations to the device are completed in a single operation.</span></span> <span data-ttu-id="2fedb-133">Se trata de la unidad de escritura atómica y de qué e/s no almacenada en búfer necesitará alinearse con el fin de tener características de confiabilidad y rendimiento óptimas.</span><span class="sxs-lookup"><span data-stu-id="2fedb-133">This is the unit of atomic write, and what unbuffered I/O will need to be aligned to in order to have optimal performance and reliability characteristics.</span></span>

<span data-ttu-id="2fedb-134">La mayoría de las API de Windows actuales, como [**ioctl \_ Disk \_ Get \_ Drive \_ Geometry**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) y [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), devolverán el tamaño del sector lógico, pero el tamaño del sector físico se puede recuperar a través del código de control de [**\_ propiedad de \_ consulta \_ de almacenamiento ioctl**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) , con la información pertinente contenida en el miembro **BytesPerPhysicalSector** en la estructura del [**\_ \_ \_ descriptor de alineación de acceso de almacenamiento**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) .</span><span class="sxs-lookup"><span data-stu-id="2fedb-134">Most current Windows APIs, such as [**IOCTL\_DISK\_GET\_DRIVE\_GEOMETRY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) and [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), will return the logical sector size, but the physical sector size can be retrieved through the [**IOCTL\_STORAGE\_QUERY\_PROPERTY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) control code, with the relevant information contained in the **BytesPerPhysicalSector** member in the [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure.</span></span> <span data-ttu-id="2fedb-135">Para obtener un ejemplo, vea el código de ejemplo en el [**\_ \_ \_ descriptor de alineación de acceso al almacenamiento**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span><span class="sxs-lookup"><span data-stu-id="2fedb-135">For an example, see the sample code at [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span></span> <span data-ttu-id="2fedb-136">Microsoft recomienda encarecidamente que los desarrolladores alineen la e/s no almacenada en búfer con el tamaño de sector físico, tal y como lo indique el código de control de **\_ propiedad de \_ consulta \_ de almacenamiento ioctl** para ayudar a garantizar que sus aplicaciones estén preparadas para esta transición de tamaño de sector.</span><span class="sxs-lookup"><span data-stu-id="2fedb-136">Microsoft strongly recommends that developers align unbuffered I/O to the physical sector size as reported by the **IOCTL\_STORAGE\_QUERY\_PROPERTY** control code to help ensure their applications are prepared for this sector size transition.</span></span>

<span data-ttu-id="2fedb-137">**Windows Server 2003 y Windows XP:** La estructura del [**\_ \_ \_ descriptor de alineación de acceso de almacenamiento**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) no está disponible.</span><span class="sxs-lookup"><span data-stu-id="2fedb-137">**Windows Server 2003 and Windows XP:** The [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure is not available.</span></span> <span data-ttu-id="2fedb-138">Se presentó con Windows Vista y Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="2fedb-138">It was introduced with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="2fedb-139">Dado que las direcciones de búfer para las operaciones de lectura y escritura deben estar alineadas por sectores, la aplicación debe tener control directo sobre cómo se asignan estos búferes.</span><span class="sxs-lookup"><span data-stu-id="2fedb-139">Because buffer addresses for read and write operations must be sector-aligned, the application must have direct control of how these buffers are allocated.</span></span> <span data-ttu-id="2fedb-140">Una manera de utilizar los búferes de alineación de sectores es usar la función [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) para asignar los búferes.</span><span class="sxs-lookup"><span data-stu-id="2fedb-140">One way to sector-align buffers is to use the [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function to allocate the buffers.</span></span> <span data-ttu-id="2fedb-141">Tenga en cuenta lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="2fedb-141">Consider the following:</span></span>

-   <span data-ttu-id="2fedb-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) asigna memoria que está alineada en direcciones que son múltiplos enteros del tamaño de página del sistema.</span><span class="sxs-lookup"><span data-stu-id="2fedb-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) allocates memory that is aligned on addresses that are integer multiples of the system's page size.</span></span> <span data-ttu-id="2fedb-143">El tamaño de página es de 4.096 bytes en x64 y en bytes x86 o 8.192 para sistemas basados en Itanium.</span><span class="sxs-lookup"><span data-stu-id="2fedb-143">Page size is 4,096 bytes on x64 and x86 or 8,192 bytes for Itanium-based systems.</span></span> <span data-ttu-id="2fedb-144">Para obtener más información, vea la función [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) .</span><span class="sxs-lookup"><span data-stu-id="2fedb-144">For additional information, see the [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) function.</span></span>
-   <span data-ttu-id="2fedb-145">El tamaño del sector suele ser de 512 a 4.096 bytes para dispositivos de almacenamiento de acceso directo (discos duros) y 2.048 bytes para CD-ROM.</span><span class="sxs-lookup"><span data-stu-id="2fedb-145">Sector size is typically 512 to 4,096 bytes for direct-access storage devices (hard drives) and 2,048 bytes for CD-ROMs.</span></span>
-   <span data-ttu-id="2fedb-146">Los tamaños de página y de sector son potencias de 2.</span><span class="sxs-lookup"><span data-stu-id="2fedb-146">Both page and sector sizes are powers of 2.</span></span>

<span data-ttu-id="2fedb-147">Por lo tanto, en la mayoría de los casos, la memoria alineada en páginas también estará alineada por sectores, porque el caso en el que el tamaño del sector es mayor que el tamaño de página es poco frecuente.</span><span class="sxs-lookup"><span data-stu-id="2fedb-147">Therefore, in most situations, page-aligned memory will also be sector-aligned, because the case where the sector size is larger than the page size is rare.</span></span>

<span data-ttu-id="2fedb-148">Otra manera de obtener los búferes de memoria alineados manualmente es usar la función [ \_ aligned \_ malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) de la biblioteca de Run-Time de C.</span><span class="sxs-lookup"><span data-stu-id="2fedb-148">Another way to obtain manually-aligned memory buffers is to use the [\_aligned\_malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) function from the C Run-Time library.</span></span> <span data-ttu-id="2fedb-149">Para obtener un ejemplo de cómo controlar manualmente la alineación del búfer, vea el ejemplo de código del lenguaje C++ en la sección de código de ejemplo de [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="2fedb-149">For an example of how to manually control buffer alignment, see the C++ language code example in the Example Code section of [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span>

 

 
