---
description: En este artículo se proporcionan detalles adicionales sobre los metadatos de Control Flow Guard en imágenes de PE.
title: Metadatos de PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c2bce23a94629900f8610cf3cbc1e2ba0db1c4e6a079bd5f610be230df24ec6e
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/11/2021
ms.locfileid: "119994495"
---
# <a name="pe-metadata"></a>Metadatos de PE

En este artículo se proporcionan detalles adicionales para los metadatos de Control Flow Guard (CFG) en imágenes de PE. Se supone que está familiarizado con la estructura de los metadatos de CFG en las imágenes de PE. Consulte el [tema Formato PE](../debug/pe-format.md) para obtener documentación de alto nivel sobre los metadatos de CFG en imágenes de PE.

- Las funciones que son destinos de llamadas indirectos válidos se enumeran en **la tabla GuardCFFunctionTable** adjuntada al directorio de configuración de carga, a veces llamada **tabla GFIDS** por brevedad. Se trata de una lista ordenada de direcciones virtuales relativas (RVA) que contienen información sobre los destinos de llamada CFG válidos. Por lo general, se trata de símbolos de función tomados de direcciones. Una imagen que quiera aplicar CFG debe enumerar todos los símbolos de función tomadas de dirección en su **tabla GFIDS.** La lista de RVA de la **tabla GFIDS** debe estar ordenada correctamente o no se cargará la imagen. La **tabla GFIDS** es una matriz de 4 + *n* bytes, donde *n* la especifica ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT). "GuardFlags" es el campo GuardFlags del directorio de configuración de carga. Esto permite adjuntar metadatos adicionales a los destinos de llamada CFG en el futuro. Los únicos metadatos definidos actualmente son un campo opcional de marcas adicionales de 1 byte ("marcas GFIDS") que se adjunta a cada entrada **de GFIDS** si algún destino de llamada tiene metadatos. Hay dos **marcas GFIDS** definidas:
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | El destino de llamada se suprime explícitamente (no lo trate como válido para fines de CFG) |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2 | El destino de la llamada se suprime. Consulte [Exportación de la supresión](#export-suppression) para obtener más detalles. |
  
  Para compatibilidad futura, las herramientas no deben establecer marcas **GFIDS** que aún no se hayan definido y no deben incluir bytes de metadatos adicionales de **GFIDS** más allá del 1 byte definido actualmente, ya que los significados de otras marcas o metadatos adicionales aún no están asignados. Puede encontrar ejemplos de imágenes que incluyen bytes de metadatos adicionales mediante el volcado de la tabla **GFIDS** de archivos binarios, como Ntdll.dll en una versión Windows 10 sistema operativo moderna.

  Las herramientas solo deben declarar símbolos de función como destinos de llamada válidos, lo que puede merecer consideraciones adicionales para el código ensamblador en el que se pueden tomar etiquetas. Por motivos históricos, el código del ensamblador puede basarse en etiquetas de código que no sean PROC o .altentry, ya que el vinculador no se convierte en destinos de llamada CFG.

  También por motivos históricos, el código puede declarar deliberadamente código como datos para evitar la inclusión en la **tabla GFIDS.** Por ejemplo, un archivo de objeto puede implementar un símbolo como código, mientras que otro puede declararlo como datos para tomar la dirección del símbolo sin generar un registro de destino CFG válido. Por compatibilidad, se recomienda que los conjuntos de herramientas admitan esta práctica.

- Las imágenes que admiten CFG y que desean o realizan comprobaciones de CFG deben establecer los bits IMAGE_GUARD_CF_INSTRUMENTED y IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags, y deben establecer el bit IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics en los encabezados de imagen.

- El directorio de configuración de carga anuncia dos punteros de función: GuardCFCheckFunctionPointer y GuardCFDispatchFunctionPointer (este último solo se admite para determinadas arquitecturas, como AMD64). Estos punteros de función deben apuntar a la memoria de solo lectura para que la seguridad de CFG sea eficaz; El cargador de DLL del sistema operativo volverá a proteger la memoria de forma transitoria durante la carga de imágenes para almacenar los punteros de función. El uso típico podría ser combinarlos en la misma sección que contiene la tabla de direcciones de importación (IAT). GuardCFCheckFunctionPointer proporciona la dirección de un símbolo proporcionado por el cargador del sistema operativo al que se puede llamar con un puntero de función en el primer registro de argumento entero (ECX en x86) que devolverá si se ejecuta correctamente o anulará el proceso si el destino de la llamada no es un destino CFG válido. GuardCFDispatchFunctionPointer proporciona la dirección de un símbolo proporcionado por el cargador del sistema operativo que toma un destino de llamada en el registro RAX y realiza una llamada combinada optimizada para la rama de cola y comprobación CFG al destino de llamada (los registros R10/R11 están reservados para su uso por GuardCFDispatchFunctionPointer y los registros de argumentos enteros están reservados para su uso por el destino de llamada final). La dirección predeterminada de los símbolos CFG de una imagen debe apuntar a una función que solo devuelve (GuardCFCheckFunctionPointer) o que devuelve un símbolo suprimido por protección (o se omite por completo del símbolo de tabla **GFIDS)** que ejecuta una instrucción "jmp rax". En el caso de AMD64 GuardCFDispatchFunctionPointer, cuando se carga una imagen en un sistema operativo compatible con CFG y se habilita CFG, el cargador de DLL del sistema operativo instalará los punteros de función adecuados, lo que permite la compatibilidad con versiones anteriores. Una imagen puede proporcionar 0 para GuardCFDispatchFunctionPointer en la configuración de carga si no pretende usar la instalación de distribución de CFG. Esto debe hacerse para las arquitecturas que no son AMD64 para compatibilidad futura, en caso de que estas arquitecturas admitan finalmente el mecanismo de distribución CFG de alguna forma. Tenga en cuenta Windows 8.1 AMD64 no admite el envío de CFG y dejaría el puntero de función predeterminado en su lugar para GuardCFDispatchFunctionPointer. La distribución de CFG solo se admite en Windows 10 y sistemas operativos posteriores.

- El modo de usuario CFG solo se puede aplicar para imágenes marcadas como compatibles con la selección aleatoria de diseño de espacio de direcciones (ASLR) (especificada por la opción /DYNAMICBASE con el vinculador de Microsoft). Esto se debe a cómo el sistema operativo controla internamente CFG, donde está conectado esencialmente a la infraestructura de ASLR. En general, los usuarios de CFG deben habilitar ASLR para sus imágenes como primer paso. Las herramientas no deben suponer que el sistema operativo siempre omitirá CFG sin aslr establecido, pero generalmente debe establecer ambos al mismo tiempo.

## <a name="compiler-directives"></a>Directivas del compilador

- Los destinos de llamada se pueden marcar como suprimidos explícitamente con el modificador __declspec(guard(suppress)) o con la directiva del vinculador /guardsym:symname,S (por ejemplo, para el código asm). Esto hace que el destino de llamada se incluya en la tabla **GFIDS,** pero se marque de forma que el sistema operativo trate el destino de llamada como no válido. Algunos escenarios que no son de producción, como con cierta instrumentación de comprobador de aplicaciones habilitada en algunos sistemas operativos anteriores, pueden permitir que los destinos de llamada suprimidos se traten como válidos, pero en general no se espera que estos escenarios sean escenarios de producción. Esta directiva es útil para anotar funciones "peligrosas" que no deben considerarse como destinos de llamada válidos, aunque la regla CFG normal los incluya.

- El código puede indicar que no se quieren comprobaciones de CFG con el modificador __declspec(guard(nocf)). Esto hace que el compilador no inserte ninguna comprobación de CFG para toda la función. El compilador debe tener cuidado de propagar esta directiva a cualquier código aportado por una función en línea que esté marcada como no quiere comprobaciones de CFG. Normalmente, este enfoque solo se usa con moderación en situaciones específicas en las que el programador ha insertado manualmente la protección "equivalente a CFG". El programador sabe que llama a través de alguna tabla de funciones de solo lectura cuya dirección se obtiene a través de referencias de memoria de solo lectura y para la que el índice se enmascara hasta el límite de la tabla de funciones. Este enfoque también se puede aplicar a funciones contenedoras pequeñas que no están en la base de datos y que no hacen nada más que realizar una llamada a través de un puntero de función. Dado que el uso incorrecto de esta directiva puede poner en peligro la seguridad de CFG, el programador debe tener mucho cuidado con la directiva . Normalmente, este uso se limita a funciones muy pequeñas que solo llaman a una función.

## <a name="import-handling"></a>Control de importación

- Las llamadas a través de IAT no deben usar la protección CFG. El IAT solo se lee en imágenes modernas (suponiendo que el IAT se declare en los encabezados PE, en cuyo caso debe estar en sus propias páginas). El IAT se puede usar para acceder a funciones que se suprimen con protección, por lo que se trata de un requisito de corrección. La protección de memoria de solo lectura a través de IAT reemplaza a la de CFG, ya que el enlace de destino de llamada es inmutable después de que se resuelvan los instantáneas de importación de imágenes y la resolución de enlace sea más específica.

- Carga de retraso protegida: las llamadas a través del IAT de carga retrasada no deben usar la protección CFG, por las mismas razones que el IAT estándar. El IAT de carga retrasada debe estar en su propia sección y la imagen debe establecer el IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags. Esto indica que el cargador de DLL del sistema operativo debe cambiar las protecciones del IAT de carga retrasada durante la resolución de exportación si se usa la compatibilidad con la carga de retraso del sistema operativo nativa para Windows 8 y sistemas operativos posteriores. El cargador de DLL del sistema operativo administra la sincronización de este paso si la compatibilidad con la carga de retraso del sistema operativo nativo está en uso (por ejemplo, ResolveDelayLoadedAPI), por lo que ningún otro componente debe volver a proteger las páginas que abarcan el IAT de carga de retraso declarado. Para la compatibilidad con versiones anteriores con sistemas operativos anteriores a CFG, las herramientas pueden habilitar la opción de mover el IAT de carga retrasada a su propia sección (canónicamente ".didat"), protegida como lectura/escritura en los encabezados de imagen y, además, establecer la marca IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION. Esta configuración hará que los cargadores de ARCHIVOS DLL del sistema operativo que tienen en cuenta el CFG vuelvan a proteger toda la sección que contiene la tabla IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT solo leer memoria durante la carga de imágenes. Es posible que no sea necesaria la opción de colocar el IAT de carga retrasada en su propia sección si no le importa ejecutar una imagen en sistemas operativos anteriores a la compatibilidad con CFG, pero las herramientas deben tomar esa decisión en función de la compatibilidad mínima del sistema operativo que necesita una imagen.

  Si una imagen no usa la compatibilidad con la carga de retraso nativa del sistema operativo, todavía puede establecer los bits GuardFlags relacionados con la carga de retraso protegida. En esta configuración, el cargador del sistema operativo solo proporcionará compatibilidad para proteger el IAT de carga retrasada como de solo lectura en tiempo de ejecución si es compatible con la plataforma, y se convierte en la responsabilidad de los códigos auxiliares de resolución de carga de retraso interno de la imagen para sincronizar y administrar la protección del retraso del IAT de carga. Siempre que la tabla de configuración de carga se almacene en memoria de solo lectura (lo que se recomienda), la presencia o ausencia del bit IAT de carga de retraso protegido en el campo GuardFlags de la imagen podría ser útil como una sugerencia interna a los códigos auxiliares de resolución de carga de retraso interno de la imagen para indicar si debe o no proteger el IAT de carga de retraso.

  Se recomienda habilitar la carga de retraso protegida de forma predeterminada si CFG está habilitado. Las imágenes que se ejecutan en versiones anteriores del sistema operativo y que usan la compatibilidad con la carga de retraso nativa del sistema operativo, como se indicó, pueden usar el IAT de carga retrasada en su propia sección para la compatibilidad con versiones anteriores. Esto se diferencia de marcar el IAT de carga de retraso como de solo lectura y combinarlo con otra sección, lo que interrumpiría las cargas de retraso protegidas del sistema operativo anterior que no comprenden las cargas de retraso protegidas y que proporcionan compatibilidad nativa con la resolución de carga de retraso. Todas las Windows 10 y las primeras compilaciones de Windows 8.1/Windows Server 2012 R2 que admiten CFG (es decir, la actualización de noviembre de 2014) introducen compatibilidad con la carga de retraso protegida en el sistema operativo.

## <a name="function-alignment"></a>Alineación de funciones

- Las funciones que son direcciones tomadas y, por lo tanto, se incluyen en la **tabla GFIDS,** deben alinearse con 16 bytes, si es posible. Es posible que esto no siempre sea posible. Por ejemplo, para las funciones que no son COMDAT que forman parte de los archivos de objeto ensamblados juntos como una unidad por herramientas que no son de CFG, que algunos ensambladores pueden generar, el usuario de la herramienta que produjo los archivos debe establecer correctamente la alineación. Las herramientas pueden optar por emitir una advertencia de diagnóstico en esta situación para que el usuario pueda tomar las medidas correctivas adecuadas. El motivo es que CFG marca los destinos de llamada como válidos o no válidos en límites de 16 bytes para mejorar la eficacia de las comprobaciones rápidas de CFG. Si una función no está alineada con 16 bytes, toda la ranura de 16 bytes debe marcarse como válida, lo que no es tan seguro, ya que puede llamar a un código que no está alineado en el principio de una función. Este escenario se admite para facilitar la interoperabilidad al incorporar primero CFG para un proyecto. Las imágenes que no son compatibles con CFG se marcan de forma similar como válidas para cualquier alineación de destino de llamada por compatibilidad. Como antes, tener destinos de llamada desalineados reduce las ventajas de seguridad de CFG, por lo que las herramientas deben alinearse automáticamente con un límite de 16 bytes para cualquier elemento de la tabla **GFIDS** cuando se desee CFG para una imagen. Los símbolos que no están en **la tabla GFIDS** no necesitan tener alineaciones concretas para CFG.

## <a name="export-suppression"></a>Exportación de la supresión

- La supresión de exportación de CFG (CFG ES) es un modo opcional que permite a un proceso indicar que los destinos de llamada que solo eran válidos porque eran símbolos dllexport y que GetProcAddress aún no ha resuelto dinámicamente, se considerarán no válidos para fines de CFG. Esto reduce el área de superficie de CFG de las exportaciones dll del sistema. La supresión de la exportación implica comunicar los destinos de llamada dllexport "export suppressed" válidos al marcarlos con IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **de GFIDS.** Los símbolos dllexport y el punto de entrada de imagen de PE deben considerarse implícitamente direcciones tomadas por las herramientas con el fin de generar la **tabla GFIDS.**  Si un símbolo de exportación está alineado con 16 bytes y se toma como dirección sin otra razón que ser un archivo dllexport, se puede marcar con la marca **GFIDS** suprimida de exportación en la tabla de funciones. Los destinos de llamada que no  están alineados con 16 bytes no deben marcarse con la marca **IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED GFIDS** y no se pueden restringir a que solo se habiliten dinámicamente como destinos de llamada válidos en el momento de GetProcAddress.

  Una imagen que admite CFG ES incluye una clase GuardAddressTakenIatEntryTable cuyo recuento proporciona GuardAddressTakenIatEntryCount como parte de su directorio de configuración de carga. Esta tabla tiene el mismo formato estructural que la **tabla GFIDS.** Usa el mismo mecanismo guardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK para codificar bytes de metadatos opcionales adicionales en la tabla IAT de la dirección tomada, aunque todos los bytes de metadatos deben ser cero para la tabla IAT de la dirección tomada y están reservados. La tabla IAT de la dirección tomada indica una matriz ordenada de DTA de thunks de importación que tienen el importado como una dirección de símbolo tomada como destino de llamada. Esta construcción admite símbolos de dirección tomados que existen en un módulo remoto y que son dllexports, con CFG ES en uso. Un ejemplo de este tipo de construcción de código sería:

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  Todas estas direcciones tomadas para importar thunks deben enumerarse para que el cargador del sistema operativo pueda encontrarlos y hacer válidos los destinos de llamada adecuados al cargar una imagen y ajustar sus importaciones. La tabla y el recuento pueden ser 0 si no hay ningún thunk de importación que se haya tomado la dirección.

  Un módulo establece el bit IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags para indicar que ha enumerado todas las direcciones tomadas thunks en la tabla IAT de la dirección tomada y que todas las exportaciones que son aptas para CFG ES se marcan con la marca **IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED GFIDS.** Tenga en cuenta que puede haber cero tales thunks y que también puede haber cero tales símbolos dllexport. Si no se mantiene la tabla IAT de la dirección tomada, puede ser un problema de corrección, ya que es posible que algunos destinos de llamada no sean válidos cuando deben estar en tiempo de carga del archivo DLL.

  Un módulo establece el IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags para indicar que desea habilitar CFG ES para el proceso. En la práctica, esto solo es significativo para las ESE de hoy en día. Un proceso que habilite CFG ES no debe cargar archivos DLL no creados con CFG ES o pueden producirse errores en tiempo de ejecución debido a la dirección no diseñada tomada símbolos IAT. La compatibilidad con la habilitación de CFG ES debe ser una opción opcional independiente de la habilitación de CFG. Proporcionar metadatos de CFG ES es seguro y recomendado de forma predeterminada con CFG, aunque los conjuntos de herramientas deben tener cuidado para asegurarse de que generan metadatos correctos. Si no es así, es posible que las imágenes generadas no se ejecuten correctamente en un proceso de CFG ES. Dicha compatibilidad debe probarse exhaustivamente en un proceso de prueba que aplique CFG ES. Los archivos DLL del sistema operativo integrados admiten metadatos de CFG ES para versiones Windows 10 de sistema operativo modernas que entienden CFG ES. Las versiones del sistema operativo anteriores a esta compatibilidad no entienden en absoluto CFG ES y omitirán las directivas relacionadas con CFG ES en la imagen. Estas imágenes siguen siendo compatibles con versiones anteriores del sistema operativo.

  La compatibilidad con CFG ES es opcional desde la perspectiva del conjunto de herramientas, pero se recomienda que los conjuntos de herramientas incluyan al menos compatibilidad para enumerar la información suficiente para que las imágenes se ejecuten en un proceso que desee CFG ES. Como se mencionó, es fundamental que la compatibilidad con conjuntos de herramientas se compruebe exhaustivamente para asegurarse de que es compatible con CFG ES, ya que la mayoría de los procesos aún no habilitan CFG ES.

## <a name="exception-handling-and-unwinding"></a>Control y desenredo de excepciones

- Los controladores específicos del lenguaje como __C_specific_handler, tal como lo designa la información del controlador de excepciones en un registro .pdata, no deben marcarse como destinos de llamada válidos en la **tabla GFIDS.** En su lugar, se buscan recorriendo la memoria de solo lectura. De forma similar, el controlador específico del lenguaje C de Microsoft usa búsquedas de memoria de solo lectura para buscar funclets para controladores de excepciones y, por tanto, no declara sus funclets como destinos de llamada válidos en la **tabla GFIDS.**

- Control de salto largo (para destinos que no son x86 como AMD64): los conjuntos de herramientas que se compilan con CFG y que admiten setjmp()/longjmp() deben implementar el salto largo como "salto largo seguro" que interopera con el control de excepciones estructurado (SEH). Esto significa que el salto largo se implementa como una llamada a RtlUnwindEx con STATUS_LONGJUMP como código de estado en el registro de excepciones proporcionado y un _JUMP_BUFFER estándar al que apunta ExceptionInformation[0]. El destino de desenredo de salto debe ser targetip del desenredo. El búfer de salto representa el contexto de registro restaurado por el sistema operativo una vez completado el salto largo. RtlUnwind(Ex) cuando se llama con STATUS_LONGJUMP tiene una importancia especial única para CFG. El destino de salto largo (_JUMP_BUFFER. Rasgar o _JUMP_BUFFER. Lr en ARM64) se busca en la lista de módulos cargados que mantiene el sistema operativo en memoria de solo lectura. Si el módulo que contiene el destino de salto (el "módulo de destino") tiene la marca IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT establecida en su campo GuardFlags, el directorio de configuración de carga tiene un elemento GuardLongJumpTargetTable con un recuento de elementos especificado por el campo GuardLongJumpTargetCount de configuración de carga. Esta tabla tiene el mismo formato estructural que la tabla **GFIDS** y usa el mismo mecanismo guardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK para codificar bytes de metadatos adicionales opcionales en la tabla de salto largo. Todos los bytes de metadatos deben ser cero para la tabla de salto largo y están reservados.

  La tabla de saltos largos representa una matriz ordenada de PDA que son destinos de salto largo válidos. Si un módulo de destino de salto largo IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT en su campo GuardFlags, todos los destinos de salto largo deben enumerarse en LongJumpTargetTable. Incluso si un módulo tiene cero destinos de salto largos, todavía debe establecer la marca IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT si el conjunto de herramientas admite la seguridad de salto largo para CFG. Esto significa explícitamente que la imagen no tiene destinos de salto largos y no es una imagen antigua que el sistema operativo debe suponer que podría tener destinos de salto largo válidos en ubicaciones sin marcar para las que no puede realizar la comprobación de destino de salto largo.

  Se recomienda habilitar la seguridad de salto largo de forma predeterminada si se admite CFG. Esta es la disposición de los compiladores de Microsoft. Los sistemas operativos que no comprenden la protección de salto largo (versiones anteriores a la Windows 10 o versiones anteriores de Windows 10) no realizarán comprobaciones de protección de salto largo y omitirán los metadatos de protección de salto largo, por lo que la protección de saltos largos es compatible con versiones anteriores del sistema operativo.

  En el caso de las imágenes en modo kernel, la tabla de destino de salto largo de protección no debe incluirse en una sección descartable. La tabla de destino de salto largo de protección siempre debe almacenarse en la memoria de solo lectura para que sus propiedades de seguridad sean eficaces.

## <a name="coff-information"></a>Información de COFF

- Hay marcas de archivo de objeto para declarar si un archivo de objeto se ajusta a CFG o no. Un archivo de objeto que se ajusta a CFG enumerará los destinos de llamada válidos que genera, explícitamente, así como cualquier dirección tomada metadatos de IAT. Un archivo de objeto que no se ajusta a CFG debe tener destinos de llamada inferidos mediante el examen de las reubicaciones de COFF del archivo obj para buscar reubicaciones que apunten al inicio de un símbolo de función. Esto puede afectar en exceso a los destinos de llamada CFG válidos, por lo que es conveniente que las herramientas marquen sus archivos obj que sean compatibles con CFG e incluyan los metadatos del archivo OBJ de CFG si se compilan con CFG.

- Hay marcas de archivo de objeto para declarar destinos de salto largo para el salto largo de CFG, que se debe rellenar para el modo de compilación CFG.
