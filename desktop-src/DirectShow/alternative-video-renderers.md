---
description: En este tema se describe cómo escribir un representador de vídeo personalizado para DirectShow.
ms.assetid: abba5113-125f-4dac-b566-99c0d9b5978c
title: Representadores de vídeo alternativos
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 070e55375d9d1d5a32c306853aafcb431a76c368
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/06/2021
ms.locfileid: "103806608"
---
# <a name="alternative-video-renderers"></a><span data-ttu-id="8eeaa-103">Representadores de vídeo alternativos</span><span class="sxs-lookup"><span data-stu-id="8eeaa-103">Alternative Video Renderers</span></span>

<span data-ttu-id="8eeaa-104">En este tema se describe cómo escribir un representador de vídeo personalizado para DirectShow.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-104">This topic describes how to write a custom video renderer for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="8eeaa-105">En lugar de escribir un representador de vídeo personalizado, se recomienda escribir un asignador de complemento para el representador de mezcla de vídeo (VMR) o [**Enhanced video renderer**](enhanced-video-renderer-filter.md) (EVR).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-105">Instead of writing a custom video renderer, it is recommended that you write a plug-in allocator-presenter for the Video Mixing Renderer (VMR) or [**Enhanced Video Renderer**](enhanced-video-renderer-filter.md) (EVR).</span></span> <span data-ttu-id="8eeaa-106">Este enfoque le proporcionará todas las ventajas de VMR/EVR, incluida la compatibilidad con la aceleración de vídeo de DirectX (DXVA), el desentrelazado de hardware y la ejecución de fotogramas, y es probable que sea más robusto que un representador de vídeo personalizado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-106">This approach will give you all of the benefits of the VMR/EVR, including support for DirectX Video Acceleration (DXVA), hardware deinterlacing, and frame stepping, and is likely to be more robust than a custom video renderer.</span></span> <span data-ttu-id="8eeaa-107">Para obtener más información, vea los temas siguientes:</span><span class="sxs-lookup"><span data-stu-id="8eeaa-107">For more information, see the following topics:</span></span>
>
> -   [<span data-ttu-id="8eeaa-108">Modo de reproducción no representativo de VMR (asignador personalizado)</span><span class="sxs-lookup"><span data-stu-id="8eeaa-108">VMR Renderless Playback Mode (Custom Allocator-Presenters)</span></span>](vmr-renderless-playback-mode--custom-allocator-presenters.md)
> -   [<span data-ttu-id="8eeaa-109">Cómo escribir un presentador de EVR</span><span class="sxs-lookup"><span data-stu-id="8eeaa-109">How to Write an EVR Presenter</span></span>](/windows/desktop/medfound/how-to-write-an-evr-presenter)

 

## <a name="writing-an-alternative-renderer"></a><span data-ttu-id="8eeaa-110">Escribir un representador alternativo</span><span class="sxs-lookup"><span data-stu-id="8eeaa-110">Writing an Alternative Renderer</span></span>

<span data-ttu-id="8eeaa-111">Microsoft DirectShow proporciona un representador de vídeo basado en ventanas. también proporciona un representador de pantalla completa en la instalación en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-111">Microsoft DirectShow provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation.</span></span> <span data-ttu-id="8eeaa-112">Puede usar las clases base de DirectShow para escribir representadores de vídeo alternativos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-112">You can use the DirectShow base classes to write alternative video renderers.</span></span> <span data-ttu-id="8eeaa-113">Para que los representadores alternativos interactúen correctamente con las aplicaciones basadas en DirectShow, los representadores deben cumplir las directrices descritas en este artículo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-113">For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article.</span></span> <span data-ttu-id="8eeaa-114">Puede usar las clases [**CBaseRenderer**](cbaserenderer.md) y [**CBaseVideoRenderer**](cbasevideorenderer.md) para ayudar a seguir estas instrucciones al implementar una representación de vídeo alternativa.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-114">You can use the [**CBaseRenderer**](cbaserenderer.md) and [**CBaseVideoRenderer**](cbasevideorenderer.md) classes to help follow these guidelines when implementing an alternative video render.</span></span> <span data-ttu-id="8eeaa-115">Debido al desarrollo continuo de DirectShow, revise la implementación periódicamente para asegurarse de que los representadores son compatibles con la versión más reciente de DirectShow.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-115">Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.</span></span>

<span data-ttu-id="8eeaa-116">En este tema se tratan muchas notificaciones que un representador es responsable de controlar.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-116">This topic discusses many notifications that a renderer is responsible for handling.</span></span> <span data-ttu-id="8eeaa-117">Una breve revisión de las notificaciones de DirectShow puede ayudarle a establecer la fase.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-117">A brief review of DirectShow notifications might help to set the stage.</span></span> <span data-ttu-id="8eeaa-118">Esencialmente, hay tres tipos de notificaciones que se producen en DirectShow:</span><span class="sxs-lookup"><span data-stu-id="8eeaa-118">There are essentially three kinds of notifications that occur in DirectShow:</span></span>

-   <span data-ttu-id="8eeaa-119">*Notificaciones de secuencia*, que son eventos que se producen en el flujo multimedia y se pasan de un filtro al siguiente.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-119">*Stream notifications*, which are events that occur in the media stream and are passed from one filter to the next.</span></span> <span data-ttu-id="8eeaa-120">Estas pueden ser el vaciado inicial, el vaciado de final o las notificaciones de final de secuencia y se envían llamando al método adecuado en el PIN de entrada del filtro de nivel inferior (por ejemplo, [**IPin:: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-120">These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the downstream filter's input pin (for example [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span></span>
-   <span data-ttu-id="8eeaa-121">*Filtre las notificaciones de gráficos*, que son eventos enviados desde un filtro al administrador de gráficos de filtro, como la [**\_ finalización de EC**](ec-complete.md).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-121">*Filter graph notifications*, which are events sent from a filter to the Filter Graph Manager such as [**EC\_COMPLETE**](ec-complete.md).</span></span> <span data-ttu-id="8eeaa-122">Esto se logra mediante una llamada al método [**IMediaEventSink:: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) en el administrador de gráficos de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-122">This is accomplished by calling the [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) method on the Filter Graph Manager.</span></span>
-   <span data-ttu-id="8eeaa-123">*Notificaciones de aplicación*, que la aplicación de control recupera del administrador de gráficos de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-123">*Application notifications*, which are retrieved from the Filter Graph Manager by the controlling application.</span></span> <span data-ttu-id="8eeaa-124">Una aplicación llama al método [**IMediaEvent:: GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) en el administrador de gráficos de filtro para recuperar estos eventos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-124">An application calls the [**IMediaEvent::GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) method on the Filter Graph Manager to retrieve these events.</span></span> <span data-ttu-id="8eeaa-125">A menudo, el administrador de gráficos de filtro pasa por los eventos que recibe a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-125">Often, the Filter Graph Manager passes through the events it receives to the application.</span></span>

<span data-ttu-id="8eeaa-126">En este tema se describe la responsabilidad del filtro de representador en el control de las notificaciones de transmisión que recibe y en el envío de notificaciones de gráfico de filtro apropiadas.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-126">This topic discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph notifications.</span></span>

## <a name="handling-end-of-stream-and-flushing-notifications"></a><span data-ttu-id="8eeaa-127">Control de las notificaciones de final de secuencia y de vaciado</span><span class="sxs-lookup"><span data-stu-id="8eeaa-127">Handling End-of-stream and Flushing Notifications</span></span>

<span data-ttu-id="8eeaa-128">Una notificación de final de secuencia comienza en un filtro de nivel superior (como el filtro de origen) cuando ese filtro detecta que no puede enviar más datos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-128">An end-of-stream notification begins at an upstream filter (such as the source filter) when that filter detects that it can send no more data.</span></span> <span data-ttu-id="8eeaa-129">Se pasa por todos los filtros del gráfico y finalmente finaliza en el representador, que es responsable de enviar posteriormente una notificación de [**\_ finalización de EC**](ec-complete.md) al administrador de gráficos de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-129">It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="8eeaa-130">Los representadores tienen responsabilidades especiales cuando se trata de administrar estas notificaciones.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-130">Renderers have special responsibilities when it comes to handling these notifications.</span></span>

<span data-ttu-id="8eeaa-131">Un representador recibe una notificación de final de secuencia cuando el filtro de nivel superior llama al método [**IPin:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) del PIN de entrada.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-131">A renderer receives an end-of-stream notification when its input pin's [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) method is called by the upstream filter.</span></span> <span data-ttu-id="8eeaa-132">Un representador debe anotar esta notificación y continuar representando los datos que ya haya recibido.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-132">A renderer should note this notification and continue to render any data it has already received.</span></span> <span data-ttu-id="8eeaa-133">Una vez que se han recibido todos los datos restantes, el representador debe enviar una notificación de [**\_ finalización de EC**](ec-complete.md) al administrador de gráficos de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-133">Once all remaining data has been received, the renderer should send an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="8eeaa-134">La notificación de finalización de **EC \_** solo debe enviarse una vez por un representador cada vez que llega al final de una secuencia.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-134">The **EC\_COMPLETE** notification should be sent only once by a renderer each time it reaches the end of a stream.</span></span> <span data-ttu-id="8eeaa-135">Además, las notificaciones **\_ completas de EC** nunca deben enviarse, excepto cuando se está ejecutando el gráfico de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-135">Furthermore, **EC\_COMPLETE** notifications must never be sent except when the filter graph is running.</span></span> <span data-ttu-id="8eeaa-136">Por lo tanto, si el gráfico de filtros se pausa cuando un filtro de origen envía una notificación de final de secuencia, no se debe enviar la finalización de **EC \_** hasta que finalmente se ejecute el gráfico de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-136">Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then **EC\_COMPLETE** should not be sent until the filter graph is finally run.</span></span>

<span data-ttu-id="8eeaa-137">Las llamadas a los métodos [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) o [**IMemInputPin:: ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) después de una notificación de final de secuencia se deben rechazar.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-137">Any calls to the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) methods after an end-of-stream notification is signaled should be rejected.</span></span> <span data-ttu-id="8eeaa-138">**E \_ Inesperado** es el mensaje de error más apropiado que se devuelve en este caso.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-138">**E\_UNEXPECTED** is the most appropriate error message to return in this case.</span></span>

<span data-ttu-id="8eeaa-139">Cuando se detiene un gráfico de filtros, se debe borrar cualquier notificación de final de secuencia almacenada en caché y no volver a enviarla cuando se inicie la siguiente.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-139">When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started.</span></span> <span data-ttu-id="8eeaa-140">Esto se debe a que Filter Graph Manager siempre pausa todos los filtros justo antes de ejecutarlos para que se produzca el vaciado adecuado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-140">This is because the Filter Graph Manager always pauses all filters just before running them so that proper flushing occurs.</span></span> <span data-ttu-id="8eeaa-141">Por lo tanto, por ejemplo, si el gráfico de filtros está en pausa y se recibe una notificación de final de secuencia y, a continuación, se detiene el gráfico de filtros, el representador no debe enviar una notificación [**\_ completa de EC**](ec-complete.md) cuando se ejecute posteriormente.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-141">So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an [**EC\_COMPLETE**](ec-complete.md) notification when it is subsequently run.</span></span> <span data-ttu-id="8eeaa-142">Si no se ha producido ninguna búsqueda, el filtro de origen enviará automáticamente otra notificación de final de secuencia durante el estado de pausa que precede a un estado de ejecución.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-142">If no seeks have occurred, the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state.</span></span> <span data-ttu-id="8eeaa-143">Por otro lado, si se ha producido una búsqueda mientras se detiene el gráfico de filtros, el filtro de origen podría tener datos para enviar, por lo que no enviará una notificación de final de secuencia.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-143">If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.</span></span>

<span data-ttu-id="8eeaa-144">Los representadores de vídeo a menudo dependen de las notificaciones de final de secuencia durante más tiempo que el envío de notificaciones [**\_ completas de EC**](ec-complete.md) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-144">Video renderers often depend on end-of-stream notifications for more than the sending of [**EC\_COMPLETE**](ec-complete.md) notifications.</span></span> <span data-ttu-id="8eeaa-145">Por ejemplo, si una secuencia ha terminado de reproducirse (es decir, se envía una notificación de final de secuencia) y se arrastra otra ventana sobre una ventana de representador de vídeo, se generará una serie de mensajes de ventana de [**\_ Paint de WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-145">For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) window messages will be generated.</span></span> <span data-ttu-id="8eeaa-146">La práctica habitual para ejecutar representadores de vídeo es abstenerse de volver a pintar el fotograma actual tras la recepción de los mensajes de **\_ pintura de WM** (en función de la suposición de que se recibirá otro fotograma que se va a dibujar).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-146">The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of **WM\_PAINT** messages (based on the assumption that another frame to be drawn will be received).</span></span> <span data-ttu-id="8eeaa-147">Sin embargo, cuando se ha enviado la notificación de final de secuencia, el representador se encuentra en estado de espera; todavía se está ejecutando pero es consciente de que no recibirá ningún dato adicional.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-147">However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data.</span></span> <span data-ttu-id="8eeaa-148">En estas circunstancias, el representador normalmente dibuja el área de reproducción en negro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-148">Under these circumstances, the renderer customarily draws the playback area black.</span></span>

<span data-ttu-id="8eeaa-149">Controlar el vaciado es una complicación adicional para los representadores.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-149">Handling flushing is an additional complication for renderers.</span></span> <span data-ttu-id="8eeaa-150">El vaciado se lleva a cabo a través de un par de métodos [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) denominados [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) y [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-150">Flushing is carried out through a pair of [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) methods called [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) and [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span> <span data-ttu-id="8eeaa-151">El vaciado es esencialmente un estado adicional que el representador debe controlar.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-151">Flushing is essentially an additional state that the renderer must handle.</span></span> <span data-ttu-id="8eeaa-152">No es válido que un filtro de origen llame a **BeginFlush** sin llamar a **EndFlush**, por lo que espero que el estado sea corto y discreto; sin embargo, el representador debe administrar correctamente los datos o las notificaciones que recibe durante la transición de vaciado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-152">It is illegal for a source filter to call **BeginFlush** without calling **EndFlush**, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.</span></span>

<span data-ttu-id="8eeaa-153">Cualquier dato recibido después de llamar a [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) debe rechazarse inmediatamente devolviendo **S \_ false**.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-153">Any data received after calling [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) should be rejected immediately by returning **S\_FALSE**.</span></span> <span data-ttu-id="8eeaa-154">Además, cualquier notificación de final de secuencia en caché también debe borrarse cuando se vacía un representador.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-154">Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed.</span></span> <span data-ttu-id="8eeaa-155">Un representador se vaciará normalmente como respuesta a una búsqueda.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-155">A renderer will typically be flushed in response to a seek.</span></span> <span data-ttu-id="8eeaa-156">El vaciado garantiza que los datos antiguos se borran del gráfico de filtro antes de que se envíen los ejemplos actualizados.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-156">The flush ensures that old data is cleared from the filter graph before fresh samples are sent.</span></span> <span data-ttu-id="8eeaa-157">(Normalmente, la reproducción de dos secciones de una secuencia, una tras otra, se controla mejor mediante comandos diferidos en lugar de esperar a que finalice una sección y, a continuación, emitir un comando de búsqueda).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-157">(Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.)</span></span>

## <a name="handling-state-changes-and-pause-completion"></a><span data-ttu-id="8eeaa-158">Control de los cambios de estado y pausa de la finalización</span><span class="sxs-lookup"><span data-stu-id="8eeaa-158">Handling State Changes and Pause Completion</span></span>

<span data-ttu-id="8eeaa-159">Un filtro de representador se comporta igual que cualquier otro filtro del gráfico de filtro cuando se cambia su estado, con la siguiente excepción.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-159">A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception.</span></span> <span data-ttu-id="8eeaa-160">Una vez que se haya pausado, el representador tendrá algunos datos en cola, listos para ser representados cuando se ejecuten posteriormente.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-160">After being paused, the renderer will have some data queued, ready to be rendered when subsequently run.</span></span> <span data-ttu-id="8eeaa-161">Cuando se detiene el representador de vídeo, este se mantiene en los datos en cola.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-161">When the video renderer is stopped, it holds on to this queued data.</span></span> <span data-ttu-id="8eeaa-162">Se trata de una excepción a la regla de DirectShow de que los filtros no deben mantener ningún recurso mientras se detiene el gráfico de filtros.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-162">This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.</span></span>

<span data-ttu-id="8eeaa-163">La razón de esta excepción es que, al almacenar los recursos, el representador siempre tendrá una imagen con la que volver a dibujar la ventana si recibe un mensaje de [**\_ dibujo de WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-163">The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message.</span></span> <span data-ttu-id="8eeaa-164">También tiene una imagen para satisfacer métodos, como [**CBaseControlVideo:: GetStaticImage**](cbasecontrolvideo-getstaticimage.md), que solicitan una copia de la imagen actual.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-164">It also has an image to satisfy methods, such as [**CBaseControlVideo::GetStaticImage**](cbasecontrolvideo-getstaticimage.md), that request a copy of the current image.</span></span> <span data-ttu-id="8eeaa-165">Otro efecto de la retención de recursos es que al mantener la imagen se detiene el asignador, lo que, a su vez, hace que el siguiente cambio de estado se realice mucho más rápido porque los búferes de imagen ya están asignados.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-165">Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.</span></span>

<span data-ttu-id="8eeaa-166">Un representador de vídeo debe presentar y publicar los ejemplos solo mientras se ejecuta.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-166">A video renderer should render and release samples only while running.</span></span> <span data-ttu-id="8eeaa-167">Mientras está en pausa, el filtro podría representarlos (por ejemplo, al dibujar una imagen de póster estático en una ventana), pero no debe liberarlas.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-167">While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them.</span></span> <span data-ttu-id="8eeaa-168">Los representadores de audio no realizarán ninguna representación mientras están en pausa (aunque pueden realizar otras actividades, como preparar el dispositivo de onda, por ejemplo).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-168">Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example).</span></span> <span data-ttu-id="8eeaa-169">La hora a la que se deben representar los ejemplos se obtiene combinando el tiempo de flujo en el ejemplo con el tiempo de referencia pasado como un parámetro al método [**IMediaControl:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-169">The time at which the samples should be rendered is obtained by combining the stream time in the sample with the reference time passed as a parameter to the [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) method.</span></span> <span data-ttu-id="8eeaa-170">Los representadores deben rechazar los ejemplos con horas de inicio menores o iguales que las horas de finalización.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-170">Renderers should reject samples with start times less than or equal to end times.</span></span>

<span data-ttu-id="8eeaa-171">Cuando una aplicación pone en pausa un gráfico de filtros, el gráfico de filtros no vuelve de su método [**IMediaControl::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) hasta que haya datos en cola en los representadores.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-171">When an application pauses a filter graph, the filter graph does not return from its [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) method until there is data queued at the renderers.</span></span> <span data-ttu-id="8eeaa-172">Para garantizar esto, cuando un representador está en pausa, debe devolver S \_ false si no hay ningún dato en espera para ser representado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-172">In order to ensure this, when a renderer is paused, it should return S\_FALSE if there is no data waiting to be rendered.</span></span> <span data-ttu-id="8eeaa-173">Si tiene datos en cola, puede devolver **S \_ correctos**.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-173">If it has data queued, then it can return **S\_OK**.</span></span>

<span data-ttu-id="8eeaa-174">Filter Graph Manager comprueba todos los valores devueltos al pausar un gráfico de filtros para asegurarse de que los representadores tengan datos en cola.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-174">The Filter Graph Manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued.</span></span> <span data-ttu-id="8eeaa-175">Si uno o más filtros no están listos, el administrador de gráficos de filtros sondea los filtros del gráfico mediante una llamada a [**IMediaFilter:: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-175">If one or more filters are not ready, then the Filter Graph Manager polls the filters in the graph by calling [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span></span> <span data-ttu-id="8eeaa-176">El método **GetState** toma un parámetro de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-176">The **GetState** method takes a time-out parameter.</span></span> <span data-ttu-id="8eeaa-177">Un filtro (normalmente un representador) que todavía está esperando a que lleguen los datos antes de completar el cambio de estado devuelve el **\_ Estado VFW S \_ \_ intermedia** si el método **GetState** expira.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-177">A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns **VFW\_S\_STATE\_INTERMEDIATE** if the **GetState** method expires.</span></span> <span data-ttu-id="8eeaa-178">Una vez que los datos llegan al representador, **GetState** debe devolverse inmediatamente con **S \_ OK**.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-178">Once data arrives at the renderer, **GetState** should be returned immediately with **S\_OK**.</span></span>

<span data-ttu-id="8eeaa-179">En el estado intermedio y completado, el estado de filtro indicado será en \_ pausa.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-179">In both the intermediate and completed state, the reported filter state will be State\_Paused.</span></span> <span data-ttu-id="8eeaa-180">Solo el valor devuelto indica si el filtro está realmente listo o no.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-180">Only the return value indicates whether the filter is really ready or not.</span></span> <span data-ttu-id="8eeaa-181">Si, mientras un representador está esperando a que lleguen los datos, su filtro de origen envía una notificación de final de secuencia, que también debe completar el cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-181">If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.</span></span>

<span data-ttu-id="8eeaa-182">Una vez que todos los filtros realmente tienen datos en espera de ser representados, el gráfico de filtros completará el cambio de estado de pausa.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-182">Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.</span></span>

## <a name="handling-termination"></a><span data-ttu-id="8eeaa-183">Control de la terminación</span><span class="sxs-lookup"><span data-stu-id="8eeaa-183">Handling Termination</span></span>

<span data-ttu-id="8eeaa-184">Los representadores de vídeo deben controlar correctamente los eventos de finalización del usuario.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-184">Video renderers must correctly handle termination events from the user.</span></span> <span data-ttu-id="8eeaa-185">Esto implica ocultar correctamente la ventana y saber qué hacer si posteriormente se fuerza la presentación de una ventana.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-185">This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed.</span></span> <span data-ttu-id="8eeaa-186">Además, los representadores de vídeo deben notificar al administrador de gráficos de filtro cuando se destruya su ventana (o con más precisión, cuando el representador se quite del gráfico de filtros) libere recursos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-186">Also, video renderers must notify the Filter Graph Manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.</span></span>

<span data-ttu-id="8eeaa-187">Si el usuario cierra la ventana de vídeo (por ejemplo, presionando ALT + F4), la Convención consiste en ocultar la ventana inmediatamente y enviar una [**notificación \_ USERABORT de EC**](ec-userabort.md) al administrador de gráficos de filtros.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-187">If the user closes the video window (for instance by pressing ALT+F4), the convention is to hide the window immediately and send an [**EC\_USERABORT**](ec-userabort.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="8eeaa-188">Esta notificación se pasa a la aplicación, que detendrá la reproducción del gráfico.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-188">This notification is passed through to the application, which will stop the graph playing.</span></span> <span data-ttu-id="8eeaa-189">Después de enviar el **\_ USERABORT de EC**, un representador de vídeo debe rechazar cualquier ejemplo adicional que se le haya entregado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-189">After sending **EC\_USERABORT**, a video renderer should reject any additional samples delivered to it.</span></span>

<span data-ttu-id="8eeaa-190">El representador debe dejar en el representador hasta que se detenga, momento en el que se debe restablecer para que una aplicación pueda invalidar la acción del usuario y seguir reproduciendo el gráfico si lo desea.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-190">The graph-stopped flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an application can override the user action and continue playing the graph if it desires.</span></span> <span data-ttu-id="8eeaa-191">Si se presiona ALT + F4 mientras se está ejecutando el vídeo, se ocultará la ventana y se rechazarán todas las muestras proporcionadas.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-191">If ALT+F4 is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected.</span></span> <span data-ttu-id="8eeaa-192">Si la ventana se muestra posteriormente (quizás a través de [**IVideoWindow::p UT \_ visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), no se deben generar notificaciones de [**\_ Repaint de EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-192">If the window is subsequently shown (perhaps through [**IVideoWindow::put\_Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), then no [**EC\_REPAINT**](ec-repaint.md) notifications should be generated.</span></span>

<span data-ttu-id="8eeaa-193">El representador de vídeo también debe enviar la notificación de la [**ventana de EC \_ \_ destruida**](ec-window-destroyed.md) al gráfico de filtros cuando el representador de vídeo está finalizando.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-193">The video renderer should also send the [**EC\_WINDOW\_DESTROYED**](ec-window-destroyed.md) notification to the filter graph when the video renderer is terminating.</span></span> <span data-ttu-id="8eeaa-194">De hecho, es mejor controlar esto cuando se llama al método [**IBaseFilter:: JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) del representador con un parámetro null (lo que indica que el representador está a punto de quitarse del gráfico de filtro), en lugar de esperar hasta que se destruya la ventana de vídeo real.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-194">In fact, it is best to handle this when the renderer's [**IBaseFilter::JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed.</span></span> <span data-ttu-id="8eeaa-195">El envío de esta notificación permite que el distribuidor del complemento del administrador de gráficos de filtro pase los recursos que dependen del foco de la ventana a otros filtros, como los dispositivos de audio.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-195">Sending this notification enables the plug-in distributor in the Filter Graph Manager to pass on resources that depend on window focus to other filters, such as audio devices.</span></span>

## <a name="handling-dynamic-format-changes"></a><span data-ttu-id="8eeaa-196">Control de los cambios de formato dinámico</span><span class="sxs-lookup"><span data-stu-id="8eeaa-196">Handling Dynamic Format Changes</span></span>

<span data-ttu-id="8eeaa-197">En algunos casos, el filtro de nivel superior del representador podría intentar cambiar el formato de vídeo mientras se reproduce el vídeo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-197">In some cases, the renderer's upstream filter might try to change the video format while the video is playing.</span></span> <span data-ttu-id="8eeaa-198">Suele ser el descompresor de vídeo que inicia un cambio de formato dinámico.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-198">It is most often the video decompressor that initiates a dynamic format change.</span></span>

<span data-ttu-id="8eeaa-199">Un filtro de nivel superior que intenta cambiar los formatos de forma dinámica siempre debe llamar al método [**IPin:: QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) en el PIN de entrada del representador.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-199">An upstream filter attempting to change formats dynamically should always call the [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) method on the renderer input pin.</span></span> <span data-ttu-id="8eeaa-200">Un representador de vídeo tiene algunas libertad en cuanto a los tipos de cambios de formato dinámicos que debe admitir.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-200">A video renderer has some leeway as to what kinds of dynamic format changes it should support.</span></span> <span data-ttu-id="8eeaa-201">Como mínimo, debe permitir que el filtro de nivel superior cambie las paletas.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-201">At a minimum, it should allow the upstream filter to change palettes.</span></span> <span data-ttu-id="8eeaa-202">Cuando un filtro de nivel superior cambia los tipos de medios, adjunta el tipo de medio al primer ejemplo entregado en el nuevo formato.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-202">When an upstream filter changes media types, it attaches the media type to the first sample delivered in the new format.</span></span> <span data-ttu-id="8eeaa-203">Si el representador contiene muestras en una cola para su representación, no debe cambiar el formato hasta que represente el ejemplo con el cambio de tipo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-203">If the renderer holds samples in a queue for rendering, it should not change the format until it renders the sample with the type change.</span></span>

<span data-ttu-id="8eeaa-204">Un representador de vídeo también puede solicitar un cambio de formato desde el descodificador.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-204">A video renderer can also request a format change from the decoder.</span></span> <span data-ttu-id="8eeaa-205">Por ejemplo, podría pedirle al descodificador que proporcione un formato compatible con DirectDraw con una **bialtura** negativa.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-205">For example, it might ask the decoder to provide a DirectDraw-compatible format with a negative **biHeight**.</span></span> <span data-ttu-id="8eeaa-206">Cuando el representador está en pausa, debe llamar a [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) en el PIN de nivel superior para ver qué formatos puede proporcionar el descodificador.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-206">When the renderer is paused, it should call [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) on the upstream pin to see which formats the decoder can provide.</span></span> <span data-ttu-id="8eeaa-207">Sin embargo, es posible que el descodificador no enumere todos los tipos que puede aceptar, por lo que el representador debería ofrecer algunos tipos incluso si el descodificador no los anuncia.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-207">The decoder might not enumerate all of the types that it can accept, however, so the renderer should offer some types even if the decoder does not advertise them.</span></span>

<span data-ttu-id="8eeaa-208">Si el descodificador puede cambiar al formato solicitado, devuelve **S \_** de [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-208">If the decoder can switch to the requested format, it returns **S\_OK** from [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span></span> <span data-ttu-id="8eeaa-209">A continuación, el representador asocia el nuevo tipo de medio al siguiente ejemplo multimedia en el asignador de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-209">The renderer then attaches the new media type to the next media sample on the upstream allocator.</span></span> <span data-ttu-id="8eeaa-210">Para que esto funcione, el representador debe proporcionar un asignador personalizado que implemente un método privado para adjuntar el tipo de medio a la siguiente muestra.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-210">For this to work, the renderer must provide a custom allocator that implements a private method for attaching the media type to the next sample.</span></span> <span data-ttu-id="8eeaa-211">(Dentro de este método privado, llame a [**IMediaSample:: SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) para establecer el tipo).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-211">(Within this private method, call [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to set the type.)</span></span>

<span data-ttu-id="8eeaa-212">El PIN de entrada del representador debe devolver el asignador personalizado del representador en el método [**IMemInputPin:: GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-212">The renderer's input pin should return the renderer's custom allocator in the [**IMemInputPin::GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) method.</span></span> <span data-ttu-id="8eeaa-213">Invalide [**IMemInputPin:: NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) para que se produzca un error si el filtro de nivel superior no usa el asignador del representador.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-213">Override [**IMemInputPin::NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) so that it fails if the upstream filter does not use the renderer's allocator.</span></span>

<span data-ttu-id="8eeaa-214">Con algunos descodificadores, el establecimiento de **biheight** en un número positivo en los tipos YUV hace que el descodificador dibuje la imagen al revés.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-214">With some decoders, setting **biHeight** to a positive number on YUV types causes the decoder to draw the image upside down.</span></span> <span data-ttu-id="8eeaa-215">(Esto es incorrecto y debe considerarse un error en el descodificador).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-215">(This is incorrect, and should be considered a bug in the decoder.)</span></span>

<span data-ttu-id="8eeaa-216">Cada vez que el representador de vídeo detecta un cambio de formato, debe enviar una notificación de [**\_ visualización de \_ cambios de EC**](ec-display-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-216">Whenever a format change is detected by the video renderer, it should send an [**EC\_DISPLAY\_CHANGED**](ec-display-changed.md) notification.</span></span> <span data-ttu-id="8eeaa-217">La mayoría de los representadores de vídeo eligen un formato durante la conexión para que el formato se pueda dibujar eficazmente a través de GDI.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-217">Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI.</span></span> <span data-ttu-id="8eeaa-218">Si el usuario cambia el modo de presentación actual sin reiniciar el equipo, un representador podría encontrarse con una conexión de formato de imagen incorrecta y debería enviar esta notificación.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-218">If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification.</span></span> <span data-ttu-id="8eeaa-219">El primer parámetro debe ser el PIN que necesita volver a conectarse.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-219">The first parameter should be the pin that needs reconnecting.</span></span> <span data-ttu-id="8eeaa-220">Filter Graph Manager organizará el gráfico de filtro para que se detenga y el PIN se vuelva a conectar.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-220">The Filter Graph Manager will arrange for the filter graph to be stopped and the pin reconnected.</span></span> <span data-ttu-id="8eeaa-221">Durante la reconexión posterior, el representador puede aceptar un formato más adecuado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-221">During the subsequent reconnection, the renderer can accept a more appropriate format.</span></span>

<span data-ttu-id="8eeaa-222">Siempre que un representador de vídeo detecta un cambio de paleta en la secuencia, debe enviar la notificación de cambio de la [**\_ \_ paleta de EC**](ec-palette-changed.md) al administrador de gráficos de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-222">Whenever a video renderer detects a palette change in the stream it should send the [**EC\_PALETTE\_CHANGED**](ec-palette-changed.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="8eeaa-223">Los representadores de vídeo de DirectShow detectan si una paleta ha cambiado realmente en formato dinámico o no.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-223">The DirectShow video renderers detect whether a palette has really changed in dynamic format or not.</span></span> <span data-ttu-id="8eeaa-224">Los representadores de vídeo lo hacen no solo para filtrar el número de notificaciones de la **paleta de EC que \_ \_ han cambiado** , sino también para reducir la cantidad de creación de paletas, la instalación y la eliminación necesarias.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-224">The video renderers do this not only to filter out the number of **EC\_PALETTE\_CHANGED** notifications sent but also to reduce the amount of palette creation, installation, and deletion required.</span></span>

<span data-ttu-id="8eeaa-225">Por último, el representador de vídeo también podría detectar que el tamaño del vídeo ha cambiado, en cuyo caso debe enviar la notificación de [**cambio de tamaño de vídeo de EC \_ \_ \_**](ec-video-size-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-225">Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the [**EC\_VIDEO\_SIZE\_CHANGED**](ec-video-size-changed.md) notification.</span></span> <span data-ttu-id="8eeaa-226">Una aplicación podría usar esta notificación para negociar el espacio en un documento compuesto.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-226">An application might use this notification to negotiate space in a compound document.</span></span> <span data-ttu-id="8eeaa-227">Las dimensiones de vídeo reales están disponibles a través de la interfaz de control [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-227">The actual video dimensions are available through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) control interface.</span></span> <span data-ttu-id="8eeaa-228">Los representadores de DirectShow detectan si el vídeo ha cambiado de tamaño o no antes de enviar estos eventos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-228">The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.</span></span>

## <a name="handling-persistent-properties"></a><span data-ttu-id="8eeaa-229">Controlar propiedades persistentes</span><span class="sxs-lookup"><span data-stu-id="8eeaa-229">Handling Persistent Properties</span></span>

<span data-ttu-id="8eeaa-230">Todas las propiedades que se establecen a través de las interfaces [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) y [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) están pensadas para ser persistentes entre conexiones.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-230">All properties set through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) interfaces are meant to be persistent across connections.</span></span> <span data-ttu-id="8eeaa-231">Por lo tanto, desconectar y volver a conectar un representador no debe mostrar ningún efecto en el tamaño, la posición o los estilos de la ventana.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-231">Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles.</span></span> <span data-ttu-id="8eeaa-232">Sin embargo, si las dimensiones de vídeo cambian entre las conexiones, el representador debe restablecer los rectángulos de origen y de destino a sus valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-232">However, if the video dimensions change between connections, the renderer should reset the source and destination rectangles to their defaults.</span></span> <span data-ttu-id="8eeaa-233">Las posiciones de origen y destino se establecen a través de la interfaz **IBasicVideo** .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-233">The source and destination positions are set through the **IBasicVideo** interface.</span></span>

<span data-ttu-id="8eeaa-234">Tanto [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) como [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) proporcionan un acceso suficiente a las propiedades para permitir que una aplicación guarde y restaure todos los datos de la interfaz en un formato persistente.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-234">Both [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format.</span></span> <span data-ttu-id="8eeaa-235">Esto resultará útil para las aplicaciones que deben guardar la configuración exacta y las propiedades de los gráficos de filtros durante una sesión de edición y restaurarlos más adelante.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-235">This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.</span></span>

## <a name="handling-ec_repaint-notifications"></a><span data-ttu-id="8eeaa-236">Control de \_ notificaciones de REpintar de EC</span><span class="sxs-lookup"><span data-stu-id="8eeaa-236">Handling EC\_REPAINT Notifications</span></span>

<span data-ttu-id="8eeaa-237">La notificación de [**\_ Repaint de EC**](ec-repaint.md) solo se envía cuando el representador está en pausa o detenido.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-237">The [**EC\_REPAINT**](ec-repaint.md) notification is sent only when the renderer is either paused or stopped.</span></span> <span data-ttu-id="8eeaa-238">Esta notificación indica al administrador de gráficos de filtro que el representador necesita datos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-238">This notification signals to the Filter Graph Manager that the renderer needs data.</span></span> <span data-ttu-id="8eeaa-239">Si el gráfico de filtros se detiene cuando recibe una de estas notificaciones, pausará el gráfico de filtros, esperará a que todos los filtros reciban datos (mediante una llamada a [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)) y, a continuación, lo detendrán de nuevo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-239">If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), and then stop it again.</span></span> <span data-ttu-id="8eeaa-240">Cuando se detiene, un representador de vídeo debe conservar la imagen para que se puedan controlar los mensajes de [**\_ pintura de WM**](/windows/desktop/gdi/wm-paint) posteriores.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-240">When stopped, a video renderer should hold on to the image so that subsequent [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages can be handled.</span></span>

<span data-ttu-id="8eeaa-241">Por lo tanto, si un representador de vídeo recibe un mensaje de [**\_ dibujo de WM**](/windows/desktop/gdi/wm-paint) cuando está detenido o en pausa, y no tiene nada con el que pintar su ventana, debe enviar el redibujo de EC al administrador de gráficos de filtro. [**\_**](ec-repaint.md)</span><span class="sxs-lookup"><span data-stu-id="8eeaa-241">Therefore, if a video renderer receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message when stopped or paused, and it has nothing with which to paint its window, then it should send [**EC\_REPAINT**](ec-repaint.md) to the Filter Graph Manager.</span></span> <span data-ttu-id="8eeaa-242">Si se recibe una notificación de **\_ repintar de EC** mientras está en pausa, el administrador de gráficos de filtros llama a [**IMediaPosition::p UT \_ CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) con la posición actual (es decir, busca en la posición actual).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-242">If an **EC\_REPAINT** notification is received while paused, then the Filter Graph Manager calls [**IMediaPosition::put\_CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) with the current position (that is, seeks to the current position).</span></span> <span data-ttu-id="8eeaa-243">Esto hace que los filtros de origen vacíen el gráfico de filtro y hace que se envíen nuevos datos a través del gráfico de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-243">This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.</span></span>

<span data-ttu-id="8eeaa-244">Un representador solo debe enviar una de estas notificaciones a la vez.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-244">A renderer must send only one of these notifications at a time.</span></span> <span data-ttu-id="8eeaa-245">Por lo tanto, una vez que el representador envía una notificación, debe asegurarse de que no se envíen más hasta que se entreguen algunos ejemplos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-245">Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered.</span></span> <span data-ttu-id="8eeaa-246">La manera convencional de hacerlo es tener una marca para indicar que se puede enviar un recorte, que se desactiva después de enviar una notificación de [**\_ repintar de EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-246">The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an [**EC\_REPAINT**](ec-repaint.md) notification is sent.</span></span> <span data-ttu-id="8eeaa-247">Esta marca debe restablecerse una vez que se entreguen los datos o cuando se vacíe el PIN de entrada, pero no si el final de la secuencia se señala en el PIN de entrada.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-247">This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.</span></span>

<span data-ttu-id="8eeaa-248">Si el representador no supervisa sus notificaciones de [**\_ Repaint de EC**](ec-repaint.md) , desbordará el administrador de gráficos de filtro con solicitudes de **\_ repintar de EC** (que son relativamente costosas de procesar).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-248">If the renderer does not monitor its [**EC\_REPAINT**](ec-repaint.md) notifications, it will flood the Filter Graph Manager with **EC\_REPAINT** requests (which are relatively expensive to process).</span></span> <span data-ttu-id="8eeaa-249">Por ejemplo, si un representador no tiene ninguna imagen para dibujar y se arrastra otra ventana por la ventana del representador en una operación de arrastre completo, el representador recibe varios mensajes de [**\_ pintura de WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-249">For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages.</span></span> <span data-ttu-id="8eeaa-250">Solo el primero de ellos debe generar una notificación de evento de **EC \_ Repaint** desde el representador al administrador de gráficos de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-250">Only the first of these should generate an **EC\_REPAINT** event notification from the renderer to the Filter Graph Manager.</span></span>

<span data-ttu-id="8eeaa-251">Un representador debe enviar su PIN de entrada como primer parámetro a la notificación de [**\_ Repaint de EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-251">A renderer should send its input pin as the first parameter to the [**EC\_REPAINT**](ec-repaint.md) notification.</span></span> <span data-ttu-id="8eeaa-252">Al hacerlo, se consultará la clavija de salida adjunta para [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink)y, si se admite, la notificación de **\_ repintar de EC** se enviará en primer lugar.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-252">By doing this, the attached output pin will be queried for [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), and if supported, the **EC\_REPAINT** notification will be sent there first.</span></span> <span data-ttu-id="8eeaa-253">Esto permite que los pin de salida controlen los retoques antes de que se deba tocar el gráfico de filtro.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-253">This enables output pins to handle repaints before the filter graph must be touched.</span></span> <span data-ttu-id="8eeaa-254">Esto no se realizará si el gráfico de filtros se detiene, porque no hay ningún búfer disponible en el asignador de representador desasignado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-254">This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.</span></span>

<span data-ttu-id="8eeaa-255">Si el PIN de salida no puede controlar la solicitud y el gráfico de filtros se está ejecutando, se omite la notificación de [**\_ repintar de EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="8eeaa-255">If the output pin cannot handle the request and the filter graph is running, then the [**EC\_REPAINT**](ec-repaint.md) notification is ignored.</span></span> <span data-ttu-id="8eeaa-256">Un PIN de salida debe devolver **S \_ OK** desde [**IMediaEventSink:: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) para indicar que ha procesado la solicitud Repaint correctamente.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-256">An output pin must return **S\_OK** from [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) to signal that it processed the repaint request successfully.</span></span> <span data-ttu-id="8eeaa-257">Se llamará al pin de salida en el subproceso de trabajo del administrador de gráficos de filtro, lo que evita que el representador llame directamente al pin de salida y, por tanto, evita cualquier problema de interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-257">The output pin will be called on the Filter Graph Manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues.</span></span> <span data-ttu-id="8eeaa-258">Si el gráfico de filtro está detenido o en pausa y la salida no controla la solicitud, se realiza el procesamiento predeterminado.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-258">If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.</span></span>

## <a name="handling-notifications-in-full-screen-mode"></a><span data-ttu-id="8eeaa-259">Control de notificaciones en modo de Full-Screen</span><span class="sxs-lookup"><span data-stu-id="8eeaa-259">Handling Notifications in Full-Screen Mode</span></span>

<span data-ttu-id="8eeaa-260">El distribuidor de complementos de [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) (PID) del gráfico de filtros administra la reproducción a pantalla completa.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-260">The [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) plug-in distributor (PID) in the filter graph manages full-screen playback.</span></span> <span data-ttu-id="8eeaa-261">Cambiará un representador de vídeo para un representador de pantalla completa especialista, ajustará una ventana de un representador a la pantalla completa o hará que el representador implemente directamente la reproducción de pantalla completa.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-261">It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer implement full-screen playback directly.</span></span> <span data-ttu-id="8eeaa-262">Para interactuar en los protocolos de pantalla completa, un representador de vídeo debe enviar una notificación de [**\_ activación de EC**](ec-activate.md) siempre que su ventana esté activada o desactivada.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-262">To interact in full-screen protocols, a video renderer should send an [**EC\_ACTIVATE**](ec-activate.md) notification whenever its window is either activated or deactivated.</span></span> <span data-ttu-id="8eeaa-263">En otras palabras, se debe enviar una notificación de **\_ activación de EC** para cada mensaje de ACTIVATEAPP de WM que \_ reciba un representador.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-263">In other words, an **EC\_ACTIVATE** notification should be sent for each WM\_ACTIVATEAPP message a renderer receives.</span></span>

<span data-ttu-id="8eeaa-264">Cuando se usa un representador en el modo de pantalla completa, estas notificaciones administran el cambio dentro y fuera del modo de pantalla completa.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-264">When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode.</span></span> <span data-ttu-id="8eeaa-265">La desactivación de la ventana suele producirse cuando un usuario presiona ALT + TAB para cambiar a otra ventana, que el representador de pantalla completa de DirectShow usa como indicación para volver al modo de representación típico.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-265">Window deactivation typically occurs when a user presses ALT+TAB to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.</span></span>

<span data-ttu-id="8eeaa-266">Cuando se envía la notificación de [**\_ activación de EC**](ec-activate.md) al administrador de gráficos de filtros al desactivar el modo de pantalla completa, el administrador de gráficos de filtros envía una notificación de [**\_ \_ pérdida de pantalla completa de EC**](ec-fullscreen-lost.md) a la aplicación de control.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-266">When the [**EC\_ACTIVATE**](ec-activate.md) notification is sent to the Filter Graph Manager upon switching out of full-screen mode, the Filter Graph Manager sends an [**EC\_FULLSCREEN\_LOST**](ec-fullscreen-lost.md) notification to the controlling application.</span></span> <span data-ttu-id="8eeaa-267">La aplicación podría usar esta notificación para restaurar el estado de un botón de pantalla completa, por ejemplo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-267">The application might use this notification to restore the state of a full-screen button, for example.</span></span> <span data-ttu-id="8eeaa-268">DirectShow usa internamente las notificaciones de **\_ activación de EC** para administrar el cambio de pantalla completa de las pilas de los representadores de vídeo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-268">The **EC\_ACTIVATE** notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers.</span></span>

## <a name="summary-of-notifications"></a><span data-ttu-id="8eeaa-269">Resumen de notificaciones</span><span class="sxs-lookup"><span data-stu-id="8eeaa-269">Summary of Notifications</span></span>

<span data-ttu-id="8eeaa-270">En esta sección se enumeran las notificaciones de gráficos de filtro que puede enviar un representador.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-270">This section lists the filter graph notifications that a renderer can send.</span></span>



| <span data-ttu-id="8eeaa-271">Notificación de evento</span><span class="sxs-lookup"><span data-stu-id="8eeaa-271">Event notification</span></span>                                        | <span data-ttu-id="8eeaa-272">Descripción</span><span class="sxs-lookup"><span data-stu-id="8eeaa-272">Description</span></span>                                                                                                                                                                                       |
|-----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="8eeaa-273">**activación de EC \_**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-273">**EC\_ACTIVATE**</span></span>](ec-activate.md)                       | <span data-ttu-id="8eeaa-274">Lo envían los representadores de vídeo en el modo de representación de pantalla completa para cada mensaje de ACTIVATEAPP de WM \_ recibido.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-274">Sent by video renderers in full-screen rendering mode for each WM\_ACTIVATEAPP message received.</span></span>                                                                                                  |
| [<span data-ttu-id="8eeaa-275">**EC \_ completado**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-275">**EC\_COMPLETE**</span></span>](ec-complete.md)                       | <span data-ttu-id="8eeaa-276">Lo envían los representadores una vez representados todos los datos.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-276">Sent by renderers after all data has been rendered.</span></span>                                                                                                                                               |
| [<span data-ttu-id="8eeaa-277">**visualización de EC \_ \_ modificada**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-277">**EC\_DISPLAY\_CHANGED**</span></span>](ec-display-changed.md)        | <span data-ttu-id="8eeaa-278">Lo envían los representadores de vídeo cuando cambia el formato de presentación.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-278">Sent by video renderers when a display format changes.</span></span>                                                                                                                                            |
| [<span data-ttu-id="8eeaa-279">**paleta de EC \_ \_ modificada**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-279">**EC\_PALETTE\_CHANGED**</span></span>](ec-palette-changed.md)        | <span data-ttu-id="8eeaa-280">Se envía cuando un representador de vídeo detecta un cambio de paleta en la secuencia.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-280">Sent whenever a video renderer detects a palette change in the stream.</span></span>                                                                                                                            |
| [<span data-ttu-id="8eeaa-281">**repintar EC \_**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-281">**EC\_REPAINT**</span></span>](ec-repaint.md)                         | <span data-ttu-id="8eeaa-282">Enviado por representadores de vídeo detenidos o en pausa cuando \_ se recibe un mensaje de pintura de WM y no hay datos para mostrar.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-282">Sent by stopped or paused video renderers when a WM\_PAINT message is received and there is no data to display.</span></span> <span data-ttu-id="8eeaa-283">Esto hace que Filter Graph Manager genere un marco para pintar en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-283">This causes the Filter Graph Manager to generate a frame to paint to the display.</span></span> |
| [<span data-ttu-id="8eeaa-284">**USERABORT de EC \_**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-284">**EC\_USERABORT**</span></span>](ec-userabort.md)                     | <span data-ttu-id="8eeaa-285">Lo envían los representadores de vídeo para indicar un cierre que el usuario solicitó (por ejemplo, un usuario que cierra la ventana de vídeo).</span><span class="sxs-lookup"><span data-stu-id="8eeaa-285">Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window).</span></span>                                                                               |
| [<span data-ttu-id="8eeaa-286">**tamaño de vídeo de EC \_ \_ \_ cambiado**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-286">**EC\_VIDEO\_SIZE\_CHANGED**</span></span>](ec-video-size-changed.md) | <span data-ttu-id="8eeaa-287">Lo envían los representadores de vídeo siempre que se detecta un cambio en el tamaño de vídeo nativo.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-287">Sent by video renderers whenever a change in native video size is detected.</span></span>                                                                                                                       |
| [<span data-ttu-id="8eeaa-288">**ventana de EC \_ \_ destruida**</span><span class="sxs-lookup"><span data-stu-id="8eeaa-288">**EC\_WINDOW\_DESTROYED**</span></span>](ec-window-destroyed.md)      | <span data-ttu-id="8eeaa-289">Lo envían los representadores de vídeo cuando se quita o se destruye el filtro para que los recursos que dependen del foco de ventana se puedan pasar a otros filtros.</span><span class="sxs-lookup"><span data-stu-id="8eeaa-289">Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.</span></span>                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="8eeaa-290">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="8eeaa-290">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8eeaa-291">Escritura de representadores de vídeo</span><span class="sxs-lookup"><span data-stu-id="8eeaa-291">Writing Video Renderers</span></span>](writing-video-renderers.md)
</dt> </dl>

 

 
