---
description: En las secciones siguientes se describe cómo Direct3D controla las conversiones entre los tipos de datos.
ms.assetid: 454d3fd0-fc0f-46a9-925e-13f8e3c39f02
title: Reglas de conversión de datos
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 61abdc58811af9155c67d7b32bcd47e9d4b71ea5
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "103807351"
---
# <a name="data-conversion-rules"></a><span data-ttu-id="ba626-103">Reglas de conversión de datos</span><span class="sxs-lookup"><span data-stu-id="ba626-103">Data Conversion Rules</span></span>

<span data-ttu-id="ba626-104">En las secciones siguientes se describe cómo Direct3D controla las conversiones entre los tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="ba626-104">The following sections describe how Direct3D handles conversions between data types.</span></span>

-   [<span data-ttu-id="ba626-105">Terminología de tipos de datos</span><span class="sxs-lookup"><span data-stu-id="ba626-105">Data Type Terminology</span></span>](#data-type-terminology)
-   [<span data-ttu-id="ba626-106">Conversión de punto flotante</span><span class="sxs-lookup"><span data-stu-id="ba626-106">Floating Point Conversion</span></span>](#floating-point-conversion)
    -   [<span data-ttu-id="ba626-107">Conververting de una representación de rango superior a una representación de rango inferior</span><span class="sxs-lookup"><span data-stu-id="ba626-107">Conververting from a higher range representation to a lower range representation</span></span>](#conververting-from-a-higher-range-representation-to-a-lower-range-representation)
    -   [<span data-ttu-id="ba626-108">Convertir una representación de rango inferior en una representación de rango superior</span><span class="sxs-lookup"><span data-stu-id="ba626-108">Converting from a lower range representation to a higher range representation</span></span>](#converting-from-a-lower-range-representation-to-a-higher-range-representation)
-   [<span data-ttu-id="ba626-109">Conversión de enteros</span><span class="sxs-lookup"><span data-stu-id="ba626-109">Integer Conversion</span></span>](#integer-conversion)
-   [<span data-ttu-id="ba626-110">Conversión de enteros de punto fijo</span><span class="sxs-lookup"><span data-stu-id="ba626-110">Fixed Point Integer Conversion</span></span>](#fixed-point-integer-conversion)
-   [<span data-ttu-id="ba626-111">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="ba626-111">Related topics</span></span>](#related-topics)

## <a name="data-type-terminology"></a><span data-ttu-id="ba626-112">Terminología de tipos de datos</span><span class="sxs-lookup"><span data-stu-id="ba626-112">Data Type Terminology</span></span>

<span data-ttu-id="ba626-113">El siguiente conjunto de términos se utiliza posteriormente para caracterizar varias conversiones de formato.</span><span class="sxs-lookup"><span data-stu-id="ba626-113">The following set of terms are subsequently used to characterize various format conversions.</span></span>



| <span data-ttu-id="ba626-114">Término</span><span class="sxs-lookup"><span data-stu-id="ba626-114">Term</span></span>  | <span data-ttu-id="ba626-115">Definición</span><span class="sxs-lookup"><span data-stu-id="ba626-115">Definition</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="ba626-116">SNORM</span><span class="sxs-lookup"><span data-stu-id="ba626-116">SNORM</span></span> | <span data-ttu-id="ba626-117">Entero normalizado con signo, lo que significa que para un número de complemento de n bits 2, el valor máximo significa 1,0 f (por ejemplo, el valor de 5 bits 01111 se asigna a 1,0 f) y el valor mínimo significa-1,0 f (por ejemplo, el valor de 5 bits 10000 se asigna a-1,0 f).</span><span class="sxs-lookup"><span data-stu-id="ba626-117">Signed normalized integer, meaning that for an n-bit 2's complement number, the maximum value means 1.0f (e.g. the 5-bit value 01111 maps to 1.0f), and the minimum value means -1.0f (e.g. the 5-bit value 10000 maps to -1.0f).</span></span> <span data-ttu-id="ba626-118">Además, el segundo número mínimo se asigna a-1,0 f (por ejemplo, el valor de 5 bits 10001 se asigna a-1,0 f).</span><span class="sxs-lookup"><span data-stu-id="ba626-118">In addition, the second-minimum number maps to -1.0f (e.g. the 5-bit value 10001 maps to -1.0f).</span></span> <span data-ttu-id="ba626-119">Por tanto, hay dos representaciones enteras para-1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-119">There are thus two integer representations for -1.0f.</span></span> <span data-ttu-id="ba626-120">Hay una única representación para 0.0 f y una única representación para 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-120">There is a single representation for 0.0f, and a single representation for 1.0f.</span></span> <span data-ttu-id="ba626-121">Esto da como resultado un conjunto de representaciones enteras para los valores de punto flotante con espaciado uniforme en el intervalo (-1,0 f... 0.0 f) y también un conjunto complementario de representaciones para números en el intervalo (0,0 f... 1,0 f)</span><span class="sxs-lookup"><span data-stu-id="ba626-121">This results in a set of integer representations for evenly spaced floating point values in the range (-1.0f...0.0f), and also a complementary set of representations for numbers in the range (0.0f...1.0f)</span></span> |
| <span data-ttu-id="ba626-122">UNORM</span><span class="sxs-lookup"><span data-stu-id="ba626-122">UNORM</span></span> | <span data-ttu-id="ba626-123">Entero normalizado sin signo, lo que significa que para un número de n bits, el valor de 0 significa 0,0 f y el de los 1 significa 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-123">Unsigned normalized integer, meaning that for an n-bit number, all 0's means 0.0f, and all 1's means 1.0f.</span></span> <span data-ttu-id="ba626-124">Se representa una secuencia de valores de punto flotante de espaciado uniforme entre 0,0 y 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-124">A sequence of evenly spaced floating point values from 0.0f to 1.0f are represented.</span></span> <span data-ttu-id="ba626-125">por ejemplo, un UNORM de 2 bits representa 0,0 f, 1/3, 2/3 y 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-125">e.g. a 2-bit UNORM represents 0.0f, 1/3, 2/3, and 1.0f.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="ba626-126">San</span><span class="sxs-lookup"><span data-stu-id="ba626-126">SINT</span></span>  | <span data-ttu-id="ba626-127">Entero con signo.</span><span class="sxs-lookup"><span data-stu-id="ba626-127">Signed integer.</span></span> <span data-ttu-id="ba626-128">número entero del complemento 2.</span><span class="sxs-lookup"><span data-stu-id="ba626-128">2's complement integer.</span></span> <span data-ttu-id="ba626-129">por ejemplo, un SINT de 3 bits representa los valores enteros-4,-3,-2,-1, 0, 1, 2, 3.</span><span class="sxs-lookup"><span data-stu-id="ba626-129">e.g. an 3-bit SINT represents the integral values -4, -3, -2, -1, 0, 1, 2, 3.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="ba626-130">UINT</span><span class="sxs-lookup"><span data-stu-id="ba626-130">UINT</span></span>  | <span data-ttu-id="ba626-131">Entero sin signo.</span><span class="sxs-lookup"><span data-stu-id="ba626-131">Unsigned integer.</span></span> <span data-ttu-id="ba626-132">por ejemplo, un UINT de 3 bits representa los valores enteros 0, 1, 2, 3, 4, 5, 6, 7.</span><span class="sxs-lookup"><span data-stu-id="ba626-132">e.g. a 3-bit UINT represents the integral values 0, 1, 2, 3, 4, 5, 6, 7.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="ba626-133">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-133">FLOAT</span></span> | <span data-ttu-id="ba626-134">Un valor de punto flotante en cualquiera de las representaciones definidas por Direct3D.</span><span class="sxs-lookup"><span data-stu-id="ba626-134">A floating-point value in any of the representations defined by Direct3D.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="ba626-135">SRGB</span><span class="sxs-lookup"><span data-stu-id="ba626-135">SRGB</span></span>  | <span data-ttu-id="ba626-136">Similar a UNORM, en que para un número de n bits, todo el valor de 0 significa 0,0 f y el de 1 significa 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-136">Similar to UNORM, in that for an n-bit number, all 0's means 0.0f and all 1's means 1.0f.</span></span> <span data-ttu-id="ba626-137">Sin embargo, a diferencia de UNORM, con SRGB, la secuencia de codificaciones de enteros sin signo entre 0 a todos los 1 representa una progresión no lineal en la interpretación de punto flotante de los números, entre 0,0 f y 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-137">However unlike UNORM, with SRGB the sequence of unsigned integer encodings between all 0's to all 1's represent a nonlinear progression in the floating point interpretation of the numbers, between 0.0f to 1.0f.</span></span> <span data-ttu-id="ba626-138">Aproximadamente, si esta progresión no lineal, SRGB, se muestra como una secuencia de colores, aparecería como una rampa lineal de niveles de luminosidad a un observador "promedio", en "Average" condiciones de visualización, en una pantalla de "promedio".</span><span class="sxs-lookup"><span data-stu-id="ba626-138">Roughly, if this nonlinear progression, SRGB, is displayed as a sequence of colors, it would appear as a linear ramp of luminosity levels to an "average" observer, under "average" viewing conditions, on an "average" display.</span></span> <span data-ttu-id="ba626-139">Para obtener detalles completos, consulte el estándar de color SRGB, IEC 61996-2-1, en IEC (Comisión electrotécnica internacional (CEI)).</span><span class="sxs-lookup"><span data-stu-id="ba626-139">For complete detail, refer to the SRGB color standard, IEC 61996-2-1, at IEC (International Electrotechnical Commission).</span></span>                |



 

## <a name="floating-point-conversion"></a><span data-ttu-id="ba626-140">Conversión de punto flotante</span><span class="sxs-lookup"><span data-stu-id="ba626-140">Floating Point Conversion</span></span>

<span data-ttu-id="ba626-141">Siempre que se produce una conversión de punto flotante entre distintas representaciones, incluidas las representaciones de punto no flotante o desde ellas, se aplican las reglas siguientes.</span><span class="sxs-lookup"><span data-stu-id="ba626-141">Whenever a floating point conversion between different representations occurs, including to or from non-floating point representations, the following rules apply.</span></span>

### <a name="conververting-from-a-higher-range-representation-to-a-lower-range-representation"></a><span data-ttu-id="ba626-142">Conververting de una representación de rango superior a una representación de rango inferior</span><span class="sxs-lookup"><span data-stu-id="ba626-142">Conververting from a higher range representation to a lower range representation</span></span>

-   <span data-ttu-id="ba626-143">El redondeo a cero se usa durante la conversión a otro formato de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="ba626-143">Round-to-zero is used during conversion to another float format.</span></span> <span data-ttu-id="ba626-144">Si el destino es un formato de número entero o de punto fijo, se usa la operación de redondeo a la más cercana, a menos que la conversión esté documentada explícitamente como si se usara otro comportamiento de redondeo, por ejemplo, de redondeo a SNORM, FLOAT a UNORM o FLOAT a SRGB.</span><span class="sxs-lookup"><span data-stu-id="ba626-144">If the target is an integer or fixed point format, round-to-nearest-even is used, unless the conversion is explicitly documented as using another rounding behavior, such as round-to-nearest for FLOAT to SNORM, FLOAT to UNORM or FLOAT to SRGB.</span></span> <span data-ttu-id="ba626-145">Otras excepciones son las instrucciones del sombreador ftoi y ftou, que usan un redondeo a cero.</span><span class="sxs-lookup"><span data-stu-id="ba626-145">Other exceptions are the ftoi and ftou shader instructions, which use round-to-zero.</span></span> <span data-ttu-id="ba626-146">Por último, las conversiones de punto flotante a fijo usadas por el muestreador y el rasterizador de texturas tienen una tolerancia especificada que se mide en el último lugar de una versión ideal infinitamente.</span><span class="sxs-lookup"><span data-stu-id="ba626-146">Finally, the float-to-fixed conversions used by the texture sampler and rasterizer have a specified tolerance measured in Unit-Last-Place from an infinitely precise ideal.</span></span>
-   <span data-ttu-id="ba626-147">Para los valores de origen mayores que el intervalo dinámico de un formato de destino de rango inferior (por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="ba626-147">For source values greater than the dynamic range of a lower range target format (eg.</span></span> <span data-ttu-id="ba626-148">un valor Float de 32 bits grande se escribe en un RenderTarget Float de 16 bits, el valor máximo que se pueda representar (con la firma adecuada), sin incluir el infinito con signo (debido al redondeo a cero descrito anteriormente).</span><span class="sxs-lookup"><span data-stu-id="ba626-148">a large 32-bit float value is written into a 16-bit float RenderTarget), the maximum representable (appropriately signed) value results, NOT including signed infinity (due to the round to zero described above).</span></span>
-   <span data-ttu-id="ba626-149">Los NaN con un formato de intervalo más alto se convertirán en una representación de NaN en el formato de intervalo inferior si la representación NaN existe en el formato de intervalo inferior.</span><span class="sxs-lookup"><span data-stu-id="ba626-149">NaN in a higher range format will be converted to NaN representation in the lower range format if the NaN representation exists in the lower range format.</span></span> <span data-ttu-id="ba626-150">Si el formato inferior no tiene una representación NaN, el resultado será 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-150">If the lower format does not have a NaN representation, the result will be 0.</span></span>
-   <span data-ttu-id="ba626-151">INF en un formato de intervalo superior se convertirá a INF en el formato de intervalo inferior, si está disponible.</span><span class="sxs-lookup"><span data-stu-id="ba626-151">INF in a higher range format will be converted to INF in the lower range format if available.</span></span> <span data-ttu-id="ba626-152">Si el formato inferior no tiene una representación de INF, se convertirá en el valor máximo que se puede representar.</span><span class="sxs-lookup"><span data-stu-id="ba626-152">If the lower format does not have an INF representation, it will be converted to the maximum value representable.</span></span> <span data-ttu-id="ba626-153">El signo se conservará si está disponible en el formato de destino.</span><span class="sxs-lookup"><span data-stu-id="ba626-153">The sign will be preserved if available in the target format.</span></span>
-   <span data-ttu-id="ba626-154">La desnormada en un formato de intervalo superior se convertirá a la representación de desnormativa en el formato de intervalo inferior si está disponible en el formato de intervalo inferior y la conversión es posible; de lo contrario, el resultado es 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-154">Denorm in a higher range format will be converted to the Denorm representation in the lower range format if available in the lower range format and the conversion is possible, otherwise the result is 0.</span></span> <span data-ttu-id="ba626-155">El bit de signo se conservará si está disponible en el formato de destino.</span><span class="sxs-lookup"><span data-stu-id="ba626-155">The sign bit will be preserved if available in the target format.</span></span>

### <a name="converting-from-a-lower-range-representation-to-a-higher-range-representation"></a><span data-ttu-id="ba626-156">Convertir una representación de rango inferior en una representación de rango superior</span><span class="sxs-lookup"><span data-stu-id="ba626-156">Converting from a lower range representation to a higher range representation</span></span>

-   <span data-ttu-id="ba626-157">Los NaN en un formato de intervalo inferior se convertirán en la representación NaN en el formato de intervalo superior si están disponibles en el formato de rango superior.</span><span class="sxs-lookup"><span data-stu-id="ba626-157">NaN in a lower range format will be converted to the NaN representation in the higher range format if available in the higher range format.</span></span> <span data-ttu-id="ba626-158">Si el formato de rango superior no tiene una representación NaN, se convertirá en 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-158">If the higher range format does not have a NaN representation, it will be converted to 0.</span></span>
-   <span data-ttu-id="ba626-159">INF en un formato de intervalo inferior se convertirá a la representación de INF en el formato de intervalo superior si está disponible en el formato de rango superior.</span><span class="sxs-lookup"><span data-stu-id="ba626-159">INF in a lower range format will be converted to the INF representation in the higher range format if available in the higher range format.</span></span> <span data-ttu-id="ba626-160">Si el formato más alto no tiene una representación de INF, se convertirá en el valor máximo que se puede representar (MAX \_ float en ese formato).</span><span class="sxs-lookup"><span data-stu-id="ba626-160">If the higher format does not have an INF representation, it will be converted to the maximum value representable (MAX\_FLOAT in that format).</span></span> <span data-ttu-id="ba626-161">El signo se conservará si está disponible en el formato de destino.</span><span class="sxs-lookup"><span data-stu-id="ba626-161">The sign will be preserved if available in the target format.</span></span>
-   <span data-ttu-id="ba626-162">La desnormada en un formato de intervalo inferior se convertirá a una representación normalizada en el formato de intervalo más alto si es posible, o bien a una representación de desnormativa en el formato de intervalo superior si existe la representación de desnormativa.</span><span class="sxs-lookup"><span data-stu-id="ba626-162">Denorm in a lower range format will be converted to a normalized representation in the higher range format if possible, or else to a Denorm representation in the higher range format if the Denorm representation exists.</span></span> <span data-ttu-id="ba626-163">Con errores, si el formato de rango superior no tiene una representación de desnormativa, se convertirá en 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-163">Failing those, if the higher range format does not have a Denorm representation, it will be converted to 0.</span></span> <span data-ttu-id="ba626-164">El signo se conservará si está disponible en el formato de destino.</span><span class="sxs-lookup"><span data-stu-id="ba626-164">The sign will be preserved if available in the target format.</span></span> <span data-ttu-id="ba626-165">Tenga en cuenta que los números Float de 32 bits cuentan como un formato sin una representación de desnormativa (dado que las desnormativas en operaciones en los flotantes de 32 bits se vacían para firmar con el valor 0).</span><span class="sxs-lookup"><span data-stu-id="ba626-165">Note that 32-bit float numbers count as a format without a Denorm representation (because Denorms in operations on 32-bit floats flush to sign preserved 0).</span></span>

## <a name="integer-conversion"></a><span data-ttu-id="ba626-166">Conversión de enteros</span><span class="sxs-lookup"><span data-stu-id="ba626-166">Integer Conversion</span></span>

<span data-ttu-id="ba626-167">En la tabla siguiente se describen las conversiones de diversas representaciones descritas anteriormente a otras representaciones.</span><span class="sxs-lookup"><span data-stu-id="ba626-167">The following table describes conversions from various representations described above to other representations.</span></span> <span data-ttu-id="ba626-168">Solo se muestran las conversiones que realmente se producen en Direct3D.</span><span class="sxs-lookup"><span data-stu-id="ba626-168">Only conversions that actually occur in Direct3D are shown.</span></span>



<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="ba626-169">Tipo de datos de origen</span><span class="sxs-lookup"><span data-stu-id="ba626-169">Source Data Type</span></span></th>
<th><span data-ttu-id="ba626-170">Tipo de datos de destino</span><span class="sxs-lookup"><span data-stu-id="ba626-170">Destination Data Type</span></span></th>
<th><span data-ttu-id="ba626-171">Regla de conversión</span><span class="sxs-lookup"><span data-stu-id="ba626-171">Conversion Rule</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="ba626-172">SNORM</span><span class="sxs-lookup"><span data-stu-id="ba626-172">SNORM</span></span></td>
<td><span data-ttu-id="ba626-173">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-173">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-174">Dado un valor entero de n bits que representa el intervalo con signo [-1,0 f a 1.0 f], la conversión a punto flotante es como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="ba626-174">Given an n-bit integer value representing the signed range [-1.0f to 1.0f], conversion to floating-point is as follows.</span></span><br/>
<ul>
<li><span data-ttu-id="ba626-175">El valor más negativo se asigna a-1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-175">The most-negative value maps to -1.0f.</span></span> <span data-ttu-id="ba626-176">por ejemplo, el valor de 5 bits 10000 se asigna a-1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-176">e.g. the 5-bit value 10000 maps to -1.0f.</span></span></li>
<li><span data-ttu-id="ba626-177">Cada otro valor se convierte en un valor Float (lo llama c) y, a continuación, result = c \* (1.0 f/(2 ⁽ ⁿ ⁻ ¹ ⁾-1)).</span><span class="sxs-lookup"><span data-stu-id="ba626-177">Every other value is converted to a float (call it c), and then result = c \* (1.0f / (2⁽ⁿ⁻¹⁾-1)).</span></span> <span data-ttu-id="ba626-178">Por ejemplo, el valor de 5 bits 10001 se convierte en-15.0 f y, a continuación, se divide entre 15 f, produciendo-1.0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-178">For example the 5-bit value 10001 is converted to -15.0f, and then divided by 15.0f, yielding -1.0f.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="ba626-179">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-179">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-180">SNORM</span><span class="sxs-lookup"><span data-stu-id="ba626-180">SNORM</span></span></td>
<td><span data-ttu-id="ba626-181">Dado un número de punto flotante, la conversión a un valor entero de n bits que representa el intervalo con signo [-1,0 f a 1.0 f] es como sigue.</span><span class="sxs-lookup"><span data-stu-id="ba626-181">Given a floating-point number, conversion to an n-bit integer value representing the signed range [-1.0f to 1.0f] is as follows.</span></span><br/>
<ul>
<li><span data-ttu-id="ba626-182">Permita que c represente el valor de inicio.</span><span class="sxs-lookup"><span data-stu-id="ba626-182">Let c represent the starting value.</span></span></li>
<li><span data-ttu-id="ba626-183">Si c es NaN, el resultado es 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-183">If c is NaN, the result is 0.</span></span></li>
<li><span data-ttu-id="ba626-184">Si c > 1.0 f, incluido el INF, se fija en 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-184">If c > 1.0f, including INF, it is clamped to 1.0f.</span></span></li>
<li><span data-ttu-id="ba626-185">Si c <-1.0 f, incluido-INF, se fija en-1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-185">If c < -1.0f, including -INF, it is clamped to -1.0f.</span></span></li>
<li><span data-ttu-id="ba626-186">Convertir de escala flotante a escala de entero: c = c \* (2 ⁿ ⁻ ¹-1).</span><span class="sxs-lookup"><span data-stu-id="ba626-186">Convert from float scale to integer scale: c = c \* (2ⁿ⁻¹-1).</span></span></li>
<li><span data-ttu-id="ba626-187">Convertir en un entero como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="ba626-187">Convert to an integer as follows.</span></span>
<ul>
<li><span data-ttu-id="ba626-188">Si c >= 0, c = c + 0.5 f; de lo contrario, c = c-0.5 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-188">If c >= 0 then c = c + 0.5f, otherwise, c = c - 0.5f.</span></span></li>
<li><span data-ttu-id="ba626-189">Quite la fracción decimal y el valor de punto flotante (entero) restante se convierte directamente en un entero.</span><span class="sxs-lookup"><span data-stu-id="ba626-189">Drop the decimal fraction, and the remaining floating point (integral) value is converted directly to an integer.</span></span></li>
</ul></li>
</ul>
<span data-ttu-id="ba626-190">A esta conversión se le permite una tolerancia de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_Unit de la última posición (en el lado entero).</span><span class="sxs-lookup"><span data-stu-id="ba626-190">This conversion is permitted a tolerance of D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_Unit-Last-Place Unit-Last-Place (on the integer side).</span></span> <span data-ttu-id="ba626-191">Esto significa que, después de realizar la conversión de la escala de punto flotante a entero, se permite que cualquier valor dentro de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unidad en el último lugar de un valor de formato de destino que se puede representar se asigne a ese valor.</span><span class="sxs-lookup"><span data-stu-id="ba626-191">This means that after converting from float to integer scale, any value within D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place of a representable target format value is permitted to map to that value.</span></span> <span data-ttu-id="ba626-192">El requisito adicional de inversión de datos garantiza que la conversión se nondecreasing en el intervalo y todos los valores de salida se pueden alcanzar.</span><span class="sxs-lookup"><span data-stu-id="ba626-192">The additional Data Invertability requirement ensures that the conversion is nondecreasing across the range and all output values are attainable.</span></span> <span data-ttu-id="ba626-193">(En las constantes que se muestran aquí, <em>XX</em> debe reemplazarse por la versión de Direct3D, por ejemplo, 10, 11 o 12).</span><span class="sxs-lookup"><span data-stu-id="ba626-193">(In the constants shown here, <em>xx</em> should be replaced with the Direct3D version, for example 10, 11, or 12.)</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="ba626-194">UNORM</span><span class="sxs-lookup"><span data-stu-id="ba626-194">UNORM</span></span></td>
<td><span data-ttu-id="ba626-195">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-195">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-196">El valor de n bits de inicio se convierte en Float (0,0 f, 1,0 f, 2.0 f, etc.) y, a continuación, se divide entre (2 ⁿ-1).</span><span class="sxs-lookup"><span data-stu-id="ba626-196">The starting n-bit value is converted to float (0.0f, 1.0f, 2.0f, etc.) and then divided by (2ⁿ-1).</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="ba626-197">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-197">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-198">UNORM</span><span class="sxs-lookup"><span data-stu-id="ba626-198">UNORM</span></span></td>
<td><span data-ttu-id="ba626-199">Permita que c represente el valor de inicio.</span><span class="sxs-lookup"><span data-stu-id="ba626-199">Let c represent the starting value.</span></span><br/>
<ul>
<li><span data-ttu-id="ba626-200">Si c es NaN, el resultado es 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-200">If c is NaN, the result is 0.</span></span></li>
<li><span data-ttu-id="ba626-201">Si c > 1.0 f, incluido el INF, se fija en 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-201">If c > 1.0f, including INF, it is clamped to 1.0f.</span></span></li>
<li><span data-ttu-id="ba626-202">Si c < 0.0 f, incluido-INF, se fija en 0,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-202">If c < 0.0f, including -INF, it is clamped to 0.0f.</span></span></li>
<li><span data-ttu-id="ba626-203">Convertir de escala flotante a escala de entero: c = c \* (2 ⁿ-1).</span><span class="sxs-lookup"><span data-stu-id="ba626-203">Convert from float scale to integer scale: c = c \* (2ⁿ-1).</span></span></li>
<li><span data-ttu-id="ba626-204">Convertir en entero.</span><span class="sxs-lookup"><span data-stu-id="ba626-204">Convert to integer.</span></span>
<ul>
<li><span data-ttu-id="ba626-205">c = c + 0.5 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-205">c = c + 0.5f.</span></span></li>
<li><span data-ttu-id="ba626-206">Se quita la fracción decimal y el valor de punto flotante (entero) restante se convierte directamente en un entero.</span><span class="sxs-lookup"><span data-stu-id="ba626-206">The decimal fraction is dropped, and the remaining floating point (integral) value is converted directly to an integer.</span></span></li>
</ul></li>
</ul>
<span data-ttu-id="ba626-207">A esta conversión se le permite una tolerancia de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unidad (en el lado entero).</span><span class="sxs-lookup"><span data-stu-id="ba626-207">This conversion is permitted a tolerance of D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place (on the integer side).</span></span> <span data-ttu-id="ba626-208">Esto significa que, después de realizar la conversión de la escala de punto flotante a entero, se permite que cualquier valor dentro de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unidad en el último lugar de un valor de formato de destino que se puede representar se asigne a ese valor.</span><span class="sxs-lookup"><span data-stu-id="ba626-208">This means that after converting from float to integer scale, any value within D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place of a representable target format value is permitted to map to that value.</span></span> <span data-ttu-id="ba626-209">El requisito adicional de inversión de datos garantiza que la conversión se nondecreasing en el intervalo y todos los valores de salida se pueden alcanzar.</span><span class="sxs-lookup"><span data-stu-id="ba626-209">The additional Data Invertability requirement ensures that the conversion is nondecreasing across the range and all output values are attainable.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="ba626-210">SRGB</span><span class="sxs-lookup"><span data-stu-id="ba626-210">SRGB</span></span></td>
<td><span data-ttu-id="ba626-211">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-211">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-212">A continuación se encuentra la conversión ideal de SRGB a FLOAT.</span><span class="sxs-lookup"><span data-stu-id="ba626-212">The following is the ideal SRGB to FLOAT conversion.</span></span><br/>
<ul>
<li><span data-ttu-id="ba626-213">Tome el valor de n bits inicial, conviértalo en Float (0,0 f, 1,0 f, 2.0 f, etc.); Llame a este c.</span><span class="sxs-lookup"><span data-stu-id="ba626-213">Take the starting n-bit value, convert it a float (0.0f, 1.0f, 2.0f, etc.); call this c.</span></span></li>
<li><span data-ttu-id="ba626-214">c = c \* (1,0 f/(2 ⁿ-1))</span><span class="sxs-lookup"><span data-stu-id="ba626-214">c = c \* (1.0f / (2ⁿ-1))</span></span></li>
<li><span data-ttu-id="ba626-215">Si (c < = D3D<em>xx</em>_SRGB_TO_FLOAT_THRESHOLD): result = c/D3D<em>XX</em>_SRGB_TO_FLOAT_DENOMINATOR_1, Else: result = ((c + D3D<em>xx</em>_SRGB_TO_FLOAT_OFFSET)/D3D<em>XX</em>_SRGB_TO_FLOAT_DENOMINATOR_2) D3D<em>XX</em>_SRGB_TO_FLOAT_EXPONENT</span><span class="sxs-lookup"><span data-stu-id="ba626-215">If (c < = D3D<em>xx</em>_SRGB_TO_FLOAT_THRESHOLD) then: result = c / D3D<em>xx</em>_SRGB_TO_FLOAT_DENOMINATOR_1, else: result = ((c + D3D<em>xx</em>_SRGB_TO_FLOAT_OFFSET)/D3D<em>xx</em>_SRGB_TO_FLOAT_DENOMINATOR_2)D3D<em>xx</em>_SRGB_TO_FLOAT_EXPONENT</span></span></li>
</ul>
<span data-ttu-id="ba626-216">A esta conversión se le permite una tolerancia de D3D<em>xx</em>_SRGB_TO_FLOAT_TOLERANCE_IN_ULP unidad-último lugar (en el lado de sRGB).</span><span class="sxs-lookup"><span data-stu-id="ba626-216">This conversion is permitted a tolerance of D3D<em>xx</em>_SRGB_TO_FLOAT_TOLERANCE_IN_ULP Unit-Last-Place (on the SRGB side).</span></span> <br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="ba626-217">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-217">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-218">SRGB</span><span class="sxs-lookup"><span data-stu-id="ba626-218">SRGB</span></span></td>
<td><span data-ttu-id="ba626-219">A continuación se encuentra la conversión de tipo "FLOAT-> SRGB" ideal.</span><span class="sxs-lookup"><span data-stu-id="ba626-219">The following is the ideal FLOAT -> SRGB conversion.</span></span><br/> <span data-ttu-id="ba626-220">Suponiendo que el componente de color SRGB de destino tiene n bits:</span><span class="sxs-lookup"><span data-stu-id="ba626-220">Assuming the target SRGB color component has n bits:</span></span><br/>
<ul>
<li><span data-ttu-id="ba626-221">Supongamos que el valor inicial es c.</span><span class="sxs-lookup"><span data-stu-id="ba626-221">Suppose the starting value is c.</span></span></li>
<li><span data-ttu-id="ba626-222">Si c es NaN, el resultado es 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-222">If c is NaN, the result is 0.</span></span></li>
<li><span data-ttu-id="ba626-223">Si c > 1.0 f, incluido el archivo INF, se fija en 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-223">If c > 1.0f, including INF, is clamped to 1.0f.</span></span></li>
<li><span data-ttu-id="ba626-224">Si c < 0.0 f, incluido-INF, se fija en 0,0 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-224">If c < 0.0f, including -INF, it is clamped to 0.0f.</span></span></li>
<li><span data-ttu-id="ba626-225">Si (c <= D3D<em>xx</em>_FLOAT_TO_SRGB_THRESHOLD): c = d3d<em>XX</em>_FLOAT_TO_SRGB_SCALE_1 \* c, Else: c = D3D<em>XX</em>_FLOAT_TO_SRGB_SCALE_2 \* c (D3D<em>XX</em>_FLOAT_TO_SRGB_EXPONENT_NUMERATOR/D3D<em>XX</em>_FLOAT_TO_SRGB_EXPONENT_DENOMINATOR)-D3D<em>XX</em>_FLOAT_TO_SRGB_OFFSET</span><span class="sxs-lookup"><span data-stu-id="ba626-225">If (c <= D3D<em>xx</em>_FLOAT_TO_SRGB_THRESHOLD) then: c = D3D<em>xx</em>_FLOAT_TO_SRGB_SCALE_1 \* c, else: c = D3D<em>xx</em>_FLOAT_TO_SRGB_SCALE_2 \* c(D3D<em>xx</em>_FLOAT_TO_SRGB_EXPONENT_NUMERATOR/D3D<em>xx</em>_FLOAT_TO_SRGB_EXPONENT_DENOMINATOR) - D3D<em>xx</em>_FLOAT_TO_SRGB_OFFSET</span></span></li>
<li><span data-ttu-id="ba626-226">Convertir de escala flotante a escala de entero: c = c \* (2 ⁿ-1).</span><span class="sxs-lookup"><span data-stu-id="ba626-226">Convert from float scale to integer scale: c = c \* (2ⁿ-1).</span></span></li>
<li><span data-ttu-id="ba626-227">Convertir en entero:</span><span class="sxs-lookup"><span data-stu-id="ba626-227">Convert to integer:</span></span>
<ul>
<li><span data-ttu-id="ba626-228">c = c + 0.5 f.</span><span class="sxs-lookup"><span data-stu-id="ba626-228">c = c + 0.5f.</span></span></li>
<li><span data-ttu-id="ba626-229">Se quita la fracción decimal y el valor de punto flotante (entero) restante se convierte directamente en un entero.</span><span class="sxs-lookup"><span data-stu-id="ba626-229">The decimal fraction is dropped, and the remaining floating point (integral) value is converted directly to an integer.</span></span></li>
</ul></li>
</ul>
<span data-ttu-id="ba626-230">A esta conversión se le permite una tolerancia de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unidad (en el lado entero).</span><span class="sxs-lookup"><span data-stu-id="ba626-230">This conversion is permitted a tolerance of D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place (on the integer side).</span></span> <span data-ttu-id="ba626-231">Esto significa que, después de realizar la conversión de la escala de punto flotante a entero, se permite que cualquier valor dentro de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unidad en el último lugar de un valor de formato de destino que se puede representar se asigne a ese valor.</span><span class="sxs-lookup"><span data-stu-id="ba626-231">This means that after converting from float to integer scale, any value within D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place of a representable target format value is permitted to map to that value.</span></span> <span data-ttu-id="ba626-232">El requisito adicional de inversión de datos garantiza que la conversión se nondecreasing en el intervalo y todos los valores de salida se pueden alcanzar.</span><span class="sxs-lookup"><span data-stu-id="ba626-232">The additional Data Invertability requirement ensures that the conversion is nondecreasing across the range and all output values are attainable.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="ba626-233">San</span><span class="sxs-lookup"><span data-stu-id="ba626-233">SINT</span></span></td>
<td><span data-ttu-id="ba626-234">SINT con más bits</span><span class="sxs-lookup"><span data-stu-id="ba626-234">SINT With More Bits</span></span></td>
<td><span data-ttu-id="ba626-235">Para convertir de SINT a un San con más bits, el bit más significativo (MSB) del número de inicio se &quot; extiende con signo &quot; a los bits adicionales disponibles en el formato de destino.</span><span class="sxs-lookup"><span data-stu-id="ba626-235">To convert from SINT to an SINT with more bits, the most significant bit (MSB) of the starting number is &quot;sign-extended&quot; to the additional bits available in the target format.</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="ba626-236">UINT</span><span class="sxs-lookup"><span data-stu-id="ba626-236">UINT</span></span></td>
<td><span data-ttu-id="ba626-237">SINT con más bits</span><span class="sxs-lookup"><span data-stu-id="ba626-237">SINT With More Bits</span></span></td>
<td><span data-ttu-id="ba626-238">Para convertir de UINT a un SINT con más bits, el número se copia en los bits menos significativos del formato de destino (LSBs) y los MSBs adicionales se rellenan con 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-238">To convert from UINT to an SINT with more bits, the number is copied to the target format's least significant bits (LSBs) and additional MSBs are padded with 0.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="ba626-239">San</span><span class="sxs-lookup"><span data-stu-id="ba626-239">SINT</span></span></td>
<td><span data-ttu-id="ba626-240">UINT con más bits</span><span class="sxs-lookup"><span data-stu-id="ba626-240">UINT With More Bits</span></span></td>
<td><span data-ttu-id="ba626-241">Para convertir de SINT a UINT con más bits: si es negativo, el valor se fija en 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-241">To convert from SINT to UINT with more bits: If negative, the value is clamped to 0.</span></span> <span data-ttu-id="ba626-242">En caso contrario, el número se copia en el LSBs del formato de destino y los MSB adicionales se rellenan con 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-242">Otherwise the number is copied to the target format's LSBs and additional MSB's are padded with 0.</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="ba626-243">UINT</span><span class="sxs-lookup"><span data-stu-id="ba626-243">UINT</span></span></td>
<td><span data-ttu-id="ba626-244">UINT con más bits</span><span class="sxs-lookup"><span data-stu-id="ba626-244">UINT With More Bits</span></span></td>
<td><span data-ttu-id="ba626-245">Para convertir de UINT a UINT con más bits, el número se copia en el LSBs del formato de destino y los MSB adicionales se rellenan con 0.</span><span class="sxs-lookup"><span data-stu-id="ba626-245">To convert from UINT to UINT with more bits the number is copied to the target format's LSBs and additional MSB's are padded with 0.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="ba626-246">SINT o UINT</span><span class="sxs-lookup"><span data-stu-id="ba626-246">SINT or UINT</span></span></td>
<td><span data-ttu-id="ba626-247">SINT o UINT con menos o igual bits</span><span class="sxs-lookup"><span data-stu-id="ba626-247">SINT or UINT With Fewer or Equal Bits</span></span></td>
<td><span data-ttu-id="ba626-248">Para convertir de un SINT o UINT a SINT o UINT con menos o igual bits (y/o cambiar en la firma), el valor inicial se fija simplemente en el intervalo del formato de destino.</span><span class="sxs-lookup"><span data-stu-id="ba626-248">To convert from a SINT or UINT to SINT or UINT with fewer or equal bits (and/or change in signedness), the starting value is simply clamped to the range of the target format.</span></span><br/></td>
</tr>
</tbody>
</table>



 

## <a name="fixed-point-integer-conversion"></a><span data-ttu-id="ba626-249">Conversión de enteros de punto fijo</span><span class="sxs-lookup"><span data-stu-id="ba626-249">Fixed Point Integer Conversion</span></span>

<span data-ttu-id="ba626-250">Los enteros de punto fijo son simplemente enteros de algún tamaño de bit que tienen un punto decimal implícito en una ubicación fija.</span><span class="sxs-lookup"><span data-stu-id="ba626-250">Fixed point integers are simply integers of some bit size that have an implicit decimal point at a fixed location.</span></span>

<span data-ttu-id="ba626-251">El tipo de datos omnipresente "integer" es un caso especial de un entero de punto fijo con el decimal al final del número.</span><span class="sxs-lookup"><span data-stu-id="ba626-251">The ubiquitous "integer" data type is a special case of a fixed point integer with the decimal at the end of the number.</span></span>

<span data-ttu-id="ba626-252">Las representaciones de números de punto fijo se caracterizan como: i. f, donde i es el número de bits enteros y f es el número de bits fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="ba626-252">Fixed point number representations are characterized as: i.f, where i is the number of integer bits and f is the number of fractional bits.</span></span> <span data-ttu-id="ba626-253">por ejemplo, 16,8 significa un entero de 16 bits seguido de 8 bits de fracción.</span><span class="sxs-lookup"><span data-stu-id="ba626-253">e.g. 16.8 means 16 bits integer followed by 8 bits of fraction.</span></span> <span data-ttu-id="ba626-254">La parte entera se almacena en el complemento de 2, al menos como se define aquí (aunque también se puede definir igualmente para enteros sin signo).</span><span class="sxs-lookup"><span data-stu-id="ba626-254">The integer part is stored in 2's complement, at least as defined here (though it can be defined equally for unsigned integers as well).</span></span> <span data-ttu-id="ba626-255">La parte fraccionaria se almacena en formato sin signo.</span><span class="sxs-lookup"><span data-stu-id="ba626-255">The fractional part is stored in unsigned form.</span></span> <span data-ttu-id="ba626-256">La parte fraccionaria siempre representa la fracción positiva entre los dos valores enteros más cercanos, empezando por el más negativo.</span><span class="sxs-lookup"><span data-stu-id="ba626-256">The fractional part always represents the positive fraction between the two nearest integral values, starting from the most negative.</span></span>

<span data-ttu-id="ba626-257">Las operaciones de suma y resta en números de punto fijo se realizan simplemente mediante la aritmética de enteros estándar, sin tener en cuenta el lugar en el que se encuentra el decimal implícito.</span><span class="sxs-lookup"><span data-stu-id="ba626-257">Addition and subtraction operations on fixed point numbers are performed simply using standard integer arithmetic, without any consideration for where the implied decimal lies.</span></span> <span data-ttu-id="ba626-258">Agregar 1 a un número de punto fijo 16,8 significa agregar 256, ya que el decimal es 8 lugares en el extremo menos significativo del número.</span><span class="sxs-lookup"><span data-stu-id="ba626-258">Adding 1 to a 16.8 fixed point number just means adding 256, since the decimal is 8 places in from the least significant end of the number.</span></span> <span data-ttu-id="ba626-259">Otras operaciones, como la multiplicación, se pueden realizar simplemente usando aritmética de enteros, siempre que se tenga en cuenta el efecto en el decimal fijo.</span><span class="sxs-lookup"><span data-stu-id="ba626-259">Other operations such as multiplication, can be performed as well simply using integer arithmetic, provided the effect on the fixed decimal is accounted for.</span></span> <span data-ttu-id="ba626-260">Por ejemplo, si se multiplican dos enteros 16,8 mediante una multiplicación de enteros, se genera un resultado de 32,16.</span><span class="sxs-lookup"><span data-stu-id="ba626-260">For example, multiplying two 16.8 integers using an integer multiply produces a 32.16 result.</span></span>

<span data-ttu-id="ba626-261">Las representaciones de enteros de punto fijo se usan de dos maneras en Direct3D.</span><span class="sxs-lookup"><span data-stu-id="ba626-261">Fixed point integer representations are used in two ways in Direct3D.</span></span>

-   <span data-ttu-id="ba626-262">Las posiciones de vértices recortadas en el rasterizador se ajustan a un punto fijo para distribuir uniformemente la precisión en el área de RenderTarget.</span><span class="sxs-lookup"><span data-stu-id="ba626-262">Post-clipped vertex positions in the rasterizer are snapped to fixed point, to uniformly distribute precision across the RenderTarget area.</span></span> <span data-ttu-id="ba626-263">Muchas operaciones de rasterizador, incluida la selección de caras como un ejemplo, se producen en posiciones ajustadas de punto fijo, mientras que otras operaciones, como la configuración del interpolador de atributos, usan posiciones que se han convertido de nuevo en punto flotante desde las posiciones ajustadas de punto fijo.</span><span class="sxs-lookup"><span data-stu-id="ba626-263">Many rasterizer operations, including face culling as one example, occur on fixed point snapped positions, while other operations, such as attribute interpolator setup, use positions that have been converted back to floating point from the fixed point snapped positions.</span></span>
-   <span data-ttu-id="ba626-264">Las coordenadas de textura de las operaciones de muestreo se ajustan a un punto fijo (después de que se escalen por tamaño de textura), para distribuir uniformemente la precisión a través del espacio de textura, en elegir el filtro puntee en ubicaciones/pesos.</span><span class="sxs-lookup"><span data-stu-id="ba626-264">Texture coordinates for sampling operations are snapped to fixed point (after being scaled by texture size), to uniformly distribute precision across texture space, in choosing filter tap locations/weights.</span></span> <span data-ttu-id="ba626-265">Los valores de peso se convierten de nuevo en el punto flotante antes de que se realice la aritmética de filtrado real.</span><span class="sxs-lookup"><span data-stu-id="ba626-265">Weight values are converted back to floating point before actual filtering arithmetic is performed.</span></span>



<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="ba626-266">Tipo de datos de origen</span><span class="sxs-lookup"><span data-stu-id="ba626-266">Source Data Type</span></span></th>
<th><span data-ttu-id="ba626-267">Tipo de datos de destino</span><span class="sxs-lookup"><span data-stu-id="ba626-267">Destination Data Type</span></span></th>
<th><span data-ttu-id="ba626-268">Regla de conversión</span><span class="sxs-lookup"><span data-stu-id="ba626-268">Conversion Rule</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="ba626-269">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-269">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-270">Entero de punto fijo</span><span class="sxs-lookup"><span data-stu-id="ba626-270">Fixed Point Integer</span></span></td>
<td><span data-ttu-id="ba626-271">A continuación se presenta el procedimiento general para convertir un número de punto flotante n en un entero de punto fijo i. f, donde i es el número de bits enteros (con signo) y f es el número de bits fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="ba626-271">The following is the general procedure for converting a floating point number n to a fixed point integer i.f, where i is the number of (signed) integer bits and f is the number of fractional bits.</span></span><br/>
<ul>
<li><span data-ttu-id="ba626-272">Compute FixedMin =-2 ⁽ ⁱ ⁻ ¹ ⁾</span><span class="sxs-lookup"><span data-stu-id="ba626-272">Compute FixedMin = -2⁽ⁱ⁻¹⁾</span></span></li>
<li><span data-ttu-id="ba626-273">Compute FixedMax = 2 ⁽ ⁱ ⁻ ¹ ⁾-2<sup>(-f)</sup></span><span class="sxs-lookup"><span data-stu-id="ba626-273">Compute FixedMax = 2⁽ⁱ⁻¹⁾ - 2<sup>(-f)</sup></span></span></li>
<li><span data-ttu-id="ba626-274">Si n es un NaN, el resultado es 0; Si n es + inf, result = FixedMax \* 2<sup>f</sup>; Si n es-inf, result = FixedMin \* 2<sup>f</sup></span><span class="sxs-lookup"><span data-stu-id="ba626-274">If n is a NaN, result = 0; if n is +Inf, result = FixedMax*2<sup>f</sup>; if n is -Inf, result = FixedMin*2<sup>f</sup></span></span></li>
<li><span data-ttu-id="ba626-275">Si n >= FixedMax, result = Fixedmax \* 2<sup>f</sup>; Si n <= FixedMin, result = FixedMin \* 2 <sup> f</span><span class="sxs-lookup"><span data-stu-id="ba626-275">If n >= FixedMax, result = Fixedmax*2<sup>f</sup>; if n <= FixedMin, result = FixedMin*2<sup>f</span></span></sup></li>
<li><span data-ttu-id="ba626-276">En caso contrario, Compute n \* 2<sup>f</sup> y conviértalo en Integer.</span><span class="sxs-lookup"><span data-stu-id="ba626-276">Else compute n\*2<sup>f</sup> and convert to integer.</span></span></li>
</ul>
<span data-ttu-id="ba626-277">Las implementaciones tienen permitidos D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP tolerancia de última vez en el resultado entero, en lugar del valor Infinitely preciso n \* 2<sup>f</sup> después del último paso anterior.</span><span class="sxs-lookup"><span data-stu-id="ba626-277">Implementations are permitted D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place tolerance in the integer result, instead of the infinitely precise value n\*2<sup>f</sup> after the last step above.</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="ba626-278">Entero de punto fijo</span><span class="sxs-lookup"><span data-stu-id="ba626-278">Fixed Point Integer</span></span></td>
<td><span data-ttu-id="ba626-279">FLOAT</span><span class="sxs-lookup"><span data-stu-id="ba626-279">FLOAT</span></span></td>
<td><span data-ttu-id="ba626-280">Supongamos que la representación de punto fijo específica que se está convirtiendo en Float no contiene más de un total de 24 bits de información, y no más de 23 bits de que se encuentra en el componente fraccionario.</span><span class="sxs-lookup"><span data-stu-id="ba626-280">Assume that the specific fixed point representation being converted to float does not contain more than a total of 24 bits of information, no more than 23 bits of which is in the fractional component.</span></span> <span data-ttu-id="ba626-281">Supongamos que un número de punto fijo determinado, fxp, se encuentra en formato i. f (i bits entero, fracción de f bits).</span><span class="sxs-lookup"><span data-stu-id="ba626-281">Suppose a given fixed point number, fxp, is in i.f form (i bits integer, f bits fraction).</span></span> <span data-ttu-id="ba626-282">La conversión a Float es similar al siguiente pseudocódigo.</span><span class="sxs-lookup"><span data-stu-id="ba626-282">The conversion to float is akin to the following pseudocode.</span></span><br/> <span data-ttu-id="ba626-283">Float Result = (float) (fxp >> f) +//Extract Integer</span><span class="sxs-lookup"><span data-stu-id="ba626-283">float result = (float)(fxp >> f) + // extract integer</span></span><br/> <dl> <span data-ttu-id="ba626-284">((float) (fxp & (2<sup>f</sup> - 1))/(2<sup>f</sup>));//extraer fracción</span><span class="sxs-lookup"><span data-stu-id="ba626-284">((float)(fxp & (2<sup>f</sup> - 1)) / (2<sup>f</sup>)); // extract fraction</span></span><br />
</dl></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="ba626-285">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="ba626-285">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ba626-286">Recursos (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="ba626-286">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 




