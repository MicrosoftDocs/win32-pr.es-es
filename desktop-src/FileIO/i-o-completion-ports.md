---
description: Los puertos de finalización de e/s proporcionan un modelo de subprocesos eficaz para procesar varias solicitudes de e/s asincrónicas en un sistema de varios procesadores.
ms.assetid: 213c48e8-bb21-43ed-9c00-2a5cf8ac25f0
title: Puertos de finalización de e/s
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 882363ef99821a0b0b40810f45d609c5b5f7760c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105669690"
---
# <a name="io-completion-ports"></a><span data-ttu-id="16893-103">Puertos de finalización de e/s</span><span class="sxs-lookup"><span data-stu-id="16893-103">I/O Completion Ports</span></span>

<span data-ttu-id="16893-104">Los puertos de finalización de e/s proporcionan un modelo de subprocesos eficaz para procesar varias solicitudes de e/s asincrónicas en un sistema de varios procesadores.</span><span class="sxs-lookup"><span data-stu-id="16893-104">I/O completion ports provide an efficient threading model for processing multiple asynchronous I/O requests on a multiprocessor system.</span></span> <span data-ttu-id="16893-105">Cuando un proceso crea un puerto de finalización de e/s, el sistema crea un objeto de cola asociado para las solicitudes cuyo único propósito es atender estas solicitudes.</span><span class="sxs-lookup"><span data-stu-id="16893-105">When a process creates an I/O completion port, the system creates an associated queue object for requests whose sole purpose is to service these requests.</span></span> <span data-ttu-id="16893-106">Los procesos que administran muchas solicitudes de e/s asincrónicas simultáneas pueden hacerlo de manera más rápida y eficaz mediante puertos de finalización de e/s junto con un grupo de subprocesos previamente asignados que al crear subprocesos en el momento en que reciben una solicitud de e/s.</span><span class="sxs-lookup"><span data-stu-id="16893-106">Processes that handle many concurrent asynchronous I/O requests can do so more quickly and efficiently by using I/O completion ports in conjunction with a pre-allocated thread pool than by creating threads at the time they receive an I/O request.</span></span>

## <a name="how-io-completion-ports-work"></a><span data-ttu-id="16893-107">Cómo funcionan los puertos de finalización de e/s</span><span class="sxs-lookup"><span data-stu-id="16893-107">How I/O Completion Ports Work</span></span>

<span data-ttu-id="16893-108">La función [**CreateIoCompletionPort**](createiocompletionport.md) crea un puerto de finalización de e/s y asocia uno o más identificadores de archivo a ese puerto.</span><span class="sxs-lookup"><span data-stu-id="16893-108">The [**CreateIoCompletionPort**](createiocompletionport.md) function creates an I/O completion port and associates one or more file handles with that port.</span></span> <span data-ttu-id="16893-109">Cuando se completa una operación de e/s asincrónica en uno de estos identificadores de archivo, un paquete de finalización de e/s se pone en cola en el orden FIFO (el primero en salir es el primero en salir) al puerto de terminación de e/s asociado.</span><span class="sxs-lookup"><span data-stu-id="16893-109">When an asynchronous I/O operation on one of these file handles completes, an I/O completion packet is queued in first-in-first-out (FIFO) order to the associated I/O completion port.</span></span> <span data-ttu-id="16893-110">Un uso eficaz de este mecanismo es combinar el punto de sincronización para varios identificadores de archivo en un solo objeto, aunque también hay otras aplicaciones útiles.</span><span class="sxs-lookup"><span data-stu-id="16893-110">One powerful use for this mechanism is to combine the synchronization point for multiple file handles into a single object, although there are also other useful applications.</span></span> <span data-ttu-id="16893-111">Tenga en cuenta que, mientras los paquetes se ponen en cola en orden FIFO, se pueden quitar de la cola en un orden diferente.</span><span class="sxs-lookup"><span data-stu-id="16893-111">Please note that while the packets are queued in FIFO order they may be dequeued in a different order.</span></span>

> [!Note]
>
> <span data-ttu-id="16893-112">El término *identificador de archivo* tal como se usa aquí hace referencia a una abstracción del sistema que representa un punto de conexión de e/s superpuesto, no solo un archivo en disco.</span><span class="sxs-lookup"><span data-stu-id="16893-112">The term *file handle* as used here refers to a system abstraction representing an overlapped I/O endpoint, not only a file on disk.</span></span> <span data-ttu-id="16893-113">Por ejemplo, puede ser un punto de conexión de red, un socket TCP, una canalización con nombre o una ranura de correo.</span><span class="sxs-lookup"><span data-stu-id="16893-113">For example, it can be a network endpoint, TCP socket, named pipe, or mail slot.</span></span> <span data-ttu-id="16893-114">Se puede usar cualquier objeto del sistema que admita e/s superpuesta.</span><span class="sxs-lookup"><span data-stu-id="16893-114">Any system object that supports overlapped I/O can be used.</span></span> <span data-ttu-id="16893-115">Para obtener una lista de las funciones de e/s relacionadas, consulte el final de este tema.</span><span class="sxs-lookup"><span data-stu-id="16893-115">For a list of related I/O functions, see the end of this topic.</span></span>

 

<span data-ttu-id="16893-116">Cuando un identificador de archivo está asociado a un puerto de finalización, el bloque de estado que se pasa no se actualizará hasta que el paquete se quite del puerto de finalización.</span><span class="sxs-lookup"><span data-stu-id="16893-116">When a file handle is associated with a completion port, the status block passed in will not be updated until the packet is removed from the completion port.</span></span> <span data-ttu-id="16893-117">La única excepción es si la operación original vuelve sincrónicamente con un error.</span><span class="sxs-lookup"><span data-stu-id="16893-117">The only exception is if the original operation returns synchronously with an error.</span></span> <span data-ttu-id="16893-118">Un subproceso (uno creado por el subproceso principal o el propio subproceso principal) utiliza la función [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) para esperar a que un paquete de finalización se encuentre en la cola del puerto de finalización de e/s, en lugar de esperar directamente a que se complete la e/s asincrónica.</span><span class="sxs-lookup"><span data-stu-id="16893-118">A thread (either one created by the main thread or the main thread itself) uses the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function to wait for a completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete.</span></span> <span data-ttu-id="16893-119">Los subprocesos que bloquean su ejecución en un puerto de finalización de e/s se liberan en orden LIFO (último en salir, primero en salir) y el siguiente paquete de finalización se extrae de la cola FIFO del puerto de finalización de e/s para ese subproceso.</span><span class="sxs-lookup"><span data-stu-id="16893-119">Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order, and the next completion packet is pulled from the I/O completion port's FIFO queue for that thread.</span></span> <span data-ttu-id="16893-120">Esto significa que, cuando se publica un paquete de finalización en un subproceso, el sistema libera el último subproceso (más reciente) asociado a ese puerto y lo pasa a la información de finalización de la finalización de e/s más antigua.</span><span class="sxs-lookup"><span data-stu-id="16893-120">This means that, when a completion packet is released to a thread, the system releases the last (most recent) thread associated with that port, passing it the completion information for the oldest I/O completion.</span></span>

<span data-ttu-id="16893-121">Aunque cualquier número de subprocesos puede llamar a [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) para un puerto de terminación de e/s especificado, cuando un subproceso especificado llama a **GetQueuedCompletionStatus** la primera vez, se asocia con el puerto de finalización de e/s especificado hasta que se produce una de tres cosas: el subproceso se cierra, especifica un puerto de finalización de e/s diferente o cierra el puerto de finalización</span><span class="sxs-lookup"><span data-stu-id="16893-121">Although any number of threads can call [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) for a specified I/O completion port, when a specified thread calls **GetQueuedCompletionStatus** the first time, it becomes associated with the specified I/O completion port until one of three things occurs: The thread exits, specifies a different I/O completion port, or closes the I/O completion port.</span></span> <span data-ttu-id="16893-122">En otras palabras, un único subproceso se puede asociar a un puerto de finalización de e/s como máximo.</span><span class="sxs-lookup"><span data-stu-id="16893-122">In other words, a single thread can be associated with, at most, one I/O completion port.</span></span>

<span data-ttu-id="16893-123">Cuando un paquete de finalización se pone en cola en un puerto de finalización de e/s, el sistema comprueba primero cuántos subprocesos asociados a ese puerto se están ejecutando.</span><span class="sxs-lookup"><span data-stu-id="16893-123">When a completion packet is queued to an I/O completion port, the system first checks how many threads associated with that port are running.</span></span> <span data-ttu-id="16893-124">Si el número de subprocesos que se ejecutan es menor que el valor de simultaneidad (descrito en la sección siguiente), se permite que uno de los subprocesos en espera (el más reciente) Procese el paquete de finalización.</span><span class="sxs-lookup"><span data-stu-id="16893-124">If the number of threads running is less than the concurrency value (discussed in the next section), one of the waiting threads (the most recent one) is allowed to process the completion packet.</span></span> <span data-ttu-id="16893-125">Cuando un subproceso en ejecución completa su procesamiento, normalmente llama de nuevo a [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) , momento en el que se devuelve con el siguiente paquete de finalización o espera si la cola está vacía.</span><span class="sxs-lookup"><span data-stu-id="16893-125">When a running thread completes its processing, it typically calls [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) again, at which point it either returns with the next completion packet or waits if the queue is empty.</span></span>

<span data-ttu-id="16893-126">Los subprocesos pueden usar la función [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) para colocar los paquetes de finalización en la cola de un puerto de finalización de e/s.</span><span class="sxs-lookup"><span data-stu-id="16893-126">Threads can use the [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) function to place completion packets in an I/O completion port's queue.</span></span> <span data-ttu-id="16893-127">Al hacerlo, el puerto de finalización se puede usar para recibir comunicaciones de otros subprocesos del proceso, además de recibir paquetes de finalización de e/s del sistema de e/s.</span><span class="sxs-lookup"><span data-stu-id="16893-127">By doing so, the completion port can be used to receive communications from other threads of the process, in addition to receiving I/O completion packets from the I/O system.</span></span> <span data-ttu-id="16893-128">La función **PostQueuedCompletionStatus** permite a una aplicación poner en cola sus propios paquetes de finalización especial en el puerto de finalización de e/s sin iniciar una operación de e/s asincrónica.</span><span class="sxs-lookup"><span data-stu-id="16893-128">The **PostQueuedCompletionStatus** function allows an application to queue its own special-purpose completion packets to the I/O completion port without starting an asynchronous I/O operation.</span></span> <span data-ttu-id="16893-129">Esto es útil para notificar a los subprocesos de trabajo de eventos externos, por ejemplo.</span><span class="sxs-lookup"><span data-stu-id="16893-129">This is useful for notifying worker threads of external events, for example.</span></span>

<span data-ttu-id="16893-130">El identificador de puerto de finalización de e/s y todos los identificadores de archivo asociados a ese puerto de terminación de e/s concreto se conocen como *referencias al puerto de terminación de e/s*.</span><span class="sxs-lookup"><span data-stu-id="16893-130">The I/O completion port handle and every file handle associated with that particular I/O completion port are known as *references to the I/O completion port*.</span></span> <span data-ttu-id="16893-131">El puerto de finalización de e/s se libera cuando no hay más referencias a él.</span><span class="sxs-lookup"><span data-stu-id="16893-131">The I/O completion port is released when there are no more references to it.</span></span> <span data-ttu-id="16893-132">Por lo tanto, todos estos identificadores deben estar cerrados correctamente para liberar el puerto de finalización de e/s y sus recursos del sistema asociados.</span><span class="sxs-lookup"><span data-stu-id="16893-132">Therefore, all of these handles must be properly closed to release the I/O completion port and its associated system resources.</span></span> <span data-ttu-id="16893-133">Una vez que se cumplen estas condiciones, una aplicación debe cerrar el identificador del puerto de finalización de e/s mediante una llamada a la función [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) .</span><span class="sxs-lookup"><span data-stu-id="16893-133">After these conditions are satisfied, an application should close the I/O completion port handle by calling the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span>

> [!Note]
>
> <span data-ttu-id="16893-134">Un puerto de finalización de e/s está asociado al proceso que lo creó y no se puede compartir entre los procesos.</span><span class="sxs-lookup"><span data-stu-id="16893-134">An I/O completion port is associated with the process that created it and is not sharable between processes.</span></span> <span data-ttu-id="16893-135">Sin embargo, un único identificador se compartirá entre los subprocesos del mismo proceso.</span><span class="sxs-lookup"><span data-stu-id="16893-135">However, a single handle is sharable between threads in the same process.</span></span>

 

## <a name="threads-and-concurrency"></a><span data-ttu-id="16893-136">Subprocesos y simultaneidad</span><span class="sxs-lookup"><span data-stu-id="16893-136">Threads and Concurrency</span></span>

<span data-ttu-id="16893-137">La propiedad más importante de un puerto de finalización de e/s que se debe considerar con cuidado es el valor de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="16893-137">The most important property of an I/O completion port to consider carefully is the concurrency value.</span></span> <span data-ttu-id="16893-138">El valor de simultaneidad de un puerto de finalización se especifica cuando se crea con [**CreateIoCompletionPort**](createiocompletionport.md) a través del parámetro *NumberOfConcurrentThreads* .</span><span class="sxs-lookup"><span data-stu-id="16893-138">The concurrency value of a completion port is specified when it is created with [**CreateIoCompletionPort**](createiocompletionport.md) via the *NumberOfConcurrentThreads* parameter.</span></span> <span data-ttu-id="16893-139">Este valor limita el número de subprocesos ejecutables asociados al puerto de finalización.</span><span class="sxs-lookup"><span data-stu-id="16893-139">This value limits the number of runnable threads associated with the completion port.</span></span> <span data-ttu-id="16893-140">Cuando el número total de subprocesos ejecutables asociados al puerto de finalización alcanza el valor de simultaneidad, el sistema bloquea la ejecución de los subprocesos posteriores asociados a ese puerto de finalización hasta que el número de subprocesos ejecutables caiga por debajo del valor de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="16893-140">When the total number of runnable threads associated with the completion port reaches the concurrency value, the system blocks the execution of any subsequent threads associated with that completion port until the number of runnable threads drops below the concurrency value.</span></span>

<span data-ttu-id="16893-141">El escenario más eficaz se produce cuando hay paquetes de finalización en espera en la cola, pero no se puede satisfacer ninguna espera porque el puerto ha alcanzado su límite de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="16893-141">The most efficient scenario occurs when there are completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit.</span></span> <span data-ttu-id="16893-142">Tenga en cuenta lo que sucede con un valor de simultaneidad de uno y varios subprocesos que esperan en la llamada de función [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) .</span><span class="sxs-lookup"><span data-stu-id="16893-142">Consider what happens with a concurrency value of one and multiple threads waiting in the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function call.</span></span> <span data-ttu-id="16893-143">En este caso, si la cola siempre tiene paquetes de finalización en espera, cuando el subproceso en ejecución llama a **GetQueuedCompletionStatus**, no bloqueará la ejecución porque, como se mencionó anteriormente, la cola de subprocesos es LIFO.</span><span class="sxs-lookup"><span data-stu-id="16893-143">In this case, if the queue always has completion packets waiting, when the running thread calls **GetQueuedCompletionStatus**, it will not block execution because, as mentioned earlier, the thread queue is LIFO.</span></span> <span data-ttu-id="16893-144">En su lugar, este subproceso recogerá inmediatamente el siguiente paquete de finalización en cola.</span><span class="sxs-lookup"><span data-stu-id="16893-144">Instead, this thread will immediately pick up the next queued completion packet.</span></span> <span data-ttu-id="16893-145">No se producirán cambios de contexto de subproceso, ya que el subproceso en ejecución selecciona continuamente los paquetes de finalización y los demás subprocesos no se pueden ejecutar.</span><span class="sxs-lookup"><span data-stu-id="16893-145">No thread context switches will occur, because the running thread is continually picking up completion packets and the other threads are unable to run.</span></span>

> [!Note]
>
> <span data-ttu-id="16893-146">En el ejemplo anterior, los subprocesos adicionales parecen ser inútiles y no ejecutarse, pero eso supone que el subproceso en ejecución nunca se pone en un estado de espera por algún otro mecanismo, finaliza o cierra su puerto de finalización de e/s asociado.</span><span class="sxs-lookup"><span data-stu-id="16893-146">In the previous example, the extra threads appear to be useless and never run, but that assumes that the running thread never gets put in a wait state by some other mechanism, terminates, or otherwise closes its associated I/O completion port.</span></span> <span data-ttu-id="16893-147">Tenga en cuenta todas esas ramificaciones de ejecución de subprocesos al diseñar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="16893-147">Consider all such thread execution ramifications when designing the application.</span></span>

 

<span data-ttu-id="16893-148">El mejor valor máximo general para elegir para el valor de simultaneidad es el número de CPU del equipo.</span><span class="sxs-lookup"><span data-stu-id="16893-148">The best overall maximum value to pick for the concurrency value is the number of CPUs on the computer.</span></span> <span data-ttu-id="16893-149">Si la transacción requirió un cálculo largo, un valor de simultaneidad mayor permitirá que se ejecuten más subprocesos.</span><span class="sxs-lookup"><span data-stu-id="16893-149">If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run.</span></span> <span data-ttu-id="16893-150">Cada paquete de finalización puede tardar más tiempo en completarse, pero se procesarán más paquetes de finalización al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="16893-150">Each completion packet may take longer to finish, but more completion packets will be processed at the same time.</span></span> <span data-ttu-id="16893-151">Puede experimentar con el valor de simultaneidad junto con las herramientas de generación de perfiles para lograr el mejor efecto para su aplicación.</span><span class="sxs-lookup"><span data-stu-id="16893-151">You can experiment with the concurrency value in conjunction with profiling tools to achieve the best effect for your application.</span></span>

<span data-ttu-id="16893-152">El sistema también permite que un subproceso que espera en [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) procese un paquete de finalización si otro subproceso en ejecución asociado con el mismo puerto de finalización de e/s entra en un estado de espera por otros motivos, por ejemplo, la función [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) .</span><span class="sxs-lookup"><span data-stu-id="16893-152">The system also allows a thread waiting in [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) to process a completion packet if another running thread associated with the same I/O completion port enters a wait state for other reasons, for example the [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) function.</span></span> <span data-ttu-id="16893-153">Cuando el subproceso en el estado de espera empieza a ejecutarse de nuevo, puede haber un breve período en el que el número de subprocesos activos supera el valor de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="16893-153">When the thread in the wait state begins running again, there may be a brief period when the number of active threads exceeds the concurrency value.</span></span> <span data-ttu-id="16893-154">Sin embargo, el sistema reduce rápidamente este número al no permitir ningún subproceso activo nuevo hasta que el número de subprocesos activos caiga por debajo del valor de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="16893-154">However, the system quickly reduces this number by not allowing any new active threads until the number of active threads falls below the concurrency value.</span></span> <span data-ttu-id="16893-155">Esta es una de las razones para que la aplicación cree más subprocesos en su grupo de subprocesos que el valor de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="16893-155">This is one reason to have your application create more threads in its thread pool than the concurrency value.</span></span> <span data-ttu-id="16893-156">La administración de grupos de subprocesos queda fuera del ámbito de este tema, pero una buena regla general es tener un mínimo de dos subprocesos en el grupo de subprocesos, ya que hay procesadores en el sistema.</span><span class="sxs-lookup"><span data-stu-id="16893-156">Thread pool management is beyond the scope of this topic, but a good rule of thumb is to have a minimum of twice as many threads in the thread pool as there are processors on the system.</span></span> <span data-ttu-id="16893-157">Para obtener más información sobre la agrupación de subprocesos, vea [grupos de subprocesos](/windows/desktop/ProcThread/thread-pools).</span><span class="sxs-lookup"><span data-stu-id="16893-157">For additional information about thread pooling, see [Thread Pools](/windows/desktop/ProcThread/thread-pools).</span></span>

## <a name="supported-io-functions"></a><span data-ttu-id="16893-158">Funciones de e/s admitidas</span><span class="sxs-lookup"><span data-stu-id="16893-158">Supported I/O Functions</span></span>

<span data-ttu-id="16893-159">Las siguientes funciones se pueden usar para iniciar operaciones de e/s que se completan mediante puertos de finalización de e/s.</span><span class="sxs-lookup"><span data-stu-id="16893-159">The following functions can be used to start I/O operations that complete by using I/O completion ports.</span></span> <span data-ttu-id="16893-160">Debe pasar la función a una instancia de la estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) y a un identificador de archivo asociado previamente a un puerto de finalización de e/s (mediante una llamada a [**CreateIoCompletionPort**](createiocompletionport.md)) para habilitar el mecanismo del puerto de finalización de e/s:</span><span class="sxs-lookup"><span data-stu-id="16893-160">You must pass the function an instance of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure and a file handle previously associated with an I/O completion port (by a call to [**CreateIoCompletionPort**](createiocompletionport.md)) to enable the I/O completion port mechanism:</span></span>

-   [<span data-ttu-id="16893-161">**ConnectNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="16893-161">**ConnectNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)
-   [<span data-ttu-id="16893-162">**DeviceIoControl**</span><span class="sxs-lookup"><span data-stu-id="16893-162">**DeviceIoControl**</span></span>](/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol)
-   [<span data-ttu-id="16893-163">**LockFileEx**</span><span class="sxs-lookup"><span data-stu-id="16893-163">**LockFileEx**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-lockfileex)
-   [<span data-ttu-id="16893-164">**ReadDirectoryChangesW**</span><span class="sxs-lookup"><span data-stu-id="16893-164">**ReadDirectoryChangesW**</span></span>](/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw)
-   [<span data-ttu-id="16893-165">**ReadFile**</span><span class="sxs-lookup"><span data-stu-id="16893-165">**ReadFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-readfile)
-   [<span data-ttu-id="16893-166">**TransactNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="16893-166">**TransactNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)
-   [<span data-ttu-id="16893-167">**WaitCommEvent**</span><span class="sxs-lookup"><span data-stu-id="16893-167">**WaitCommEvent**</span></span>](/windows/desktop/api/winbase/nf-winbase-waitcommevent)
-   [<span data-ttu-id="16893-168">**WriteFile**</span><span class="sxs-lookup"><span data-stu-id="16893-168">**WriteFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-writefile)
-   [<span data-ttu-id="16893-169">**WSASendMsg**</span><span class="sxs-lookup"><span data-stu-id="16893-169">**WSASendMsg**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)
-   [<span data-ttu-id="16893-170">**WSASendTo**</span><span class="sxs-lookup"><span data-stu-id="16893-170">**WSASendTo**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendto)
-   [<span data-ttu-id="16893-171">**WSASend**</span><span class="sxs-lookup"><span data-stu-id="16893-171">**WSASend**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasend)
-   [<span data-ttu-id="16893-172">**WSARecvFrom**</span><span class="sxs-lookup"><span data-stu-id="16893-172">**WSARecvFrom**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom)
-   [<span data-ttu-id="16893-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span><span class="sxs-lookup"><span data-stu-id="16893-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span></span>](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)
-   [<span data-ttu-id="16893-174">**WSARecv**</span><span class="sxs-lookup"><span data-stu-id="16893-174">**WSARecv**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecv)

## <a name="related-topics"></a><span data-ttu-id="16893-175">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="16893-175">Related topics</span></span>

<dl> <span data-ttu-id="16893-176"><dt>


</dt> <dt></span><span class="sxs-lookup"><span data-stu-id="16893-176"><dt>


</dt> <dt></span></span>

[<span data-ttu-id="16893-177">Acerca de los procesos y los subprocesos</span><span class="sxs-lookup"><span data-stu-id="16893-177">About Processes and Threads</span></span>](/windows/desktop/ProcThread/about-processes-and-threads)
</dt> <dt>

[<span data-ttu-id="16893-178">**BindIoCompletionCallback**</span><span class="sxs-lookup"><span data-stu-id="16893-178">**BindIoCompletionCallback**</span></span>](/windows/desktop/api/winbase/nf-winbase-bindiocompletioncallback)
</dt> <dt>

[<span data-ttu-id="16893-179">**CreateIoCompletionPort**</span><span class="sxs-lookup"><span data-stu-id="16893-179">**CreateIoCompletionPort**</span></span>](createiocompletionport.md)
</dt> <dt>

[<span data-ttu-id="16893-180">**GetQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="16893-180">**GetQueuedCompletionStatus**</span></span>](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)
</dt> <dt>

[<span data-ttu-id="16893-181">**GetQueuedCompletionStatusEx**</span><span class="sxs-lookup"><span data-stu-id="16893-181">**GetQueuedCompletionStatusEx**</span></span>](getqueuedcompletionstatusex-func.md)
</dt> <dt>

[<span data-ttu-id="16893-182">**PostQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="16893-182">**PostQueuedCompletionStatus**</span></span>](postqueuedcompletionstatus.md)
</dt> </dl>

 

 
