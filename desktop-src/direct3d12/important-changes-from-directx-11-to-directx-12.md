---
title: Cambios importantes de Direct3D 11 a Direct3D 12
description: Direct3D 12 representa una salida significativa del modelo de programación de Direct3D 11. Direct3D 12 permite que las aplicaciones se acerquen más al hardware que nunca.
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5be891d71d6c1f3a12d8d5aac3ec46785207ed31
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/20/2020
ms.locfileid: "104549082"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="b487e-104">Cambios importantes de Direct3D 11 a Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="b487e-104">Important Changes from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="b487e-105">Direct3D 12 representa una salida significativa del modelo de programación de Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="b487e-105">Direct3D 12 represents a significant departure from the Direct3D 11 programming model.</span></span> <span data-ttu-id="b487e-106">Direct3D 12 permite que las aplicaciones se acerquen más al hardware que nunca.</span><span class="sxs-lookup"><span data-stu-id="b487e-106">Direct3D 12 lets apps get closer to hardware than ever before.</span></span> <span data-ttu-id="b487e-107">Al estar más cerca del hardware, Direct3D 12 es más rápido y eficaz.</span><span class="sxs-lookup"><span data-stu-id="b487e-107">By being closer to hardware, Direct3D 12 is faster and more efficient.</span></span> <span data-ttu-id="b487e-108">Sin embargo, el equilibrio entre la aplicación y la mayor velocidad y eficacia con Direct3D 12 es que usted es responsable de realizar más tareas de las que tenía Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="b487e-108">But, the trade-off of your app having increased speed and efficiency with Direct3D 12 is that you are responsible for more tasks than you were with Direct3D 11.</span></span>

-   [<span data-ttu-id="b487e-109">Sincronización explícita</span><span class="sxs-lookup"><span data-stu-id="b487e-109">Explicit Synchronization</span></span>](#explicit-synchronization)
-   [<span data-ttu-id="b487e-110">Administración de la residencia de memoria física</span><span class="sxs-lookup"><span data-stu-id="b487e-110">Physical Memory Residency Management</span></span>](#physical-memory-residency-management)
-   [<span data-ttu-id="b487e-111">Objetos de estado de canalización</span><span class="sxs-lookup"><span data-stu-id="b487e-111">Pipeline state objects</span></span>](#pipeline-state-objects)
-   [<span data-ttu-id="b487e-112">Listas de comandos y agrupaciones</span><span class="sxs-lookup"><span data-stu-id="b487e-112">Command lists and bundles</span></span>](#command-lists-and-bundles)
-   [<span data-ttu-id="b487e-113">Tablas y montones de descriptores</span><span class="sxs-lookup"><span data-stu-id="b487e-113">Descriptor heaps and tables</span></span>](#descriptor-heaps-and-tables)
-   [<span data-ttu-id="b487e-114">Portabilidad desde Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="b487e-114">Porting from Direct3D 11</span></span>](#porting-from-direct3d-11)
-   [<span data-ttu-id="b487e-115">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="b487e-115">Related topics</span></span>](#related-topics)

<span data-ttu-id="b487e-116">Direct3D 12 es una devolución a la programación de bajo nivel; proporciona un mayor control sobre los elementos gráficos de los juegos y las aplicaciones mediante la introducción de estas nuevas características: objetos para representar el estado general de la canalización, las listas de comandos y las agrupaciones para el envío del trabajo, y las tablas y los montones de descriptor para el acceso a los recursos.</span><span class="sxs-lookup"><span data-stu-id="b487e-116">Direct3D 12 is a return to low-level programming; it gives you more control over the graphical elements of your games and apps by introducing these new features: objects to represent the overall state of the pipeline, command lists and bundles for work submission, and descriptor heaps and tables for resource access.</span></span>

<span data-ttu-id="b487e-117">La aplicación ha aumentado la velocidad y la eficacia con Direct3D 12, pero usted es responsable de realizar más tareas de las que tenía Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="b487e-117">Your app has increased speed and efficiency with Direct3D 12, but you are responsible for more tasks than you were with Direct3D 11.</span></span>

## <a name="explicit-synchronization"></a><span data-ttu-id="b487e-118">Sincronización explícita</span><span class="sxs-lookup"><span data-stu-id="b487e-118">Explicit Synchronization</span></span>

-   <span data-ttu-id="b487e-119">En Direct3D 12, la sincronización de CPU-GPU es ahora la responsabilidad explícita de la aplicación y ya no la realiza el tiempo de ejecución de forma implícita, como en Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="b487e-119">In Direct3D 12, CPU-GPU synchronization is now the explicit responsibility of the app and is no longer implicitly performed by the runtime, as it is in Direct3D 11.</span></span> <span data-ttu-id="b487e-120">Este hecho también significa que Direct3D 12 no realiza la comprobación automática de los peligros de la canalización, por lo que es responsabilidad de las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="b487e-120">This fact also means that no automatic checking for pipeline hazards is performed by Direct3D 12, so again this is the apps responsibility.</span></span>
-   <span data-ttu-id="b487e-121">En Direct3D 12, las aplicaciones son responsables de la canalización de las actualizaciones de datos.</span><span class="sxs-lookup"><span data-stu-id="b487e-121">In Direct3D 12, apps are responsible for pipelining data updates.</span></span> <span data-ttu-id="b487e-122">Es decir, el patrón "Map/Lock-discard" de Direct3D 11 debe realizarse manualmente en Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="b487e-122">That is, the "Map/Lock-DISCARD" pattern in Direct3D 11 must be performed manually in Direct3D 12.</span></span> <span data-ttu-id="b487e-123">En Direct3D 11, si la GPU todavía usa el búfer cuando se llama a [**ID3D11DeviceContext:: Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) con [**D3D11 \_ map \_ Write \_ discard**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), el tiempo de ejecución devuelve un puntero a una nueva región de memoria en lugar de los datos de búfer antiguos.</span><span class="sxs-lookup"><span data-stu-id="b487e-123">In Direct3D 11, if the GPU is still using the buffer when you call [**ID3D11DeviceContext::Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) with [**D3D11\_MAP\_WRITE\_DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), the runtime returns a pointer to a new region of memory instead of the old buffer data.</span></span> <span data-ttu-id="b487e-124">Esto permite que la GPU siga usando los datos antiguos mientras la aplicación coloca los datos en el nuevo búfer.</span><span class="sxs-lookup"><span data-stu-id="b487e-124">This allows the GPU to continue using the old data while the app places data in the new buffer.</span></span> <span data-ttu-id="b487e-125">No se requiere ninguna administración de memoria adicional en la aplicación; el búfer antiguo se reutiliza o se destruye automáticamente cuando la GPU finaliza con él.</span><span class="sxs-lookup"><span data-stu-id="b487e-125">No additional memory management is required in the app; the old buffer is reused or destroyed automatically when the GPU is finished with it.</span></span>
-   <span data-ttu-id="b487e-126">En Direct3D 12, todas las actualizaciones dinámicas (incluidos los búferes de constantes, los búferes de vértices dinámicos, las texturas dinámicas, etc.) son controladas explícitamente por la aplicación.</span><span class="sxs-lookup"><span data-stu-id="b487e-126">In Direct3D 12, all dynamic updates (including constant buffers, dynamic vertex buffers, dynamic textures, and so on) are explicitly controlled by the app.</span></span> <span data-ttu-id="b487e-127">Estas actualizaciones dinámicas incluyen las barreras o el almacenamiento en búfer necesarios de la GPU.</span><span class="sxs-lookup"><span data-stu-id="b487e-127">These dynamic updates include any required GPU fences or buffering.</span></span> <span data-ttu-id="b487e-128">La aplicación es responsable de mantener la memoria disponible hasta que ya no se necesita.</span><span class="sxs-lookup"><span data-stu-id="b487e-128">The app is responsible for keeping the memory available until it is no longer needed.</span></span>
-   <span data-ttu-id="b487e-129">Direct3D 12 usa el recuento de referencias de estilo COM solo para las duraciones de las interfaces (mediante el modelo de referencia débil de Direct3D vinculado a la duración del dispositivo).</span><span class="sxs-lookup"><span data-stu-id="b487e-129">Direct3D 12 uses COM-style reference counting only for the lifetimes of interfaces (by using the weak reference model of Direct3D tied to the lifetime of the device).</span></span> <span data-ttu-id="b487e-130">Toda la duración de la memoria de los recursos y las descripciones es el único responsable de la aplicación para mantener la duración adecuada y no se cuentan las referencias.</span><span class="sxs-lookup"><span data-stu-id="b487e-130">All resource and description memory lifetimes are the sole responsibly of the app to maintain for the proper duration, and are not reference counted.</span></span> <span data-ttu-id="b487e-131">Direct3D 11 usa el recuento de referencias para administrar también la duración de las dependencias de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="b487e-131">Direct3D 11 uses reference counting to manage the lifetimes of interface dependencies as well.</span></span>

## <a name="physical-memory-residency-management"></a><span data-ttu-id="b487e-132">Administración de la residencia de memoria física</span><span class="sxs-lookup"><span data-stu-id="b487e-132">Physical Memory Residency Management</span></span>

<span data-ttu-id="b487e-133">Una aplicación de Direct3D 12 debe evitar las condiciones de carrera entre varias colas, varios adaptadores y los subprocesos de CPU.</span><span class="sxs-lookup"><span data-stu-id="b487e-133">A Direct3D 12 application must prevent race-conditions between multiple queues, multiple adapters, and the CPU threads.</span></span> <span data-ttu-id="b487e-134">D3D12 ya no sincroniza la CPU y la GPU, ni admite mecanismos cómodos para el cambio de nombre de recursos o el almacenamiento en búfer múltiple.</span><span class="sxs-lookup"><span data-stu-id="b487e-134">D3D12 no longer synchronizes the CPU and GPU, nor supports convenient mechanisms for resource renaming or multi-buffering.</span></span> <span data-ttu-id="b487e-135">Las barreras deben usarse para evitar que varias unidades de procesamiento sobrescriban la memoria antes de que otra unidad de procesamiento termine de usarlas.</span><span class="sxs-lookup"><span data-stu-id="b487e-135">Fences must be used to avoid multiple processing units from over-writing memory before another processing unit finishes using it.</span></span>

<span data-ttu-id="b487e-136">La aplicación Direct3D 12 debe asegurarse de que los datos residen en la memoria mientras la GPU lo lee.</span><span class="sxs-lookup"><span data-stu-id="b487e-136">The Direct3D 12 application must ensure data is resident in memory while the GPU reads it.</span></span> <span data-ttu-id="b487e-137">La memoria usada por cada objeto se hace residente durante la creación del objeto.</span><span class="sxs-lookup"><span data-stu-id="b487e-137">Memory used by each object is made resident during the creation of the object.</span></span> <span data-ttu-id="b487e-138">Las aplicaciones que llaman a estos métodos deben usar barreras para asegurarse de que la GPU no tenga acceso a los objetos que se han expulsado.</span><span class="sxs-lookup"><span data-stu-id="b487e-138">Applications which call these methods must use fences to ensure the GPU doesn't access objects which have been evicted.</span></span>

<span data-ttu-id="b487e-139">Las barreras de recursos son otro tipo de sincronización necesario, que se utiliza para sincronizar las transiciones de recursos y Subrecursos en un nivel muy granular.</span><span class="sxs-lookup"><span data-stu-id="b487e-139">Resource barriers are another type of synchronization needed, used to synchronize resource and subresource transitions at a very granular level.</span></span>

<span data-ttu-id="b487e-140">Consulte [Administración de memoria en Direct3D 12](memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="b487e-140">Refer to [Memory Management in Direct3D 12](memory-management.md).</span></span>

## <a name="pipeline-state-objects"></a><span data-ttu-id="b487e-141">Objetos de estado de canalización</span><span class="sxs-lookup"><span data-stu-id="b487e-141">Pipeline state objects</span></span>

<span data-ttu-id="b487e-142">Direct3D 11 permite la manipulación del estado de la canalización a través de un gran conjunto de objetos independientes.</span><span class="sxs-lookup"><span data-stu-id="b487e-142">Direct3D 11 allows pipeline state manipulation through a large set of independent objects.</span></span> <span data-ttu-id="b487e-143">Por ejemplo, el estado del ensamblador de entrada, el estado del sombreador de píxeles, el estado de rasterizador y el estado de fusión de salida se pueden modificar de forma independiente.</span><span class="sxs-lookup"><span data-stu-id="b487e-143">For example, input assembler state, pixel shader state, rasterizer state, and output merger state can all be independently modified.</span></span> <span data-ttu-id="b487e-144">Este diseño proporciona una representación práctica y relativamente de alto nivel de la canalización de gráficos, pero no utiliza las capacidades del hardware moderno, principalmente porque los diversos Estados suelen ser interdependientes.</span><span class="sxs-lookup"><span data-stu-id="b487e-144">This design provides a convenient and relatively high-level representation of the graphics pipeline, but it doesn’t utilize the capabilities of modern hardware, primarily because the various states are often interdependent.</span></span> <span data-ttu-id="b487e-145">Por ejemplo, muchas GPU combinan el sombreador de píxeles y el estado de fusión de salida en una única representación de hardware.</span><span class="sxs-lookup"><span data-stu-id="b487e-145">For example, many GPUs combine pixel shader and output merger state into a single hardware representation.</span></span> <span data-ttu-id="b487e-146">Sin embargo, dado que la API de Direct3D 11 permite que estas fases de canalización se establezcan por separado, el controlador de pantalla no puede resolver los problemas de estado de la canalización hasta que finalice el estado, que no es hasta el momento de la hora de dibujo.</span><span class="sxs-lookup"><span data-stu-id="b487e-146">But because the Direct3D 11 API allows these pipeline stages to be set separately, the display driver can't resolve issues of pipeline state until the state is finalized, which isn’t until draw time.</span></span> <span data-ttu-id="b487e-147">Este esquema retrasa la configuración de estado de hardware, lo que significa sobrecarga adicional y menos llamadas de dibujo por fotograma.</span><span class="sxs-lookup"><span data-stu-id="b487e-147">This scheme delays hardware state setup, which means extra overhead and fewer maximum draw calls per frame.</span></span>

<span data-ttu-id="b487e-148">Direct3D 12 aborda este esquema al unificar gran parte del estado de la canalización en objetos de estado de canalización inmutables (PSO), que se finalizan tras la creación.</span><span class="sxs-lookup"><span data-stu-id="b487e-148">Direct3D 12 addresses this scheme by unifying much of the pipeline state into immutable pipeline state objects (PSOs), which are finalized upon creation.</span></span> <span data-ttu-id="b487e-149">El hardware y los controladores pueden convertir inmediatamente el PSO en cualquier Estado y instrucciones nativas de hardware necesarias para ejecutar el trabajo de la GPU.</span><span class="sxs-lookup"><span data-stu-id="b487e-149">Hardware and drivers can then immediately convert the PSO into whatever hardware native instructions and state are required to execute GPU work.</span></span> <span data-ttu-id="b487e-150">Todavía puede cambiar dinámicamente qué PSO está en uso, pero para hacerlo, el hardware solo necesita copiar la cantidad mínima de estado precalculada directamente en los registros de hardware, en lugar de calcular el estado del hardware sobre la marcha.</span><span class="sxs-lookup"><span data-stu-id="b487e-150">You can still dynamically change which PSO is in use, but to do so, the hardware only needs to copy the minimal amount of pre-computed state directly to the hardware registers, rather than computing the hardware state on the fly.</span></span> <span data-ttu-id="b487e-151">Mediante el uso de PSO, la sobrecarga de la llamada a Draw se reduce significativamente y se pueden producir muchas más llamadas a Draw por fotograma.</span><span class="sxs-lookup"><span data-stu-id="b487e-151">By using PSOs, draw call overhead is reduced significantly, and many more draw calls can occur per frame.</span></span> <span data-ttu-id="b487e-152">Para obtener más información sobre PSO, vea [administrar el estado de canalización de gráficos en Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="b487e-152">For more information about PSOs, see [Managing graphics pipeline state in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="command-lists-and-bundles"></a><span data-ttu-id="b487e-153">Listas de comandos y agrupaciones</span><span class="sxs-lookup"><span data-stu-id="b487e-153">Command lists and bundles</span></span>

<span data-ttu-id="b487e-154">En Direct3D 11, todo el envío de trabajo se realiza a través del [contexto inmediato](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), que representa una única secuencia de comandos que van a la GPU.</span><span class="sxs-lookup"><span data-stu-id="b487e-154">In Direct3D 11, all work submission is done via the [immediate context](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), which represents a single stream of commands that go to the GPU.</span></span> <span data-ttu-id="b487e-155">Para lograr el escalado multiproceso, los juegos también tienen [contextos diferidos](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) a su disposición.</span><span class="sxs-lookup"><span data-stu-id="b487e-155">To achieve multithreaded scaling, games also have [deferred contexts](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) available to them.</span></span> <span data-ttu-id="b487e-156">Los contextos aplazados en Direct3D 11 no se asignan perfectamente al hardware, por lo que se puede hacer relativamente poco trabajo en ellos.</span><span class="sxs-lookup"><span data-stu-id="b487e-156">Deferred contexts in Direct3D 11 don't map perfectly to hardware, so relatively little work can be done in them.</span></span>

<span data-ttu-id="b487e-157">Direct3D 12 presenta un nuevo modelo para el envío de trabajo basado en listas de comandos que contienen toda la información necesaria para ejecutar una carga de trabajo determinada en la GPU.</span><span class="sxs-lookup"><span data-stu-id="b487e-157">Direct3D 12 introduces a new model for work submission based on command lists that contain the entirety of information needed to execute a particular workload on the GPU.</span></span> <span data-ttu-id="b487e-158">Cada nueva lista de comandos contiene información como qué PSO usar, qué recursos de textura y de búfer son necesarios y los argumentos para todas las llamadas a Draw.</span><span class="sxs-lookup"><span data-stu-id="b487e-158">Each new command list contains information such as which PSO to use, what texture and buffer resources are needed, and the arguments to all draw calls.</span></span> <span data-ttu-id="b487e-159">Dado que cada lista de comandos es independiente y no hereda ningún Estado, el controlador puede calcular previamente todos los comandos de GPU necesarios por adelantado y de forma libre.</span><span class="sxs-lookup"><span data-stu-id="b487e-159">Because each command list is self-contained and inherits no state, the driver can pre-compute all necessary GPU commands up-front and in a free-threaded manner.</span></span> <span data-ttu-id="b487e-160">El único proceso en serie necesario es el envío final de las listas de comandos a la GPU a través de la cola de comandos.</span><span class="sxs-lookup"><span data-stu-id="b487e-160">The only serial process necessary is the final submission of command lists to the GPU via the command queue.</span></span>

<span data-ttu-id="b487e-161">Además de las listas de comandos, Direct3D 12 también presenta un segundo nivel de cálculo previo de trabajo: *paquetes*.</span><span class="sxs-lookup"><span data-stu-id="b487e-161">In addition to command lists, Direct3D 12 also introduces a second level of work pre-computation: *bundles*.</span></span> <span data-ttu-id="b487e-162">A diferencia de las listas de comandos, que son completamente independientes y que normalmente se construyen, envían una vez y se descartan, los paquetes proporcionan una forma de herencia de estado que permite la reutilización.</span><span class="sxs-lookup"><span data-stu-id="b487e-162">Unlike command lists, which are completely self-contained and are typically constructed, submitted once, and discarded, bundles provide a form of state inheritance that permits reuse.</span></span> <span data-ttu-id="b487e-163">Por ejemplo, si un juego desea dibujar dos modelos de caracteres con distintas texturas, un enfoque consiste en registrar una lista de comandos con dos conjuntos de llamadas Draw idénticas.</span><span class="sxs-lookup"><span data-stu-id="b487e-163">For example, if a game wants to draw two character models with different textures, one approach is to record a command list with two sets of identical draw calls.</span></span> <span data-ttu-id="b487e-164">Pero otro enfoque es "grabar" una agrupación que dibuja un modelo de un solo carácter y, a continuación, "reproducir" el paquete dos veces en la lista de comandos con recursos diferentes.</span><span class="sxs-lookup"><span data-stu-id="b487e-164">But another approach is to "record" one bundle that draws a single character model, then "play back" the bundle twice on the command list using different resources.</span></span> <span data-ttu-id="b487e-165">En el último caso, el controlador de pantalla solo tiene que calcular las instrucciones adecuadas una vez, y la creación de la lista de comandos básicamente se refiere a dos llamadas de función de bajo costo.</span><span class="sxs-lookup"><span data-stu-id="b487e-165">In the latter case, the display driver only has to compute the appropriate instructions once, and creating the command list essentially amounts to two low-cost function calls.</span></span>

<span data-ttu-id="b487e-166">Para obtener más información sobre las listas de comandos y agrupaciones, vea [envío de trabajos en Direct3D 12](command-queues-and-command-lists.md).</span><span class="sxs-lookup"><span data-stu-id="b487e-166">For more information about command lists and bundles, see [Work Submission in Direct3D 12](command-queues-and-command-lists.md).</span></span>

## <a name="descriptor-heaps-and-tables"></a><span data-ttu-id="b487e-167">Tablas y montones de descriptores</span><span class="sxs-lookup"><span data-stu-id="b487e-167">Descriptor heaps and tables</span></span>

<span data-ttu-id="b487e-168">El enlace de recursos en Direct3D 11 está muy condensado y práctico, pero deja muchas capacidades de hardware modernas poco utilizadas.</span><span class="sxs-lookup"><span data-stu-id="b487e-168">Resource binding in Direct3D 11 is highly abstracted and convenient, but leaves many modern hardware capabilities underutilized.</span></span> <span data-ttu-id="b487e-169">En Direct3D 11, los juegos crean objetos de *vista* de recursos y, luego, enlazan esas vistas a varias *ranuras* en varias fases del sombreador en la canalización.</span><span class="sxs-lookup"><span data-stu-id="b487e-169">In Direct3D 11, games create *view* objects of resources, then bind those views to several *slots* at various shader stages in the pipeline.</span></span> <span data-ttu-id="b487e-170">Los sombreadores, a su vez, leen los datos de esas ranuras de enlace explícitas, que se corrigen en tiempo de dibujo.</span><span class="sxs-lookup"><span data-stu-id="b487e-170">Shaders, in turn, read data from those explicit bind slots, which are fixed at draw time.</span></span> <span data-ttu-id="b487e-171">Este modelo significa que cada vez que un juego dibuje con distintos recursos, debe volver a enlazar diferentes vistas a diferentes ranuras y volver a llamar a Draw.</span><span class="sxs-lookup"><span data-stu-id="b487e-171">This model means that whenever a game will draw using different resources, it must re-bind different views to different slots, and call draw again.</span></span> <span data-ttu-id="b487e-172">Este caso también representa la sobrecarga que se puede eliminar al usar completamente las capacidades de hardware modernas.</span><span class="sxs-lookup"><span data-stu-id="b487e-172">This case also represents overhead that can be eliminated by fully utilizing modern hardware capabilities.</span></span>

<span data-ttu-id="b487e-173">Direct3D 12 cambia el modelo de enlace para que coincida con el hardware moderno y mejora significativamente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="b487e-173">Direct3D 12 changes the binding model to match modern hardware and significantly improves performance.</span></span> <span data-ttu-id="b487e-174">En lugar de requerir vistas de recursos independientes y la asignación explícita a las ranuras, Direct3D 12 proporciona un montón de descriptores en el que los juegos crean sus diversas vistas de recursos.</span><span class="sxs-lookup"><span data-stu-id="b487e-174">Instead of requiring standalone resource views and explicit mapping to slots, Direct3D 12 provides a descriptor heap into which games create their various resource views.</span></span> <span data-ttu-id="b487e-175">Este esquema proporciona un mecanismo para que la GPU escriba directamente el hardware: Descripción de los recursos nativos (descriptor) en la memoria por adelantado.</span><span class="sxs-lookup"><span data-stu-id="b487e-175">This scheme provides a mechanism for the GPU to directly write the hardware-native resource description (descriptor) to memory up-front.</span></span> <span data-ttu-id="b487e-176">Para declarar qué recursos va a utilizar la canalización para una llamada de Draw determinada, los juegos especifican una o más tablas de descriptores que representan subintervalos del montón de descriptor completo.</span><span class="sxs-lookup"><span data-stu-id="b487e-176">To declare which resources are to be used by the pipeline for a particular draw call, games specify one or more descriptor tables that represent sub-ranges of the full descriptor heap.</span></span> <span data-ttu-id="b487e-177">Dado que el montón de descriptores ya se ha rellenado con los datos de descriptor específicos del hardware adecuados, el cambio de las tablas de descriptores es una operación extremadamente económica.</span><span class="sxs-lookup"><span data-stu-id="b487e-177">As the descriptor heap has already been populated with the appropriate hardware-specific descriptor data, changing descriptor tables is an extremely low-cost operation.</span></span>

<span data-ttu-id="b487e-178">Además del rendimiento mejorado que ofrecen los montones y las tablas de descriptores, Direct3D 12 también permite indexar dinámicamente los recursos en sombreadores, lo que proporciona una flexibilidad sin precedentes y desbloquea nuevas técnicas de representación.</span><span class="sxs-lookup"><span data-stu-id="b487e-178">In addition to the improved performance offered by descriptor heaps and tables, Direct3D 12 also allows resources to be dynamically indexed in shaders, which provides unprecedented flexibility and unlocks new rendering techniques.</span></span> <span data-ttu-id="b487e-179">Por ejemplo, los motores de representación diferidos modernos normalmente codifican un material o un identificador de objeto de algún tipo en el búfer g intermedio.</span><span class="sxs-lookup"><span data-stu-id="b487e-179">As an example, modern deferred rendering engines typically encode a material or object identifier of some kind to the intermediate g-buffer.</span></span> <span data-ttu-id="b487e-180">En Direct3D 11, estos motores deben tener cuidado de evitar el uso de demasiados materiales, ya que incluir demasiados en un búfer g puede ralentizar considerablemente la fase de representación final.</span><span class="sxs-lookup"><span data-stu-id="b487e-180">In Direct3D 11, these engines must be careful to avoid using too many materials, as including too many in one g-buffer can significantly slow down the final render pass.</span></span> <span data-ttu-id="b487e-181">Con recursos indexables dinámicamente, una escena con mil materiales se puede finalizar tan pronto como una con solo diez.</span><span class="sxs-lookup"><span data-stu-id="b487e-181">With dynamically indexable resources, a scene with a thousand materials can be finalized just as quickly as one with only ten.</span></span>

<span data-ttu-id="b487e-182">Para obtener más información sobre los montones y las tablas de descriptores, vea [enlace de recursos](resource-binding.md)y [diferencias en el modelo de enlace de Direct3D 11](binding-model.md).</span><span class="sxs-lookup"><span data-stu-id="b487e-182">For more information about descriptor heaps and tables, see [Resource Binding](resource-binding.md), and [Differences in the Binding Model from Direct3D 11](binding-model.md).</span></span>

## <a name="porting-from-direct3d-11"></a><span data-ttu-id="b487e-183">Portabilidad desde Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="b487e-183">Porting from Direct3D 11</span></span>

<span data-ttu-id="b487e-184">La migración de Direct3D 11 es un proceso implicado, que se describe en [migración de Direct3D 11 a Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="b487e-184">Porting from Direct3D 11 is an involved process, described in [Porting from Direct3D 11 to Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span></span> <span data-ttu-id="b487e-185">Consulte también el intervalo de opciones para [trabajar con Direct3D 11, Direct3D 10 y Direct2D](direct3d-12-interop.md).</span><span class="sxs-lookup"><span data-stu-id="b487e-185">Also refer to the range of options in [Working with Direct3D 11, Direct3D 10 and Direct2D](direct3d-12-interop.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="b487e-186">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="b487e-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b487e-187">Descripción de Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="b487e-187">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> </dl>

 

 