---
description: Los objetos con nombre proporcionan una manera sencilla de que los procesos compartan los identificadores de objetos.
ms.assetid: 00a00227-45fc-49a1-8ff5-aeccb172d16a
title: Nombres de objeto
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ee746150a41f335a4073cb4b5ba282d17ad706f9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105667975"
---
# <a name="object-names"></a><span data-ttu-id="dfbb7-103">Nombres de objeto</span><span class="sxs-lookup"><span data-stu-id="dfbb7-103">Object Names</span></span>

<span data-ttu-id="dfbb7-104">Los objetos con nombre proporcionan una manera sencilla de que los procesos compartan los identificadores de objetos.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-104">Named objects provide an easy way for processes to share object handles.</span></span> <span data-ttu-id="dfbb7-105">Después de que un proceso haya creado un objeto con nombre, una exclusión mutua, un semáforo o un objeto de temporizador, otros procesos pueden usar el nombre para llamar a la función adecuada ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew)o [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) para abrir un identificador para el objeto.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-105">After a process has created a named event, mutex, semaphore, or timer object, other processes can use the name to call the appropriate function ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew), or [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) to open a handle to the object.</span></span> <span data-ttu-id="dfbb7-106">La comparación de nombres distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-106">Name comparison is case sensitive.</span></span>

<span data-ttu-id="dfbb7-107">Los nombres de evento, semáforo, exclusión mutua, temporizador que se pueden esperar, asignación de archivos y objetos de trabajo comparten el mismo espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-107">The names of event, semaphore, mutex, waitable timer, file-mapping, and job objects share the same namespace.</span></span> <span data-ttu-id="dfbb7-108">Si intenta crear un objeto con un nombre que está en uso por un objeto de otro tipo, se produce un error en la función y [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) devuelve un **\_ \_ identificador no válido**.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-108">If you try to create an object using a name that is in use by an object of another type, the function fails and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_INVALID\_HANDLE**.</span></span> <span data-ttu-id="dfbb7-109">Por lo tanto, al crear objetos con nombre, use nombres únicos y asegúrese de comprobar los valores devueltos de la función en busca de errores de nombre duplicado.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-109">Therefore, when creating named objects, use unique names and be sure to check function return values for duplicate-name errors.</span></span>

<span data-ttu-id="dfbb7-110">Si intenta crear un objeto con un nombre que está siendo utilizado por un objeto del mismo tipo, la función se ejecuta correctamente, devuelve un identificador al objeto existente y [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) devuelve el **error \_ ya \_ existe**.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-110">If you try to create an object using a name that is in use by an object of same type, the function succeeds, returning a handle to the existing object, and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_ALREADY\_EXISTS**.</span></span> <span data-ttu-id="dfbb7-111">Por ejemplo, si el nombre especificado en una llamada a la función [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) coincide con el nombre de un objeto mutex existente, la función devuelve un identificador al objeto existente.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-111">For example, if the name specified in a call to the [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) function matches the name of an existing mutex object, the function returns a handle to the existing object.</span></span> <span data-ttu-id="dfbb7-112">En este caso, la llamada a **CreateMutex** es equivalente a una llamada a la función [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) .</span><span class="sxs-lookup"><span data-stu-id="dfbb7-112">In this case, the call to **CreateMutex** is equivalent to a call to the [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) function.</span></span> <span data-ttu-id="dfbb7-113">La existencia de varios procesos usa **CreateMutex** para la misma exclusión mutua, por lo tanto, es equivalente a tener un proceso que llama a **CreateMutex** mientras que los demás procesos llaman a **OpenMutex**, salvo que elimina la necesidad de asegurarse de que el proceso de creación se inicia en primer lugar.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-113">Having multiple processes use **CreateMutex** for the same mutex is therefore equivalent to having one process that calls **CreateMutex** while the other processes call **OpenMutex**, except that it eliminates the need to ensure that the creating process is started first.</span></span> <span data-ttu-id="dfbb7-114">Sin embargo, cuando se usa esta técnica para objetos mutex, ninguno de los procesos de llamada debe solicitar la propiedad inmediata de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-114">When using this technique for mutex objects, however, none of the calling processes should request immediate ownership of the mutex.</span></span> <span data-ttu-id="dfbb7-115">Si varios procesos solicitan la propiedad inmediata, puede ser difícil predecir qué proceso obtiene realmente la propiedad inicial.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-115">If multiple processes do request immediate ownership, it can be difficult to predict which process actually gets the initial ownership.</span></span>

<span data-ttu-id="dfbb7-116">Un entorno de Terminal Services tiene un espacio de nombres global para eventos, semáforos, exclusiones mutuas, temporizadores que se esperan, objetos de asignación de archivos y objetos de trabajo.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-116">A Terminal Services environment has a global namespace for events, semaphores, mutexes, waitable timers, file-mapping objects, and job objects.</span></span> <span data-ttu-id="dfbb7-117">Además, cada Terminal Services sesión de cliente tiene su propio espacio de nombres independiente para estos objetos.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-117">In addition, each Terminal Services client session has its own separate namespace for these objects.</span></span> <span data-ttu-id="dfbb7-118">Terminal Services procesos de cliente pueden utilizar nombres de objeto con un \\ prefijo "global" o "local \\ " para crear explícitamente un objeto en el espacio de nombres global o de sesión.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-118">Terminal Services client processes can use object names with a "Global\\" or "Local\\" prefix to explicitly create an object in the global or session namespace.</span></span> <span data-ttu-id="dfbb7-119">Para obtener más información, vea [espacios de nombres de objetos de kernel](../termserv/kernel-object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="dfbb7-119">For more information, see [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span></span> <span data-ttu-id="dfbb7-120">El cambio rápido de usuario se implementa mediante Terminal Services sesiones (cada usuario inicia sesión en una sesión diferente).</span><span class="sxs-lookup"><span data-stu-id="dfbb7-120">Fast user switching is implemented using Terminal Services sessions (each user logs into a different session).</span></span> <span data-ttu-id="dfbb7-121">Los nombres de objeto de kernel deben seguir las instrucciones descritas para Terminal Services para que las aplicaciones puedan admitir varios usuarios.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-121">Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</span></span>

<span data-ttu-id="dfbb7-122">Los objetos de sincronización se pueden crear en un espacio de nombres privado.</span><span class="sxs-lookup"><span data-stu-id="dfbb7-122">Synchronization objects can be created in a private namespace.</span></span> <span data-ttu-id="dfbb7-123">Para obtener más información, vea [espacios de nombres de objetos](object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="dfbb7-123">For more information, see [Object Namespaces](object-namespaces.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="dfbb7-124">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="dfbb7-124">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="dfbb7-125">Usar objetos con nombre</span><span class="sxs-lookup"><span data-stu-id="dfbb7-125">Using Named Objects</span></span>](using-named-objects.md)
</dt> </dl>

 

 
