---
title: Degradar correctamente en ausencia de una interfaz
description: Dado que un control puede no admitir ninguna interfaz que no sea IUnknown, un contenedor tiene que degradarse correctamente cuando encuentra la ausencia de una interfaz determinada.
ms.assetid: 1b833900-2357-4b39-b88d-5ee6321f488e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: fef1b329faa2d4da333cf2e201fc887764af96bc5ea2573060f41774b57c0d56
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/11/2021
ms.locfileid: "119501285"
---
# <a name="degrading-gracefully-in-the-absence-of-an-interface"></a>Degradar correctamente en ausencia de una interfaz

Dado que un control puede no admitir ninguna interfaz que no sea [**IUnknown,**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown)un contenedor tiene que degradarse correctamente cuando encuentra la ausencia de una interfaz determinada.

Es posible que se cuestione la utilidad de un control con nada más que [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown). Pero tenga en cuenta las ventajas que un control recibe del entorno de programación visual de un contenedor (por ejemplo, VB) cuando el contenedor reconoce el objeto como un control:

-   Aparece un botón para el objeto en un cuadro de herramientas.
-   Se puede crear un objeto arrastrándolo desde el cuadro de herramientas a un formulario.
-   Se puede dar al objeto un nombre que se reconozca en el entorno de programación visual.
-   El mismo nombre de (3) anterior se puede usar inmediatamente al escribir cualquier otro código para los controles en el mismo formulario (o incluso en otro).
-   El contenedor puede proporcionar automáticamente puntos de entrada de código para cualquier evento disponible desde ese objeto.
-   El contenedor proporciona su propia interfaz de usuario de exploración de propiedades para las propiedades disponibles.

Cuando un objeto no se reconoce como control, potencialmente pierde todas estas características de integración muy eficaces y beneficiosas. Por ejemplo, en Visual Basic 4.0 es muy difícil integrar realmente algún objeto aleatorio que no es un control en el sentido completo, pero que todavía puede tener propiedades y eventos. Dado Visual Basic la idea de 4 de un control es muy restrictiva, el objeto no obtiene ninguna de las características de integración anteriores. Pero incluso un control con [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), donde la simple duración del control determina la existencia de algún recurso, debe ser capaz de obtener las funcionalidades de integración descritas anteriormente.

Dado que las herramientas actuales requieren un gran conjunto de interfaces de control para obtener cualquier ventaja, los controles suelen llevar a una implementación en exceso, de modo que contienen más código del que realmente necesitan. Los controles que podrían ser 7K pueden acabar siendo 25 000, lo que es un gran problema de rendimiento en áreas como Internet. Esto también ha llevado a la percepción de que solo se puede implementar un control con una herramienta como la CDK debido a la complejidad de implementar todas las interfaces, lo que tiene implicaciones cuando se requiere un archivo DLL grande como OC30.DLL para este control, lo que aumenta el espacio de trabajo. Si no se requieren todas las interfaces, esto permite a muchos desarrolladores escribir controles muy pequeños y ligeros con OLE sencillo o también con otras herramientas, lo que minimiza la sobrecarga de cada control.

Este es el motivo por el que este apéndice reconoce un control como cualquier objeto con un CLSID y una [**interfaz IUnknown.**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) Incluso con nada más que IUnknown, un contenedor con un entorno de programación debe ser capaz de proporcionar al menos las características 3 y ) entrada del Registro, obtiene \# \# 1 y \# 2. Si el objeto proporciona [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer) (e [**IProvideClassInfo**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo) generalmente) para algún conjunto de eventos, obtiene 5 y, si admite \# **IDispatch para** propiedades y métodos, obtiene 6, así como una mejor integración de código en el \# contenedor.

En resumen, un objeto debe ser capaz de implementar tan poco como **IDispatch** y un conjunto de eventos expuesto a través de [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer) para obtener todas las características visuales anteriores.

Con esto en mente, en la tabla siguiente se describe lo que podría hacer un contenedor en ausencia de cualquier interfaz posible. Tenga en cuenta que solo se muestran esas interfaces que el contenedor obtendrá directamente a través [**de QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)). Otras interfaces, [**como IOleInPlaceActiveObject,**](/windows/desktop/api/OleIdl/nn-oleidl-ioleinplaceactiveobject)se obtienen a través de otros medios.



| Interfaz                                                                                                             | Significado de la ausencia de interfaz                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)<br/>                                                                       | El control no tiene ningún objeto visual que se dibuje a sí mismo, por lo que no tiene extensiones definidas que proporcionar. En tiempo de ejecución, el contenedor simplemente no intenta dibujar nada cuando esta interfaz está ausente. En tiempo de diseño, el contenedor debe dibujar al menos algún tipo de rectángulo predeterminado con un nombre para este control, por lo que un usuario de un entorno de programación visual puede seleccionar el objeto y comprobar sus propiedades, métodos y eventos que existen. Controlar la ausencia de [**IViewObject2 es**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) fundamental para una buena compatibilidad con la programación visual.<br/> |
| [**IOleObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleobject)<br/>                                                                           | El control no necesita el sitio de ningún tipo ni participa en ninguna negociación de diseño de objetos incrustados. Cualquier información (como las extensiones de control) que un contenedor podría esperar de esta interfaz debe rellenarse con los valores predeterminados proporcionados por el contenedor.<br/>                                                                                                                                                                                                                                                                                                       |
| [**IOleInPlaceObject**](/windows/desktop/api/OleIdl/nn-oleidl-ioleinplaceobject)<br/>                                                             | El control no se activa en su lugar (como una etiqueta) y, por tanto, nunca intenta activarse de esta manera. Su única activación puede ser sus páginas de propiedades.<br/>                                                                                                                                                                                                                                                                                                                                                                                                            |
| [**IOleControl**](/windows/desktop/api/OCIdl/nn-ocidl-iolecontrol)<br/>                                                                         | El control no tiene ningún elemento mnemotécnico y no usa propiedades ambientales, y no le importa si el contenedor omite los eventos. En ausencia de esta interfaz, el contenedor simplemente no llama a sus métodos.<br/>                                                                                                                                                                                                                                                                                                                                                                         |
| [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject)<br/>                                                                         | El control no proporciona ningún conjunto de propiedades ni representaciones visuales que se puedan almacenar en caché, por lo que el contenedor elegiría almacenar en caché alguna presentación predeterminada en ausencia de esta interfaz (compatibilidad con CF METAFILEPICT, específicamente) y deshabilitar cualquier funcionalidad relacionada con el conjunto de \_ propiedades.<br/>                                                                                                                                                                                                                                                                            |
| **IDispatch**<br/>                                                                                              | El control no tiene propiedades ni métodos personalizados. En este caso, el contenedor no necesita intentar mostrar ninguna propiedad de control y no debe permitir las llamadas a métodos personalizados que el contenedor no reconozca como que pertenecen a sus propios controles extendidos (que pueden admitir métodos y propiedades). Como los controles extendidos suelen delegar determinadas llamadas **IDispatch** al control, un control extendido no debe esperar que el control tenga **IDispatch** en absoluto.<br/>                                                                                          |
| [**IConnectionPointContainer**](/windows/desktop/api/OCIdl/nn-ocidl-iconnectionpointcontainer)<br/>                                             | El control no tiene eventos, por lo que el contenedor no tiene que pensar en controlar ninguno.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [**IProvideClassInfo**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo)<br/> [**IProvideClassInfo2**](/windows/desktop/api/OCIdl/nn-ocidl-iprovideclassinfo2)<br/> | El control no tiene información de tipo ni eventos, o el contenedor debe ir a la información de tipo del control a través de las entradas del Registro del control. La existencia de esta interfaz es una optimización.<br/>                                                                                                                                                                                                                                                                                                                                            |
| [**ISpecifyPropertyPages**](/windows/desktop/api/OCIdl/nn-ocidl-ispecifypropertypages)<br/>                                                     | El control no tiene páginas de propiedades, por lo que si el contenedor tiene alguna interfaz de usuario que las invoque, el contenedor debe deshabilitar esa interfaz de usuario.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| [**IPerPropertyBrowsing**](/windows/desktop/api/OCIdl/nn-ocidl-iperpropertybrowsing)<br/>                                                       | El control no tiene ningún nombre para mostrar, ninguna cadena y valores predeterminados y ninguna propiedad para la asignación de páginas. Esta interfaz casi siempre se usa para generar la interfaz de usuario del contenedor, por lo que estos elementos de interfaz de usuario se deshabilitarían en ausencia de esta interfaz.<br/>                                                                                                                                                                                                                                                                                                 |
| IPersist\*<br/>                                                                                                 | El control no tiene ningún estado persistente del que hablar, por lo que el contenedor no tiene que preocuparse de guardar datos específicos del control. Por supuesto, el contenedor guardará su propia información sobre el control en su propio formulario o documento, pero el propio control no tiene nada que contribuir a esa información.<br/>                                                                                                                                                                                                                                                        |
| [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache)<br/> [**IOleCache2**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache2)<br/>                                 | El objeto no admite el almacenamiento en caché. Un contenedor todavía puede admitir el almacenamiento en caché mediante la creación de una caché de datos mediante [**CreateDataCache.**](/windows/desktop/api/ObjBase/nf-objbase-createdatacache)<br/>                                                                                                                                                                                                                                                                                                                                                                                                    |



 

## <a name="related-topics"></a>Temas relacionados

<dl> <dt>

[Contenedores](containers.md)
</dt> </dl>

 

 





