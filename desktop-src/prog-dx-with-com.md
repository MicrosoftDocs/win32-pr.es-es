---
description: Programar DirectX con COM.
title: Programar DirectX con COM
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 67fc7a35f42439e1a9eeef1b2895d88dc0dbf5d4
ms.sourcegitcommit: f712e5fed19d6afe2762a77ffcdf8b5977f85901
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/26/2021
ms.locfileid: "104003251"
---
# <a name="programming-directx-with-com"></a><span data-ttu-id="b442c-103">Programar DirectX con COM</span><span class="sxs-lookup"><span data-stu-id="b442c-103">Programming DirectX with COM</span></span>

<span data-ttu-id="b442c-104">El modelo de objetos componentes (COM) de Microsoft es un modelo de programación orientado a objetos que utilizan varias tecnologías, incluida la mayor parte de la superficie de la API de DirectX.</span><span class="sxs-lookup"><span data-stu-id="b442c-104">The Microsoft Component Object Model (COM) is an object-oriented programming model used by several technologies, including the bulk of the DirectX API surface.</span></span> <span data-ttu-id="b442c-105">Por ese motivo, usted (como desarrollador de DirectX) utiliza inevitablemente COM al programar DirectX.</span><span class="sxs-lookup"><span data-stu-id="b442c-105">For that reason, you (as a DirectX developer) inevitably use COM when you program DirectX.</span></span>

> [!NOTE]
> <span data-ttu-id="b442c-106">En el tema [consumir componentes com con c++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) se muestra cómo usar las API de DirectX (y cualquier API com, en ese caso) mediante [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span><span class="sxs-lookup"><span data-stu-id="b442c-106">The topic [Consume COM components with C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) shows how to consume DirectX APIs (and any COM API, for that matter) by using [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span></span> <span data-ttu-id="b442c-107">Esta es la tecnología más conveniente y recomendada para usar.</span><span class="sxs-lookup"><span data-stu-id="b442c-107">That's by far the most convenient and recommended technology to use.</span></span>

<span data-ttu-id="b442c-108">Como alternativa, puede usar COM sin formato y eso es lo que trata este tema.</span><span class="sxs-lookup"><span data-stu-id="b442c-108">Alternatively, you can use raw COM, and that's what this topic is about.</span></span> <span data-ttu-id="b442c-109">Necesitará una comprensión básica de los principios y las técnicas de programación implicadas en el consumo de API de COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-109">You'll need a basic understanding of the principles and programming techniques involved in consuming COM APIs.</span></span> <span data-ttu-id="b442c-110">Aunque COM tiene una reputación por ser difícil y complejo, la programación COM que requieren la mayoría de las aplicaciones de DirectX es sencilla.</span><span class="sxs-lookup"><span data-stu-id="b442c-110">Although COM has a reputation for being difficult and complex, the COM programming required by most DirectX applications is straightforward.</span></span> <span data-ttu-id="b442c-111">En parte, esto se debe a que va a consumir los objetos COM que proporciona DirectX.</span><span class="sxs-lookup"><span data-stu-id="b442c-111">In part, this is because you'll be consuming the COM objects provided by DirectX.</span></span> <span data-ttu-id="b442c-112">No es necesario que cree sus propios objetos COM, lo que suele ser donde surge la complejidad.</span><span class="sxs-lookup"><span data-stu-id="b442c-112">There's no need for you to author your own COM objects, which is typically where the complexity arises.</span></span>

## <a name="com-component-overview"></a><span data-ttu-id="b442c-113">Información general sobre el componente COM</span><span class="sxs-lookup"><span data-stu-id="b442c-113">COM component overview</span></span>

<span data-ttu-id="b442c-114">Un objeto COM es esencialmente un componente encapsulado de funcionalidad que las aplicaciones pueden usar para realizar una o más tareas.</span><span class="sxs-lookup"><span data-stu-id="b442c-114">A COM object is essentially an encapsulated component of functionality that can be used by applications to perform one or more tasks.</span></span> <span data-ttu-id="b442c-115">Para la implementación, uno o varios componentes COM se empaquetan en un archivo binario denominado servidor COM. con mayor frecuencia que no un archivo DLL.</span><span class="sxs-lookup"><span data-stu-id="b442c-115">For deployment, one or more COM components are packaged into a binary called a COM server; more often than not a DLL.</span></span>

<span data-ttu-id="b442c-116">Un archivo DLL tradicional exporta funciones libres.</span><span class="sxs-lookup"><span data-stu-id="b442c-116">A traditional DLL exports free functions.</span></span> <span data-ttu-id="b442c-117">Un servidor COM puede hacer lo mismo.</span><span class="sxs-lookup"><span data-stu-id="b442c-117">A COM server can do the same.</span></span> <span data-ttu-id="b442c-118">Sin embargo, los componentes COM dentro del servidor COM exponen interfaces COM y métodos de miembro que pertenecen a esas interfaces.</span><span class="sxs-lookup"><span data-stu-id="b442c-118">But the COM components inside the COM server expose COM interfaces and member methods belonging to those interfaces.</span></span> <span data-ttu-id="b442c-119">La aplicación crea instancias de componentes COM, recupera interfaces de ellos y llama a métodos en esas interfaces para beneficiarse de las características implementadas en los componentes COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-119">Your application creates instances of COM components, retrieves interfaces from them, and calls methods on those interfaces in order to benefit from the features implemented in the COM components.</span></span>

<span data-ttu-id="b442c-120">En la práctica, esto se asemeja a llamar a métodos en un objeto de C++ normal.</span><span class="sxs-lookup"><span data-stu-id="b442c-120">In practice, this feels similar to calling methods on a regular C++ object.</span></span> <span data-ttu-id="b442c-121">Pero hay algunas diferencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-121">But there are some differences.</span></span>

- <span data-ttu-id="b442c-122">Un objeto COM exige una encapsulación más estricta que el de un objeto de C++.</span><span class="sxs-lookup"><span data-stu-id="b442c-122">A COM object enforces stricter encapsulation than a C++ object does.</span></span> <span data-ttu-id="b442c-123">No se puede crear el objeto y, a continuación, llamar a cualquier método público.</span><span class="sxs-lookup"><span data-stu-id="b442c-123">You can't just create the object, and then call any public method.</span></span> <span data-ttu-id="b442c-124">En su lugar, los métodos públicos de un componente COM se agrupan en una o más interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-124">Instead, a COM component's public methods are grouped into one or more COM interfaces.</span></span> <span data-ttu-id="b442c-125">Para llamar a un método, se crea el objeto y se recupera del objeto la interfaz que implementa el método.</span><span class="sxs-lookup"><span data-stu-id="b442c-125">To call a method, you create the object and retrieve from the object the interface that implements the method.</span></span> <span data-ttu-id="b442c-126">Normalmente, una interfaz implementa un conjunto relacionado de métodos que proporcionan acceso a una característica determinada del objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-126">An interface typically implements a related set of methods that provide access to a particular feature of the object.</span></span> <span data-ttu-id="b442c-127">Por ejemplo, la interfaz [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) representa un adaptador de gráficos virtuales y contiene métodos que permiten crear recursos, por ejemplo, y muchas otras tareas relacionadas con el adaptador.</span><span class="sxs-lookup"><span data-stu-id="b442c-127">For example, the [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) interface represents a virtual graphics adapter, and it contains methods that enable you create resources, for example, and many other adapter-related tasks.</span></span>
- <span data-ttu-id="b442c-128">Un objeto COM no se crea de la misma manera que un objeto de C++.</span><span class="sxs-lookup"><span data-stu-id="b442c-128">A COM object is not created in the same way as a C++ object.</span></span> <span data-ttu-id="b442c-129">Hay varias maneras de crear un objeto COM, pero todas implican técnicas específicas de COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-129">There are several ways to create a COM object, but all involve COM-specific techniques.</span></span> <span data-ttu-id="b442c-130">La API de DirectX incluye una variedad de funciones y métodos auxiliares que simplifican la creación de la mayoría de los objetos COM de DirectX.</span><span class="sxs-lookup"><span data-stu-id="b442c-130">The DirectX API includes a variety of helper functions and methods that simplify creating most of the DirectX COM objects.</span></span>
- <span data-ttu-id="b442c-131">Debe utilizar técnicas específicas de COM para controlar la duración de un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-131">You must use COM-specific techniques to control the lifetime of a COM object.</span></span>
- <span data-ttu-id="b442c-132">No es necesario cargar explícitamente el servidor COM (normalmente, un archivo DLL).</span><span class="sxs-lookup"><span data-stu-id="b442c-132">The COM server (typically a DLL) doesn't need to be explicitly loaded.</span></span> <span data-ttu-id="b442c-133">No se vincula a una biblioteca estática para usar un componente COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-133">Nor do you link to a static library in order to use a COM component.</span></span> <span data-ttu-id="b442c-134">Cada componente COM tiene un identificador único registrado (un identificador único global o GUID), que la aplicación usa para identificar el objeto COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-134">Each COM component has a unique registered identifier (a globally-unique identifier, or GUID), which your application uses to identify the COM object.</span></span> <span data-ttu-id="b442c-135">La aplicación identifica el componente y el tiempo de ejecución COM carga automáticamente el archivo DLL de servidor COM correcto.</span><span class="sxs-lookup"><span data-stu-id="b442c-135">Your application identifies the component, and the COM runtime automatically loads the correct COM server DLL.</span></span>
- <span data-ttu-id="b442c-136">COM es una especificación binaria.</span><span class="sxs-lookup"><span data-stu-id="b442c-136">COM is a binary specification.</span></span> <span data-ttu-id="b442c-137">Los objetos COM se pueden escribir en y se puede tener acceso a ellos desde diversos lenguajes.</span><span class="sxs-lookup"><span data-stu-id="b442c-137">COM objects can be written in and accessed from a variety of languages.</span></span> <span data-ttu-id="b442c-138">No es necesario saber nada sobre el código fuente del objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-138">You don't need to know anything about the object's source code.</span></span> <span data-ttu-id="b442c-139">Por ejemplo, Visual Basic aplicaciones utilizan habitualmente objetos COM que se escribieron en C++.</span><span class="sxs-lookup"><span data-stu-id="b442c-139">For example, Visual Basic applications routinely use COM objects that were written in C++.</span></span>

## <a name="component-object-and-interface"></a><span data-ttu-id="b442c-140">Componente, objeto e interfaz</span><span class="sxs-lookup"><span data-stu-id="b442c-140">Component, object, and interface</span></span>

<span data-ttu-id="b442c-141">Es importante comprender la diferencia entre los componentes, los objetos y las interfaces.</span><span class="sxs-lookup"><span data-stu-id="b442c-141">It's important to understand the distinction between components, objects, and interfaces.</span></span> <span data-ttu-id="b442c-142">En el uso ocasional, puede oír un componente u objeto al que se hace referencia por el nombre de su interfaz principal.</span><span class="sxs-lookup"><span data-stu-id="b442c-142">In casual usage, you may hear a component or object referred to by the name of its principal interface.</span></span> <span data-ttu-id="b442c-143">Sin embargo, los términos no son intercambiables.</span><span class="sxs-lookup"><span data-stu-id="b442c-143">But the terms are not interchangeable.</span></span> <span data-ttu-id="b442c-144">Un componente puede implementar cualquier número de interfaces; y un objeto es una instancia de un componente.</span><span class="sxs-lookup"><span data-stu-id="b442c-144">A component can implement any number of interfaces; and an object is an instance of a component.</span></span> <span data-ttu-id="b442c-145">Por ejemplo, aunque todos los componentes deben implementar la [**interfaz IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), normalmente implementan al menos una interfaz adicional y pueden implementar muchos.</span><span class="sxs-lookup"><span data-stu-id="b442c-145">For example, while all components must implement the [**IUnknown interface**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), they normally implement at least one additional interface, and they might implement many.</span></span>

<span data-ttu-id="b442c-146">Para usar un método de interfaz determinado, no debe crear solo una instancia de un objeto, también debe obtener la interfaz correcta de él.</span><span class="sxs-lookup"><span data-stu-id="b442c-146">To use a particular interface method, you must not only instantiate an object, you must also obtain the correct interface from it.</span></span>

<span data-ttu-id="b442c-147">Además, más de un componente podría implementar la misma interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-147">In addition, more than one component might implement the same interface.</span></span> <span data-ttu-id="b442c-148">Una interfaz es un grupo de métodos que realizan un conjunto de operaciones relacionadas lógicamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-148">An interface is a group of methods that perform a logically-related set of operations.</span></span> <span data-ttu-id="b442c-149">La definición de interfaz especifica solo la sintaxis de los métodos y su funcionalidad general.</span><span class="sxs-lookup"><span data-stu-id="b442c-149">The interface definition specifies only the syntax of the methods and their general functionality.</span></span> <span data-ttu-id="b442c-150">Cualquier componente COM que necesite admitir un conjunto determinado de operaciones puede hacerlo mediante la implementación de una interfaz adecuada.</span><span class="sxs-lookup"><span data-stu-id="b442c-150">Any COM component that needs to support a particular set of operations can do so by implementing a suitable interface.</span></span> <span data-ttu-id="b442c-151">Algunas interfaces están muy especializadas y solo se implementan en un único componente; otros son útiles en diversas circunstancias y se implementan mediante muchos componentes.</span><span class="sxs-lookup"><span data-stu-id="b442c-151">Some interfaces are highly specialized, and are implemented only by a single component; others are useful in a variety of circumstances, and are implemented by many components.</span></span>

<span data-ttu-id="b442c-152">Si un componente implementa una interfaz, debe admitir todos los métodos de la definición de interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-152">If a component implements an interface, it must support every method in the interface definition.</span></span> <span data-ttu-id="b442c-153">En otras palabras, debe poder llamar a cualquier método y estar seguro de que existe.</span><span class="sxs-lookup"><span data-stu-id="b442c-153">In other words, you must be able to call any method and be confident that it exists.</span></span> <span data-ttu-id="b442c-154">Sin embargo, los detalles de cómo se implementa un método determinado pueden variar de un componente a otro.</span><span class="sxs-lookup"><span data-stu-id="b442c-154">However, the details of how a particular method is implemented may vary from one component to another.</span></span> <span data-ttu-id="b442c-155">Por ejemplo, diferentes componentes pueden usar algoritmos diferentes para llegar al resultado final.</span><span class="sxs-lookup"><span data-stu-id="b442c-155">For example, different components may use different algorithms to arrive at the final result.</span></span> <span data-ttu-id="b442c-156">Tampoco hay ninguna garantía de que un método se admita de forma no trivial.</span><span class="sxs-lookup"><span data-stu-id="b442c-156">There is also no guarantee that a method will be supported in a nontrivial way.</span></span> <span data-ttu-id="b442c-157">A veces, un componente implementa una interfaz de uso frecuente, pero solo necesita admitir un subconjunto de los métodos.</span><span class="sxs-lookup"><span data-stu-id="b442c-157">Sometimes, a component implements a commonly-used interface, but it needs to support only a subset of the methods.</span></span> <span data-ttu-id="b442c-158">Todavía podrá llamar a los métodos restantes correctamente, pero devolverá un [**HRESULT**](#hresult-values) (que es un tipo com estándar que representa un código de resultado) que contiene el valor **E_NOTIMPL**.</span><span class="sxs-lookup"><span data-stu-id="b442c-158">You will still be able to call the remaining methods successfully, but they will return an [**HRESULT**](#hresult-values) (which is a standard COM type representing a result code) containing the value **E_NOTIMPL**.</span></span> <span data-ttu-id="b442c-159">Debe consultar su documentación para ver cómo implementa una interfaz un componente determinado.</span><span class="sxs-lookup"><span data-stu-id="b442c-159">You should refer to its documentation to see how an interface is implemented by any particular component.</span></span>

<span data-ttu-id="b442c-160">El estándar COM requiere que una definición de interfaz no cambie una vez publicada.</span><span class="sxs-lookup"><span data-stu-id="b442c-160">The COM standard requires that an interface definition must not change once it has been published.</span></span> <span data-ttu-id="b442c-161">El autor no puede, por ejemplo, agregar un nuevo método a una interfaz existente.</span><span class="sxs-lookup"><span data-stu-id="b442c-161">The author cannot, for example, add a new method to an existing interface.</span></span> <span data-ttu-id="b442c-162">En su lugar, el autor debe crear una nueva interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-162">The author must instead create a new interface.</span></span> <span data-ttu-id="b442c-163">Aunque no hay restricciones en cuanto a los métodos que deben estar en esa interfaz, una práctica común es que la interfaz de próxima generación incluya todos los métodos de la interfaz antigua, además de los métodos nuevos.</span><span class="sxs-lookup"><span data-stu-id="b442c-163">While there are no restrictions on what methods must be in that interface, a common practice is to have the next-generation interface include all the of the old interface's methods, plus any new methods.</span></span>

<span data-ttu-id="b442c-164">No es raro que una interfaz tenga varias generaciones.</span><span class="sxs-lookup"><span data-stu-id="b442c-164">It's not unusual for an interface to have several generations.</span></span> <span data-ttu-id="b442c-165">Normalmente, todas las generaciones realizan esencialmente la misma tarea general, pero son diferentes en concreto.</span><span class="sxs-lookup"><span data-stu-id="b442c-165">Typically, all generations perform essentially the same overall task, but they're different in specifics.</span></span> <span data-ttu-id="b442c-166">A menudo, un componente COM implementa cada generación actual y anterior del linaje de una interfaz determinada.</span><span class="sxs-lookup"><span data-stu-id="b442c-166">Often, a COM component implements every current and prior generation of a given interface's lineage.</span></span> <span data-ttu-id="b442c-167">Esto permite que las aplicaciones anteriores sigan usando las interfaces más antiguas del objeto, mientras que las aplicaciones más recientes pueden aprovechar las características de las interfaces más recientes.</span><span class="sxs-lookup"><span data-stu-id="b442c-167">Doing so allows older applications to continue using the object's older interfaces, while newer applications can take advantage of the features of the newer interfaces.</span></span> <span data-ttu-id="b442c-168">Normalmente, un grupo de descensos de las interfaces tienen el mismo nombre, más un entero que indica la generación.</span><span class="sxs-lookup"><span data-stu-id="b442c-168">Typically, a descent group of interfaces all have the same name, plus an integer that indicates the generation.</span></span> <span data-ttu-id="b442c-169">Por ejemplo, si la interfaz original se denomina **IMyInterface** (que implica la generación 1), las dos generaciones siguientes se denominarán **IMyInterface2** y **IMyInterface3**.</span><span class="sxs-lookup"><span data-stu-id="b442c-169">For example, if the original interface were named **IMyInterface** (implying generation 1), then the next two generations would be called **IMyInterface2** and **IMyInterface3**.</span></span> <span data-ttu-id="b442c-170">En el caso de las interfaces de DirectX, las generaciones sucesivas suelen denominarse para el número de versión de DirectX.</span><span class="sxs-lookup"><span data-stu-id="b442c-170">In the case of DirectX interfaces, successive generations are typically named for the version number of DirectX.</span></span>

## <a name="guids"></a><span data-ttu-id="b442c-171">GUID</span><span class="sxs-lookup"><span data-stu-id="b442c-171">GUIDs</span></span>

<span data-ttu-id="b442c-172">Los GUID son una parte fundamental del modelo de programación COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-172">GUIDs are a key part of the COM programming model.</span></span> <span data-ttu-id="b442c-173">En su mayor nivel básico, un GUID es una estructura de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="b442c-173">At its most basic, a GUID is a 128-bit structure.</span></span> <span data-ttu-id="b442c-174">Sin embargo, los GUID se crean de forma que se garantiza que no haya dos GUID iguales.</span><span class="sxs-lookup"><span data-stu-id="b442c-174">However, GUIDs are created in such a way as to guarantee that no two GUIDs are the same.</span></span> <span data-ttu-id="b442c-175">COM utiliza los GUID en gran medida para dos propósitos principales.</span><span class="sxs-lookup"><span data-stu-id="b442c-175">COM uses GUIDs extensively for two primary purposes.</span></span>

- <span data-ttu-id="b442c-176">Para identificar de forma única un componente COM determinado.</span><span class="sxs-lookup"><span data-stu-id="b442c-176">To uniquely identify a particular COM component.</span></span> <span data-ttu-id="b442c-177">Un GUID que se asigna para identificar un componente COM se denomina identificador de clase (CLSID) y se utiliza un CLSID cuando se desea crear una instancia del componente COM asociado.</span><span class="sxs-lookup"><span data-stu-id="b442c-177">A GUID that is assigned to identify a COM component is called a class identifier (CLSID), and you use a CLSID when you want to create an instance of the associated COM component.</span></span>
- <span data-ttu-id="b442c-178">Para identificar de forma única una interfaz COM determinada.</span><span class="sxs-lookup"><span data-stu-id="b442c-178">To uniquely identify a particular COM interface.</span></span> <span data-ttu-id="b442c-179">Un GUID que se asigna para identificar una interfaz COM se denomina identificador de interfaz (IID) y se usa un IID al solicitar una interfaz determinada de una instancia de un componente (un objeto).</span><span class="sxs-lookup"><span data-stu-id="b442c-179">A GUID that is assigned to identify a COM interface is called an interface identifier (IID), and you use an IID when you request a particular interface from an instance of a component (an object).</span></span> <span data-ttu-id="b442c-180">El IID de una interfaz será el mismo, independientemente del componente que implemente la interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-180">An interface's IID will be the same, regardless of which component implements the interface.</span></span>

<span data-ttu-id="b442c-181">Para mayor comodidad, la documentación de DirectX hace referencia normalmente a componentes e interfaces por sus nombres descriptivos (por ejemplo, **ID3D12Device**) en lugar de por sus GUID.</span><span class="sxs-lookup"><span data-stu-id="b442c-181">For convenience, the DirectX documentation normally refers to components and interfaces by their descriptive names (for example, **ID3D12Device**) rather than by their GUIDs.</span></span> <span data-ttu-id="b442c-182">En el contexto de la documentación de DirectX, no hay ambigüedad.</span><span class="sxs-lookup"><span data-stu-id="b442c-182">Within the context of the DirectX documentation, there is no ambiguity.</span></span> <span data-ttu-id="b442c-183">Técnicamente, es posible que un tercero cree una interfaz con el nombre descriptivo **ID3D12Device** (debe tener un IID diferente para que sea válido).</span><span class="sxs-lookup"><span data-stu-id="b442c-183">It's technically possible for a third-party to author an interface with the descriptive name **ID3D12Device** (it would need to have a different IID in order to be valid).</span></span> <span data-ttu-id="b442c-184">Sin embargo, en aras de la claridad, no se recomienda.</span><span class="sxs-lookup"><span data-stu-id="b442c-184">In the interest of clarity, though, we don't recommend that.</span></span>

<span data-ttu-id="b442c-185">Por lo tanto, la única manera inequívoca de hacer referencia a un objeto o una interfaz concretos es por su GUID.</span><span class="sxs-lookup"><span data-stu-id="b442c-185">So, the only unambiguous way to refer to a particular object or interface is by its GUID.</span></span>

<span data-ttu-id="b442c-186">Aunque un GUID es una estructura, un GUID suele expresarse en un formato de cadena equivalente.</span><span class="sxs-lookup"><span data-stu-id="b442c-186">Although a GUID is a structure, a GUID is often expressed in equivalent string form.</span></span> <span data-ttu-id="b442c-187">El formato general de la forma de cadena de un GUID es de 32 dígitos hexadecimales, con el formato 8-4-4-4-12.</span><span class="sxs-lookup"><span data-stu-id="b442c-187">The general format of the string form of a GUID is 32 hexadecimal digits, in the format 8-4-4-4-12.</span></span> <span data-ttu-id="b442c-188">Es decir, {xxxxxxxx-XXXX-XXXX-XXXX-XXXXXXXXXXXX}, donde cada x corresponde a un dígito hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="b442c-188">That is, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, where each x corresponds to a hexadecimal digit.</span></span> <span data-ttu-id="b442c-189">Por ejemplo, la forma de cadena del IID de la interfaz **ID3D12Device** es {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span><span class="sxs-lookup"><span data-stu-id="b442c-189">For example, the string form of the IID for the **ID3D12Device** interface is {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span></span>

<span data-ttu-id="b442c-190">Dado que el GUID real es algo complicado de usar y fácil de escribir, normalmente se proporciona un nombre equivalente.</span><span class="sxs-lookup"><span data-stu-id="b442c-190">Because the actual GUID is somewhat clumsy to use and easy to mistype, an equivalent name is usually provided as well.</span></span> <span data-ttu-id="b442c-191">En el código, puede usar este nombre en lugar de la estructura real al llamar a funciones, por ejemplo, cuando se pasa un argumento para el `riid` parámetro a [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span><span class="sxs-lookup"><span data-stu-id="b442c-191">In your code, you can use this name instead of the actual structure when you call functions, for example when you pass an argument for the `riid` parameter to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span></span> <span data-ttu-id="b442c-192">La Convención de nomenclatura personalizada es anteponer IID_ o CLSID_ al nombre descriptivo de la interfaz u objeto, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-192">The customary naming convention is to prepend either IID_ or CLSID_ to the descriptive name of the interface or object, respectively.</span></span> <span data-ttu-id="b442c-193">Por ejemplo, el nombre del IID de la interfaz **ID3D12Device** es IID_ID3D12Device.</span><span class="sxs-lookup"><span data-stu-id="b442c-193">For example, the name of the **ID3D12Device** interface's IID is IID_ID3D12Device.</span></span>

> [!NOTE]
> <span data-ttu-id="b442c-194">Las aplicaciones de DirectX deben vincularse con ``dxguid.lib`` y ``uuid.lib`` para proporcionar definiciones para los distintos GUID de interfaz y de clase.</span><span class="sxs-lookup"><span data-stu-id="b442c-194">DirectX applications should link with ``dxguid.lib`` and ``uuid.lib`` to provide definitions for the various interface and class GUIDs.</span></span> <span data-ttu-id="b442c-195">Visual C++ y otros compiladores admiten la extensión de lenguaje del operador de **__uuidof** , pero también se admite la vinculación de estilo C explícita con estas bibliotecas de vínculos y es totalmente portátil.</span><span class="sxs-lookup"><span data-stu-id="b442c-195">Visual C++ and other compilers support the **__uuidof** operator language extension, but explicit C-style linkage with these link libraries is also supported and fully portable.</span></span>

## <a name="hresult-values"></a><span data-ttu-id="b442c-196">Valores HRESULT</span><span class="sxs-lookup"><span data-stu-id="b442c-196">HRESULT values</span></span>

<span data-ttu-id="b442c-197">La mayoría de los métodos COM devuelven un entero de 32 bits denominado **HRESULT**.</span><span class="sxs-lookup"><span data-stu-id="b442c-197">Most COM methods return a 32-bit integer called an **HRESULT**.</span></span> <span data-ttu-id="b442c-198">Con la mayoría de los métodos, el valor HRESULT es esencialmente una estructura que contiene dos partes principales de la información.</span><span class="sxs-lookup"><span data-stu-id="b442c-198">With most methods, the HRESULT is essentially a structure that contains two primary pieces of information.</span></span>
- <span data-ttu-id="b442c-199">Si el método se realizó correctamente o no.</span><span class="sxs-lookup"><span data-stu-id="b442c-199">Whether the method succeeded or failed.</span></span>
- <span data-ttu-id="b442c-200">Información más detallada sobre el resultado de la operación realizada por el método.</span><span class="sxs-lookup"><span data-stu-id="b442c-200">More detailed information about the outcome of the operation performed by the method.</span></span>

<span data-ttu-id="b442c-201">Algunos métodos devuelven un valor **HRESULT** del conjunto estándar definido en `Winerror.h` .</span><span class="sxs-lookup"><span data-stu-id="b442c-201">Some methods return a **HRESULT** value from the standard set defined in `Winerror.h`.</span></span> <span data-ttu-id="b442c-202">Sin embargo, un método es libre de devolver un valor **HRESULT** personalizado con información más especializada.</span><span class="sxs-lookup"><span data-stu-id="b442c-202">However, a method is free to return a custom **HRESULT** value with more specialized information.</span></span> <span data-ttu-id="b442c-203">Estos valores se documentan normalmente en la página de referencia del método.</span><span class="sxs-lookup"><span data-stu-id="b442c-203">These values are normally documented on the method's reference page.</span></span>

<span data-ttu-id="b442c-204">La lista de valores **HRESULT** que se encuentra en la página de referencia de un método suele ser solo un subconjunto de los posibles valores que se pueden devolver.</span><span class="sxs-lookup"><span data-stu-id="b442c-204">The list of **HRESULT** values that you find on a method's reference page is often only a subset of the possible values that may be returned.</span></span> <span data-ttu-id="b442c-205">La lista normalmente solo cubre los valores específicos del método, así como los valores estándar que tienen algún significado específico del método.</span><span class="sxs-lookup"><span data-stu-id="b442c-205">The list typically covers only those values that are specific to the method, as well as those standard values that have some method-specific meaning.</span></span> <span data-ttu-id="b442c-206">Debe suponer que un método puede devolver una variedad de valores **HRESULT** estándar, incluso si no están documentados explícitamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-206">You should assume that a method may return a variety of standard **HRESULT** values, even if they're not explicitly documented.</span></span>

<span data-ttu-id="b442c-207">Aunque los valores **HRESULT** se usan a menudo para devolver información de error, no debe considerarlos como códigos de error.</span><span class="sxs-lookup"><span data-stu-id="b442c-207">While **HRESULT** values are often used to return error information, you should not think of them as error codes.</span></span> <span data-ttu-id="b442c-208">El hecho de que el bit que indica éxito o error se almacene por separado de los bits que contienen la información detallada permite que los valores **HRESULT** tengan cualquier número de códigos correctos y erróneos.</span><span class="sxs-lookup"><span data-stu-id="b442c-208">The fact that the bit that indicates success or failure is stored separately from the bits that contain the detailed information allows **HRESULT** values to have any number of success and failure codes.</span></span> <span data-ttu-id="b442c-209">Por Convención, los nombres de códigos de éxito llevan como prefijo S_ y códigos de error de E_.</span><span class="sxs-lookup"><span data-stu-id="b442c-209">By convention, the names of success codes are prefixed by S_ and failure codes by E_.</span></span> <span data-ttu-id="b442c-210">Por ejemplo, los dos códigos usados con más frecuencia son S_OK y E_FAIL, que indican el éxito o el fracaso sencillos, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-210">For example, the two most commonly used codes are S_OK and E_FAIL, which indicate simple success or failure, respectively.</span></span>

<span data-ttu-id="b442c-211">El hecho de que los métodos COM devuelvan una variedad de códigos de éxito o de error significa que debe tener cuidado al probar el valor **HRESULT** .</span><span class="sxs-lookup"><span data-stu-id="b442c-211">The fact that COM methods may return a variety of success or failure codes means that you have to be careful how you test the **HRESULT** value.</span></span> <span data-ttu-id="b442c-212">Por ejemplo, considere un método hipotético con valores devueltos documentados de S_OK si es correcto y E_FAIL en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="b442c-212">For example, consider a hypothetical method with documented return values of S_OK if successful and E_FAIL if not.</span></span> <span data-ttu-id="b442c-213">Sin embargo, recuerde que el método también puede devolver otros códigos de error o de éxito.</span><span class="sxs-lookup"><span data-stu-id="b442c-213">However, remember that the method may also return other failure or success codes.</span></span> <span data-ttu-id="b442c-214">En el fragmento de código siguiente se muestra el riesgo de utilizar una prueba simple, donde `hr` contiene el valor **HRESULT** devuelto por el método.</span><span class="sxs-lookup"><span data-stu-id="b442c-214">The following code fragment illustrates the danger of using a simple test, where `hr` contains the **HRESULT** value returned by the method.</span></span>

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="b442c-215">Siempre que, en el caso de error, este método solo devuelva E_FAIL (y no otro código de error), esta prueba funciona.</span><span class="sxs-lookup"><span data-stu-id="b442c-215">As long as, in the failure case, this method only ever return E_FAIL (and not some other failure code), then this test works.</span></span> <span data-ttu-id="b442c-216">Sin embargo, es más realista que se implemente un método determinado para devolver un conjunto de códigos de error específicos, quizás E_NOTIMPL o E_INVALIDARG.</span><span class="sxs-lookup"><span data-stu-id="b442c-216">However, it's more realistic that a given method is implemented to return a set of specific failure codes, perhaps E_NOTIMPL or E_INVALIDARG.</span></span> <span data-ttu-id="b442c-217">Con el código anterior, esos valores se interpretaban incorrectamente como correctos.</span><span class="sxs-lookup"><span data-stu-id="b442c-217">With the code above, those values would be incorrectly interpreted as a success.</span></span>

<span data-ttu-id="b442c-218">Si necesita información detallada sobre el resultado de la llamada al método, debe probar cada valor **HRESULT** relevante.</span><span class="sxs-lookup"><span data-stu-id="b442c-218">If you need detailed information about the outcome of the method call, you need to test each relevant **HRESULT** value.</span></span> <span data-ttu-id="b442c-219">Sin embargo, puede que solo le interese si el método se realizó correctamente o no.</span><span class="sxs-lookup"><span data-stu-id="b442c-219">However, you may be interested only in whether the method succeeded or failed.</span></span> <span data-ttu-id="b442c-220">Una manera eficaz de comprobar si un valor **HRESULT** indica que el resultado es correcto o incorrecto es pasar el valor a una de las siguientes macros, definidas en Winerror. h.</span><span class="sxs-lookup"><span data-stu-id="b442c-220">A robust way to test whether an **HRESULT** value indicates success or failure is to pass the value to the one of the following macros, defined in Winerror.h.</span></span>

- <span data-ttu-id="b442c-221">La `SUCCEEDED` macro devuelve true para un código de operación correcta y false para un código de error.</span><span class="sxs-lookup"><span data-stu-id="b442c-221">The `SUCCEEDED` macro returns TRUE for a success code, and FALSE for a failure code.</span></span>
- <span data-ttu-id="b442c-222">La `FAILED` macro devuelve true para un código de error y false para un código de operación correcta.</span><span class="sxs-lookup"><span data-stu-id="b442c-222">The `FAILED` macro returns TRUE for a failure code, and FALSE for a success code.</span></span>

<span data-ttu-id="b442c-223">Por lo tanto, puede corregir el fragmento de código anterior mediante la `FAILED` macro, tal y como se muestra en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="b442c-223">So, you can fix the preceding code fragment by using the `FAILED` macro, as shown in the following code.</span></span>

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="b442c-224">Este fragmento de código corregido trata correctamente E_NOTIMPL y E_INVALIDARG como errores.</span><span class="sxs-lookup"><span data-stu-id="b442c-224">This corrected code fragment properly treats E_NOTIMPL and E_INVALIDARG as failures.</span></span>

<span data-ttu-id="b442c-225">Aunque la mayoría de los métodos COM devuelven valores **HRESULT** estructurados, un número pequeño usa **HRESULT** para devolver un entero simple.</span><span class="sxs-lookup"><span data-stu-id="b442c-225">Although most COM methods return structured **HRESULT** values, a small number use the **HRESULT** to return a simple integer.</span></span> <span data-ttu-id="b442c-226">Implícitamente, estos métodos siempre son correctos.</span><span class="sxs-lookup"><span data-stu-id="b442c-226">Implicitly, these methods are always successful.</span></span> <span data-ttu-id="b442c-227">Si pasa un **valor HRESULT** de esta ordenación a la macro Succeeded, la macro siempre devuelve true.</span><span class="sxs-lookup"><span data-stu-id="b442c-227">If you pass an **HRESULT** of this sort to the SUCCEEDED macro, then the macro always returns TRUE.</span></span> <span data-ttu-id="b442c-228">Un ejemplo de un método denominado comúnmente que no devuelve un **valor HRESULT** es el método **IUnknown:: Release** , que devuelve un ulong.</span><span class="sxs-lookup"><span data-stu-id="b442c-228">An example of a commonly-called method that doesn't return an **HRESULT** is the **IUnknown::Release** method, which returns a ULONG.</span></span> <span data-ttu-id="b442c-229">Este método reduce el recuento de referencias de un objeto en uno y devuelve el recuento de referencias actual.</span><span class="sxs-lookup"><span data-stu-id="b442c-229">This method decrements an object's reference count by one and returns the current reference count.</span></span> <span data-ttu-id="b442c-230">Consulte [Administración de la duración de un objeto com](#managing-a-com-objects-lifetime) para obtener una explicación del recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-230">See [Managing a COM object's lifetime](#managing-a-com-objects-lifetime) for a discussion of reference counting.</span></span>

## <a name="the-address-of-a-pointer"></a><span data-ttu-id="b442c-231">La dirección de un puntero</span><span class="sxs-lookup"><span data-stu-id="b442c-231">The address of a pointer</span></span>

<span data-ttu-id="b442c-232">Si ve algunas páginas de referencia de métodos COM, es probable que se ejecute en algo parecido a lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="b442c-232">If you view a few COM method reference pages, you'll probably run across something like the following.</span></span>

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

<span data-ttu-id="b442c-233">Aunque un puntero normal es bastante familiar para cualquier desarrollador de C/C++, COM suele usar un nivel adicional de direccionamiento indirecto.</span><span class="sxs-lookup"><span data-stu-id="b442c-233">While a normal pointer is quite familiar to any C/C++ developer, COM often uses an additional level of indirection.</span></span> <span data-ttu-id="b442c-234">Este segundo nivel de direccionamiento indirecto se indica mediante dos asteriscos, `**` , después de la declaración de tipos y el nombre de la variable normalmente tiene un prefijo de `pp` .</span><span class="sxs-lookup"><span data-stu-id="b442c-234">This second level of indirection is indicated by two asterisks, `**`, following the type declaration, and the variable name typically has a prefix of `pp`.</span></span> <span data-ttu-id="b442c-235">Para la función anterior, el `ppDevice` parámetro se denomina normalmente dirección de un puntero a un void.</span><span class="sxs-lookup"><span data-stu-id="b442c-235">For the function above, the `ppDevice` parameter is typically referred to as the address of a pointer to a void.</span></span> <span data-ttu-id="b442c-236">En la práctica, en este ejemplo, `ppDevice` es la dirección de un puntero a una interfaz **ID3D12Device** .</span><span class="sxs-lookup"><span data-stu-id="b442c-236">In practice, in this example, `ppDevice` is the address of a pointer to an **ID3D12Device** interface.</span></span>

<span data-ttu-id="b442c-237">A diferencia de un objeto de C++, no se tiene acceso directo a los métodos de un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-237">Unlike a C++ object, you don't access a COM object's methods directly.</span></span> <span data-ttu-id="b442c-238">En su lugar, debe obtener un puntero a una interfaz que exponga el método.</span><span class="sxs-lookup"><span data-stu-id="b442c-238">Instead, you must obtain a pointer to an interface that exposes the method.</span></span> <span data-ttu-id="b442c-239">Para invocar el método, se usa esencialmente la misma sintaxis que para invocar un puntero a un método de C++.</span><span class="sxs-lookup"><span data-stu-id="b442c-239">To invoke the method, you use essentially the same syntax as you would to invoke a pointer to a C++ method.</span></span> <span data-ttu-id="b442c-240">Por ejemplo, para invocar el método **IMyInterface::D osomething** , usaría la siguiente sintaxis.</span><span class="sxs-lookup"><span data-stu-id="b442c-240">For example, to invoke the **IMyInterface::DoSomething** method, you would use the following syntax.</span></span>

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

<span data-ttu-id="b442c-241">La necesidad de un segundo nivel de direccionamiento indirecto procede del hecho de que no se crean directamente punteros de interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-241">The need for a second level of indirection comes from the fact that you don't create interface pointers directly.</span></span> <span data-ttu-id="b442c-242">Debe llamar a uno de los diversos métodos, como el método **D3D12CreateDevice** mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="b442c-242">You must call one of a variety of methods, such as the **D3D12CreateDevice** method shown above.</span></span> <span data-ttu-id="b442c-243">Para usar este tipo de método para obtener un puntero de interfaz, se declara una variable como un puntero a la interfaz deseada y, a continuación, se pasa la dirección de esa variable al método.</span><span class="sxs-lookup"><span data-stu-id="b442c-243">To use such a method to obtain an interface pointer, you declare a variable as a pointer to the desired interface, and then you pass the address of that variable to the method.</span></span> <span data-ttu-id="b442c-244">En otras palabras, se pasa la dirección de un puntero al método.</span><span class="sxs-lookup"><span data-stu-id="b442c-244">In other words, you pass the address of a pointer to the method.</span></span> <span data-ttu-id="b442c-245">Cuando el método devuelve, la variable apunta a la interfaz solicitada y puede usar ese puntero para llamar a cualquiera de los métodos de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-245">When the method returns, the variable points to the requested interface, and you can use that pointer to call any of the interface's methods.</span></span>

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a><span data-ttu-id="b442c-246">Crear un objeto COM</span><span class="sxs-lookup"><span data-stu-id="b442c-246">Creating a COM object</span></span>

<span data-ttu-id="b442c-247">Hay varias maneras de crear un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-247">There are several ways to create a COM object.</span></span> <span data-ttu-id="b442c-248">Estos son los dos usados más comúnmente en la programación de DirectX.</span><span class="sxs-lookup"><span data-stu-id="b442c-248">These are the two most commonly used in DirectX programming.</span></span>

- <span data-ttu-id="b442c-249">Indirectamente, llamando a un método o función de DirectX que crea el objeto automáticamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-249">Indirectly, by calling a DirectX method or function that creates the object for you.</span></span> <span data-ttu-id="b442c-250">El método crea el objeto y devuelve una interfaz en el objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-250">The method creates the object, and returns an interface on the object.</span></span> <span data-ttu-id="b442c-251">Al crear un objeto de esta manera, a veces puede especificar qué interfaz se debe devolver, otras veces que la interfaz es implícita.</span><span class="sxs-lookup"><span data-stu-id="b442c-251">When you create an object this way, sometimes you can specify which interface should be returned, other times the interface is implied.</span></span> <span data-ttu-id="b442c-252">En el ejemplo de código anterior se muestra cómo crear indirectamente un objeto COM de dispositivo Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="b442c-252">The code example above shows how to indirectly create a Direct3D 12 device COM object.</span></span>
- <span data-ttu-id="b442c-253">Directamente, pasando el CLSID del objeto a la [**función CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="b442c-253">Directly, by passing the object's CLSID to the [**CoCreateInstance function**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span> <span data-ttu-id="b442c-254">La función crea una instancia del objeto y devuelve un puntero a una interfaz que se especifica.</span><span class="sxs-lookup"><span data-stu-id="b442c-254">The function creates an instance of the object, and it returns a pointer to an interface that you specify.</span></span>

<span data-ttu-id="b442c-255">Una vez, antes de crear objetos COM, debe inicializar COM mediante una llamada a la [**función CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="b442c-255">One time, before you create any COM objects, you must initialize COM by calling the [**CoInitializeEx function**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="b442c-256">Si va a crear objetos indirectamente, el método de creación de objetos controla esta tarea.</span><span class="sxs-lookup"><span data-stu-id="b442c-256">If you're creating objects indirectly, then the object creation method handles this task.</span></span> <span data-ttu-id="b442c-257">Sin embargo, si necesita crear un objeto con **CoCreateInstance**, debe llamar a **CoInitializeEx** explícitamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-257">But, if you need to create an object with **CoCreateInstance**, then you must call **CoInitializeEx** explicitly.</span></span> <span data-ttu-id="b442c-258">Cuando haya terminado, COM no debe inicializarse llamando a [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span><span class="sxs-lookup"><span data-stu-id="b442c-258">When you're finished, COM must be uninitialized by calling [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span></span> <span data-ttu-id="b442c-259">Si realiza una llamada a **CoInitializeEx** , debe coincidir con una llamada a **CoUninitialize**.</span><span class="sxs-lookup"><span data-stu-id="b442c-259">If you make a call to **CoInitializeEx** then you must match it with a call to **CoUninitialize**.</span></span> <span data-ttu-id="b442c-260">Normalmente, las aplicaciones que necesitan inicializar COM explícitamente lo hacen en su rutina de inicio y anulan la inicialización de COM en la rutina de limpieza.</span><span class="sxs-lookup"><span data-stu-id="b442c-260">Typically, applications that need to explicitly initialize COM do so in their startup routine, and they uninitialize COM in their cleanup routine.</span></span>

<span data-ttu-id="b442c-261">Para crear una nueva instancia de un objeto COM con **CoCreateInstance**, debe tener el CLSID del objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-261">To create a new instance of a COM object with **CoCreateInstance**, you must have the object's CLSID.</span></span> <span data-ttu-id="b442c-262">Si este CLSID está disponible públicamente, lo encontrará en la documentación de referencia o en el archivo de encabezado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="b442c-262">If this CLSID is publicly available, you will find it in the reference documentation or the appropriate header file.</span></span> <span data-ttu-id="b442c-263">Si el CLSID no está disponible públicamente, no podrá crear el objeto directamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-263">If the CLSID is not publicly available, then you can't create the object directly.</span></span>

<span data-ttu-id="b442c-264">La función **CoCreateInstance** tiene cinco parámetros.</span><span class="sxs-lookup"><span data-stu-id="b442c-264">The **CoCreateInstance** function has five parameters.</span></span> <span data-ttu-id="b442c-265">En el caso de los objetos COM que va a usar con DirectX, normalmente puede establecer los parámetros como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="b442c-265">For the COM objects you will be using with DirectX, you can normally set the parameters as follows.</span></span>

<span data-ttu-id="b442c-266">*rclsid* Establézcalo en el CLSID del objeto que desea crear.</span><span class="sxs-lookup"><span data-stu-id="b442c-266">*rclsid* Set this to the CLSID of the object that you want to create.</span></span>

<span data-ttu-id="b442c-267">*pUnkOuter* Establezca en `nullptr` .</span><span class="sxs-lookup"><span data-stu-id="b442c-267">*pUnkOuter* Set to `nullptr`.</span></span> <span data-ttu-id="b442c-268">Este parámetro solo se usa si se agregan objetos.</span><span class="sxs-lookup"><span data-stu-id="b442c-268">This parameter is used only if you are aggregating objects.</span></span> <span data-ttu-id="b442c-269">Un debate sobre la agregación COM está fuera del ámbito de este tema.</span><span class="sxs-lookup"><span data-stu-id="b442c-269">A discussion of COM aggregation is outside the scope of this topic.</span></span>

<span data-ttu-id="b442c-270">*dwClsContext* Establezca en CLSCTX_INPROC_SERVER.</span><span class="sxs-lookup"><span data-stu-id="b442c-270">*dwClsContext* Set to CLSCTX_INPROC_SERVER.</span></span> <span data-ttu-id="b442c-271">Este valor indica que el objeto se implementa como un archivo DLL y se ejecuta como parte del proceso de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="b442c-271">This setting indicates that the object is implemented as a DLL and runs as part of your application's process.</span></span>

<span data-ttu-id="b442c-272">*riid* Establezca en el IID de la interfaz que desea que se devuelva.</span><span class="sxs-lookup"><span data-stu-id="b442c-272">*riid* Set to the IID of the interface that you would like to have returned.</span></span> <span data-ttu-id="b442c-273">La función creará el objeto y devolverá el puntero de interfaz solicitado en el parámetro PPV.</span><span class="sxs-lookup"><span data-stu-id="b442c-273">The function will create the object and return the requested interface pointer in the ppv parameter.</span></span>

<span data-ttu-id="b442c-274">*PPV* Establézcalo en la dirección de un puntero que se establecerá en la interfaz especificada por `riid` cuando la función devuelva un valor.</span><span class="sxs-lookup"><span data-stu-id="b442c-274">*ppv* Set this to the address of a pointer that will be set to the interface specified by `riid` when the function returns.</span></span> <span data-ttu-id="b442c-275">Esta variable debe declararse como un puntero a la interfaz solicitada y la referencia al puntero en la lista de parámetros debe convertirse en (LPVOID \*).</span><span class="sxs-lookup"><span data-stu-id="b442c-275">This variable should be declared as a pointer to the requested interface, and the reference to the pointer in the parameter list should be cast as (LPVOID \*).</span></span>

<span data-ttu-id="b442c-276">Normalmente, la creación de un objeto indirectamente es mucho más sencilla, como vimos en el ejemplo de código anterior.</span><span class="sxs-lookup"><span data-stu-id="b442c-276">Creating an object indirectly is usually much simpler, as we saw in the code example above.</span></span> <span data-ttu-id="b442c-277">El método de creación de objetos se pasa a la dirección de un puntero de interfaz y, a continuación, el método crea el objeto y devuelve un puntero de interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-277">You pass the object creation method the address of an interface pointer, and the method then creates the object and returns an interface pointer.</span></span> <span data-ttu-id="b442c-278">Cuando se crea un objeto de forma indirecta, aunque no se pueda elegir la interfaz que devuelve el método, a menudo se puede especificar una gran variedad de cosas sobre cómo se debe crear el objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-278">When you create an object indirectly, even if you can't choose which interface the method returns, often you can still specify a variety of things about how the object should be created.</span></span>

<span data-ttu-id="b442c-279">Por ejemplo, puede pasar a **D3D12CreateDevice** un valor que especifique el nivel de característica D3D mínimo que el dispositivo devuelto debe admitir, tal como se muestra en el ejemplo de código anterior.</span><span class="sxs-lookup"><span data-stu-id="b442c-279">For example, you can pass to **D3D12CreateDevice** a value specifying the minimum D3D feature level that the returned device should support, as shown in the code example above.</span></span>

## <a name="using-com-interfaces"></a><span data-ttu-id="b442c-280">Uso de interfaces COM</span><span class="sxs-lookup"><span data-stu-id="b442c-280">Using COM interfaces</span></span>

<span data-ttu-id="b442c-281">Cuando se crea un objeto COM, el método de creación devuelve un puntero de interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-281">When you create a COM object, the creation method returns an interface pointer.</span></span> <span data-ttu-id="b442c-282">Después, puede usar ese puntero para tener acceso a cualquiera de los métodos de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-282">You can then use that pointer to access any of the interface's methods.</span></span> <span data-ttu-id="b442c-283">La sintaxis es idéntica a la que se usa con un puntero a un método de C++.</span><span class="sxs-lookup"><span data-stu-id="b442c-283">The syntax is identical to that used with a pointer to a C++ method.</span></span>

## <a name="requesting-additional-interfaces"></a><span data-ttu-id="b442c-284">Solicitud de interfaces adicionales</span><span class="sxs-lookup"><span data-stu-id="b442c-284">Requesting Additional Interfaces</span></span>

<span data-ttu-id="b442c-285">En muchos casos, el puntero de interfaz que recibe del método de creación puede ser el único que necesite.</span><span class="sxs-lookup"><span data-stu-id="b442c-285">In many cases, the interface pointer that you receive from the creation method may be the only one that you need.</span></span> <span data-ttu-id="b442c-286">De hecho, es relativamente común que un objeto solo exporte una interfaz que no sea **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="b442c-286">In fact, it's relatively common for an object to export only one interface other than **IUnknown**.</span></span> <span data-ttu-id="b442c-287">Sin embargo, muchos objetos exportan varias interfaces y es posible que necesite punteros a varias de ellas.</span><span class="sxs-lookup"><span data-stu-id="b442c-287">However, many objects export multiple interfaces, and you may need pointers to several of them.</span></span> <span data-ttu-id="b442c-288">Si necesita más interfaces de las devueltas por el método de creación, no es necesario crear un nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-288">If you need more interfaces than the one returned by the creation method, there's no need to create a new object.</span></span> <span data-ttu-id="b442c-289">En su lugar, solicite otro puntero de interfaz mediante el [**método IUnknown:: QueryInterface**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))del objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-289">Instead, request another interface pointer by using the object's [**IUnknown::QueryInterface method**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)).</span></span>

<span data-ttu-id="b442c-290">Si crea el objeto con **CoCreateInstance**, puede solicitar un puntero a la interfaz **IUnknown** y, a continuación, llamar a **IUnknown:: QueryInterface** para solicitar todas las interfaces que necesite.</span><span class="sxs-lookup"><span data-stu-id="b442c-290">If you create your object with **CoCreateInstance**, then you can request an **IUnknown** interface pointer and then call **IUnknown::QueryInterface** to request every interface you need.</span></span> <span data-ttu-id="b442c-291">Sin embargo, este enfoque no es práctico si solo necesita una interfaz y no funciona en absoluto si usa un método de creación de objetos que no le permite especificar el puntero de interfaz que se debe devolver.</span><span class="sxs-lookup"><span data-stu-id="b442c-291">However, this approach is inconvenient if you need only a single interface, and it doesn't work at all if you use an object creation method that doesn't allow you to specify which interface pointer should be returned.</span></span> <span data-ttu-id="b442c-292">En la práctica, normalmente no es necesario obtener un puntero **IUnknown** explícito, ya que todas las interfaces com amplían la interfaz **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="b442c-292">In practice, you usually don't need to obtain an explicit **IUnknown** pointer, because all COM interfaces extend the **IUnknown** interface.</span></span>

<span data-ttu-id="b442c-293">La extensión de una interfaz es conceptualmente similar a la herencia de una clase de C++.</span><span class="sxs-lookup"><span data-stu-id="b442c-293">Extending an interface is conceptually similar to inheriting from a C++ class.</span></span> <span data-ttu-id="b442c-294">La interfaz secundaria expone todos los métodos de la interfaz primaria, más uno o más de los suyos propios.</span><span class="sxs-lookup"><span data-stu-id="b442c-294">The child interface exposes all of the parent interface's methods, plus one or more of its own.</span></span> <span data-ttu-id="b442c-295">De hecho, a menudo verá "se hereda de", que se usa en lugar de "extends".</span><span class="sxs-lookup"><span data-stu-id="b442c-295">In fact, you will often see "inherits from" used instead of "extends".</span></span> <span data-ttu-id="b442c-296">Lo que debe recordar es que la herencia es interna para el objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-296">What you need to remember is that the inheritance is internal to the object.</span></span> <span data-ttu-id="b442c-297">La aplicación no puede heredar de o extender la interfaz de un objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-297">Your application can't inherit from or extend an object's interface.</span></span> <span data-ttu-id="b442c-298">Sin embargo, puede usar la interfaz secundaria para llamar a cualquiera de los métodos del elemento primario o secundario.</span><span class="sxs-lookup"><span data-stu-id="b442c-298">However, you can use the child interface to call any of the methods of the child or parent.</span></span>

<span data-ttu-id="b442c-299">Dado que todas las interfaces son elementos secundarios de **IUnknown**, puede llamar a **QueryInterface** en cualquiera de los punteros de interfaz que ya tiene para el objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-299">Because all interfaces are children of **IUnknown**, you can call **QueryInterface** on any of the interface pointers that you already have for the object.</span></span> <span data-ttu-id="b442c-300">Al hacerlo, debe proporcionar el IID de la interfaz que está solicitando y la dirección de un puntero que contendrá el puntero de interfaz cuando se devuelva el método.</span><span class="sxs-lookup"><span data-stu-id="b442c-300">When you do so, you must provide the IID of the interface that you're requesting and the address of a pointer that will contain the interface pointer when the method returns.</span></span>

<span data-ttu-id="b442c-301">Por ejemplo, en el fragmento de código siguiente se llama a **IDXGIFactory2:: CreateSwapChainForHwnd** para crear un objeto de cadena de intercambio principal.</span><span class="sxs-lookup"><span data-stu-id="b442c-301">For example, the following code fragment calls **IDXGIFactory2::CreateSwapChainForHwnd** to create a primary swap chain object.</span></span> <span data-ttu-id="b442c-302">Este objeto expone varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="b442c-302">This object exposes several interfaces.</span></span> <span data-ttu-id="b442c-303">El método **CreateSwapChainForHwnd** devuelve una interfaz **IDXGISwapChain1** .</span><span class="sxs-lookup"><span data-stu-id="b442c-303">The **CreateSwapChainForHwnd** method returns an **IDXGISwapChain1** interface.</span></span> <span data-ttu-id="b442c-304">Después, el código siguiente usa la interfaz **IDXGISwapChain1** para llamar a **QueryInterface** para solicitar una interfaz **IDXGISwapChain3** .</span><span class="sxs-lookup"><span data-stu-id="b442c-304">The subsequent code then uses the **IDXGISwapChain1** interface to call **QueryInterface** to request an **IDXGISwapChain3** interface.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> <span data-ttu-id="b442c-305">En C++, puede hacer uso de la ``IID_PPV_ARGS`` macro en lugar del IID explícito y del puntero de conversión: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` .</span><span class="sxs-lookup"><span data-stu-id="b442c-305">In C++ you can make use of the ``IID_PPV_ARGS`` macro rather than the explicit IID and cast pointer: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));``.</span></span>
> <span data-ttu-id="b442c-306">Esto se utiliza a menudo para los métodos de creación y **QueryInterface**.</span><span class="sxs-lookup"><span data-stu-id="b442c-306">This is often used for creation methods as well as **QueryInterface**.</span></span> <span data-ttu-id="b442c-307">Vea [combaseapi. h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="b442c-307">See [combaseapi.h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) for more information.</span></span>

## <a name="managing-a-com-objects-lifetime"></a><span data-ttu-id="b442c-308">Administrar la duración de un objeto COM</span><span class="sxs-lookup"><span data-stu-id="b442c-308">Managing a COM object's lifetime</span></span>

<span data-ttu-id="b442c-309">Cuando se crea un objeto, el sistema asigna los recursos de memoria necesarios.</span><span class="sxs-lookup"><span data-stu-id="b442c-309">When an object is created, the system allocates the necessary memory resources.</span></span> <span data-ttu-id="b442c-310">Cuando ya no se necesita un objeto, se debe destruir.</span><span class="sxs-lookup"><span data-stu-id="b442c-310">When an object is no longer needed, it should be destroyed.</span></span> <span data-ttu-id="b442c-311">El sistema puede utilizar esa memoria para otros fines.</span><span class="sxs-lookup"><span data-stu-id="b442c-311">The system can use that memory for other purposes.</span></span> <span data-ttu-id="b442c-312">Con objetos de C++, puede controlar la duración del objeto directamente con los `new` operadores y en los casos en los que `delete` está trabajando en ese nivel, o simplemente usando la duración de la pila y el ámbito.</span><span class="sxs-lookup"><span data-stu-id="b442c-312">With C++ objects, you can control the object's lifetime directly with the `new` and `delete` operators in cases where you're operating at that level, or just by using the stack and scope lifetime.</span></span> <span data-ttu-id="b442c-313">COM no permite crear ni destruir objetos directamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-313">COM doesn't enable you to directly create or destroy objects.</span></span> <span data-ttu-id="b442c-314">La razón de este diseño es que el mismo objeto puede ser utilizado por más de una parte de la aplicación o, en algunos casos, por más de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="b442c-314">The reason for this design is that the same object may be used by more than one part of your application or, in some cases, by more than one application.</span></span> <span data-ttu-id="b442c-315">Si una de esas referencias fuera a destruir el objeto, las demás referencias dejarán de ser válidas.</span><span class="sxs-lookup"><span data-stu-id="b442c-315">If one of those references were to destroy the object, then the other references would become invalid.</span></span> <span data-ttu-id="b442c-316">En su lugar, COM usa un sistema de recuento de referencias para controlar la duración de un objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-316">Instead, COM uses a system of reference counting to control an object's lifetime.</span></span>

<span data-ttu-id="b442c-317">El recuento de referencias de un objeto es el número de veces que se ha solicitado una de sus interfaces.</span><span class="sxs-lookup"><span data-stu-id="b442c-317">An object's reference count is the number of times one of its interfaces has been requested.</span></span> <span data-ttu-id="b442c-318">Cada vez que se solicita una interfaz, se incrementa el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-318">Each time that an interface is requested, the reference count is incremented.</span></span> <span data-ttu-id="b442c-319">Una aplicación libera una interfaz cuando esa interfaz ya no se necesita, lo que disminuye el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-319">An application releases an interface when that interface is no longer needed, decrementing the reference count.</span></span> <span data-ttu-id="b442c-320">Siempre que el recuento de referencias sea mayor que cero, el objeto permanece en la memoria.</span><span class="sxs-lookup"><span data-stu-id="b442c-320">As long as the reference count is greater than zero, the object remains in memory.</span></span> <span data-ttu-id="b442c-321">Cuando el recuento de referencias llega a cero, el objeto se destruye.</span><span class="sxs-lookup"><span data-stu-id="b442c-321">When the reference count reaches zero, the object destroys itself.</span></span> <span data-ttu-id="b442c-322">No es necesario saber nada sobre el recuento de referencias de un objeto.</span><span class="sxs-lookup"><span data-stu-id="b442c-322">You don't need to know anything about the reference count of an object.</span></span> <span data-ttu-id="b442c-323">Siempre que obtenga y libere correctamente las interfaces de un objeto, el objeto tendrá la duración adecuada.</span><span class="sxs-lookup"><span data-stu-id="b442c-323">As long as you obtain and release an object's interfaces properly, the object will have the appropriate lifetime.</span></span>

<span data-ttu-id="b442c-324">Controlar correctamente el recuento de referencias es una parte fundamental de la programación COM.</span><span class="sxs-lookup"><span data-stu-id="b442c-324">Properly handling reference counting is a crucial part of COM programming.</span></span> <span data-ttu-id="b442c-325">Si no lo hace, puede crear fácilmente una pérdida de memoria o un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="b442c-325">Failure to do so can easily create a memory leak or a crash.</span></span> <span data-ttu-id="b442c-326">Uno de los errores más comunes que los programadores de COM realizan no pueden liberar una interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-326">One of the most common mistakes that COM programmers make is failing to release an interface.</span></span> <span data-ttu-id="b442c-327">Cuando esto sucede, el recuento de referencias nunca llega a cero y el objeto permanece en memoria indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="b442c-327">When this happens, the reference count never reaches zero, and the object remains in memory indefinitely.</span></span>

> [!NOTE]
> <span data-ttu-id="b442c-328">Direct3D 10 o posterior tiene reglas de duración ligeramente modificadas para los objetos.</span><span class="sxs-lookup"><span data-stu-id="b442c-328">Direct3D 10 or later has slightly modified lifetime rules for objects.</span></span> <span data-ttu-id="b442c-329">En concreto, los objetos que se derivan de **ID3DxxDeviceChild** nunca durar másn su dispositivo primario (es decir, si el **ID3DxxDevice** propietario alcanza un valor de recuento 0, entonces todos los objetos secundarios no son válidos también).</span><span class="sxs-lookup"><span data-stu-id="b442c-329">In particular, objects that are derived from **ID3DxxDeviceChild** never outlive their parent device (that is, if the owning **ID3DxxDevice** hits a 0 refcount, then all child objects are immediately invalid as well).</span></span> <span data-ttu-id="b442c-330">Además, cuando se usan métodos **set** para enlazar objetos a la canalización de representación, estas referencias no aumentan el recuento de referencias (es decir, son referencias débiles).</span><span class="sxs-lookup"><span data-stu-id="b442c-330">Also, when you use **Set** methods to bind objects to the render pipeline, these references don't increase the reference count (that is, they are weak references).</span></span> <span data-ttu-id="b442c-331">En la práctica, esto se controla mejor asegurándose de liberar todos los objetos secundarios del dispositivo antes de liberar el dispositivo.</span><span class="sxs-lookup"><span data-stu-id="b442c-331">In practice, this is best handled by ensuring that you release all device child objects fully before you release the device.</span></span>

## <a name="incrementing-and-decrementing-the-reference-count"></a><span data-ttu-id="b442c-332">Aumentar y disminuir el recuento de referencias</span><span class="sxs-lookup"><span data-stu-id="b442c-332">Incrementing and decrementing the reference count</span></span>

<span data-ttu-id="b442c-333">Siempre que obtenga un nuevo puntero de interfaz, el recuento de referencias se debe incrementar mediante una llamada a [**IUnknown:: AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span><span class="sxs-lookup"><span data-stu-id="b442c-333">Whenever you obtain a new interface pointer, the reference count must be incremented by a call to [**IUnknown::AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span></span> <span data-ttu-id="b442c-334">Sin embargo, la aplicación normalmente no necesita llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="b442c-334">However, your application doesn't usually need to call this method.</span></span> <span data-ttu-id="b442c-335">Si obtiene un puntero de interfaz llamando a un método de creación de objetos o llamando a **IUnknown:: QueryInterface**, el objeto incrementa automáticamente el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-335">If you obtain an interface pointer by calling an object creation method, or by calling **IUnknown::QueryInterface**, then the object automatically increments the reference count.</span></span> <span data-ttu-id="b442c-336">Sin embargo, si crea un puntero de interfaz de otra manera, como copiar un puntero existente, debe llamar explícitamente a **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="b442c-336">However, if you create an interface pointer in some other way, such as copying an existing pointer, then you must explicitly call **IUnknown::AddRef**.</span></span> <span data-ttu-id="b442c-337">De lo contrario, al liberar el puntero de interfaz original, el objeto se puede destruir aunque sea necesario usar la copia del puntero.</span><span class="sxs-lookup"><span data-stu-id="b442c-337">Otherwise, when you release the original interface pointer, the object may be destroyed even though you may still need to use the copy of the pointer.</span></span>

<span data-ttu-id="b442c-338">Debe liberar todos los punteros de interfaz, independientemente de si usted o el objeto incrementaron el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-338">You must release all interface pointers, regardless of whether you or the object incremented the reference count.</span></span> <span data-ttu-id="b442c-339">Cuando ya no necesite un puntero de interfaz, llame a [**IUnknown:: Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) para reducir el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-339">When you no longer need an interface pointer, call [**IUnknown::Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) to decrement the reference count.</span></span> <span data-ttu-id="b442c-340">Una práctica común es inicializar todos los punteros de interfaz y, a `nullptr` continuación, volver a configurarlos `nullptr` cuando se lancen.</span><span class="sxs-lookup"><span data-stu-id="b442c-340">A common practice is to initialize all interface pointers to `nullptr`, and then to set them back to `nullptr` when they are released.</span></span> <span data-ttu-id="b442c-341">Esa Convención le permite probar todos los punteros de interfaz en el código de limpieza.</span><span class="sxs-lookup"><span data-stu-id="b442c-341">That convention allows you to test all interface pointers in your cleanup code.</span></span> <span data-ttu-id="b442c-342">Que `nullptr` todavía no están activas y debe liberarlas antes de finalizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="b442c-342">Those that are not `nullptr` are still active, and you need to release them before you terminate the application.</span></span>

<span data-ttu-id="b442c-343">El siguiente fragmento de código amplía el ejemplo mostrado anteriormente para ilustrar cómo controlar el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="b442c-343">The following code fragment extends the sample shown earlier to illustrate how to handle reference counting.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a><span data-ttu-id="b442c-344">Punteros inteligentes COM</span><span class="sxs-lookup"><span data-stu-id="b442c-344">COM Smart Pointers</span></span>

<span data-ttu-id="b442c-345">El código hasta ahora ha llamado explícitamente ``Release`` ``AddRef`` a y para mantener los recuentos de referencias mediante métodos **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="b442c-345">The code so far has explicitly called ``Release`` and ``AddRef`` to maintain the reference counts using **IUnknown** methods.</span></span> <span data-ttu-id="b442c-346">Este patrón requiere que el programador sea diligente para recordar que el recuento se mantiene correctamente en todos los rutas posibles.</span><span class="sxs-lookup"><span data-stu-id="b442c-346">This pattern requires the programmer to be diligent in remembering to properly maintain the count in all possible codepaths.</span></span> <span data-ttu-id="b442c-347">Esto puede dar lugar a un control de errores complicado y, con el control de excepciones de C++ habilitado, puede ser especialmente difícil de implementar.</span><span class="sxs-lookup"><span data-stu-id="b442c-347">This can result in complicated error-handling, and with C++ exception handling enabled can be particularly difficult to implement.</span></span> <span data-ttu-id="b442c-348">Una solución mejor con C++ es usar un [puntero inteligente](/cpp/cpp/smart-pointers-modern-cpp).</span><span class="sxs-lookup"><span data-stu-id="b442c-348">A better solution with C++ is to make use of a [smart pointer](/cpp/cpp/smart-pointers-modern-cpp).</span></span>

* <span data-ttu-id="b442c-349">**winrt:: com_ptr** es un puntero inteligente proporcionado por las [proyecciones de lenguaje de C++/WinRT](/uwp/cpp-ref-for-winrt/com-ptr).</span><span class="sxs-lookup"><span data-stu-id="b442c-349">**winrt::com_ptr** is a smart pointer provided by the [C++/WinRT language projections](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="b442c-350">Este es el puntero inteligente COM recomendado que se usará para las aplicaciones UWP.</span><span class="sxs-lookup"><span data-stu-id="b442c-350">This is the recommended COM smart pointer to use for UWP apps.</span></span> <span data-ttu-id="b442c-351">Tenga en cuenta que C++/WinRT requiere C++ 17.</span><span class="sxs-lookup"><span data-stu-id="b442c-351">Note that C++/WinRT requires C++17.</span></span>

* <span data-ttu-id="b442c-352">**Microsoft:: WRL:: ComPtr** es un puntero inteligente proporcionado por el [Windows Runtime biblioteca de plantillas de C++ (WRL)](/cpp/cppcx/wrl/comptr-class).</span><span class="sxs-lookup"><span data-stu-id="b442c-352">**Microsoft::WRL::ComPtr** is a smart pointer provided by the [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span></span> <span data-ttu-id="b442c-353">Esta biblioteca es "pura" de C++, por lo que se puede usar para aplicaciones Windows Runtime (a través de C++/CX o C++/WinRT), así como aplicaciones de escritorio clásicas de Win32.</span><span class="sxs-lookup"><span data-stu-id="b442c-353">This library is "pure" C++ so it can be utilized for Windows Runtime applications (via C++/CX or C++/WinRT) as well as classic Win32 desktop applications.</span></span> <span data-ttu-id="b442c-354">Este puntero inteligente también funciona en versiones anteriores de Windows que no admiten las API de Windows Runtime.</span><span class="sxs-lookup"><span data-stu-id="b442c-354">This smart pointer also works on older versions of Windows that do not support the Windows Runtime APIs.</span></span> <span data-ttu-id="b442c-355">En el caso de las aplicaciones de escritorio de Win32, puede usar ``#include <wrl/client.h>`` para incluir solo esta clase y, opcionalmente, definir el símbolo del preprocesador ``__WRL_CLASSIC_COM_STRICT__`` .</span><span class="sxs-lookup"><span data-stu-id="b442c-355">For Win32 desktop applications, you can use ``#include <wrl/client.h>`` to only include this class and optionally define the preprocessor symbol ``__WRL_CLASSIC_COM_STRICT__`` as well.</span></span> <span data-ttu-id="b442c-356">Para obtener más información, vea [punteros inteligentes com revisitados](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span><span class="sxs-lookup"><span data-stu-id="b442c-356">For more information, see [COM smart pointers revisited](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span></span>

* <span data-ttu-id="b442c-357">**CComPtr** es un puntero inteligente proporcionado por el [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span><span class="sxs-lookup"><span data-stu-id="b442c-357">**CComPtr** is a smart pointer provided by the [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span></span> <span data-ttu-id="b442c-358">**Microsoft:: WRL:: ComPtr** es una versión más reciente de esta implementación que aborda una serie de problemas de uso sutiles, por lo que no se recomienda el uso de este puntero inteligente para los proyectos nuevos.</span><span class="sxs-lookup"><span data-stu-id="b442c-358">The **Microsoft::WRL::ComPtr** is a newer version of this implementation that addresses a number of subtle usage issues, so use of this smart pointer is not recommended for new projects.</span></span> <span data-ttu-id="b442c-359">Para obtener más información, vea [Cómo crear y usar CComPtr y CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span><span class="sxs-lookup"><span data-stu-id="b442c-359">For more information, see [How to create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span></span>


## <a name="using-atl-with-directx-9"></a><span data-ttu-id="b442c-360">Usar ATL con DirectX 9</span><span class="sxs-lookup"><span data-stu-id="b442c-360">Using ATL with DirectX 9</span></span>

<span data-ttu-id="b442c-361">Para usar el Active Template Library (ATL) con DirectX 9, debe volver a definir las interfaces para la compatibilidad con ATL.</span><span class="sxs-lookup"><span data-stu-id="b442c-361">To use the Active Template Library (ATL) with DirectX 9, you must redefine the interfaces for ATL compatibility.</span></span> <span data-ttu-id="b442c-362">Esto le permite usar correctamente la clase **CComQIPtr** para obtener un puntero a una interfaz.</span><span class="sxs-lookup"><span data-stu-id="b442c-362">This allows you to properly use the **CComQIPtr** class to obtain a pointer to an interface.</span></span>

<span data-ttu-id="b442c-363">Sabrá si no redefine las interfaces para ATL, ya que verá el siguiente mensaje de error.</span><span class="sxs-lookup"><span data-stu-id="b442c-363">You'll know if you don't redefine the interfaces for ATL, because you'll see the following error message.</span></span>

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

<span data-ttu-id="b442c-364">En el ejemplo de código siguiente se muestra cómo definir la interfaz IDirectXFileData.</span><span class="sxs-lookup"><span data-stu-id="b442c-364">The following code sample shows how to define the IDirectXFileData interface.</span></span>

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

<span data-ttu-id="b442c-365">Después de volver a definir la interfaz, debe utilizar el método **Attach** para adjuntar la interfaz al puntero de interfaz devuelto por **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="b442c-365">After redefining the interface, you must use the **Attach** method to attach the interface to the interface pointer returned by **::Direct3DCreate9**.</span></span> <span data-ttu-id="b442c-366">Si no lo hace, la interfaz de **IDirect3D9** no se liberará correctamente mediante la clase de puntero inteligente.</span><span class="sxs-lookup"><span data-stu-id="b442c-366">If you don't, then the **IDirect3D9** interface won't be properly released by the smart pointer class.</span></span>

<span data-ttu-id="b442c-367">La clase **CComPtr** llama internamente a **IUnknown:: AddRef** en el puntero de interfaz cuando se crea el objeto y cuando se asigna una interfaz a la clase **CComPtr** .</span><span class="sxs-lookup"><span data-stu-id="b442c-367">The **CComPtr** class internally calls **IUnknown::AddRef** on the interface pointer when the object is created and when an interface is assigned to the **CComPtr** class.</span></span> <span data-ttu-id="b442c-368">Para evitar la pérdida del puntero de interfaz, no llame a \* \* IUnknown:: AddRef en la interfaz devuelta desde **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="b442c-368">To avoid leaking the interface pointer, don't call \*\*IUnknown::AddRef on the interface returned from **::Direct3DCreate9**.</span></span>

<span data-ttu-id="b442c-369">El código siguiente libera correctamente la interfaz sin llamar a **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="b442c-369">The following code properly releases the interface without calling **IUnknown::AddRef**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

<span data-ttu-id="b442c-370">Use el código anterior.</span><span class="sxs-lookup"><span data-stu-id="b442c-370">Use the previous code.</span></span> <span data-ttu-id="b442c-371">No use el código siguiente, que llama a **IUnknown:: AddRef** seguido de **IUnknown:: Release** y no libera la referencia agregada por **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="b442c-371">Don't use the following code, which calls **IUnknown::AddRef** followed by **IUnknown::Release**, and doesn't release the reference added by **::Direct3DCreate9**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

<span data-ttu-id="b442c-372">Tenga en cuenta que este es el único lugar en Direct3D 9 en el que tendrá que usar el método **Attach** de esta manera.</span><span class="sxs-lookup"><span data-stu-id="b442c-372">Note that this is the only place in Direct3D 9 where you'll have to use the **Attach** method in this manner.</span></span>

<span data-ttu-id="b442c-373">Para obtener más información sobre las clases **CComPTR** y **CComQIPtr** , vea sus definiciones en el `Atlbase.h` archivo de encabezado.</span><span class="sxs-lookup"><span data-stu-id="b442c-373">For more information about the **CComPTR** and **CComQIPtr** classes, see their definitions in the `Atlbase.h` header file.</span></span>
