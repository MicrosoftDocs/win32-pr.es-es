---
description: Aunque este mecanismo es suficiente para las aplicaciones sencillas, no puede admitir los requisitos de distribución de mensajes complejos de aplicaciones más avanzadas, como los que usan el modelo de interfaz de múltiples documentos (MDI).
ms.assetid: e4558e71-bbec-415a-a7c2-9025a4d6c474
title: Enlace de bloqueo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2dcd098692784a662456c990a238bd309db0c321
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "105715137"
---
# <a name="blocking-hook"></a><span data-ttu-id="5a7b2-103">Enlace de bloqueo</span><span class="sxs-lookup"><span data-stu-id="5a7b2-103">Blocking Hook</span></span>

<span data-ttu-id="5a7b2-104">Aunque este mecanismo es suficiente para las aplicaciones sencillas, no puede admitir los requisitos de distribución de mensajes complejos de aplicaciones más avanzadas, como los que usan el modelo de interfaz de múltiples documentos (MDI).</span><span class="sxs-lookup"><span data-stu-id="5a7b2-104">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications such as those using the Multiple Document Interface (MDI) model.</span></span> <span data-ttu-id="5a7b2-105">Para estas aplicaciones, la aplicación puede instalar un enlace de bloqueo específico del subproceso.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-105">For such applications, a thread-specific blocking hook may be installed by the application.</span></span> <span data-ttu-id="5a7b2-106">El proveedor de servicios llamará a este método en lugar del enlace de bloqueo predeterminado descrito en el anterior.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-106">This will be called by the service provider instead of the default blocking hook described in the preceding.</span></span> <span data-ttu-id="5a7b2-107">Un proveedor de servicios debe recuperar un puntero al enlace de bloqueo por subproceso del \_32.dll Ws2 llamando a [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span><span class="sxs-lookup"><span data-stu-id="5a7b2-107">A service provider must retrieve a pointer to the per-thread blocking hook from the Ws2\_32.dll by calling [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span></span> <span data-ttu-id="5a7b2-108">Si la aplicación no ha instalado su propio enlace de bloqueo, se devolverá un puntero a la función de enlace de bloqueo predeterminada.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-108">If the application has not installed its own blocking hook a pointer to the default blocking hook function will be returned.</span></span>

<span data-ttu-id="5a7b2-109">Un proveedor de servicios de Windows Sockets no puede suponer que un enlace de bloqueo proporcionado por la aplicación permita que el procesamiento de mensajes continúe como lo hace el enlace de bloqueo predeterminado.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-109">A Windows Sockets service provider cannot assume that an application-supplied blocking hook allows message processing to continue as the default blocking hook does.</span></span> <span data-ttu-id="5a7b2-110">Algunas aplicaciones no pueden tolerar la posibilidad de que se produzcan mensajes reentrantes mientras una operación de bloqueo esté pendiente.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-110">Some applications cannot tolerate the possibility of reentrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="5a7b2-111">Este tipo de función de enlace de bloqueo de una aplicación simplemente devolverá **false**.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-111">Such an application's blocking hook function would simply return **FALSE**.</span></span> <span data-ttu-id="5a7b2-112">Si un proveedor de servicios depende de mensajes para su operación interna, puede ejecutar **PeekMessage**(hMyWnd...) antes de ejecutar el enlace de bloqueo de la aplicación para que pueda obtener sus propios mensajes sin afectar al resto del sistema.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-112">If a service provider depends on messages for its internal operation, it may execute **PeekMessage**(hMyWnd...) before executing the application's blocking hook so that it can get its own messages without affecting the rest of the system.</span></span>

<span data-ttu-id="5a7b2-113">No hay ningún enlace de bloqueo predeterminado instalado en las versiones preferentes multiproceso de Windows.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-113">There is no default blocking hook installed in preemptive multithreaded versions of Windows.</span></span> <span data-ttu-id="5a7b2-114">Esto se debe a que otros procesos no se bloquearán si una sola aplicación está esperando a que se complete una operación (y, por tanto, no llama a **PeekMessage** o a **GetMessage** , lo que hace que la aplicación produzca el procesador en ventanas no adelantadas).</span><span class="sxs-lookup"><span data-stu-id="5a7b2-114">This is because other processes will not be blocked if a single application is waiting for an operation to complete (and hence not calling **PeekMessage** or **GetMessage** which causes the application to yield the processor in nonpreemptive Windows).</span></span> <span data-ttu-id="5a7b2-115">Cuando el proveedor de servicios llama a [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) , se devolverá un puntero nulo que indica que el proveedor va a utilizar funciones de bloqueo del sistema operativo nativo.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-115">When the service provider calls [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) a null pointer will be returned indicating that the provider is to use native operating system blocking functions.</span></span> <span data-ttu-id="5a7b2-116">Sin embargo, para mantener la compatibilidad con versiones anteriores, un enlace de bloqueo proporcionado por la aplicación todavía se puede instalar por subproceso en Windows.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-116">However, in order to preserve backward compatibility, an application-supplied blocking hook can still be installed on a per-thread basis in Windows.</span></span>

<span data-ttu-id="5a7b2-117">El proveedor de servicios Winsock llama al enlace de bloqueo solo si se cumplen todas las condiciones siguientes: la rutina es una que se define como capaz de bloquearse, el socket especificado es un socket de bloqueo y la solicitud no se puede completar inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-117">The Winsock service provider calls the blocking hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.</span></span> <span data-ttu-id="5a7b2-118">Si solo se usan Sockets sin bloqueos y [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85)) / [**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) en lugar de [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) , no se llamará nunca al enlace de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-118">If only nonblocking sockets and [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85))/[**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) instead of [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) are used, then the blocking hook will never be called.</span></span>

> [!Note]  
> <span data-ttu-id="5a7b2-119">Si, durante el tiempo que se usa pseudoblocking para bloquear un subproceso, se recibe un mensaje de Windows para el subproceso, existe el riesgo de que el subproceso intente emitir otra llamada Winsock.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-119">If, during the time pseudoblocking is being used to block a thread, a Windows message is received for the thread, there is a risk that the thread will attempt to issue another Winsock call.</span></span> <span data-ttu-id="5a7b2-120">Debido a la dificultad de administrar esta condición de forma segura, la especificación 1,1 de Windows Sockets no permite este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-120">Because of the difficulty of managing this condition safely, the Windows Sockets 1.1 specification disallowed this behavior.</span></span> <span data-ttu-id="5a7b2-121">No se permite que un subproceso determinado realice varias llamadas a función Winsock anidadas.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-121">It is not permissible for a given thread to make multiple, nested Winsock function calls.</span></span> <span data-ttu-id="5a7b2-122">Solo se permite una llamada de función pendiente para un subproceso determinado.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-122">Only one outstanding function call is allowed for a particular thread.</span></span> <span data-ttu-id="5a7b2-123">Cualquier llamada de función Winsock anidada produce un error WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-123">Any nested Winsock function calls fail with the error WSAEINPROGRESS.</span></span> <span data-ttu-id="5a7b2-124">Se debe resaltar que esta restricción se aplica a las operaciones de bloqueo y de no bloqueo, pero solo en entornos de Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-124">It should be emphasized that this restriction applies to both blocking and nonblocking operations, but only in Windows Sockets 1.1 environments.</span></span> <span data-ttu-id="5a7b2-125">Hay algunas excepciones a esta regla, incluidas dos funciones que permiten que una aplicación determine si una operación de pseudoblocking es de hecho en curso, y para cancelar esta operación si es necesario.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-125">There are a few exceptions to this rule, including two functions that allow an application to determine whether a pseudoblocking operation is in fact in progress, and to cancel such an operation if need be.</span></span> <span data-ttu-id="5a7b2-126">Se describen a continuación.</span><span class="sxs-lookup"><span data-stu-id="5a7b2-126">These are described in the following.</span></span>

 

 

 
