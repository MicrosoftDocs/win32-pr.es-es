---
description: Obtenga información acerca de cómo evitar pérdidas de memoria en aplicaciones Windows para plataformas Windows 7 y Windows Server 2008 R2.
ms.assetid: c5dedcab-3e6f-433f-95de-d741321c683e
title: Evitar pérdidas de memoria en aplicaciones Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e973da19d075ac94824df340d1741fd9cefb3486
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "104567390"
---
# <a name="preventing-memory-leaks-in-windows-applications"></a><span data-ttu-id="86394-103">Evitar pérdidas de memoria en aplicaciones Windows</span><span class="sxs-lookup"><span data-stu-id="86394-103">Preventing Memory Leaks in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="86394-104">Plataformas afectadas</span><span class="sxs-lookup"><span data-stu-id="86394-104">Affected Platforms</span></span>

<span data-ttu-id="86394-105">**Clientes** : Windows 7</span><span class="sxs-lookup"><span data-stu-id="86394-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="86394-106">**Servidores** : Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="86394-106">**Servers** - Windows Server 2008 R2</span></span>  

## <a name="description"></a><span data-ttu-id="86394-107">Descripción</span><span class="sxs-lookup"><span data-stu-id="86394-107">Description</span></span>

<span data-ttu-id="86394-108">Las pérdidas de memoria son una clase de errores en los que la aplicación no puede liberar memoria cuando ya no se necesitan.</span><span class="sxs-lookup"><span data-stu-id="86394-108">Memory leaks are a class of bugs where the application fails to release memory when no longer needed.</span></span> <span data-ttu-id="86394-109">Con el tiempo, las pérdidas de memoria afectan al rendimiento de la aplicación concreta, así como del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="86394-109">Over time, memory leaks affect the performance of both the particular application as well as the operating system.</span></span> <span data-ttu-id="86394-110">Una pérdida grande podría producir tiempos de respuesta inaceptables debido a una paginación excesiva.</span><span class="sxs-lookup"><span data-stu-id="86394-110">A large leak might result in unacceptable response times due to excessive paging.</span></span> <span data-ttu-id="86394-111">Finalmente, la aplicación, así como otras partes del sistema operativo, experimentarán errores.</span><span class="sxs-lookup"><span data-stu-id="86394-111">Eventually the application as well as other parts of the operating system will experience failures.</span></span>

<span data-ttu-id="86394-112">Windows liberará toda la memoria asignada por la aplicación al finalizar el proceso, por lo que las aplicaciones de ejecución reducida no afectarán de forma significativa al rendimiento global del sistema.</span><span class="sxs-lookup"><span data-stu-id="86394-112">Windows will free all memory allocated by the application on process termination, so short-running applications will not affect overall system performance significantly.</span></span> <span data-ttu-id="86394-113">Sin embargo, las pérdidas en procesos de ejecución prolongada como servicios o incluso complementos del explorador pueden afectar en gran medida a la confiabilidad del sistema y podrían obligar al usuario a reiniciar Windows para que el sistema pueda volver a usarse.</span><span class="sxs-lookup"><span data-stu-id="86394-113">However, leaks in long-running processes like services or even Explorer plug-ins can greatly impact system reliability and might force the user to reboot Windows in order to make the system usable again.</span></span>

<span data-ttu-id="86394-114">Las aplicaciones pueden asignar memoria en su nombre por varios medios.</span><span class="sxs-lookup"><span data-stu-id="86394-114">Applications can allocate memory on their behalf by multiple means.</span></span> <span data-ttu-id="86394-115">Cada tipo de asignación puede producir una pérdida si no se libera tras su uso.</span><span class="sxs-lookup"><span data-stu-id="86394-115">Each type of allocation can result in a leak if not freed after use.</span></span> <span data-ttu-id="86394-116">Estos son algunos ejemplos de patrones de asignación comunes:</span><span class="sxs-lookup"><span data-stu-id="86394-116">Here are some examples of common allocation patterns:</span></span>

-   <span data-ttu-id="86394-117">Memoria del montón a través de la función [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) o sus equivalentes en tiempo de ejecución de C/C++ **malloc** o **New**</span><span class="sxs-lookup"><span data-stu-id="86394-117">Heap memory via the [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) function or its C/C++ runtime equivalents **malloc** or **new**</span></span>
-   <span data-ttu-id="86394-118">Dirija las asignaciones desde el sistema operativo a través de la función [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) .</span><span class="sxs-lookup"><span data-stu-id="86394-118">Direct allocations from the operating system via the [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function.</span></span>
-   <span data-ttu-id="86394-119">Los identificadores de kernel creados a través de las API de Kernel32, como [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)o [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), contienen memoria de kernel en nombre de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="86394-119">Kernel handles created via Kernel32 APIs such as [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa), or [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), hold kernel memory on behalf of the application</span></span>
-   <span data-ttu-id="86394-120">GDI y los identificadores de usuario creados a través de las API user32 y Gdi32 (de forma predeterminada, cada proceso tiene una cuota de identificadores 10.000)</span><span class="sxs-lookup"><span data-stu-id="86394-120">GDI and USER handles created via User32 and Gdi32 APIs (by default, each process has a quota of 10,000 handles)</span></span>

## <a name="best-practices"></a><span data-ttu-id="86394-121">Prácticas recomendadas</span><span class="sxs-lookup"><span data-stu-id="86394-121">Best Practices</span></span>

<span data-ttu-id="86394-122">La supervisión del consumo de recursos de la aplicación a lo largo del tiempo es el primer paso para detectar y diagnosticar pérdidas de memoria.</span><span class="sxs-lookup"><span data-stu-id="86394-122">Monitoring the resource consumption of your application over time is the first step in detecting and diagnosing memory leaks.</span></span> <span data-ttu-id="86394-123">Use el administrador de tareas de Windows y agregue las siguientes columnas: "tamaño de confirmación", "identificadores", "objetos de usuario" y "objetos GDI".</span><span class="sxs-lookup"><span data-stu-id="86394-123">Use Windows Task Manager and add the following columns: "Commit Size", "Handles", "User Objects", and "GDI Objects".</span></span> <span data-ttu-id="86394-124">Esto le permitirá establecer una línea base para la aplicación y supervisar el uso de los recursos a lo largo del tiempo.</span><span class="sxs-lookup"><span data-stu-id="86394-124">This will allow you to establish a baseline for your application and monitor resource usage over time.</span></span>

![Captura de pantalla que muestra la página "procesos" en el administrador de tareas de Windows.](images/preventingmemoryleaks-windowstaskmanager.gif)

<span data-ttu-id="86394-126">Las siguientes herramientas de Microsoft proporcionan información más detallada y pueden ayudar a detectar y diagnosticar pérdidas para los distintos tipos de asignación de la aplicación:</span><span class="sxs-lookup"><span data-stu-id="86394-126">The following Microsoft tools provide more-detailed information and can help to detect and diagnose leaks for the various allocation types in your application:</span></span>

-   <span data-ttu-id="86394-127">El monitor de rendimiento y el Monitor de recursos forman parte de Windows 7 y pueden supervisar y usar los recursos de gráficos a lo largo del tiempo</span><span class="sxs-lookup"><span data-stu-id="86394-127">Performance Monitor and Resource Monitor are part of Windows 7 and can monitor and graph resource use over time</span></span>
-   <span data-ttu-id="86394-128">La versión más reciente de comprobador de aplicaciones puede diagnosticar pérdidas de montones en Windows 7</span><span class="sxs-lookup"><span data-stu-id="86394-128">The latest version of Application Verifier can diagnose heap leaks on Windows 7</span></span>
-   <span data-ttu-id="86394-129">UMDH, que forma parte de las herramientas de depuración para Windows, analiza las asignaciones de memoria del montón para un proceso determinado y puede ayudar a detectar pérdidas y otros patrones de uso inusuales.</span><span class="sxs-lookup"><span data-stu-id="86394-129">UMDH, which is part of the Debugging Tools for Windows, analyzes the heap memory allocations for a given process and can help find leaks and other unusual usage patterns</span></span>
-   <span data-ttu-id="86394-130">Xperf es una herramienta de análisis de rendimiento sofisticada que admite seguimientos de asignación del montón.</span><span class="sxs-lookup"><span data-stu-id="86394-130">Xperf is a sophisticated performance analysis tool with support for heap allocation traces</span></span>
-   <span data-ttu-id="86394-131">El montón de depuración de CRT realiza un seguimiento de las asignaciones de montón y puede ayudar a crear sus propias características de depuración de montón</span><span class="sxs-lookup"><span data-stu-id="86394-131">CRT Debug Heap tracks heap allocations and can help build your own heap debugging features</span></span>

<span data-ttu-id="86394-132">Ciertas prácticas de codificación y diseño pueden limitar el número de fugas en el código.</span><span class="sxs-lookup"><span data-stu-id="86394-132">Certain coding and design practices can limit the number of leaks in your code.</span></span>

-   <span data-ttu-id="86394-133">Use punteros inteligentes en el código de C++ tanto para las asignaciones de montón como para los recursos de Win32, como los **identificadores** de kernel.</span><span class="sxs-lookup"><span data-stu-id="86394-133">Use smart pointers in C++ code both for heap allocations as well as for Win32 resources like kernel **HANDLE** s.</span></span> <span data-ttu-id="86394-134">La biblioteca estándar de C++ proporciona la clase **auto \_ ptr** para las asignaciones de montón.</span><span class="sxs-lookup"><span data-stu-id="86394-134">The C++ Standard library provides the **auto\_ptr** class for heap allocations.</span></span> <span data-ttu-id="86394-135">En el caso de otros tipos de asignación, deberá escribir sus propias clases.</span><span class="sxs-lookup"><span data-stu-id="86394-135">For other allocation types you will need to write your own classes.</span></span> <span data-ttu-id="86394-136">La biblioteca ATL proporciona un amplio conjunto de clases para la administración automática de recursos tanto para los objetos de montón como para los identificadores de kernel</span><span class="sxs-lookup"><span data-stu-id="86394-136">The ATL library provides a rich set of classes for automatic resource management for both heap objects and kernel handles</span></span>
-   <span data-ttu-id="86394-137">Use características intrínsecas del compilador como **\_ com \_ ptr \_ t** para encapsular los punteros de interfaz com en "punteros inteligentes" y ayudar con el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="86394-137">Use compiler intrinsic features like **\_com\_ptr\_t** to encapsulate your COM interface pointers into "smart pointers" and assist with reference counting.</span></span> <span data-ttu-id="86394-138">Hay clases similares para otros tipos de datos COM: **\_ BSTR \_ t** y **\_ variante \_ t**</span><span class="sxs-lookup"><span data-stu-id="86394-138">There are similar classes for other COM data types: **\_bstr\_t** and **\_variant\_t**</span></span>
-   <span data-ttu-id="86394-139">Supervise el uso de memoria inusual del código .NET.</span><span class="sxs-lookup"><span data-stu-id="86394-139">Monitor your .NET code unusual memory usage.</span></span> <span data-ttu-id="86394-140">El código administrado no es inmune a pérdidas de memoria.</span><span class="sxs-lookup"><span data-stu-id="86394-140">Managed code is not immune to memory leaks.</span></span> <span data-ttu-id="86394-141">Consulte ["seguimiento de pérdidas de memoria administrada"](/archive/blogs/ricom/) sobre cómo buscar pérdidas de GC</span><span class="sxs-lookup"><span data-stu-id="86394-141">See ["Tracking down managed memory leaks"](/archive/blogs/ricom/) on how to find GC leaks</span></span>
-   <span data-ttu-id="86394-142">Tenga en cuenta los patrones de fuga en el código del lado cliente web.</span><span class="sxs-lookup"><span data-stu-id="86394-142">Be aware of leak patterns in web client-side code.</span></span> <span data-ttu-id="86394-143">Las referencias circulares entre objetos COM y motores de scripting como JScript pueden provocar grandes fugas en las aplicaciones Web.</span><span class="sxs-lookup"><span data-stu-id="86394-143">Circular references between COM objects and scripting engines like JScript can cause large leaks in web applications.</span></span> <span data-ttu-id="86394-144">["Comprender y resolver patrones de fugas de Internet Explorer"](/previous-versions/ms976398(v=msdn.10)) contiene más información sobre estos tipos de fugas.</span><span class="sxs-lookup"><span data-stu-id="86394-144">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10)) has more information on these kinds of leaks.</span></span> <span data-ttu-id="86394-145">Puede usar el detector de fugas de memoria de JavaScript para depurar pérdidas de memoria en el código.</span><span class="sxs-lookup"><span data-stu-id="86394-145">You can use the JavaScript Memory Leak Detector to debug memory leaks in your code.</span></span> <span data-ttu-id="86394-146">Aunque Windows Internet Explorer 8, que se distribuye con Windows 7, mitiga la mayoría de estos problemas, los exploradores más antiguos siguen siendo vulnerables a estos errores.</span><span class="sxs-lookup"><span data-stu-id="86394-146">While Windows Internet Explorer 8, which is shipping with Windows 7, mitigates most of these issues, older browsers are still vulnerable to these bugs</span></span>
-   <span data-ttu-id="86394-147">Evite el uso de varias rutas de acceso de salida de una función.</span><span class="sxs-lookup"><span data-stu-id="86394-147">Avoid using multiple exit paths from a function.</span></span> <span data-ttu-id="86394-148">Las asignaciones asignadas a variables en el ámbito de la función deben liberarse en un bloque determinado al final de la función.</span><span class="sxs-lookup"><span data-stu-id="86394-148">Allocations assigned to variables at function scope should be freed in one particular block at the end of the function</span></span>
-   <span data-ttu-id="86394-149">No utilice excepciones en el código sin liberar todas las variables locales en las funciones.</span><span class="sxs-lookup"><span data-stu-id="86394-149">Do not use exceptions in your code without freeing all local variables in functions.</span></span> <span data-ttu-id="86394-150">Si usa excepciones nativas, libere todas las asignaciones dentro del \_ \_ bloque Finally.</span><span class="sxs-lookup"><span data-stu-id="86394-150">If you use native exceptions, free all your allocations inside the \_\_finally block.</span></span> <span data-ttu-id="86394-151">Si usa excepciones de C++, todas las asignaciones de montón y de control deben ajustarse en punteros inteligentes</span><span class="sxs-lookup"><span data-stu-id="86394-151">If you use C++ exceptions, all your heap and handle allocations need to be wrapped in smart pointers</span></span>
-   <span data-ttu-id="86394-152">No descartar o reinicializar un objeto [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) sin llamar a la función [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)</span><span class="sxs-lookup"><span data-stu-id="86394-152">Do not discard or reinitialize a [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) object without calling the [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) function</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="86394-153">Vínculos a recursos</span><span class="sxs-lookup"><span data-stu-id="86394-153">Links to Resources</span></span>

<span data-ttu-id="86394-154">*Patrones de asignación comunes:*</span><span class="sxs-lookup"><span data-stu-id="86394-154">*Common Allocation Patterns:*</span></span>

-   [<span data-ttu-id="86394-155">**Función de asignación del montón**</span><span class="sxs-lookup"><span data-stu-id="86394-155">**Heap Allocation Function**</span></span>](/windows/win32/api/heapapi/nf-heapapi-heapalloc)
-   <span data-ttu-id="86394-156">[**Función de asignación de memoria**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-156">[**Memory Allocation Function**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="86394-157">[**New (operador) (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-157">[**New Operator (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="86394-158">**Función de asignación virtual**</span><span class="sxs-lookup"><span data-stu-id="86394-158">**Virtual Allocation Function**</span></span>](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
-   [<span data-ttu-id="86394-159">Objetos de kernel</span><span class="sxs-lookup"><span data-stu-id="86394-159">Kernel Objects</span></span>](../sysinfo/kernel-objects.md)
-   [<span data-ttu-id="86394-160">Identificadores de objetos GDI</span><span class="sxs-lookup"><span data-stu-id="86394-160">GDI Object Handles</span></span>](../sysinfo/gdi-objects.md)
-   [<span data-ttu-id="86394-161">Identificadores de objeto de interfaz de usuario</span><span class="sxs-lookup"><span data-stu-id="86394-161">User Interface Object Handles</span></span>](../sysinfo/user-objects.md)

<span data-ttu-id="86394-162">*Herramientas de Microsoft:*</span><span class="sxs-lookup"><span data-stu-id="86394-162">*Microsoft Tools:*</span></span>

-   [<span data-ttu-id="86394-163">Comprobador de aplicación</span><span class="sxs-lookup"><span data-stu-id="86394-163">Application Verifier</span></span>](application-verifier.md)
-   [<span data-ttu-id="86394-164">Herramientas de depuración para Windows</span><span class="sxs-lookup"><span data-stu-id="86394-164">Debugging Tools for Windows</span></span>](/windows-hardware/drivers/debugger/)
-   [<span data-ttu-id="86394-165">Montón de volcado de modo de usuario</span><span class="sxs-lookup"><span data-stu-id="86394-165">User-Mode Dump Heap</span></span>](/windows-hardware/drivers/debugger/umdh)
-   [<span data-ttu-id="86394-166">Herramienta de captura, procesamiento y análisis de seguimiento</span><span class="sxs-lookup"><span data-stu-id="86394-166">Trace Capture, Processing, and Analysis Tool</span></span>](https://msdn.microsoft.com/performance/cc825801.aspx)
-   [<span data-ttu-id="86394-167">Montón de depuración de CRT</span><span class="sxs-lookup"><span data-stu-id="86394-167">CRT Debug Heap</span></span>](/visualstudio/debugger/crt-debug-heap-details?view=vs-2015)

<span data-ttu-id="86394-168">*Vínculos adicionales:*</span><span class="sxs-lookup"><span data-stu-id="86394-168">*Additional Links:*</span></span>

-   <span data-ttu-id="86394-169">[**auto- \_ ptr (clase)**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-169">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="86394-170">[Clases de memoria de Active Template Library (ATL)](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-170">[Active Template Library (ATL) Memory Classes](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="86394-171">[**\_com \_ ptr \_ t (objeto)**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-171">[**\_com\_ptr\_t Object**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="86394-172">[**\_BSTR \_ t (clase)**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-172">[**\_bstr\_t Class**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="86394-173">[**\_Variant \_ YT (clase)**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-173">[**\_variant\_yt Class**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="86394-174">"Seguimiento de pérdidas de memoria administrada"</span><span class="sxs-lookup"><span data-stu-id="86394-174">"Tracking down managed memory leaks"</span></span>](/archive/blogs/ricom/)
-   <span data-ttu-id="86394-175">["Descripción y resolución de patrones de fugas de Internet Explorer"](/previous-versions/ms976398(v=msdn.10))</span><span class="sxs-lookup"><span data-stu-id="86394-175">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10))</span></span>
-   [<span data-ttu-id="86394-176">"Detector de fugas de memoria de JavaScript"</span><span class="sxs-lookup"><span data-stu-id="86394-176">"JavaScript Memory Leak Detector"</span></span>](/archive/blogs/gpde/new-javascript-memory-leak-detector-from-our-team)
-   <span data-ttu-id="86394-177">[Mitigación de pérdida de memoria circular (en exploradores):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="86394-177">[Circular Memory Leak Mitigation (in browsers):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span></span>
-   <span data-ttu-id="86394-178">[**try-finally (Instrucción)**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="86394-178">[**try-finally statement**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="86394-179">**Estructura PROPVARIANT**</span><span class="sxs-lookup"><span data-stu-id="86394-179">**PROPVARIANT Structure**</span></span>](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)
-   [<span data-ttu-id="86394-180">**PropVariantClear función)**</span><span class="sxs-lookup"><span data-stu-id="86394-180">**PropVariantClear Function**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)

 

 
