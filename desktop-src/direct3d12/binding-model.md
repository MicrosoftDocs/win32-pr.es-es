---
title: Diferencias en el modelo de enlace de Direct3D 11
description: Una de las decisiones de diseño principales detrás del enlace de DirectX12 es separarlo de otras tareas de administración. Esto pone algunos requisitos en la aplicación para administrar ciertos peligros potenciales.
ms.assetid: 3EE7E9AE-203D-40D4-9F12-4313ED179035
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 43b2785da6497fd4e775d9f88847928e7c4c08e8
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "74103845"
---
# <a name="differences-in-the-binding-model-from-direct3d-11"></a><span data-ttu-id="8732b-104">Diferencias en el modelo de enlace de Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="8732b-104">Differences in the Binding Model from Direct3D 11</span></span>

<span data-ttu-id="8732b-105">Una de las decisiones de diseño principales detrás del enlace de DirectX12 es separarlo de otras tareas de administración.</span><span class="sxs-lookup"><span data-stu-id="8732b-105">One of the main design decisions behind DirectX12 binding is to separate it from other management tasks.</span></span> <span data-ttu-id="8732b-106">Esto pone algunos requisitos en la aplicación para administrar ciertos peligros potenciales.</span><span class="sxs-lookup"><span data-stu-id="8732b-106">This places some requirements on the app to manage certain potential hazards.</span></span>

<span data-ttu-id="8732b-107">La principal ventaja del modelo de enlace D3D12 es que permite que las aplicaciones cambien los enlaces de textura con frecuencia, sin un costo de rendimiento de CPU elevado.</span><span class="sxs-lookup"><span data-stu-id="8732b-107">The main advantage of the D3D12 Binding Model is that it enables apps to change texture bindings frequently, without a huge CPU performance cost.</span></span> <span data-ttu-id="8732b-108">Otras ventajas son que los sombreadores tienen acceso a un gran número de recursos, los sombreadores no necesitan conocer de antemano cuántos recursos se enlazarán y que se puede usar un modelo de enlace de recursos unificado independientemente del hardware o el flujo de contenido de aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="8732b-108">Other benefits are that shaders have access to a very large number of resources, shaders need not know in advance how many resources will be bound, and that a unified resource binding model can be used regardless of hardware or the apps content flow.</span></span>

<span data-ttu-id="8732b-109">Para mejorar el rendimiento, el modelo de enlace no requiere que el sistema realice un seguimiento de los enlaces que una aplicación ha solicitado que use la GPU y existe una integración limpia entre las listas de comandos de enlace y multiproceso.</span><span class="sxs-lookup"><span data-stu-id="8732b-109">To improve performance, the binding model does not require the system to keep track of what bindings an app has requested the GPU to use, and there is a clean integration between binding and multi-threaded command lists.</span></span>

<span data-ttu-id="8732b-110">En las secciones siguientes se enumeran algunos de los cambios en el modelo de enlace de recursos desde D3D11.</span><span class="sxs-lookup"><span data-stu-id="8732b-110">The following sections list some of the changes to the resource binding model since D3D11.</span></span>

-   [<span data-ttu-id="8732b-111">Administración de la residencia de memoria separada del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-111">Memory Residency Management Separated From Binding</span></span>](#memory-residency-management-separated-from-binding)
-   [<span data-ttu-id="8732b-112">Administración de la duración de los objetos separados del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-112">Object Lifetime Management Separated From Binding</span></span>](#object-lifetime-management-separated-from-binding)
-   [<span data-ttu-id="8732b-113">Seguimiento de estado de recursos de controlador separado del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-113">Driver Resource State Tracking Separated From Binding</span></span>](#driver-resource-state-tracking-separated-from-binding)
-   [<span data-ttu-id="8732b-114">Sincronización de memoria asignada de GPU de CPU separada del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-114">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>](#cpu-gpu-mapped-memory-synchronization-separated-from-binding)
-   [<span data-ttu-id="8732b-115">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="8732b-115">Related topics</span></span>](#related-topics)

## <a name="memory-residency-management-separated-from-binding"></a><span data-ttu-id="8732b-116">Administración de la residencia de memoria separada del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-116">Memory Residency Management Separated From Binding</span></span>

<span data-ttu-id="8732b-117">Las aplicaciones tienen un control explícito sobre qué superficies deben estar disponibles para que la GPU pueda usarlos directamente (denominados "residentes").</span><span class="sxs-lookup"><span data-stu-id="8732b-117">Applications have explicit control over which surfaces they need to be available for the GPU to use directly (called being "resident").</span></span> <span data-ttu-id="8732b-118">Por el contrario, pueden aplicar otros Estados en recursos, como dejarlos de forma explícita o dejar que el sistema operativo elija determinadas clases de aplicaciones que requieren una superficie de memoria mínima.</span><span class="sxs-lookup"><span data-stu-id="8732b-118">Conversely, they can apply other states on resources such as explicitly making them not resident, or letting the OS choose for certain classes of applications that require a minimal memory footprint.</span></span> <span data-ttu-id="8732b-119">Lo importante aquí es que la administración de la aplicación de lo que reside está totalmente desacoplada de la forma en que proporciona acceso a los recursos a los sombreadores.</span><span class="sxs-lookup"><span data-stu-id="8732b-119">The important point here is that the application's management of what is resident is completely decoupled from how it gives access to resources to shaders.</span></span>

<span data-ttu-id="8732b-120">La desasociación de la administración de la residencia del mecanismo para dar acceso a los sombreadores reduce el costo del sistema o del hardware para la representación, ya que el sistema operativo no tiene que inspeccionar constantemente el estado de enlace local para saber qué debe hacer residente.</span><span class="sxs-lookup"><span data-stu-id="8732b-120">The decoupling of residency management from the mechanism for giving shaders access to resources reduces the system/hardware cost for rendering since the OS doesn't have to constantly inspect the local binding state to know what to make resident.</span></span> <span data-ttu-id="8732b-121">Además, ya no es necesario que los sombreadores sepan a qué superficies exactas deben hacer referencia, siempre que el conjunto completo de recursos posiblemente accesibles se haya puesto a fin de antemano.</span><span class="sxs-lookup"><span data-stu-id="8732b-121">Furthermore, shaders no longer have to know which exact surfaces they may need to reference, as long as the entire set of possibly accessible resources has been made resident ahead of time.</span></span>

## <a name="object-lifetime-management-separated-from-binding"></a><span data-ttu-id="8732b-122">Administración de la duración de los objetos separados del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-122">Object Lifetime Management Separated From Binding</span></span>

<span data-ttu-id="8732b-123">A diferencia de las API anteriores, el sistema ya no realiza un seguimiento de los enlaces de recursos a la canalización.</span><span class="sxs-lookup"><span data-stu-id="8732b-123">Unlike previous APIs, the system no longer tracks bindings of resources to the pipeline.</span></span> <span data-ttu-id="8732b-124">Esto se usa para permitir que el sistema mantenga activos los recursos que la aplicación ha liberado porque todavía se hace referencia a ellos mediante el trabajo de GPU pendiente.</span><span class="sxs-lookup"><span data-stu-id="8732b-124">This used to enable the system to keep alive resources that the application has released because they are still referenced by outstanding GPU work.</span></span>

<span data-ttu-id="8732b-125">Antes de liberar cualquier recurso, como una textura, las aplicaciones deben asegurarse de que la GPU ha completado la referencia.</span><span class="sxs-lookup"><span data-stu-id="8732b-125">Before freeing any resource, such as a texture, applications now must make sure the GPU has completed referencing it.</span></span> <span data-ttu-id="8732b-126">Esto significa que antes de que una aplicación pueda liberar de forma segura un recurso, la GPU debe haber completado la ejecución de la lista de comandos que hace referencia al recurso.</span><span class="sxs-lookup"><span data-stu-id="8732b-126">This means before an application can safely free a resource the GPU must have completed execution of the command list referencing the resource.</span></span>

## <a name="driver-resource-state-tracking-separated-from-binding"></a><span data-ttu-id="8732b-127">Seguimiento de estado de recursos de controlador separado del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-127">Driver Resource State Tracking Separated From Binding</span></span>

<span data-ttu-id="8732b-128">El sistema ya no inspecciona los enlaces de recursos para comprender cuándo se han producido transiciones de recursos que requieren un controlador o trabajo de GPU adicional.</span><span class="sxs-lookup"><span data-stu-id="8732b-128">The system no longer inspects resource bindings to understand when resource transitions have occurred which require additional driver or GPU work.</span></span> <span data-ttu-id="8732b-129">Un ejemplo común para muchas GPU y controladores es tener que saber cuándo una superficie realiza una transición de usarse como vista de destino de representación (RTV) al sombreador Vista de recursos (SRV).</span><span class="sxs-lookup"><span data-stu-id="8732b-129">A common example for many GPUs and drivers is having to know when a surface transitions from being used as a Render Target View (RTV) to Shader Resource View (SRV).</span></span> <span data-ttu-id="8732b-130">Las propias aplicaciones deben identificar ahora Cuándo se están produciendo las transiciones de recursos que el sistema puede interesar a través de API dedicadas.</span><span class="sxs-lookup"><span data-stu-id="8732b-130">Applications themselves must now identify when any resource transitions that the system might care about are happening via dedicated APIs.</span></span>

## <a name="cpu-gpu-mapped-memory-synchronization-separated-from-binding"></a><span data-ttu-id="8732b-131">Sincronización de memoria asignada de GPU de CPU separada del enlace</span><span class="sxs-lookup"><span data-stu-id="8732b-131">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>

<span data-ttu-id="8732b-132">El sistema ya no inspecciona los enlaces de recursos para saber si es necesario retrasar la representación porque depende de un recurso que se ha asignado para el acceso a la CPU, pero que aún no se ha desasignado.</span><span class="sxs-lookup"><span data-stu-id="8732b-132">The system no longer inspects resource bindings to understand if rendering needs to be delayed because it depends on a resource that has been mapped for CPU access but has not been unmapped yet.</span></span> <span data-ttu-id="8732b-133">Las aplicaciones ahora tienen la responsabilidad de sincronizar los accesos de memoria de la GPU y la CPU.</span><span class="sxs-lookup"><span data-stu-id="8732b-133">Applications now have the responsibility to synchronize CPU and GPU memory accesses.</span></span> <span data-ttu-id="8732b-134">Para ayudar con esto, el sistema proporciona mecanismos para que la aplicación solicite la suspensión de un subproceso de CPU hasta que el trabajo se complete.</span><span class="sxs-lookup"><span data-stu-id="8732b-134">To help with this, the system provides mechanisms for the application to request the sleeping of a CPU thread until work completes.</span></span> <span data-ttu-id="8732b-135">El sondeo también podría realizarse, pero puede ser menos eficaz.</span><span class="sxs-lookup"><span data-stu-id="8732b-135">Polling could also be done, but can be less efficient.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8732b-136">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="8732b-136">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8732b-137">Enlace de recursos</span><span class="sxs-lookup"><span data-stu-id="8732b-137">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




