---
title: Administración de memoria de código auxiliar de servidor
description: Administración de memoria de código auxiliar de servidor
ms.assetid: 99e3ee56-5adb-4b25-bcf2-316d1bbdbdba
keywords:
- Administración de memoria de código auxiliar de servidor
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6e052df6da999e5371ac498a1d39852b4be2b5e
ms.sourcegitcommit: ae73f4dd3cf5a3c6a1ea7d191ca32a5b01f6686b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/08/2020
ms.locfileid: "103904871"
---
# <a name="server-stub-memory-management"></a><span data-ttu-id="b26ad-104">Administración de memoria de código auxiliar de servidor</span><span class="sxs-lookup"><span data-stu-id="b26ad-104">Server Stub Memory Management</span></span>

## <a name="an-introduction-to-server-stub-memory-management"></a><span data-ttu-id="b26ad-105">Introducción a la administración de memoria de Server-Stub</span><span class="sxs-lookup"><span data-stu-id="b26ad-105">An Introduction to Server-Stub Memory Management</span></span>

<span data-ttu-id="b26ad-106">Los códigos auxiliares generados por MIDL actúan como la interfaz entre un proceso de cliente y un proceso de servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-106">MIDL-generated stubs act as the interface between a client process and a server process.</span></span> <span data-ttu-id="b26ad-107">Un código auxiliar de cliente calcula las referencias de todos los datos pasados a los parámetros marcados con el atributo [**\[ in \]**](../midl/in.md) y los envía al código auxiliar del servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-107">A client stub marshals all data passed to parameters marked with the [**\[in\]**](../midl/in.md) attribute, and sends it to the server stub.</span></span> <span data-ttu-id="b26ad-108">El código auxiliar del servidor, al recibir estos datos, reconstruye la pila de llamadas y, a continuación, ejecuta la función de servidor implementada por el usuario correspondiente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-108">The server stub, upon receiving this data, reconstructs the call stack, and then executes the corresponding user-implemented server function.</span></span> <span data-ttu-id="b26ad-109">El código auxiliar del servidor también calcula las referencias de los datos de parámetro marcados con el atributo [**\[ out \]**](../midl/out-idl.md) y lo devuelve a la aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-109">The server stub also marshals the parameter data marked with the [**\[out\]**](../midl/out-idl.md) attribute and returns it to the client application.</span></span>

<span data-ttu-id="b26ad-110">El formato de datos de serialización de bits de 32 usado por MSRPC es una versión compatible de la sintaxis de transferencia de representación de datos de red (NDR).</span><span class="sxs-lookup"><span data-stu-id="b26ad-110">The 32-bit marshaled data format used by MSRPC is a compliant version of the Network Data Representation (NDR) transfer syntax.</span></span> <span data-ttu-id="b26ad-111">Para obtener más información acerca de este formato, vea [el sitio web de Open Group](https://www.opengroup.org/).</span><span class="sxs-lookup"><span data-stu-id="b26ad-111">For more information about this format, see [The Open Group website](https://www.opengroup.org/).</span></span> <span data-ttu-id="b26ad-112">En el caso de las plataformas de 64 bits, se puede usar una extensión de Microsoft 64-bit a la sintaxis de transferencia de NDR denominada NDR64 para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="b26ad-112">For 64-bit platforms, a Microsoft 64-bit extension to NDR transfer syntax called NDR64 can be used for better performance.</span></span>

## <a name="unmarshaling-inbound-data"></a><span data-ttu-id="b26ad-113">Desserialización de datos de entrada</span><span class="sxs-lookup"><span data-stu-id="b26ad-113">Unmarshaling Inbound Data</span></span>

<span data-ttu-id="b26ad-114">En MSRPC, el código auxiliar del cliente calcula las referencias de todos los datos de parámetro etiquetados como [**\[ en \]**](../midl/in.md) en un búfer continuo para la transmisión al código auxiliar del servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-114">In MSRPC, the client stub marshals all of the parameter data tagged as [**\[in\]**](../midl/in.md) in one continuous buffer for transmission to the server stub.</span></span> <span data-ttu-id="b26ad-115">Del mismo modo, el código auxiliar del servidor calcula las referencias de todos los datos marcados con el atributo [**\[ out \]**](../midl/out-idl.md) en un búfer continuo para volver al código auxiliar del cliente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-115">Likewise, the server stub marshals all data marked with the [**\[out\]**](../midl/out-idl.md) attribute in a continuous buffer for return to the client stub.</span></span> <span data-ttu-id="b26ad-116">Mientras que la capa del Protocolo de red bajo RPC puede fragmentar y paquetes el búfer para la transmisión, la fragmentación es transparente para el código auxiliar de RPC.</span><span class="sxs-lookup"><span data-stu-id="b26ad-116">While the network protocol layer beneath RPC can fragment and packetize the buffer for transmission, the fragmentation is transparent to the RPC stubs.</span></span>

<span data-ttu-id="b26ad-117">La asignación de memoria para crear el marco de llamada del servidor puede ser una operación costosa.</span><span class="sxs-lookup"><span data-stu-id="b26ad-117">Memory allocation for creating the server call frame can be an expensive operation.</span></span> <span data-ttu-id="b26ad-118">El código auxiliar del servidor intentará minimizar el uso de memoria innecesario cuando sea posible y se supone que la rutina del servidor no liberará ni reasignará los datos marcados con los atributos de **\[ salida \]** [**\[ in \]**](../midl/in.md) o in.</span><span class="sxs-lookup"><span data-stu-id="b26ad-118">The server stub will attempt to minimize unnecessary memory usage when possible, and it is assumed that the server routine will not free or reallocate data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="b26ad-119">El código auxiliar del servidor intenta reutilizar los datos en el búfer siempre que sea posible para evitar la duplicación innecesaria.</span><span class="sxs-lookup"><span data-stu-id="b26ad-119">The server stub attempts to reuse data in the buffer whenever possible to avoid unnecessary duplication.</span></span> <span data-ttu-id="b26ad-120">La regla general es que si el formato de los datos de cálculo de referencias es el mismo que el formato de memoria, RPC usará punteros a los datos de cálculo de referencias en lugar de asignar memoria adicional para datos con el mismo formato.</span><span class="sxs-lookup"><span data-stu-id="b26ad-120">The general rule is that if the marshaled data format is the same as the memory format, RPC will use pointers to the marshalled data instead of allocating additional memory for identically formatted data.</span></span>

<span data-ttu-id="b26ad-121">Por ejemplo, la siguiente llamada RPC se define con una estructura cuyo formato de serialización es idéntico al formato en memoria.</span><span class="sxs-lookup"><span data-stu-id="b26ad-121">For example, the following RPC call is defined with a structure whose marshaled format is identical to its in-memory format.</span></span>

``` syntax
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```

<span data-ttu-id="b26ad-122">En este caso, RPC no asigna memoria adicional para los datos a los que hace referencia *plInStructure*; en su lugar, simplemente pasa el puntero a los datos de cálculo de referencias a la implementación de la función del servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-122">In this case, RPC does not allocate additional memory for the data referenced by *plInStructure*; rather, it simply passes the pointer to the marshaled data to the server-side function implementation.</span></span> <span data-ttu-id="b26ad-123">El código auxiliar del servidor RPC comprueba el búfer durante el proceso de desserialización si el código auxiliar se compila con la marca "-robusta" (que es un valor predeterminado en la versión nmost reciente del compilador de MIDL).</span><span class="sxs-lookup"><span data-stu-id="b26ad-123">The RPC server stub verifies the buffer during the unmarshaling process if the stub is compiled using the "-robust" flag (which is a default setting in the nmost recent version of the MIDL compiler).</span></span> <span data-ttu-id="b26ad-124">RPC garantiza que los datos que se pasan a la implementación de la función del servidor son válidos.</span><span class="sxs-lookup"><span data-stu-id="b26ad-124">RPC guarantees that the data passed to the server-side function implementation is valid.</span></span>

<span data-ttu-id="b26ad-125">Tenga en cuenta que la memoria se asigna para *plOutStructure*, ya que no se pasa ningún dato al servidor para ella.</span><span class="sxs-lookup"><span data-stu-id="b26ad-125">Be aware that memory is allocated for *plOutStructure*, since no data is passed to the server for it.</span></span>

## <a name="memory-allocation-for-inbound-data"></a><span data-ttu-id="b26ad-126">Asignación de memoria para los datos de entrada</span><span class="sxs-lookup"><span data-stu-id="b26ad-126">Memory Allocation for Inbound Data</span></span>

<span data-ttu-id="b26ad-127">Pueden surgir casos en los que el código auxiliar del servidor asigna memoria a los datos de parámetros marcados con los atributos [**\[ in \]**](../midl/in.md) o **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="b26ad-127">Cases can arise where the server stub allocates memory for parameter data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="b26ad-128">Esto se produce cuando el formato de datos con cálculo de referencias difiere del formato de memoria o cuando las estructuras que componen los datos serializados son suficientemente complejas y el código auxiliar del servidor RPC debe leerlos de forma atómica.</span><span class="sxs-lookup"><span data-stu-id="b26ad-128">This occurs when the marshaled data format differs from the memory format, or when the structures that comprise the marshaled data are sufficient complex and must be read atomically by the RPC server stub.</span></span> <span data-ttu-id="b26ad-129">A continuación se enumeran varios casos comunes en los que se debe asignar memoria para los datos recibidos por el código auxiliar del servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-129">Listed below are several common cases when memory must be allocated for data received by the server stub.</span></span>

-   <span data-ttu-id="b26ad-130">Los datos son una matriz variable o una matriz variable compatible.</span><span class="sxs-lookup"><span data-stu-id="b26ad-130">The data is a varying array or a conformant varying array.</span></span> <span data-ttu-id="b26ad-131">Son matrices (o punteros a matrices) que tienen la [**\[ longitud \_ () \]**](../midl/length-is.md) o el [**\[ primer atributo \_ is () \]**](../midl/first-is.md) establecido en ellos.</span><span class="sxs-lookup"><span data-stu-id="b26ad-131">These are arrays (or pointers to arrays) that have the [**\[length\_is()\]**](../midl/length-is.md) or [**\[first\_is()\]**](../midl/first-is.md) attribute set on them.</span></span> <span data-ttu-id="b26ad-132">En NDR, solo se calculan las referencias de los primeros elementos de estas matrices y se transmiten.</span><span class="sxs-lookup"><span data-stu-id="b26ad-132">In NDR, only the first element of these arrays are marshaled and transmitted.</span></span> <span data-ttu-id="b26ad-133">Por ejemplo, en el fragmento de código siguiente, los datos pasados en el parámetro *PV* tendrán la memoria asignada.</span><span class="sxs-lookup"><span data-stu-id="b26ad-133">For example, in the code snippet below, the data passed in the parameter *pv* will have memory allocated for it.</span></span>

    ``` syntax
    void RpcFunction
    (
        [in] long size,
        [in, out] long *pLength,
        [in, out, size_is(size), length_is(*pLength)] long *pv
    );
    ```

-   <span data-ttu-id="b26ad-134">Los datos son una cadena de tamaño o una cadena no compatible.</span><span class="sxs-lookup"><span data-stu-id="b26ad-134">The data is a sized string or non-conformant string.</span></span> <span data-ttu-id="b26ad-135">Estas cadenas suelen ser punteros a datos de caracteres etiquetados con el atributo [**\[ size \_ es () \]**](../midl/size-is.md) .</span><span class="sxs-lookup"><span data-stu-id="b26ad-135">These strings are usually pointers to character data tagged with the [**\[size\_is()\]**](../midl/size-is.md) attribute.</span></span> <span data-ttu-id="b26ad-136">En el ejemplo siguiente, la cadena que se pasa a la función del lado servidor **SizedString** tendrá asignada la memoria, mientras que la cadena que se pasa a la función **NormalString** se volverá a usar.</span><span class="sxs-lookup"><span data-stu-id="b26ad-136">In the example below, the string passed to the **SizedString** server-side function will have memory allocated, whereas the string passed to the **NormalString** function will be reused.</span></span>

    ``` syntax
    void SizedString
    (
        [in] long size,
        [in, size_is(size), string] char *str
    );

    void NormalString
    (
        [in, string] char str
    );
    ```

-   <span data-ttu-id="b26ad-137">Los datos son un tipo simple cuyo tamaño de memoria difiere del tamaño de las referencias calculadas, como **enum16** y **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-137">The data is a simple type whose memory size differs from its marshaled size, such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="b26ad-138">Los datos se definen mediante una estructura cuya alineación de memoria es menor que la alineación natural, contiene cualquiera de los tipos de datos anteriores o tiene un relleno de bytes final.</span><span class="sxs-lookup"><span data-stu-id="b26ad-138">The data is defined by a structure whose memory alignment is smaller than the natural alignment, contains any of the above data types, or has trailing byte padding.</span></span> <span data-ttu-id="b26ad-139">Por ejemplo, la estructura de datos compleja siguiente tiene una alineación forzada de 2 bytes y tiene relleno al final.</span><span class="sxs-lookup"><span data-stu-id="b26ad-139">For example, the following complex data structure has forced 2-byte alignment and has padding at the end.</span></span>

    ``` syntax
#pragma pack(2)
    typedef struct ComplexPackedStructure
    {
        char c;  
        long l;   // alignment is forced at the second byte
        char c2;  // there will be a trailing one-byte pad to keep 2-byte alignment
    }
    ```

-   <span data-ttu-id="b26ad-140">Los datos contienen una estructura en la que se deben calcular las referencias de campo por campo.</span><span class="sxs-lookup"><span data-stu-id="b26ad-140">The data contains a structure that must be marshaled field by field.</span></span> <span data-ttu-id="b26ad-141">Estos campos incluyen punteros de interfaz definidos en interfaces DCOM; punteros omitidos; valores enteros establecidos con el atributo [**\[ de \] intervalo**](../midl/range.md) ; elementos de matrices definidas con las [**\[ \_ \] referencias de conexión**](../midl/wire-marshal.md), [**\[ \_ serialización \] de usuario**](../midl/user-marshal.md), [**\[ transmitir \_ como \]**](../midl/transmit-as.md) y [**\[ representan \_ como \]**](../midl/represent-as.md) atributos; y estructuras de datos complejos incrustados.</span><span class="sxs-lookup"><span data-stu-id="b26ad-141">These fields include interface pointers defined in DCOM interfaces; ignored pointers; integer values set with the [**\[range\]**](../midl/range.md) attribute; elements of arrays defined with the [**\[wire\_marshal\]**](../midl/wire-marshal.md), [**\[user\_marshal\]**](../midl/user-marshal.md), [**\[transmit\_as\]**](../midl/transmit-as.md) and [**\[represent\_as\]**](../midl/represent-as.md) attributes; and embedded complex data structures.</span></span>
-   <span data-ttu-id="b26ad-142">Los datos contienen una Unión, una estructura que contiene una Unión o una matriz de uniones.</span><span class="sxs-lookup"><span data-stu-id="b26ad-142">The data contains a union, a structure containing a union, or an array of unions.</span></span> <span data-ttu-id="b26ad-143">Solo se calculan las referencias de la rama específica de la Unión en la conexión.</span><span class="sxs-lookup"><span data-stu-id="b26ad-143">Only the specific branch of the union is marshaled on the wire.</span></span>
-   <span data-ttu-id="b26ad-144">Los datos contienen una estructura con una matriz compatible multidimensional que tiene al menos una dimensión no fija.</span><span class="sxs-lookup"><span data-stu-id="b26ad-144">The data contains a structure with a multidimensional conformant array that has at least one non-fixed dimension.</span></span>
-   <span data-ttu-id="b26ad-145">Los datos contienen una matriz de estructuras complejas.</span><span class="sxs-lookup"><span data-stu-id="b26ad-145">The data contains an array of complex structures.</span></span>
-   <span data-ttu-id="b26ad-146">Los datos contienen una matriz de tipos de datos simples, como **enum16** y **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-146">The data contains an array of simple data types such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="b26ad-147">Los datos contienen una matriz de punteros Ref y de interfaz.</span><span class="sxs-lookup"><span data-stu-id="b26ad-147">The data contains an array of ref and interface pointers.</span></span>
-   <span data-ttu-id="b26ad-148">Los datos tienen un atributo [**\[ Force \_ allocate \]**](../midl/force-allocate.md) aplicado a un puntero.</span><span class="sxs-lookup"><span data-stu-id="b26ad-148">The data has a [**\[force\_allocate\]**](../midl/force-allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="b26ad-149">Los datos tienen un atributo [**\[ allocate (todos los \_ nodos) \]**](../midl/allocate.md) aplicado a un puntero.</span><span class="sxs-lookup"><span data-stu-id="b26ad-149">The data has a [**\[allocate(all\_nodes)\]**](../midl/allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="b26ad-150">Los datos tienen un atributo de [**\[ \_ recuento \] de bytes**](../midl/byte-count.md) aplicado a un puntero.</span><span class="sxs-lookup"><span data-stu-id="b26ad-150">The data has a [**\[byte\_count\]**](../midl/byte-count.md) attribute applied to a pointer.</span></span>

## <a name="64-bit-data-and-ndr64-transfer-syntax"></a><span data-ttu-id="b26ad-151">Sintaxis de transferencia de datos y NDR64 de 64 bits</span><span class="sxs-lookup"><span data-stu-id="b26ad-151">64-bit Data and NDR64 Transfer Syntax</span></span>

<span data-ttu-id="b26ad-152">Como se mencionó anteriormente, se calculan las referencias de los datos de 64 bits usando una sintaxis de transferencia de 64 bits específica denominada NDR64.</span><span class="sxs-lookup"><span data-stu-id="b26ad-152">As mentioned previously, 64-bit data is marshalled using a specific 64-bit transfer syntax called NDR64.</span></span> <span data-ttu-id="b26ad-153">Esta sintaxis de transferencia se desarrolló para abordar el problema específico que se produce cuando se serializan los punteros en un NDR de 32 bits y se transmiten a un código auxiliar de servidor en una plataforma de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="b26ad-153">This transfer syntax was developed to address the specific issue that arises when pointers are marshaled under 32-bit NDR and transmitted to a server-stub on a 64-bit platform.</span></span> <span data-ttu-id="b26ad-154">En este caso, un puntero de datos de 32 bits serializado no coincide con una de 64 bits y la asignación de memoria se realizará invariablemente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-154">In this case, a marshaled 32-bit data pointer does not match a 64-bit one, and memory allocation will invariably occur.</span></span> <span data-ttu-id="b26ad-155">Para crear un comportamiento más coherente en las plataformas de 64 bits, Microsoft desarrolló una nueva sintaxis de transferencia denominada NDR64.</span><span class="sxs-lookup"><span data-stu-id="b26ad-155">To create a more consistent behavior on 64-bit platforms, Microsoft developed a new transfer syntax called NDR64.</span></span>

<span data-ttu-id="b26ad-156">A continuación se muestra un ejemplo que ilustra este problema:</span><span class="sxs-lookup"><span data-stu-id="b26ad-156">An example illustrating this problem is as follows:</span></span>


```C++
typedef struct PtrStruct
{
  long l;
  long *pl;
}
```



<span data-ttu-id="b26ad-157">Esta estructura, cuando se calculan las referencias, la reutilizará el código auxiliar del servidor en un sistema de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="b26ad-157">This structure, when marshaled, will be reused by the server stub on a 32-bit system.</span></span> <span data-ttu-id="b26ad-158">Sin embargo, si el código auxiliar del servidor reside en un sistema de 64 bits, los datos de serialización de NDR tienen una longitud de 4 bytes, pero el tamaño de memoria necesario será 8.</span><span class="sxs-lookup"><span data-stu-id="b26ad-158">However, if the server stub resides on a 64-bit system, the NDR-marshaled data is 4 bytes in length, but the required memory size will be 8.</span></span> <span data-ttu-id="b26ad-159">Como resultado, se fuerza la asignación de memoria y la reutilización del búfer rara vez se producirá.</span><span class="sxs-lookup"><span data-stu-id="b26ad-159">As a result, memory allocation is forced, and buffer reuse will rarely occur.</span></span> <span data-ttu-id="b26ad-160">NDR64 soluciona este problema, ya que hace que el tamaño de las referencias de un puntero sea de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="b26ad-160">NDR64 addresses this problem by making the marshaled size of a pointer 64-bit.</span></span>

<span data-ttu-id="b26ad-161">A diferencia del NDR de 32 bits, tyes de datos simples, como **enum16** y **\_ \_ int3264** , no convierten una estructura o una matriz compleja en NDR64.</span><span class="sxs-lookup"><span data-stu-id="b26ad-161">In contrast with 32-bit NDR, simple data tyes such as **enum16** and **\_\_int3264** do not make a structure or array complex under NDR64.</span></span> <span data-ttu-id="b26ad-162">Del mismo modo, los valores de relleno finales no hacen que una estructura sea compleja.</span><span class="sxs-lookup"><span data-stu-id="b26ad-162">Likewise, trailing pad values do not make a structure complex.</span></span> <span data-ttu-id="b26ad-163">Los punteros de interfaz se tratan como punteros únicos en el nivel superior; como resultado, las estructuras y matrices que contienen punteros de interfaz no se consideran complejas y no requieren una asignación de memoria específica para su uso.</span><span class="sxs-lookup"><span data-stu-id="b26ad-163">Interface pointers are treated as unique pointers at the top level; as a result, structures and arrays containing interface pointers are not considered complex and will not require specific memory allocation for their use.</span></span>

## <a name="initializing-outbound-data"></a><span data-ttu-id="b26ad-164">Inicializar datos salientes</span><span class="sxs-lookup"><span data-stu-id="b26ad-164">Initializing Outbound Data</span></span>

<span data-ttu-id="b26ad-165">Una vez que se han desordenado todos los datos de entrada, el código auxiliar del servidor debe inicializar los punteros solo salientes marcados con el atributo [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="b26ad-165">After all of the inbound data has been unmarshalled, the server stub needs to initialize the outbound-only pointers marked with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span>


```C++
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```



<span data-ttu-id="b26ad-166">En la llamada anterior, el código auxiliar del servidor debe inicializar *plOutStructure* porque no estaba presente en los datos de cálculo de referencias y es un puntero de [**\[ referencia \]**](../midl/ref.md) implícito que debe estar disponible para la implementación de la función de servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-166">In the above call, the server stub must initialize *plOutStructure* because it was not present in the marshaled data, and it is an implied [**\[ref\]**](../midl/ref.md) pointer that must be made available to the server function implementation.</span></span> <span data-ttu-id="b26ad-167">El código auxiliar del servidor RPC inicializa y pone en cero los punteros de solo referencia de nivel superior con el atributo [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="b26ad-167">The RPC server stub initializes and zeroes out any top-level reference-only pointers with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span> <span data-ttu-id="b26ad-168">Los punteros de referencia que se encuentran debajo de él también se inicializan de forma recursiva. **\[ \]**</span><span class="sxs-lookup"><span data-stu-id="b26ad-168">Any **\[out\]** reference pointers beneath it are recursively initialized as well.</span></span> <span data-ttu-id="b26ad-169">La recursividad se detiene en cualquier puntero con los atributos [**\[ Unique \]**](../midl/unique.md) o [**\[ ptr \]**](../midl/ptr.md) establecidos.</span><span class="sxs-lookup"><span data-stu-id="b26ad-169">The recursion stops at any pointers with the [**\[unique\]**](../midl/unique.md) or [**\[ptr\]**](../midl/ptr.md) attributes set on them.</span></span>

<span data-ttu-id="b26ad-170">La implementación de la función de servidor no puede modificar directamente los valores de puntero de nivel superior y, por tanto, no puede reasignarlos.</span><span class="sxs-lookup"><span data-stu-id="b26ad-170">The server function implementation cannot directly alter top-level pointer values, and thus cannot reallocate them.</span></span> <span data-ttu-id="b26ad-171">Por ejemplo, en la implementación de **ProcessRpcStructure** anterior, el código siguiente no es válido:</span><span class="sxs-lookup"><span data-stu-id="b26ad-171">For example, in the implementation of **ProcessRpcStructure** above, the following code is invalid:</span></span>


```C++
void ProcessRpcStructure(RpcStructure *plInStructure, rpcStructure *plOutStructure)
{
    plOutStructure = MIDL_user_allocate(sizeof(RpcStructure));
    Process(plOutStructure);
}
```



<span data-ttu-id="b26ad-172">*plOutStructure* es un valor de pila y su cambio no se propaga de nuevo a RPC.</span><span class="sxs-lookup"><span data-stu-id="b26ad-172">*plOutStructure* is a stack value and its change is not propagated back to RPC.</span></span> <span data-ttu-id="b26ad-173">La implementación de la función de servidor puede intentar evitar la asignación al intentar liberar *plOutStructure*, lo que puede provocar daños en la memoria.</span><span class="sxs-lookup"><span data-stu-id="b26ad-173">The server function implementation can attempt to avoid allocation by attempting to free *plOutStructure*, which may result in memory corruption.</span></span> <span data-ttu-id="b26ad-174">El código auxiliar del servidor asignará espacio para el puntero de nivel superior en memoria (en el caso de puntero a puntero) y una estructura simple de nivel superior cuyo tamaño en la pila sea menor de lo esperado.</span><span class="sxs-lookup"><span data-stu-id="b26ad-174">The server stub will then allocate space for the top-level pointer in memory (in the pointer-to-pointer case) and a top-level simple structure whose size on the stack is smaller than expected.</span></span>

<span data-ttu-id="b26ad-175">En determinadas circunstancias, el cliente puede especificar el tamaño de asignación de memoria del lado del servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-175">The client can, under certain circumstances, specify the memory allocation size of the server side.</span></span> <span data-ttu-id="b26ad-176">En el ejemplo siguiente, el cliente especifica el tamaño de los datos salientes en el parámetro de *tamaño* de entrada.</span><span class="sxs-lookup"><span data-stu-id="b26ad-176">In the following example, the client specifies the size of the outbound data in the inbound *size* parameter.</span></span>

``` syntax
void VariableSizeData
(
    [in] long size,
    [out, size_is(size)] char *pv
);
```

<span data-ttu-id="b26ad-177">Después de desreferenciar los datos de entrada, incluido el *tamaño*, el código auxiliar del servidor asigna un búfer para *PV* con un tamaño de "sizeof (Char) \* size".</span><span class="sxs-lookup"><span data-stu-id="b26ad-177">After unmarshalling the inbound data, including *size*, the server stub allocates a buffer for *pv* with a size of "sizeof(char)\*size".</span></span> <span data-ttu-id="b26ad-178">Una vez asignado el espacio, el código auxiliar del servidor pone en cero el búfer.</span><span class="sxs-lookup"><span data-stu-id="b26ad-178">After the space has been allocated, the server stub zeroes out the buffer.</span></span> <span data-ttu-id="b26ad-179">Tenga en cuenta que, en este caso concreto, el código auxiliar asigna la memoria con el **usuario de MIDL \_ \_ allocate ()**, ya que el tamaño del búfer se determina en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="b26ad-179">Note that in this particular case, the stub allocates the memory with **MIDL\_user\_allocate()**, since the size of the buffer is determined at runtime.</span></span>

<span data-ttu-id="b26ad-180">Tenga en cuenta que en el caso de las interfaces DCOM, es posible que los códigos auxiliares generados por MIDL no participen en absoluto si el cliente y el servidor comparten el mismo apartamento COM, o si se implementa **ICallFrame** .</span><span class="sxs-lookup"><span data-stu-id="b26ad-180">Be aware that in the case of DCOM interfaces, MIDL-generated stubs may not be involved at all if the client and server share the same COM apartment, or if **ICallFrame** is implemented.</span></span> <span data-ttu-id="b26ad-181">En este caso, el servidor no puede depender del comportamiento de asignación y debe comprobar de forma independiente la memoria de tamaño del cliente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-181">In this case, the server cannot depend on the allocation behavior, and needs to independently verify client-sized memory.</span></span>

## <a name="server-side-function-implementations-and-outbound-data-marshaling"></a><span data-ttu-id="b26ad-182">Implementaciones de funciones de servidor y serialización de datos de salida</span><span class="sxs-lookup"><span data-stu-id="b26ad-182">Server-side Function Implementations and Outbound Data Marshaling</span></span>

<span data-ttu-id="b26ad-183">Inmediatamente después de la desserialización en los datos de entrada y la inicialización de la memoria asignada que contiene los datos de salida, el código auxiliar del servidor RPC ejecuta la implementación del lado servidor de la función a la que llama el cliente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-183">Immediately subsequent to the unmarshalling on inbound data and the initialization of the memory allocated to contain outbound data, the RPC server stub executes the server-side implementation of the function called by the client.</span></span> <span data-ttu-id="b26ad-184">En este momento, el servidor puede modificar los datos marcados específicamente con el atributo **\[ in \] , out** y puede rellenar la memoria asignada para los datos de solo salida (los datos etiquetados con [**\[ out \]**](../midl/out-idl.md)).</span><span class="sxs-lookup"><span data-stu-id="b26ad-184">At this time, the server can modify the data specifically marked with the **\[in, out\]** attribute, and it can populate the memory allocated for outbound-only data (the data tagged with [**\[out\]**](../midl/out-idl.md)).</span></span>

<span data-ttu-id="b26ad-185">Las reglas generales para la manipulación de datos de parámetros de cálculo de referencias son simples: el servidor solo puede asignar una nueva memoria o modificar la memoria asignada específicamente por el código auxiliar del servidor.</span><span class="sxs-lookup"><span data-stu-id="b26ad-185">The general rules for the manipulation of marshalled parameter data are simple: the server can only allocate new memory or modify the memory specifically allocated by the server stub.</span></span> <span data-ttu-id="b26ad-186">La reasignación o liberación de la memoria existente para los datos puede tener un impacto negativo en los resultados y en el rendimiento de la llamada de función, y puede ser muy difícil de depurar.</span><span class="sxs-lookup"><span data-stu-id="b26ad-186">Reallocating or releasing existing memory for data can have a negative impact on the results and performance of the function call, and can be very difficult to debug.</span></span>

<span data-ttu-id="b26ad-187">Lógicamente, el servidor RPC reside en un espacio de direcciones diferente del cliente y, por lo general, se puede suponer que no comparten memoria.</span><span class="sxs-lookup"><span data-stu-id="b26ad-187">Logically, the RPC server lives in a different address space than the client, and it can generally be assumed that they do not share memory.</span></span> <span data-ttu-id="b26ad-188">Como resultado, es seguro que la implementación de la función de servidor use los datos marcados con el atributo [**\[ in \]**](../midl/in.md) como memoria "temporal" sin afectar a las direcciones de memoria del cliente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-188">As a result, it is safe for the server function implementation to use the data marked with the [**\[in\]**](../midl/in.md) attribute as "scratch" memory without affecting the client memory addresses.</span></span> <span data-ttu-id="b26ad-189">Dicho esto, el servidor no debería intentar volver a asignar **\[ \] o liberar datos** , y dejar el control de esos espacios al propio código auxiliar del servidor RPC.</span><span class="sxs-lookup"><span data-stu-id="b26ad-189">That said, the server should not attempt to reallocate or release **\[in\]** data, leaving the control of those spaces to the RPC server stub itself.</span></span>

<span data-ttu-id="b26ad-190">Por lo general, la implementación de la función de servidor no necesita reasignar o liberar los datos marcados con el atributo **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="b26ad-190">Generally, the server function implementation does not need to reallocate or release data marked with the **\[in, out\]** attribute.</span></span> <span data-ttu-id="b26ad-191">En el caso de los datos de tamaño fijo, la lógica de implementación de la función puede modificar los datos directamente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-191">For fixed size data, the function implementation logic can directly modify the data.</span></span> <span data-ttu-id="b26ad-192">Del mismo modo, para los datos de tamaño variable, la implementación de la función no debe modificar el valor del campo proporcionado al atributo [**\[ size \_ es () \]**](../midl/size-is.md) , ya sea.</span><span class="sxs-lookup"><span data-stu-id="b26ad-192">Likewise, for variable-sized data, the function implementation must not modify the field value supplied to the [**\[size\_is()\]**](../midl/size-is.md) attribute, either.</span></span> <span data-ttu-id="b26ad-193">Cambiar el valor del campo usado para cambiar el tamaño de los resultados de los datos en un búfer más pequeño o más grande devuelto al cliente, que puede estar mal equipado para tratar la longitud anómala.</span><span class="sxs-lookup"><span data-stu-id="b26ad-193">Change the field value used to size the data results in a smaller or larger buffer returned to the client which may be ill-equipped to deal with the abnormal length.</span></span>

<span data-ttu-id="b26ad-194">Si se producen circunstancias en las que la rutina del servidor tiene que reasignar la memoria utilizada por los datos marcados con el atributo **\[ in, out \]** , es posible que la implementación de la función de servidor no sepa si el puntero proporcionado por el código auxiliar es a la memoria asignada con el usuario de la asignación de los **usuarios de MIDL \_ \_ ()** o el búfer de conexión de serialización.</span><span class="sxs-lookup"><span data-stu-id="b26ad-194">If circumstances occur where the server routine has to reallocate the memory used by data marked with the **\[in, out\]** attribute, it is entirely possible that the server-side function implementation will not know if the pointer provided by the stub is to memory allocated with **MIDL\_user\_allocate()** or the marshaled wire buffer.</span></span> <span data-ttu-id="b26ad-195">Para solucionar este problema, MS RPC puede garantizar que no se produzcan pérdidas de memoria o daños si se establece el atributo [**\[ Force \_ allocate \]**](../midl/force-allocate.md) en los datos.</span><span class="sxs-lookup"><span data-stu-id="b26ad-195">To work around this problem, MS RPC can ensure that no memory leak or corruption occurs if the [**\[force\_allocate\]**](../midl/force-allocate.md) attribute is set on the data.</span></span> <span data-ttu-id="b26ad-196">Cuando se establece **\[ Force \_ allocate \]** , el código auxiliar del servidor asignará siempre la memoria para el puntero, aunque la advertencia es que el rendimiento se reducirá para cada uso de la misma.</span><span class="sxs-lookup"><span data-stu-id="b26ad-196">When **\[force\_allocate\]** is set, the server stub will always allocate memory for the pointer, although the caveat is that performance will decrease for every use of it.</span></span>

<span data-ttu-id="b26ad-197">Cuando se devuelve la llamada desde la implementación de función del servidor, el código auxiliar del servidor calcula las referencias de los datos marcados con el atributo [**\[ out \]**](../midl/out-idl.md) y los envía al cliente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-197">When the call returns from the server-side function implementation, the server stub marshals the data marked with the [**\[out\]**](../midl/out-idl.md) attribute and sends it to the client.</span></span> <span data-ttu-id="b26ad-198">Tenga en cuenta que el código auxiliar no calcula las referencias de los datos si la implementación de la función del servidor produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="b26ad-198">Be aware that the stub does not marshal the data if the server-side function implementation throws an exception.</span></span>

## <a name="releasing-allocated-memory"></a><span data-ttu-id="b26ad-199">Liberar memoria asignada</span><span class="sxs-lookup"><span data-stu-id="b26ad-199">Releasing Allocated Memory</span></span>

<span data-ttu-id="b26ad-200">El código auxiliar del servidor RPC liberará la memoria de la pila una vez que se haya devuelto la llamada desde la función del servidor, tanto si se produce una excepción como si no.</span><span class="sxs-lookup"><span data-stu-id="b26ad-200">The RPC server stub will release the stack memory after the call has returned from the server-side function, whether an exception occurs or not.</span></span> <span data-ttu-id="b26ad-201">El código auxiliar de servidor libera toda la memoria asignada por el código auxiliar y cualquier memoria asignada con la **asignación de usuarios de MIDL \_ \_ ()**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-201">The server stub frees all memory allocated by the stub as well as any memory allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="b26ad-202">La implementación de la función de servidor siempre debe proporcionar a RPC un estado coherente, ya sea iniciando una excepción o devolviendo un código de error.</span><span class="sxs-lookup"><span data-stu-id="b26ad-202">The server-side function implementation must always give RPC a consistent state, either by throwing an exception or returning an error code.</span></span> <span data-ttu-id="b26ad-203">Si se produce un error en la función durante el rellenado de estructuras de datos complicadas, debe asegurarse de que todos los punteros señalan a datos válidos o que están establecidos en **null**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-203">If the function fails during the population of complicated data structures, it must ensure that all pointers point to valid data or are set to **NULL**.</span></span>

<span data-ttu-id="b26ad-204">Durante este paso, el código auxiliar del servidor libera toda la memoria que no forma parte del búfer de serialización que contiene los datos [**\[ de \]**](../midl/in.md) .</span><span class="sxs-lookup"><span data-stu-id="b26ad-204">During this pass, the server stub frees all memory that is not part of the marshaled buffer containing the [**\[in\]**](../midl/in.md) data.</span></span> <span data-ttu-id="b26ad-205">Una excepción a este comportamiento son los datos con el atributo [**\[ allocate (no \_ Free) \]**](../midl/allocate.md) establecido en ellos: el código auxiliar del servidor no libera ninguna memoria asociada a estos punteros.</span><span class="sxs-lookup"><span data-stu-id="b26ad-205">One exception to this behavior is data with the [**\[allocate(dont\_free)\]**](../midl/allocate.md) attribute set on them - the server stub does not free any memory associated with these pointers.</span></span>

<span data-ttu-id="b26ad-206">Una vez que el código auxiliar del servidor libera la memoria asignada por el código auxiliar y la implementación de la función, el código auxiliar llama a una función de notificación específica si se especifica el atributo de [**\[ \_ marca \]**](../midl/notify-flag.md) de notificación para datos determinados.</span><span class="sxs-lookup"><span data-stu-id="b26ad-206">After the server stub releases the memory allocated by the stub and the function implementation, the stub calls a specific notification function if the [**\[notify\_flag\]**](../midl/notify-flag.md) attribute is specified for particular data.</span></span>

## <a name="marshalling-a-linked-list-over-rpc----an-example"></a><span data-ttu-id="b26ad-207">Serialización de una lista vinculada a través de RPC: ejemplo</span><span class="sxs-lookup"><span data-stu-id="b26ad-207">Marshalling a Linked List over RPC -- An Example</span></span>


```C++
typedef struct _LINKEDLIST
{
    long lSize;
    [size_is(lSize)] char *pData;
    struct _LINKEDLIST *pNext;
} LINKEDLIST, *PLINKEDLIST;

void Test
(
    [in] LINKEDLIST *pIn,
    [in, out] PLINKEDLIST *pInOut,
    [out] LINKEDLIST *pOut
);
```



<span data-ttu-id="b26ad-208">En el ejemplo anterior, el formato de memoria de **LINKEDLIST** será idéntico al formato de conexión con cálculo de referencias.</span><span class="sxs-lookup"><span data-stu-id="b26ad-208">In the above example, the memory format for **LINKEDLIST** will be identical to the marshaled wire format.</span></span> <span data-ttu-id="b26ad-209">Como resultado, el código auxiliar del servidor no asigna memoria para toda la cadena de punteros de datos en el *código pIn*.</span><span class="sxs-lookup"><span data-stu-id="b26ad-209">As a result, the server stub does not allocate memory for the entire chain of data pointers under *pIn*.</span></span> <span data-ttu-id="b26ad-210">En su lugar, RPC reutiliza el búfer de conexión para toda la lista vinculada.</span><span class="sxs-lookup"><span data-stu-id="b26ad-210">Rather, RPC reuses the wire buffer for the entire linked list.</span></span> <span data-ttu-id="b26ad-211">Del mismo modo, el código auxiliar no asigna memoria para el *pines*, sino que vuelve a usar el búfer de conexión serializado por el cliente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-211">Similarly, the stub does not allocate memory for *pInOut*, but instead reuses the wire buffer marshaled by the client.</span></span>

<span data-ttu-id="b26ad-212">Dado que la firma de la función contiene un parámetro de salida, *pOut*, el código auxiliar del servidor asigna memoria para que contenga los datos devueltos.</span><span class="sxs-lookup"><span data-stu-id="b26ad-212">Because the function signature contains an outbound parameter, *pOut*, the server stub allocates memory to contain the returned data.</span></span> <span data-ttu-id="b26ad-213">La memoria asignada es inicialmente cero, con **pNext** establecido en **null**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-213">The allocated memory is initially zeroes out, with **pNext** set to **NULL**.</span></span> <span data-ttu-id="b26ad-214">La aplicación puede asignar la memoria para una nueva lista vinculada y apuntar *pOut* -> **pNext** a ella.</span><span class="sxs-lookup"><span data-stu-id="b26ad-214">The application can allocate the memory for a new linked list and point *pOut*->**pNext** to it.</span></span> <span data-ttu-id="b26ad-215">el *pIn* y la lista vinculada que contiene se pueden usar como un área temporal, pero la aplicación no debe cambiar ninguno de los punteros pNext.</span><span class="sxs-lookup"><span data-stu-id="b26ad-215">*pIn* and the linked list it contains can be used as a scratch area, but the application should not change any of the pNext pointers.</span></span>

<span data-ttu-id="b26ad-216">La aplicación puede cambiar libremente el contenido de la lista vinculada a la que apunta el *pines*, pero no debe cambiar ninguno de los punteros **pNext** , por lo que solo se permite el vínculo de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="b26ad-216">The application can freely change the content of the linked list pointed to by *pInOut*, but it must not change any of the **pNext** pointers, let alone the top-level link itself.</span></span> <span data-ttu-id="b26ad-217">Si la aplicación decide acortar la lista vinculada, no puede saber si alguno de los vínculos de puntero **pNext** especificados para un búfer interno de RPC o un búfer asignado específicamente con **MIDL \_ User \_ allocate ()**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-217">If the application decides to shorten the linked list, it cannot know if any given **pNext** pointer links tto an RPC internal buffer or a buffer specifically allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="b26ad-218">Para evitar este problema, se agrega una declaración de tipos específica para los punteros de lista vinculados que fuerza la asignación del usuario, tal como se muestra en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="b26ad-218">To work around this issue, you add a specific type declaration for linked list pointers that forces user allocation, as seen in the code below.</span></span>

``` syntax
typedef [force_allocate] PLINKEDLIST;
```

<span data-ttu-id="b26ad-219">Este atributo obliga al código auxiliar del servidor a asignar cada nodo de la lista vinculada por separado, y la aplicación puede liberar la parte abreviada de la lista vinculada llamando a **MIDL \_ \_ Free ()**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-219">This attribute forces the server stub to allocate each node of the linked list separately, and the application can free the shortened part of the linked list by calling **MIDL\_user\_free()**.</span></span> <span data-ttu-id="b26ad-220">A continuación, la aplicación puede establecer de forma segura el puntero **pNext** al final de la lista vinculada recién acortada en **null**.</span><span class="sxs-lookup"><span data-stu-id="b26ad-220">The application can then safely set the **pNext** pointer at the end of the newly-shortened linked list to **NULL**.</span></span>

 

 