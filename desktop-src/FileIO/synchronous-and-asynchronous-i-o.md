---
description: 'Hay dos tipos de sincronización de entrada/salida (e/s): e/s sincrónica y de e/s asincrónica. La e/s asincrónica también se conoce como e/s superpuesta.'
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: E/s sincrónica y asincrónica
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 071dd2943537dcb6aff67a95cb5e2c3d514f4c1a
ms.sourcegitcommit: af120ad5c30da2fc5eb717ca2a1c4c45878efd71
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/20/2021
ms.locfileid: "105689904"
---
# <a name="synchronous-and-asynchronous-io"></a><span data-ttu-id="14b5b-104">E/s sincrónica y asincrónica</span><span class="sxs-lookup"><span data-stu-id="14b5b-104">Synchronous and Asynchronous I/O</span></span>

<span data-ttu-id="14b5b-105">Vea también [aplicaciones de ejemplo relacionadas con e/s](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span><span class="sxs-lookup"><span data-stu-id="14b5b-105">Also see [I/O-related sample applications](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span></span>

<span data-ttu-id="14b5b-106">Hay dos tipos de sincronización de entrada/salida (e/s): e/s sincrónica y de e/s asincrónica.</span><span class="sxs-lookup"><span data-stu-id="14b5b-106">There are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="14b5b-107">La e/s asincrónica también se conoce como e/s superpuesta.</span><span class="sxs-lookup"><span data-stu-id="14b5b-107">Asynchronous I/O is also referred to as overlapped I/O.</span></span>

<span data-ttu-id="14b5b-108">En la *e/s de archivos sincrónicos*, un subproceso inicia una operación de e/s y entra inmediatamente en un estado de espera hasta que se completa la solicitud de e/s.</span><span class="sxs-lookup"><span data-stu-id="14b5b-108">In *synchronous file I/O*, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed.</span></span> <span data-ttu-id="14b5b-109">Un subproceso que realiza la *e/s de archivos asincrónica* envía una solicitud de e/s al kernel mediante una llamada a una función adecuada.</span><span class="sxs-lookup"><span data-stu-id="14b5b-109">A thread performing *asynchronous file I/O* sends an I/O request to the kernel by calling an appropriate function.</span></span> <span data-ttu-id="14b5b-110">Si el kernel acepta la solicitud, el subproceso que realiza la llamada continúa procesando otro trabajo hasta que el kernel señale al subproceso de que se ha completado la operación de e/s.</span><span class="sxs-lookup"><span data-stu-id="14b5b-110">If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete.</span></span> <span data-ttu-id="14b5b-111">Después, interrumpe su trabajo actual y procesa los datos de la operación de e/s según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="14b5b-111">It then interrupts its current job and processes the data from the I/O operation as necessary.</span></span>

<span data-ttu-id="14b5b-112">Los dos tipos de sincronización se muestran en la ilustración siguiente.</span><span class="sxs-lookup"><span data-stu-id="14b5b-112">The two synchronization types are illustrated in the following figure.</span></span>

![e/s sincrónica y asincrónica](images/fig2bedit.png)

<span data-ttu-id="14b5b-114">En situaciones en las que se espera que una solicitud de e/s tome una gran cantidad de tiempo, como una actualización o una copia de seguridad de una base de datos de gran tamaño o un vínculo de comunicaciones lento, la e/s asincrónica suele ser una buena manera de optimizar la eficacia del procesamiento.</span><span class="sxs-lookup"><span data-stu-id="14b5b-114">In situations where an I/O request is expected to take a large amount of time, such as a refresh or backup of a large database or a slow communications link, asynchronous I/O is generally a good way to optimize processing efficiency.</span></span> <span data-ttu-id="14b5b-115">Sin embargo, para operaciones de e/s relativamente rápidas, la sobrecarga que supone el procesamiento de las solicitudes de e/s de kernel y las señales de kernel puede hacer que la e/s asincrónica sea menos ventajosa, especialmente si es necesario realizar muchas operaciones de e/s rápidas.</span><span class="sxs-lookup"><span data-stu-id="14b5b-115">However, for relatively fast I/O operations, the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial, particularly if many fast I/O operations need to be made.</span></span> <span data-ttu-id="14b5b-116">En este caso, la e/s sincrónica sería mejor.</span><span class="sxs-lookup"><span data-stu-id="14b5b-116">In this case, synchronous I/O would be better.</span></span> <span data-ttu-id="14b5b-117">Los mecanismos y los detalles de implementación de cómo realizar estas tareas varían en función del tipo de identificador de dispositivo que se use y de las necesidades concretas de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="14b5b-117">The mechanisms and implementation details of how to accomplish these tasks vary depending on the type of device handle that is used and the particular needs of the application.</span></span> <span data-ttu-id="14b5b-118">En otras palabras, normalmente hay varias formas de resolver el problema.</span><span class="sxs-lookup"><span data-stu-id="14b5b-118">In other words, there are usually multiple ways to solve the problem.</span></span>

## <a name="synchronous-and-asynchronous-io-considerations"></a><span data-ttu-id="14b5b-119">Consideraciones de e/s sincrónicas y asincrónicas</span><span class="sxs-lookup"><span data-stu-id="14b5b-119">Synchronous and Asynchronous I/O Considerations</span></span>

<span data-ttu-id="14b5b-120">Si se abre un archivo o un dispositivo para la e/s sincrónica (es decir, no se especifica la superposición de la **\_ marca \_ de archivo** ), las llamadas subsiguientes a funciones como [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) pueden bloquear la ejecución del subproceso de llamada hasta que se produzca uno de los siguientes eventos:</span><span class="sxs-lookup"><span data-stu-id="14b5b-120">If a file or device is opened for synchronous I/O (that is, **FILE\_FLAG\_OVERLAPPED** is not specified), subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) can block execution of the calling thread until one of the following events occurs:</span></span>

-   <span data-ttu-id="14b5b-121">Se completa la operación de e/s (en este ejemplo, una escritura de datos).</span><span class="sxs-lookup"><span data-stu-id="14b5b-121">The I/O operation completes (in this example, a data write).</span></span>
-   <span data-ttu-id="14b5b-122">Error de E/S.</span><span class="sxs-lookup"><span data-stu-id="14b5b-122">An I/O error occurs.</span></span> <span data-ttu-id="14b5b-123">(Por ejemplo, la canalización se cierra desde el otro extremo).</span><span class="sxs-lookup"><span data-stu-id="14b5b-123">(For example, the pipe is closed from the other end.)</span></span>
-   <span data-ttu-id="14b5b-124">Se ha producido un error en la propia llamada (por ejemplo, uno o más parámetros no son válidos).</span><span class="sxs-lookup"><span data-stu-id="14b5b-124">An error was made in the call itself (for example, one or more parameters are not valid).</span></span>
-   <span data-ttu-id="14b5b-125">Otro subproceso del proceso llama a la función [**CancelSynchronousIo**](cancelsynchronousio-func.md) con el identificador de subproceso del subproceso bloqueado, que finaliza la e/s para ese subproceso, con lo que se produce un error en la operación de e/s.</span><span class="sxs-lookup"><span data-stu-id="14b5b-125">Another thread in the process calls the [**CancelSynchronousIo**](cancelsynchronousio-func.md) function using the blocked thread's thread handle, which terminates I/O for that thread, failing the I/O operation.</span></span>
-   <span data-ttu-id="14b5b-126">El sistema ha terminado el subproceso bloqueado; por ejemplo, el propio proceso finaliza, u otro subproceso llama a la función [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) mediante el identificador del subproceso bloqueado.</span><span class="sxs-lookup"><span data-stu-id="14b5b-126">The blocked thread is terminated by the system; for example, the process itself is terminated, or another thread calls the [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) function using the blocked thread's handle.</span></span> <span data-ttu-id="14b5b-127">(Esto suele considerarse un último recurso y no un buen diseño de la aplicación).</span><span class="sxs-lookup"><span data-stu-id="14b5b-127">(This is generally considered a last resort and not good application design.)</span></span>

<span data-ttu-id="14b5b-128">En algunos casos, este retraso puede ser inaceptable para el diseño y el propósito de la aplicación, por lo que los diseñadores de aplicaciones deben considerar el uso de la e/s asincrónica con objetos de sincronización de subprocesos adecuados, como los [puertos de finalización de e/s](i-o-completion-ports.md).</span><span class="sxs-lookup"><span data-stu-id="14b5b-128">In some cases, this delay may be unacceptable to the application's design and purpose, so application designers should consider using asynchronous I/O with appropriate thread synchronization objects such as [I/O completion ports](i-o-completion-ports.md).</span></span> <span data-ttu-id="14b5b-129">Para obtener más información acerca de la sincronización de subprocesos, consulte [acerca de la sincronización](/windows/desktop/Sync/about-synchronization).</span><span class="sxs-lookup"><span data-stu-id="14b5b-129">For more information about thread synchronization, see [About Synchronization](/windows/desktop/Sync/about-synchronization).</span></span>

<span data-ttu-id="14b5b-130">Un proceso abre un archivo para la e/s asincrónica en su llamada a [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) especificando la marca de superposición de **\_ marca \_ de archivo** en el parámetro *dwFlagsAndAttributes* .</span><span class="sxs-lookup"><span data-stu-id="14b5b-130">A process opens a file for asynchronous I/O in its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) by specifying the **FILE\_FLAG\_OVERLAPPED** flag in the *dwFlagsAndAttributes* parameter.</span></span> <span data-ttu-id="14b5b-131">Si no se especifica la **marca de archivo \_ \_ OVERLAPPED** , el archivo se abre para la e/s sincrónica.</span><span class="sxs-lookup"><span data-stu-id="14b5b-131">If **FILE\_FLAG\_OVERLAPPED** is not specified, the file is opened for synchronous I/O.</span></span> <span data-ttu-id="14b5b-132">Cuando el archivo se ha abierto para la e/s asincrónica, se pasa un puntero a una estructura [**superpuesta**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) en la llamada a [**readfile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) y [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="14b5b-132">When the file has been opened for asynchronous I/O, a pointer to an [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure is passed into the call to [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="14b5b-133">Al realizar operaciones de e/s sincrónicas, esta estructura no es necesaria en las llamadas a **readfile** y **WriteFile**.</span><span class="sxs-lookup"><span data-stu-id="14b5b-133">When performing synchronous I/O, this structure is not required in calls to **ReadFile** and **WriteFile**.</span></span>

> [!Note]  
> <span data-ttu-id="14b5b-134">Si se abre un archivo o un dispositivo para la e/s asincrónica, las llamadas subsiguientes a funciones como [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) con ese identificador normalmente devuelven de inmediato pero también se comportan de forma sincrónica con respecto a la ejecución bloqueada.</span><span class="sxs-lookup"><span data-stu-id="14b5b-134">If a file or device is opened for asynchronous I/O, subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) using that handle generally return immediately but can also behave synchronously with respect to blocked execution.</span></span> <span data-ttu-id="14b5b-135">Para más información, consulte [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span><span class="sxs-lookup"><span data-stu-id="14b5b-135">For more information, see [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span></span>

 

<span data-ttu-id="14b5b-136">Aunque [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) es la función más común que se usa para abrir archivos, volúmenes de disco, canalizaciones anónimas y otros dispositivos similares, las operaciones de e/s también se pueden realizar mediante el uso de una *conversión* de identificador de otros objetos del sistema, como un socket creado por las funciones [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) o [**Accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) .</span><span class="sxs-lookup"><span data-stu-id="14b5b-136">Although [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) is the most common function to use for opening files, disk volumes, anonymous pipes, and other similar devices, I/O operations can also be performed using a handle *typecast* from other system objects such as a socket created by the [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) or [**accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) functions.</span></span>

<span data-ttu-id="14b5b-137">Los identificadores de los objetos de directorio se obtienen mediante una llamada a la función [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) con el atributo de **semántica de copia de \_ \_ seguridad \_ del marcador de archivo** .</span><span class="sxs-lookup"><span data-stu-id="14b5b-137">Handles to directory objects are obtained by calling the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function with the **FILE\_FLAG\_BACKUP\_SEMANTICS** attribute.</span></span> <span data-ttu-id="14b5b-138">Casi nunca se usan identificadores de directorio: las aplicaciones de copia de seguridad son una de las pocas aplicaciones que normalmente las usarán.</span><span class="sxs-lookup"><span data-stu-id="14b5b-138">Directory handles are almost never used—backup applications are one of the few applications that will typically use them.</span></span>

<span data-ttu-id="14b5b-139">Después de abrir el objeto de archivo para la e/s asincrónica, una estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) se debe crear, inicializar y pasar correctamente en cada llamada a funciones como [**readfile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) y [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="14b5b-139">After opening the file object for asynchronous I/O, an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must be properly created, initialized, and passed into each call to functions such as [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="14b5b-140">Tenga en cuenta lo siguiente cuando use la estructura [**superpuesta**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) en operaciones asincrónicas de lectura y escritura:</span><span class="sxs-lookup"><span data-stu-id="14b5b-140">Keep the following in mind when using the [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure in asynchronous read and write operations:</span></span>

-   <span data-ttu-id="14b5b-141">No Desasigne ni modifique la estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) o el búfer de datos hasta que se hayan completado todas las operaciones de e/s asincrónicas en el objeto de archivo.</span><span class="sxs-lookup"><span data-stu-id="14b5b-141">Do not deallocate or modify the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure or the data buffer until all asynchronous I/O operations to the file object have been completed.</span></span>
-   <span data-ttu-id="14b5b-142">Si declara el puntero a la estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) como una variable local, no salga de la función local hasta que se hayan completado todas las operaciones de e/s asincrónicas en el objeto de archivo.</span><span class="sxs-lookup"><span data-stu-id="14b5b-142">If you declare your pointer to the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure as a local variable, do not exit the local function until all asynchronous I/O operations to the file object have been completed.</span></span> <span data-ttu-id="14b5b-143">Si la función local se sale prematuramente, la estructura **superpuesta** quedará fuera del ámbito y no será accesible para las funciones [**readfile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) o [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) que encuentre fuera de esa función.</span><span class="sxs-lookup"><span data-stu-id="14b5b-143">If the local function is exited prematurely, the **OVERLAPPED** structure will go out of scope and it will be inaccessible to any [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) functions it encounters outside of that function.</span></span>

<span data-ttu-id="14b5b-144">También puede crear un evento y colocar el identificador en la estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) . a continuación, las [funciones de espera](/windows/desktop/Sync/wait-functions) se pueden usar para esperar a que se complete la operación de e/s esperando en el controlador de eventos.</span><span class="sxs-lookup"><span data-stu-id="14b5b-144">You can also create an event and put the handle in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure; the [wait functions](/windows/desktop/Sync/wait-functions) can then be used to wait for the I/O operation to complete by waiting on the event handle.</span></span>

<span data-ttu-id="14b5b-145">Como se indicó anteriormente, al trabajar con un identificador asincrónico, las aplicaciones deben tener cuidado al realizar determinaciones sobre cuándo liberar recursos asociados a una operación de e/s especificada en ese controlador.</span><span class="sxs-lookup"><span data-stu-id="14b5b-145">As previously stated, when working with an asynchronous handle, applications should use care when making determinations about when to free resources associated with a specified I/O operation on that handle.</span></span> <span data-ttu-id="14b5b-146">Si se cancela la asignación del identificador prematuramente, [**readfile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) o [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) pueden informar incorrectamente de que se ha completado la operación de e/s.</span><span class="sxs-lookup"><span data-stu-id="14b5b-146">If the handle is deallocated prematurely, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) may incorrectly report that the I/O operation is complete.</span></span> <span data-ttu-id="14b5b-147">Además, la función **WriteFile** devolverá a veces **true** con un valor [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) de **error \_ Success**, aunque esté usando un identificador asincrónico (que también puede devolver **false** con el **error de \_ e/s \_ pendiente**).</span><span class="sxs-lookup"><span data-stu-id="14b5b-147">Further, the **WriteFile** function will sometimes return **TRUE** with a [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) value of **ERROR\_SUCCESS**, even though it is using an asynchronous handle (which can also return **FALSE** with **ERROR\_IO\_PENDING**).</span></span> <span data-ttu-id="14b5b-148">Los programadores acostumbrados al diseño de e/s sincrónica normalmente liberarán recursos de búfer de datos en este momento porque **true** y **error \_ Success** indican que la operación se ha completado.</span><span class="sxs-lookup"><span data-stu-id="14b5b-148">Programmers accustomed to synchronous I/O design will usually release data buffer resources at this point because **TRUE** and **ERROR\_SUCCESS** signify the operation is complete.</span></span> <span data-ttu-id="14b5b-149">Sin embargo, si se usan [puertos de finalización de e/s](i-o-completion-ports.md) con este identificador asincrónico, también se enviará un paquete de finalización aunque la operación de e/s se complete inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="14b5b-149">However, if [I/O completion ports](i-o-completion-ports.md) are being used with this asynchronous handle, a completion packet will also be sent even though the I/O operation completed immediately.</span></span> <span data-ttu-id="14b5b-150">En otras palabras, si la aplicación libera recursos después de que **WriteFile** devuelva **true** con el **error \_ Success** , además de en la rutina del puerto de finalización de e/s, tendrá una condición de error de doble liberación.</span><span class="sxs-lookup"><span data-stu-id="14b5b-150">In other words, if the application frees resources after **WriteFile** returns **TRUE** with **ERROR\_SUCCESS** in addition to in the I/O completion port routine, it will have a double-free error condition.</span></span> <span data-ttu-id="14b5b-151">En este ejemplo, la recomendación sería permitir que la rutina del puerto de finalización sea la única responsable de todas las operaciones de liberación de estos recursos.</span><span class="sxs-lookup"><span data-stu-id="14b5b-151">In this example, the recommendation would be to allow the completion port routine to be solely responsible for all freeing operations for such resources.</span></span>

<span data-ttu-id="14b5b-152">El sistema no mantiene el puntero de archivo en los identificadores asincrónicos de los archivos y dispositivos que admiten punteros de archivo (es decir, los dispositivos de búsqueda), por lo que la posición del archivo se debe pasar a las funciones de lectura y escritura en los miembros de datos de desplazamiento relacionados de la estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="14b5b-152">The system does not maintain the file pointer on asynchronous handles to files and devices that support file pointers (that is, seeking devices), therefore the file position must be passed to the read and write functions in the related offset data members of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="14b5b-153">Para obtener más información, vea [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) y [**readfile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span><span class="sxs-lookup"><span data-stu-id="14b5b-153">For more information, see [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) and [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span></span>

<span data-ttu-id="14b5b-154">El sistema mantiene la posición del puntero de archivo para un identificador sincrónico a medida que se leen o escriben datos y también se pueden actualizar mediante la función [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) o [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) .</span><span class="sxs-lookup"><span data-stu-id="14b5b-154">File pointer position for a synchronous handle is maintained by the system as data is read or written and can also be updated using the [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) or [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) function.</span></span>

<span data-ttu-id="14b5b-155">Una aplicación también puede esperar en el identificador de archivo para sincronizar la finalización de una operación de e/s, pero esto requiere extrema precaución.</span><span class="sxs-lookup"><span data-stu-id="14b5b-155">An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution.</span></span> <span data-ttu-id="14b5b-156">Cada vez que se inicia una operación de e/s, el sistema operativo establece el identificador de archivo en el estado no señalado.</span><span class="sxs-lookup"><span data-stu-id="14b5b-156">Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state.</span></span> <span data-ttu-id="14b5b-157">Cada vez que se completa una operación de e/s, el sistema operativo establece el identificador de archivo en el estado señalado.</span><span class="sxs-lookup"><span data-stu-id="14b5b-157">Each time an I/O operation is completed, the operating system sets the file handle to the signaled state.</span></span> <span data-ttu-id="14b5b-158">Por lo tanto, si una aplicación inicia dos operaciones de e/s y espera en el identificador de archivo, no hay ninguna manera de determinar qué operación ha finalizado cuando el identificador se establece en el estado señalado.</span><span class="sxs-lookup"><span data-stu-id="14b5b-158">Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state.</span></span> <span data-ttu-id="14b5b-159">Si una aplicación debe realizar varias operaciones de e/s asincrónicas en un único archivo, debe esperar en el identificador de eventos de la estructura [**superpuesta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) específica para cada operación de e/s, en lugar de en el identificador de archivo común.</span><span class="sxs-lookup"><span data-stu-id="14b5b-159">If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the specific [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for each I/O operation, rather than on the common file handle.</span></span>

<span data-ttu-id="14b5b-160">Para cancelar todas las operaciones de e/s asincrónicas pendientes, use:</span><span class="sxs-lookup"><span data-stu-id="14b5b-160">To cancel all pending asynchronous I/O operations, use either:</span></span>

-   <span data-ttu-id="14b5b-161">[**CancelIo**](cancelio.md): esta función solo cancela las operaciones emitidas por el subproceso que realiza la llamada para el identificador de archivo especificado.</span><span class="sxs-lookup"><span data-stu-id="14b5b-161">[**CancelIo**](cancelio.md)—this function only cancels operations issued by the calling thread for the specified file handle.</span></span>
-   <span data-ttu-id="14b5b-162">[**CancelIoEx**](cancelioex-func.md): esta función cancela todas las operaciones emitidas por los subprocesos para el identificador de archivo especificado.</span><span class="sxs-lookup"><span data-stu-id="14b5b-162">[**CancelIoEx**](cancelioex-func.md)—this function cancels all operations issued by the threads for the specified file handle.</span></span>

<span data-ttu-id="14b5b-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) para cancelar las operaciones de e/s sincrónicas pendientes.</span><span class="sxs-lookup"><span data-stu-id="14b5b-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) to cancel pending synchronous I/O operations.</span></span>

<span data-ttu-id="14b5b-164">Las funciones [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) y [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) permiten que una aplicación especifique una rutina que se va a ejecutar (consulte [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) cuando se completa la solicitud de e/s asincrónica.</span><span class="sxs-lookup"><span data-stu-id="14b5b-164">The [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) functions enable an application to specify a routine to execute (see [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) when the asynchronous I/O request is completed.</span></span>

 

 
