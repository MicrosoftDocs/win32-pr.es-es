---
title: Administrar la duración de los objetos mediante el recuento de referencias
description: Administrar la duración de los objetos mediante el recuento de referencias
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/17/2020
ms.locfileid: "105656319"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a><span data-ttu-id="441f2-103">Administrar la duración de los objetos mediante el recuento de referencias</span><span class="sxs-lookup"><span data-stu-id="441f2-103">Managing Object Lifetimes Through Reference Counting</span></span>

<span data-ttu-id="441f2-104">En los sistemas de objetos tradicionales, el ciclo de vida de los objetos (es decir, los problemas relacionados con la creación y la eliminación de objetos) se controla implícitamente mediante el lenguaje (o el tiempo de ejecución del lenguaje) o explícitamente por los programadores de aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="441f2-104">In traditional object systems, the life cycle of objects—that is, the issues surrounding the creation and deletion of objects—is handled implicitly by the language (or the language run time) or explicitly by application programmers.</span></span>

<span data-ttu-id="441f2-105">En un sistema que se desarrolla de forma descentralizada y que se compone de componentes reutilizados, ya no es cierto que cualquier cliente, o incluso cualquier programador, siempre "sabe" cómo tratar la duración de un componente.</span><span class="sxs-lookup"><span data-stu-id="441f2-105">In an evolving, decentrally constructed system made up of reused components, it is no longer true that any client, or even any programmer, always "knows" how to deal with a component's lifetime.</span></span> <span data-ttu-id="441f2-106">Para un cliente con los privilegios de seguridad correctos, sigue siendo relativamente fácil crear objetos a través de una solicitud simple, pero la eliminación de objetos es otra cuestión por completo.</span><span class="sxs-lookup"><span data-stu-id="441f2-106">For a client with the right security privileges, it is still relatively easy to create objects through a simple request, but object deletion is another matter entirely.</span></span> <span data-ttu-id="441f2-107">No es necesariamente evidente cuando un objeto ya no se necesita y se debe eliminar.</span><span class="sxs-lookup"><span data-stu-id="441f2-107">It is not necessarily clear when an object is no longer needed and should be deleted.</span></span> <span data-ttu-id="441f2-108">(Los lectores familiarizados con los entornos de programación de recolección de elementos no utilizados, como Java, pueden estar en modo de desacuerdo; sin embargo, los objetos de Java no abarcan los límites del equipo ni siquiera los procesan, por lo que la recolección de elementos no utilizados está restringida a los objetos que viven dentro de un espacio de</span><span class="sxs-lookup"><span data-stu-id="441f2-108">(Readers familiar with garbage-collected programming environments, such as Java, may disagree; however, Java objects do not span machine or even process boundaries, and therefore the garbage collection is restricted to objects living within a single-process space.</span></span> <span data-ttu-id="441f2-109">Además, Java fuerza el uso de un lenguaje de programación único). Incluso cuando el cliente original se realiza con el objeto, no puede simplemente apagar el objeto, ya que otros clientes o clientes todavía pueden tener una referencia a él.</span><span class="sxs-lookup"><span data-stu-id="441f2-109">In addition, Java forces the use of a single programming language.) Even when the original client is done with the object, it cannot simply shut the object down, because some other client or clients might still have a reference to it.</span></span>

<span data-ttu-id="441f2-110">Una manera de asegurarse de que un objeto ya no se necesita es depender por completo de un canal de comunicación subyacente para informar al sistema cuando todas las conexiones a un objeto entre procesos o entre canales han desaparecido.</span><span class="sxs-lookup"><span data-stu-id="441f2-110">One way to ensure that an object is no longer needed is to depend entirely on an underlying communication channel to inform the system when all connections to a cross-process or cross-channel object have disappeared.</span></span> <span data-ttu-id="441f2-111">Sin embargo, los esquemas que utilizan este método son inaceptables por varias razones.</span><span class="sxs-lookup"><span data-stu-id="441f2-111">However, schemes that use this method are unacceptable for several reasons.</span></span> <span data-ttu-id="441f2-112">Un problema es que podría requerir una diferencia importante entre el modelo de programación entre procesos y entre redes y el modelo de programación de un solo proceso.</span><span class="sxs-lookup"><span data-stu-id="441f2-112">One problem is that it could require a major difference between the cross-process/cross-network programming model and the single-process programming model.</span></span> <span data-ttu-id="441f2-113">En el modelo de programación entre procesos y redes, el sistema de comunicación proporcionaría los enlaces necesarios para la administración de la duración de los objetos, mientras que en el modelo de programación de un solo proceso, los objetos se conectan directamente sin ningún canal de comunicaciones que intervenga.</span><span class="sxs-lookup"><span data-stu-id="441f2-113">In the cross-process/cross-network programming model, the communication system would provide the hooks necessary for object lifetime management, while in the single-process programming model, objects are directly connected without any intervening communications channel.</span></span> <span data-ttu-id="441f2-114">Otro problema es que este esquema también podría dar lugar a una capa de software proporcionado por el sistema que interferiría con el rendimiento de los componentes en el caso en proceso.</span><span class="sxs-lookup"><span data-stu-id="441f2-114">Another problem is that this scheme could also result in a layer of system-provided software that would interfere with component performance in the in-process case.</span></span> <span data-ttu-id="441f2-115">Además, un mecanismo basado en la supervisión explícita no tiende a escalar hacia muchos miles o millones de objetos.</span><span class="sxs-lookup"><span data-stu-id="441f2-115">Furthermore, a mechanism based on explicit monitoring would not tend to scale toward many thousands or millions of objects.</span></span>

<span data-ttu-id="441f2-116">COM ofrece un enfoque escalable y distribuido a este conjunto de problemas.</span><span class="sxs-lookup"><span data-stu-id="441f2-116">COM offers a scalable and distributed approach to this set of problems.</span></span> <span data-ttu-id="441f2-117">Los clientes indican a un objeto Cuándo lo están usando y cuándo lo hacen, y los objetos se eliminan cuando ya no son necesarios.</span><span class="sxs-lookup"><span data-stu-id="441f2-117">Clients tell an object when they are using it and when they are done, and objects delete themselves when they are no longer needed.</span></span> <span data-ttu-id="441f2-118">Este enfoque tiene en cuenta que todos los objetos cuentan las referencias a ellos mismos.</span><span class="sxs-lookup"><span data-stu-id="441f2-118">This approach mandates that all objects count references to themselves.</span></span> <span data-ttu-id="441f2-119">Los lenguajes de programación, como Java, que, de forma inherente, tienen sus propios esquemas de administración de la duración, como la recolección de elementos no utilizados, pueden usar el recuento de referencias de COM para implementar y usar objetos COM internamente, lo que permite al programador evitar trabajar con él.</span><span class="sxs-lookup"><span data-stu-id="441f2-119">Programming languages such as Java, which inherently have their own lifetime management schemes, such as garbage collection, can use COM's reference counting to implement and use COM objects internally, allowing the programmer to avoid dealing with it.</span></span>

<span data-ttu-id="441f2-120">Del mismo modo que una aplicación debe liberar la memoria que se ha asignado una vez que esa memoria ya no se utiliza, un cliente de un objeto es responsable de liberar sus referencias al objeto cuando ese objeto ya no se necesita.</span><span class="sxs-lookup"><span data-stu-id="441f2-120">Just as an application must free memory it has allocated once that memory is no longer in use, a client of an object is responsible for freeing its references to the object when that object is no longer needed.</span></span> <span data-ttu-id="441f2-121">En un sistema orientado a objetos, el cliente solo puede hacer esto si asigna al objeto una instrucción para que se libere.</span><span class="sxs-lookup"><span data-stu-id="441f2-121">In an object-oriented system, the client can do this only by giving the object an instruction to free itself.</span></span>

<span data-ttu-id="441f2-122">Es importante desasignar un objeto cuando ya no se usa.</span><span class="sxs-lookup"><span data-stu-id="441f2-122">It is important that an object be deallocated when it is no longer being used.</span></span> <span data-ttu-id="441f2-123">La dificultad radica en determinar cuándo es adecuado desasignar un objeto.</span><span class="sxs-lookup"><span data-stu-id="441f2-123">The difficulty lies in determining when it is appropriate to deallocate an object.</span></span> <span data-ttu-id="441f2-124">Esto es fácil con las variables automáticas (las asignadas en la pila): no se pueden usar fuera del bloque en el que se declaran, por lo que el compilador las desasigna cuando se alcanza el final del bloque.</span><span class="sxs-lookup"><span data-stu-id="441f2-124">This is easy with automatic variables (those allocated on the stack)—they cannot be used outside the block in which they're declared, so the compiler deallocates them when the end of the block is reached.</span></span> <span data-ttu-id="441f2-125">En el caso de los objetos COM, que se asignan dinámicamente, depende de los clientes de un objeto decidir si ya no necesitan usar el objeto, especialmente los objetos locales o remotos que pueden estar usando varios clientes al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="441f2-125">For COM objects, which are dynamically allocated, it is up to the clients of an object to decide when they no longer need to use the object—especially local or remote objects that might be in use by multiple clients at the same time.</span></span> <span data-ttu-id="441f2-126">El objeto debe esperar hasta que todos los clientes finalicen con él antes de liberarse.</span><span class="sxs-lookup"><span data-stu-id="441f2-126">The object must wait until all clients are finished with it before freeing itself.</span></span> <span data-ttu-id="441f2-127">Dado que los objetos COM se manipulan a través de punteros de interfaz y pueden ser utilizados por objetos en procesos diferentes o en otros equipos, el sistema no puede realizar un seguimiento de los clientes de un objeto.</span><span class="sxs-lookup"><span data-stu-id="441f2-127">Because COM objects are manipulated through interface pointers and can be used by objects in different processes or on other machines, the system cannot keep track of an object's clients.</span></span>

<span data-ttu-id="441f2-128">El método de COM para determinar cuándo es adecuado desasignar un objeto es el recuento de referencias manual.</span><span class="sxs-lookup"><span data-stu-id="441f2-128">COM's method of determining when it is appropriate to deallocate an object is manual reference counting.</span></span> <span data-ttu-id="441f2-129">Cada objeto mantiene un recuento de referencias que realiza un seguimiento del número de clientes que están conectados a él; es decir, el número de punteros a cualquiera de sus interfaces en cualquier cliente.</span><span class="sxs-lookup"><span data-stu-id="441f2-129">Each object maintains a reference count that tracks how many clients are connected to it - that is, how many pointers exist to any of its interfaces in any client.</span></span>

<span data-ttu-id="441f2-130">Para obtener más información, vea los temas siguientes:</span><span class="sxs-lookup"><span data-stu-id="441f2-130">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="441f2-131">Implementación del recuento de referencias</span><span class="sxs-lookup"><span data-stu-id="441f2-131">Implementing Reference Counting</span></span>](implementing-reference-counting.md)
-   [<span data-ttu-id="441f2-132">Reglas para administrar recuentos de referencias</span><span class="sxs-lookup"><span data-stu-id="441f2-132">Rules for Managing Reference Counts</span></span>](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a><span data-ttu-id="441f2-133">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="441f2-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="441f2-134">Usar e implementar IUnknown</span><span class="sxs-lookup"><span data-stu-id="441f2-134">Using and Implementing IUnknown</span></span>](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




