---
title: Controlar la inercia en código no administrado
description: En esta sección se explica cómo usar la interfaz IInertiaProcessor para controlar la inercia en el código no administrado.
ms.assetid: 3261b461-add2-4e92-9a51-b2d46630fb4f
keywords:
- Windows Touch, inercia
- Windows Touch, procesador de manipulación
- inercia, código no administrado
- inercia, interfaz IInertiaProcessor
- inercia, procesador de manipulación
- procesador de manipulación, inercia
- Interfaz IInertiaProcessor, código no administrado
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3de56d06547f426de252a89ef5172df3fe4ca439
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "104075205"
---
# <a name="handling-inertia-in-unmanaged-code"></a><span data-ttu-id="c0c10-110">Controlar la inercia en código no administrado</span><span class="sxs-lookup"><span data-stu-id="c0c10-110">Handling Inertia in Unmanaged Code</span></span>

<span data-ttu-id="c0c10-111">En esta sección se explica cómo usar la interfaz [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) para controlar la inercia en el código no administrado.</span><span class="sxs-lookup"><span data-stu-id="c0c10-111">This section explains how to use the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface for handling inertia in unmanaged code.</span></span>

## <a name="overview"></a><span data-ttu-id="c0c10-112">Información general</span><span class="sxs-lookup"><span data-stu-id="c0c10-112">Overview</span></span>

<span data-ttu-id="c0c10-113">Para usar la inercia en código no administrado, debe implementar receptores de eventos para el procesador de manipulación y el procesador de inercia.</span><span class="sxs-lookup"><span data-stu-id="c0c10-113">To use inertia in unmanaged code, you must implement event sinks both for the manipulation processor and the inertia processor.</span></span> <span data-ttu-id="c0c10-114">Comience agregando compatibilidad de manipulación a la aplicación como se describe en la sección [Agregar compatibilidad de manipulación a código no administrado](adding-manipulation-support-in-unmanaged-code.md).</span><span class="sxs-lookup"><span data-stu-id="c0c10-114">Start by adding manipulation support to your application as described in the section [Adding Manipulation Support to Unmanaged Code](adding-manipulation-support-in-unmanaged-code.md).</span></span> <span data-ttu-id="c0c10-115">Tenga en cuenta que la compatibilidad con la manipulación requiere que use mensajes táctiles en lugar de mensajes de gestos para alimentar datos de eventos al procesador de manipulación.</span><span class="sxs-lookup"><span data-stu-id="c0c10-115">Note that manipulation support requires that you use touch messages rather than gesture messages to feed event data to the manipulation processor.</span></span> <span data-ttu-id="c0c10-116">Una vez que haya manipulado el trabajo, también debe implementar un segundo receptor de eventos para los eventos que la interfaz [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) va a generar o necesitará modificar el receptor de eventos existente para acomodar los eventos generados por las interfaces **IInertiaProcessor** y [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) .</span><span class="sxs-lookup"><span data-stu-id="c0c10-116">After you have manipulation working, you must also implement a second event sink for the events that the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface will be generating or will need to modify your existing event sink to accommodate both the events generated by the **IInertiaProcessor** and the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) interfaces.</span></span> <span data-ttu-id="c0c10-117">Para los fines de este ejemplo, es más fácil empezar por el receptor de eventos creado para la sección agregar compatibilidad de manipulación a código no administrado y agregar un segundo constructor que funcione con el procesador de inercia en lugar del procesador de manipulación.</span><span class="sxs-lookup"><span data-stu-id="c0c10-117">For the purposes of this example, it is easier to start from the event sink created for the section Adding Manipulation Support to Unmanaged Code and add a second constructor that works with the inertia processor instead of the manipulation processor.</span></span> <span data-ttu-id="c0c10-118">De este modo, la implementación del receptor de eventos puede funcionar en el procesador de manipulación o en el procesador de inercia.</span><span class="sxs-lookup"><span data-stu-id="c0c10-118">This way, the event sink implementation can function for either the manipulation processor or the inertia processor.</span></span> <span data-ttu-id="c0c10-119">Además de agregar un segundo constructor, el receptor de eventos tendrá una variable que indica si realizará las operaciones basadas en la entrada de inercia en lugar de en la entrada de manipulación.</span><span class="sxs-lookup"><span data-stu-id="c0c10-119">In addition to adding a second constructor, the event sink will have a variable indicating whether it will perform the operations based on inertia input rather than manipulation input.</span></span>

### <a name="add-inertia-support-to-a-manipulation-processor-event-sink"></a><span data-ttu-id="c0c10-120">Agregar compatibilidad de inercia a un receptor de eventos de procesador de manipulación</span><span class="sxs-lookup"><span data-stu-id="c0c10-120">Add Inertia Support to a Manipulation Processor Event Sink</span></span>

<span data-ttu-id="c0c10-121">En el código siguiente se muestra el nuevo constructor del receptor de eventos, las nuevas variables de miembro de una interfaz [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) y una marca que indica si el receptor está extrapolando la inercia.</span><span class="sxs-lookup"><span data-stu-id="c0c10-121">The following code shows the new event sink constructor, new member variables for an [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface, and a flag indicating whether the sink is extrapolating for inertia.</span></span>


```C++
    CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd);
    CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd);
```




```C++
    IInertiaProcessor*      m_pInert;
    BOOL fExtrapolating; 
```



<span data-ttu-id="c0c10-122">Después de que el encabezado de clase tenga los nuevos constructores y una marca que indique si está extrapolando, puede implementar el receptor de eventos para tener bloques de control independientes para los eventos [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) y [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="c0c10-122">After your class header has the new constructors and a flag indicating whether you're extrapolating, you can implement your event sink to have separate handling blocks for the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) events and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) events.</span></span> <span data-ttu-id="c0c10-123">El constructor que acepta un **IManipulationProcessor** y un **IInertiaProcessor** debe establecer la marca **fExtrapolating** en false, lo que indica que se trata de un controlador de eventos **IManipulationProcessor** .</span><span class="sxs-lookup"><span data-stu-id="c0c10-123">The constructor that accepts an **IManipulationProcessor** and an **IInertiaProcessor** should set the **fExtrapolating** flag to false, which indicates that this is a **IManipulationProcessor** event handler.</span></span> <span data-ttu-id="c0c10-124">En el código siguiente se muestra cómo se puede implementar el constructor de un receptor de eventos que usa **IManipulationProcessor** .</span><span class="sxs-lookup"><span data-stu-id="c0c10-124">The following code shows how the constructor for an event sink that uses the **IManipulationProcessor** could be implemented.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=FALSE;

    m_pManip = pManip;
    
    m_pInert = pInert;
    
    m_pManip->put_PivotRadius(-1);

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pManip->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit
        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }

    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}
```



<span data-ttu-id="c0c10-125">En el código siguiente se muestra cómo se puede implementar el constructor de un receptor de eventos que usa [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="c0c10-125">The following code shows how the constructor for an event sink that uses the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) could be implemented.</span></span> <span data-ttu-id="c0c10-126">Este constructor establece la marca **fExtrapolating** en true, lo que indica que esta instancia de la clase del receptor de eventos realizará la extrapolación y realizará las operaciones de movimiento realizadas previamente por los eventos del procesador de manipulación.</span><span class="sxs-lookup"><span data-stu-id="c0c10-126">This constructor sets the **fExtrapolating** flag to true, indicating that this instance of the event sink class will be performing extrapolation and will perform any movement operations that were performed previously by the manipulation processor events.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    m_pInert = pInert;
    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=TRUE;

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pInert->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }
    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}   
```



> [!Note]  
> <span data-ttu-id="c0c10-127">La implementación de la clase de receptor de eventos del receptor de eventos del procesador de manipulación se reutiliza como un receptor de eventos para el procesador de inercia.</span><span class="sxs-lookup"><span data-stu-id="c0c10-127">The event sink class implementation from the manipulation processor event sink is reused as an event sink for the inertia processor.</span></span>

 

<span data-ttu-id="c0c10-128">Ahora, cuando se construye esta clase, **CManipulationEventSink**, se puede construir como un receptor de eventos para un procesador de manipulación o como un receptor de eventos para un procesador de inercia.</span><span class="sxs-lookup"><span data-stu-id="c0c10-128">Now when you construct this class, **CManipulationEventSink**, it can either be constructed as an event sink for a manipulation processor or as an event sink for an inertia processor.</span></span> <span data-ttu-id="c0c10-129">Cuando se construye como un receptor de eventos del procesador de inercia, tendrá la marca **fExtrapolating** establecida en true, lo que indica que se deben extrapolar los eventos de manipulación.</span><span class="sxs-lookup"><span data-stu-id="c0c10-129">When it's constructed as an inertia processor event sink, it will have the **fExtrapolating** flag set to true, indicating that manipulation events should be extrapolated.</span></span>

> [!Note]  
> <span data-ttu-id="c0c10-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) se producirá mediante las interfaces [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) y [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="c0c10-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) will be raised by both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interfaces.</span></span>

 

<span data-ttu-id="c0c10-131">Cuando se inicia la manipulación, se establecen las propiedades de la interfaz [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="c0c10-131">When manipulation starts, the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface properties are set.</span></span> <span data-ttu-id="c0c10-132">En el código siguiente se muestra cómo se administra el evento Started.</span><span class="sxs-lookup"><span data-stu-id="c0c10-132">The following code shows how the started event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationStarted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y)
{
    m_cStartedEventCount ++;       

    // set origins in manipulation processor
    m_pInert->put_InitialOriginX(x);
    m_pInert->put_InitialOriginY(y);
    
    RECT screenRect;

    HWND desktop = GetDesktopWindow();
    GetClientRect(desktop, &screenRect);

    // physics settings
    // deceleration is units per square millisecond
    m_pInert->put_DesiredDeceleration(.1f);

    // set the boundaries        
    screenRect.left-= 1024;
    m_pInert->put_BoundaryLeft  ( static_cast<float>(screenRect.left   * 100));
    m_pInert->put_BoundaryTop   ( static_cast<float>(screenRect.top    * 100));
    m_pInert->put_BoundaryRight ( static_cast<float>(screenRect.right  * 100));
    m_pInert->put_BoundaryBottom( static_cast<float>(screenRect.bottom * 100));
    
    
    // Elastic boundaries - I set these to 90% of the screen 
    // so... 5% at left, 95% right, 5% top,  95% bottom
    // Values are whole numbers because units are in centipixels
    m_pInert->put_ElasticMarginLeft  (static_cast<float>(screenRect.left   * 5));
    m_pInert->put_ElasticMarginTop   (static_cast<float>(screenRect.top    * 5));
    m_pInert->put_ElasticMarginRight (static_cast<float>(screenRect.right  * 95));
    m_pInert->put_ElasticMarginBottom(static_cast<float>(screenRect.bottom * 95));
    
    
    return S_OK;
}
```



<span data-ttu-id="c0c10-133">En este ejemplo, se usan diferencias de manipulación para mover la ventana.</span><span class="sxs-lookup"><span data-stu-id="c0c10-133">In this example, manipulation deltas are used to move the window around.</span></span> <span data-ttu-id="c0c10-134">En el código siguiente se muestra cómo se controla el evento Delta.</span><span class="sxs-lookup"><span data-stu-id="c0c10-134">The following code shows how the delta event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationDelta( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT translationDeltaX,
    /* [in] */ FLOAT translationDeltaY,
    /* [in] */ FLOAT scaleDelta,
    /* [in] */ FLOAT expansionDelta,
    /* [in] */ FLOAT rotationDelta,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cDeltaEventCount ++;
        
    RECT rect;
            
    GetWindowRect(m_hWnd, &rect);
        
    int oldWidth =  rect.right-rect.left;
    int oldHeight = rect.bottom-rect.top;            

    // scale and translate the window size / position    
    MoveWindow(m_hWnd,                                              // the window to move
        static_cast<int>(rect.left + (translationDeltaX / 100.0f)), // the x position
        static_cast<int>(rect.top + (translationDeltaY/100.0f)),    // the y position
        static_cast<int>(oldWidth * scaleDelta),                    // width
        static_cast<int>(oldHeight * scaleDelta),                   // height
        TRUE);                                                      // redraw
                     
    return S_OK;
}
```



<span data-ttu-id="c0c10-135">En este ejemplo, los eventos de manipulación completada inician o detienen un temporizador que llamará al [**proceso**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) en la interfaz [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="c0c10-135">In this example, manipulation completed events either start or stop a timer that will call [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span> <span data-ttu-id="c0c10-136">En el código siguiente se muestra cómo se administra el evento de manipulación completado.</span><span class="sxs-lookup"><span data-stu-id="c0c10-136">The following code shows how the completed manipulation event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationCompleted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cCompletedEventCount ++;

    m_fX = x;
    m_fY = y;

    // place your code handler here to do any operations based on the manipulation   
    
    if (fExtrapolating){
        //Inertia Complete, stop the timer used for processing      
        KillTimer(m_hWnd,0);        
    }else{ 
        // setup velocities for inertia processor
        float vX = 0.0f;
        float vY = 0.0f;
        float vA = 0.0f;
        m_pManip->GetVelocityX(&vX);
        m_pManip->GetVelocityY(&vY);
        m_pManip->GetAngularVelocity(&vA);

        // complete any previous processing
        m_pInert->Complete();
        
        // Reset sets the  initial timestamp
        m_pInert->Reset();
                
        // 
        m_pInert->put_InitialVelocityX(vX);
        m_pInert->put_InitialVelocityY(vY);        
        
        m_pInert->put_InitialOriginX(x);
        m_pInert->put_InitialOriginY(y);
        
           
        // Start a timer
        SetTimer(m_hWnd,0, 50, 0);        
    }

    return S_OK;
}
```



<span data-ttu-id="c0c10-137">En el código siguiente se muestra cómo se pueden interpretar los mensajes de **\_ temporizador de WM** en **WndProc** para realizar llamadas al [**proceso**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) en la interfaz [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="c0c10-137">The following code shows how you could interpret **WM\_TIMER** messages in **WndProc** to perform calls to [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span>


```C++
case WM_TIMER:       
  if (g_pIInertProc){
    BOOL b;       
    g_pIInertProc->Process(&b);        
  }
  break;
```



### <a name="coinitialize-the-inertia-processor-and-manipulation-processor-and-initialize-the-event-sinks"></a><span data-ttu-id="c0c10-138">Coinicializar el procesador de inercia y el procesador de manipulación e inicializar los receptores de eventos</span><span class="sxs-lookup"><span data-stu-id="c0c10-138">CoInitialize the Inertia Processor and Manipulation Processor and Initialize the Event Sinks</span></span>

<span data-ttu-id="c0c10-139">Una vez que haya modificado el receptor de eventos para admitir el [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) y el [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor), está listo para inicializar los receptores de eventos y configurarlos para que se ejecuten desde la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0c10-139">After you have your event sink modified to support both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor), you are ready to initialize the event sinks and set them up to run from your application.</span></span> <span data-ttu-id="c0c10-140">En el código siguiente se muestra cómo se asignan los punteros de interfaz.</span><span class="sxs-lookup"><span data-stu-id="c0c10-140">The following code shows how the interface pointers are allocated.</span></span>


```C++
//Include windows.h for touch events
#include "windows.h"  

// Manipulation implementation file
#include <manipulations_i.c>
    
// Smart Pointer to a global reference of a manipulation processor, event sink
IManipulationProcessor* g_pIManipProc;
IInertiaProcessor*      g_pIInertProc;
```



<span data-ttu-id="c0c10-141">En el ejemplo de código siguiente se muestra cómo crear una instancia de las interfaces.</span><span class="sxs-lookup"><span data-stu-id="c0c10-141">The following code example shows how to instantiate your interfaces.</span></span>


```C++
   HRESULT hr = CoInitialize(0);
        
   hr = CoCreateInstance(CLSID_ManipulationProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIManipProc)
   );
   
   hr = CoCreateInstance(CLSID_InertiaProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIInertProc)
   );
```



<span data-ttu-id="c0c10-142">En el ejemplo de código siguiente se muestra cómo construir los receptores de eventos dados los punteros de interfaz y cómo registrar la ventana para la entrada táctil.</span><span class="sxs-lookup"><span data-stu-id="c0c10-142">The following code example shows how to construct your event sinks given the interface pointers and register the window for touch input.</span></span>


```C++
   g_pManipulationEventSink = new CManipulationEventSink(g_pIManipProc, g_pIInertProc, hWnd);
   g_pManipulationEventSink = new CManipulationEventSink(g_pIInertProc, hWnd);


   RegisterTouchWindow(hWnd, 0);  
```



## <a name="related-topics"></a><span data-ttu-id="c0c10-143">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="c0c10-143">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="c0c10-144">Inercia</span><span class="sxs-lookup"><span data-stu-id="c0c10-144">Inertia</span></span>](getting-started-with-inertia.md)
</dt> </dl>

 

 




