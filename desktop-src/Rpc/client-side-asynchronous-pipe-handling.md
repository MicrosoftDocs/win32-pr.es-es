---
title: Control de canalizaciones asincrónicas en el cliente
description: Antes de realizar una llamada remota asincrónica, el cliente debe inicializar primero el identificador asincrónico.
ms.assetid: 3d54b233-d8b0-45d1-b759-0d2d24c1e247
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 11ff503f80c77b2403d683c2b644d89836365956
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "103903745"
---
# <a name="client-side-asynchronous-pipe-handling"></a><span data-ttu-id="4ec8c-103">Control de canalizaciones asincrónicas en el cliente</span><span class="sxs-lookup"><span data-stu-id="4ec8c-103">Client-side Asynchronous Pipe Handling</span></span>

<span data-ttu-id="4ec8c-104">Antes de realizar una llamada remota asincrónica, el cliente debe inicializar primero el identificador asincrónico.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-104">Before making an asynchronous remote call, the client must first initialize the asynchronous handle.</span></span> <span data-ttu-id="4ec8c-105">Al igual que con los procedimientos no canalizados, el cliente llama a una función asincrónica con el identificador asincrónico como primer parámetro y usa el identificador asincrónico para enviar y recibir datos de canalización, consultar el estado de la llamada y recibir la respuesta.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-105">As with nonpipe procedures, the client calls an asynchronous function with the asynchronous handle as the first parameter and uses the asynchronous handle to send and receive pipe data, query the status of the call, and receive the reply.</span></span>

<span data-ttu-id="4ec8c-106">El cliente realiza la llamada asincrónica al procedimiento remoto con el identificador asincrónico como primer parámetro.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-106">The client makes the asynchronous remote procedure call with the asynchronous handle as the first parameter.</span></span> <span data-ttu-id="4ec8c-107">El cliente puede utilizar este identificador para consultar el estado de la llamada y recibir la respuesta.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-107">The client can use this handle to query the status of the call and to receive the reply.</span></span> <span data-ttu-id="4ec8c-108">El modelo de canalización asincrónica es simétrico.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-108">The asynchronous pipe model is symmetric.</span></span> <span data-ttu-id="4ec8c-109">Tanto las aplicaciones de cliente como de servidor envían y reciben activamente datos de canalización (en lugar de RPC sincrónicos, donde los datos de la canalización se envían y se reciben de manera pasiva).</span><span class="sxs-lookup"><span data-stu-id="4ec8c-109">Both client and server applications send and receive pipe data actively (as opposed to synchronous RPC, where the pipe data is sent and received passively).</span></span>

<span data-ttu-id="4ec8c-110">El cliente envía datos de canalización asincrónicos mediante una llamada a **la función de la** canalización asincrónica adecuada, con la variable de estado de la canalización como primer parámetro.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-110">The client sends asynchronous pipe data by calling the **push** function on the appropriate asynchronous pipe, with the pipe's state variable as the first parameter.</span></span> <span data-ttu-id="4ec8c-111">Cuando se devuelve **la función de envío,** el cliente puede modificar o liberar el búfer de envío.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-111">When the **push** function returns, the client can modify or free the send buffer.</span></span>

<span data-ttu-id="4ec8c-112">Si la \_ marca RPC Async \_ Notify \_ on \_ send \_ Complete está establecida en el identificador asincrónico y si se usan APC como mecanismo de notificación, se pone en cola una APC cuando el envío de la canalización se ha completado.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-112">If the RPC\_ASYNC\_NOTIFY\_ON\_SEND\_COMPLETE flag is set in the asynchronous handle, and if APCs are used as the notification mechanism, an APC is queued when the pipe send is actually complete.</span></span> <span data-ttu-id="4ec8c-113">Puede aprovechar este mecanismo para implementar el control de flujo.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-113">You can take advantage of this mechanism to implement flow control.</span></span> <span data-ttu-id="4ec8c-114">Tenga en cuenta, sin embargo, que si el cliente envía otro búfer antes de que se complete la anterior, el cliente puede, en función de la velocidad de la operación de transferencia, recibir solo una notificación de envío y completo, en lugar de una notificación para cada búfer o cada operación de **extracción** .</span><span class="sxs-lookup"><span data-stu-id="4ec8c-114">Note, however, that if the client pushes another buffer before the previous push is complete, the client may, depending on the speed of the transfer operation, receive only one send-complete notification, rather than one notification for each buffer or each **push** operation.</span></span> <span data-ttu-id="4ec8c-115">Cuando el cliente ha enviado todos los datos de la canalización, realiza una llamada de **envío** final con el número de elementos establecido en 0.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-115">When the client has sent all of the pipe data, it makes one final **push** call with the number of elements set to 0.</span></span>

<span data-ttu-id="4ec8c-116">El programa cliente recibe datos de canalización asincrónicos mediante una llamada a la función **pull** en la canalización asincrónica adecuada, con la variable de estado de la canalización como primer parámetro.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-116">The client program receives asynchronous pipe data by calling the **pull** function on the appropriate asynchronous pipe, with the pipe's state variable as the first parameter.</span></span> <span data-ttu-id="4ec8c-117">Si no hay datos de canalización disponibles, la función de **extracción** devuelve una \_ llamada asincrónica de RPC S \_ \_ \_ pendiente.</span><span class="sxs-lookup"><span data-stu-id="4ec8c-117">If no pipe data is available, the **pull** function returns RPC\_S\_ASYNC\_CALL\_PENDING.</span></span>

<span data-ttu-id="4ec8c-118">Si el mecanismo de notificación es APC y el servidor devolvió \_ \_ \_ una llamada asincrónica \_ de RPC S, el cliente debe esperar hasta que reciba el APC **RpcReceiveComplete** desde el tiempo de ejecución antes de volver a llamar a **pull** .</span><span class="sxs-lookup"><span data-stu-id="4ec8c-118">If the notification mechanism is APC, and the server returned RPC\_S\_ASYNC\_CALL\_PENDING, the client must wait until it receives the **RpcReceiveComplete** APC from run-time before calling **pull** again.</span></span>

 

 




