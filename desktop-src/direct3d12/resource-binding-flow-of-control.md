---
title: Información general sobre el enlace de recursos
description: La clave para el enlace de recursos en DirectX 12 son los conceptos de un descriptor, las tablas de descriptores, los montones de descriptores y una firma raíz.
ms.assetid: 92E100CA-822D-46B1-BD37-FF57C3FB703D
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2bc7e78255c123777716eddb43d9443e19113b34
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "74103761"
---
# <a name="resource-binding-overview"></a><span data-ttu-id="a5bce-103">Información general sobre el enlace de recursos</span><span class="sxs-lookup"><span data-stu-id="a5bce-103">Resource Binding Overview</span></span>

<span data-ttu-id="a5bce-104">La clave para el enlace de recursos en DirectX 12 son los conceptos de un *descriptor*, *las tablas de descriptores*, los *montones de descriptores* y una *firma raíz*.</span><span class="sxs-lookup"><span data-stu-id="a5bce-104">The key to resource binding in DirectX 12 are the concepts of a *descriptor*, *descriptor tables*, *descriptor heaps*, and a *root signature*.</span></span>

-   [<span data-ttu-id="a5bce-105">Recursos y la canalización de gráficos</span><span class="sxs-lookup"><span data-stu-id="a5bce-105">Resources and the Graphics Pipeline</span></span>](#resources-and-the-graphics-pipeline)
-   [<span data-ttu-id="a5bce-106">Tipos de recursos y vistas</span><span class="sxs-lookup"><span data-stu-id="a5bce-106">Resource types and views</span></span>](#resource-types-and-views)
-   [<span data-ttu-id="a5bce-107">Flujo de enlace de recursos de control</span><span class="sxs-lookup"><span data-stu-id="a5bce-107">Resource Binding Flow of Control</span></span>](#resource-binding-overview)
-   [<span data-ttu-id="a5bce-108">Subasignación</span><span class="sxs-lookup"><span data-stu-id="a5bce-108">Suballocation</span></span>](#suballocation)
-   [<span data-ttu-id="a5bce-109">Liberar recursos</span><span class="sxs-lookup"><span data-stu-id="a5bce-109">Freeing Resources</span></span>](#freeing-resources)
-   [<span data-ttu-id="a5bce-110">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="a5bce-110">Related topics</span></span>](#related-topics)

## <a name="resources-and-the-graphics-pipeline"></a><span data-ttu-id="a5bce-111">Recursos y la canalización de gráficos</span><span class="sxs-lookup"><span data-stu-id="a5bce-111">Resources and the Graphics Pipeline</span></span>

<span data-ttu-id="a5bce-112">Los recursos del sombreador (como texturas, tablas constantes, imágenes, búferes, etc.) no están enlazados directamente a la canalización del sombreador; en su lugar, se hace referencia a ellos a través de un *descriptor*.</span><span class="sxs-lookup"><span data-stu-id="a5bce-112">Shader resources (such as textures, constant tables, images, buffers and so on) are not bound directly to the shader pipeline; instead, they are referenced through a *descriptor*.</span></span> <span data-ttu-id="a5bce-113">Un descriptor es un objeto pequeño que contiene información sobre un recurso.</span><span class="sxs-lookup"><span data-stu-id="a5bce-113">A descriptor is a small object that contains information about one resource.</span></span>

<span data-ttu-id="a5bce-114">Los descriptores se agrupan en *tablas de descriptores* de formulario.</span><span class="sxs-lookup"><span data-stu-id="a5bce-114">Descriptors are grouped together to form *descriptor tables*.</span></span> <span data-ttu-id="a5bce-115">Cada tabla de descriptores almacena información sobre un intervalo de tipos de recursos.</span><span class="sxs-lookup"><span data-stu-id="a5bce-115">Each descriptor table stores information about one range of types of resource.</span></span> <span data-ttu-id="a5bce-116">Hay muchos tipos diferentes de recursos.</span><span class="sxs-lookup"><span data-stu-id="a5bce-116">There are many different types of resources.</span></span> <span data-ttu-id="a5bce-117">Los recursos más comunes son:</span><span class="sxs-lookup"><span data-stu-id="a5bce-117">The most common resources are:</span></span>

-   <span data-ttu-id="a5bce-118">Vistas de búfer de constantes (CBVs)</span><span class="sxs-lookup"><span data-stu-id="a5bce-118">Constant buffer views (CBVs)</span></span>
-   <span data-ttu-id="a5bce-119">Vistas de acceso desordenado (UAVs)</span><span class="sxs-lookup"><span data-stu-id="a5bce-119">Unordered access views (UAVs)</span></span>
-   <span data-ttu-id="a5bce-120">Vistas de recursos del sombreador (SRVs)</span><span class="sxs-lookup"><span data-stu-id="a5bce-120">Shader resource views (SRVs)</span></span>
-   <span data-ttu-id="a5bce-121">Muestras</span><span class="sxs-lookup"><span data-stu-id="a5bce-121">Samplers</span></span>

<span data-ttu-id="a5bce-122">Los descriptores SRV, UAV y CBVs se pueden combinar en la misma tabla de descriptores.</span><span class="sxs-lookup"><span data-stu-id="a5bce-122">SRV, UAV, and CBVs descriptors can be combined into the same descriptor table.</span></span>

<span data-ttu-id="a5bce-123">Las canalizaciones de gráficos y de cálculo obtienen acceso a los recursos haciendo referencia a las tablas de descriptores por índice.</span><span class="sxs-lookup"><span data-stu-id="a5bce-123">The graphics and compute pipelines gain access to resources by referencing into descriptor tables by index.</span></span>

<span data-ttu-id="a5bce-124">Las tablas de descriptor se almacenan en un *montón de descriptores*.</span><span class="sxs-lookup"><span data-stu-id="a5bce-124">Descriptor tables are stored in a *descriptor heap*.</span></span> <span data-ttu-id="a5bce-125">Idealmente, los montones de descriptor contendrán todos los descriptores (en las tablas de descriptores) de uno o varios fotogramas que se van a representar.</span><span class="sxs-lookup"><span data-stu-id="a5bce-125">Descriptor heaps will ideally contain all the descriptors (in descriptor tables) for one or more frames to be rendered.</span></span> <span data-ttu-id="a5bce-126">Todos los recursos se almacenarán en montones de modo de usuario.</span><span class="sxs-lookup"><span data-stu-id="a5bce-126">All the resources will be stored in user mode heaps.</span></span>

<span data-ttu-id="a5bce-127">Otro concepto es el de una *firma raíz*.</span><span class="sxs-lookup"><span data-stu-id="a5bce-127">Another concept is that of a *root signature*.</span></span> <span data-ttu-id="a5bce-128">La firma raíz es una Convención de enlace, definida por la aplicación, que usan los sombreadores para localizar los recursos a los que necesitan tener acceso.</span><span class="sxs-lookup"><span data-stu-id="a5bce-128">The root signature is a binding convention, defined by the application, that is used by shaders to locate the resources that they need access to.</span></span> <span data-ttu-id="a5bce-129">La firma raíz puede almacenar:</span><span class="sxs-lookup"><span data-stu-id="a5bce-129">The root signature can store:</span></span>

-   <span data-ttu-id="a5bce-130">Índices para descriptor tablas en un montón de descriptores, donde el diseño de la tabla de descriptores se ha definido previamente.</span><span class="sxs-lookup"><span data-stu-id="a5bce-130">Indexes to descriptor tables in a descriptor heap, where the layout of the descriptor table has been pre-defined.</span></span>
-   <span data-ttu-id="a5bce-131">Constantes, por lo que las aplicaciones pueden enlazar constantes definidas por el usuario (conocidas como *constantes raíz*) directamente a los sombreadores sin tener que ir a través de descriptores y tablas de descriptores.</span><span class="sxs-lookup"><span data-stu-id="a5bce-131">Constants, so apps can bind user-defined constants (known as *root constants*) directly to shaders without having to go through descriptors and descriptor tables.</span></span>
-   <span data-ttu-id="a5bce-132">Un número muy pequeño de descriptores directamente dentro de la firma raíz, como una vista de búfer de constantes (CBV) que cambia por dibujo, lo que evita que la aplicación tenga que colocar los descriptores en un montón de descriptores.</span><span class="sxs-lookup"><span data-stu-id="a5bce-132">A very small number of descriptors directly inside the root signature, such as a constant buffer view (CBV) that changes per draw, thereby saving the application from needing to put those descriptors in a descriptor heap.</span></span>

<span data-ttu-id="a5bce-133">En otras palabras, la firma raíz proporciona optimizaciones de rendimiento adecuadas para pequeñas cantidades de datos que cambian por dibujo.</span><span class="sxs-lookup"><span data-stu-id="a5bce-133">In other words, the root signature provides performance optimizations suitable for small amounts of data that change per draw.</span></span>

<span data-ttu-id="a5bce-134">El diseño de Direct3D 12 para el enlace lo separa de otras tareas, como la administración de memoria, la administración de la duración de los objetos, el seguimiento de estado y la sincronización de memoria (consulte [las diferencias en el modelo de enlace de Direct3D 11](binding-model.md)).</span><span class="sxs-lookup"><span data-stu-id="a5bce-134">The Direct3D 12 design for binding separates it from other tasks, such as memory management, object lifetime management, state tracking, and memory synchronization (refer to [Differences in the Binding Model from Direct3D 11](binding-model.md)).</span></span> <span data-ttu-id="a5bce-135">El enlace de Direct3D 12 está diseñado para ser de baja sobrecarga y está optimizado para las llamadas de API que se realizan con mayor frecuencia.</span><span class="sxs-lookup"><span data-stu-id="a5bce-135">Direct3D 12 binding is designed to be low overhead and optimized for the API calls that are made most frequently.</span></span> <span data-ttu-id="a5bce-136">También es escalable a través de hardware de low-end y High-End, y es escalable desde más antiguo (la canalización Direct3D 11 más lineal) hasta los enfoques más recientes (más paralelos) a la programación del motor de gráficos.</span><span class="sxs-lookup"><span data-stu-id="a5bce-136">It is also scalable across low end to high end hardware, and scalable from older (the more linear Direct3D 11 pipeline) to the newer (more parallel) approaches to graphics engine programming.</span></span>

## <a name="resource-types-and-views"></a><span data-ttu-id="a5bce-137">Tipos de recursos y vistas</span><span class="sxs-lookup"><span data-stu-id="a5bce-137">Resource types and views</span></span>

<span data-ttu-id="a5bce-138">Los tipos de recursos son los mismos que los de Direct3D 11, es decir:</span><span class="sxs-lookup"><span data-stu-id="a5bce-138">Resource types are the same as Direct3D 11, namely:</span></span>

-   <span data-ttu-id="a5bce-139">Texture1D y Texture1DArray</span><span class="sxs-lookup"><span data-stu-id="a5bce-139">Texture1D, and Texture1DArray</span></span>
-   <span data-ttu-id="a5bce-140">Texture2D y Texture2DArray, Texture2DMS, Texture2DMSArray</span><span class="sxs-lookup"><span data-stu-id="a5bce-140">Texture2D, and Texture2DArray, Texture2DMS, Texture2DMSArray</span></span>
-   <span data-ttu-id="a5bce-141">Texture3D</span><span class="sxs-lookup"><span data-stu-id="a5bce-141">Texture3D</span></span>
-   <span data-ttu-id="a5bce-142">Búferes (tipos, estructurados y sin formato)</span><span class="sxs-lookup"><span data-stu-id="a5bce-142">Buffers (typed, structured and raw)</span></span>

<span data-ttu-id="a5bce-143">Las vistas de recursos son similares, pero son ligeramente diferentes de las vistas de Direct3D 11, vértices e índices que se han agregado.</span><span class="sxs-lookup"><span data-stu-id="a5bce-143">Resource views are similar but slightly different from Direct3D 11, vertex and index buffer views have been added.</span></span>

-   <span data-ttu-id="a5bce-144">Vista de búfer de constantes (CBV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-144">Constant buffer view (CBV)</span></span>
-   <span data-ttu-id="a5bce-145">Vista de acceso desordenado (UAV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-145">Unordered access view (UAV)</span></span>
-   <span data-ttu-id="a5bce-146">Vista de recursos del sombreador (SRV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-146">Shader resource view (SRV)</span></span>
-   <span data-ttu-id="a5bce-147">Muestras</span><span class="sxs-lookup"><span data-stu-id="a5bce-147">Samplers</span></span>
-   <span data-ttu-id="a5bce-148">Vista de destino de representación (RTV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-148">Render Target View (RTV)</span></span>
-   <span data-ttu-id="a5bce-149">Vista de galería de símbolos de profundidad (DSV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-149">Depth Stencil View (DSV)</span></span>
-   <span data-ttu-id="a5bce-150">Vista de búfer de índice (IBV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-150">Index Buffer View (IBV)</span></span>
-   <span data-ttu-id="a5bce-151">Vista de búfer de vértices (VBV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-151">Vertex Buffer View (VBV)</span></span>
-   <span data-ttu-id="a5bce-152">Vista de salida de flujo (SOV)</span><span class="sxs-lookup"><span data-stu-id="a5bce-152">Stream Output View (SOV)</span></span>

<span data-ttu-id="a5bce-153">Solo las cuatro primeras de estas vistas son realmente visibles para los sombreadores, consulte [montones de descriptor visibles del sombreador](shader-visible-descriptor-heaps.md) y [montones de descriptor visibles de no sombreador](non-shader-visible-descriptor-heaps.md).</span><span class="sxs-lookup"><span data-stu-id="a5bce-153">Only the first four of these views are actually visible to shaders, refer to [Shader Visible Descriptor Heaps](shader-visible-descriptor-heaps.md) and [Non Shader Visible Descriptor Heaps](non-shader-visible-descriptor-heaps.md).</span></span>

## <a name="resource-binding-flow-of-control"></a><span data-ttu-id="a5bce-154">Flujo de enlace de recursos de control</span><span class="sxs-lookup"><span data-stu-id="a5bce-154">Resource Binding Flow of Control</span></span>

<span data-ttu-id="a5bce-155">Centrándose solo en las firmas raíz, los descriptores raíz, las constantes raíz, las tablas de descriptores y los montones de descriptores, el flujo de la lógica de representación de una aplicación debe ser similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="a5bce-155">Focusing just on root signatures, root descriptors, root constants, descriptor tables, and descriptor heaps, the flow of rendering logic for an app should be similar to the following:</span></span>

-   <span data-ttu-id="a5bce-156">Cree uno o más objetos de firma raíz: uno para cada configuración de enlace diferente que necesite la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a5bce-156">Create one or more root signature objects – one for every different binding configuration an application needs.</span></span>
-   <span data-ttu-id="a5bce-157">Cree sombreadores y estado de canalización con los objetos de firma raíz que se usarán con.</span><span class="sxs-lookup"><span data-stu-id="a5bce-157">Create shaders and pipeline state with the root signature objects they will be used with.</span></span>
-   <span data-ttu-id="a5bce-158">Cree uno (o, si es necesario, más) montones de descriptores que contendrá todos los descriptores SRV, UAV y CBV para cada fotograma de representación.</span><span class="sxs-lookup"><span data-stu-id="a5bce-158">Create one (or, if necessary, more) descriptor heaps that will contain all the SRV, UAV, and CBV descriptors for each frame of rendering.</span></span>
-   <span data-ttu-id="a5bce-159">Inicialice los montones de descriptor con descriptores siempre que sea posible para los conjuntos de descriptores que se reutilizarán en muchos fotogramas.</span><span class="sxs-lookup"><span data-stu-id="a5bce-159">Initialize the descriptor heap(s) with descriptors where possible for sets of descriptors that will be reused across many frames.</span></span>
-   <span data-ttu-id="a5bce-160">Para cada fotograma que se va a representar:</span><span class="sxs-lookup"><span data-stu-id="a5bce-160">For each frame to be rendered:</span></span>
    -   <span data-ttu-id="a5bce-161">Para cada lista de comandos:</span><span class="sxs-lookup"><span data-stu-id="a5bce-161">For each command list:</span></span>
        -   <span data-ttu-id="a5bce-162">Establezca la firma raíz actual que se va a usar (y cámbielo si es necesario durante la representación, lo que rara vez es necesario).</span><span class="sxs-lookup"><span data-stu-id="a5bce-162">Set the current root signature to use (and change if needed during rendering – which is rarely required).</span></span>
        -   <span data-ttu-id="a5bce-163">Actualice algunas constantes y/o descriptores de la firma raíz de la firma raíz para la nueva vista (como las proyecciones de mundo o vista).</span><span class="sxs-lookup"><span data-stu-id="a5bce-163">Update some root signature’s constants and/or root signature descriptors for the new view (such as world/view projections).</span></span>
        -   <span data-ttu-id="a5bce-164">Para cada elemento que se va a dibujar:</span><span class="sxs-lookup"><span data-stu-id="a5bce-164">For each item to draw:</span></span>
            -   <span data-ttu-id="a5bce-165">Defina los nuevos descriptores en los montones de descriptores según sea necesario para la representación por objeto.</span><span class="sxs-lookup"><span data-stu-id="a5bce-165">Define any new descriptors in descriptor heaps as needed for per-object rendering.</span></span> <span data-ttu-id="a5bce-166">En el caso de los montones de descriptor visibles del sombreador, la aplicación debe asegurarse de usar el espacio del montón del descriptor al que ya no se hace referencia mediante la representación que podría estar en vuelo; por ejemplo, asignar espacio linealmente a través del montón del descriptor durante la representación.</span><span class="sxs-lookup"><span data-stu-id="a5bce-166">For shader-visible descriptor heaps, the app must make sure to use descriptor heap space that isn’t already being referenced by rendering that could be in flight – for example, linearly allocating space through the descriptor heap during rendering.</span></span>
            -   <span data-ttu-id="a5bce-167">Actualice la firma raíz con punteros a las regiones necesarias de los montones de descriptor.</span><span class="sxs-lookup"><span data-stu-id="a5bce-167">Update the root signature with pointers to the required regions of the descriptor heaps.</span></span> <span data-ttu-id="a5bce-168">Por ejemplo, una tabla de descriptores podría señalar a algunos descriptores estáticos (sin cambiar) inicializados anteriormente, mientras que otra tabla de descriptores podría señalar a algunos descriptores dinámicos configurados para la representación actual.</span><span class="sxs-lookup"><span data-stu-id="a5bce-168">For example, one descriptor table might point to some static (unchanging) descriptors initialized earlier, while another descriptor table might point to some dynamic descriptors configured for the current rendering.</span></span>
            -   <span data-ttu-id="a5bce-169">Actualice algunas constantes y/o descriptores de la firma raíz para la representación por elemento.</span><span class="sxs-lookup"><span data-stu-id="a5bce-169">Update some root signature’s constants and/or root signature descriptors for per-item rendering.</span></span>
            -   <span data-ttu-id="a5bce-170">Establezca el estado de canalización para el elemento que se va a dibujar (solo si el cambio es necesario), compatible con la firma raíz enlazada actualmente.</span><span class="sxs-lookup"><span data-stu-id="a5bce-170">Set the pipeline state for the item to draw (only if change needed), compatible with the currently bound root signature.</span></span>
            -   <span data-ttu-id="a5bce-171">Dibujar</span><span class="sxs-lookup"><span data-stu-id="a5bce-171">Draw</span></span>
        -   <span data-ttu-id="a5bce-172">Repetir (elemento siguiente)</span><span class="sxs-lookup"><span data-stu-id="a5bce-172">Repeat (next item)</span></span>
    -   <span data-ttu-id="a5bce-173">Repetir (lista de comandos siguiente)</span><span class="sxs-lookup"><span data-stu-id="a5bce-173">Repeat (next command list)</span></span>
    -   <span data-ttu-id="a5bce-174">Estrictamente cuando la GPU haya terminado con cualquier memoria que ya no se vaya a utilizar, se puede liberar.</span><span class="sxs-lookup"><span data-stu-id="a5bce-174">Strictly when the GPU has finished with any memory that will no longer be used, it can be released.</span></span> <span data-ttu-id="a5bce-175">No es necesario eliminar las referencias de descriptores a ella si no se envía ninguna representación adicional que use esos descriptores.</span><span class="sxs-lookup"><span data-stu-id="a5bce-175">Descriptors' references to it do not need to be deleted if additional rendering that uses those descriptors is not submitted.</span></span> <span data-ttu-id="a5bce-176">Por lo tanto, la representación subsiguiente puede apuntar a otras áreas de los montones de descriptores, o bien se pueden sobrescribir descriptores obsoletos con descriptores válidos para reutilizar el espacio del montón del descriptor.</span><span class="sxs-lookup"><span data-stu-id="a5bce-176">So, subsequent rendering can point to other areas in descriptor heaps, or stale descriptors can be overwritten with valid descriptors to reuse the descriptor heap space.</span></span>
-   <span data-ttu-id="a5bce-177">Repetir (fotograma siguiente)</span><span class="sxs-lookup"><span data-stu-id="a5bce-177">Repeat (next frame)</span></span>

<span data-ttu-id="a5bce-178">Tenga en cuenta que otros tipos de descriptores, vistas de destino de representación (RTVs), vistas de estarcido de profundidad (DSV), vistas de búfer de índice (IBVs), vistas de búfer de vértices (VBVs) y vistas de objeto de sombreador (SOV), se administran de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="a5bce-178">Note that other descriptor types, render target views (RTVs), depth stencil views (DSV), index buffer views (IBVs), vertex buffer views (VBVs), and shader object views (SOV), are managed differently.</span></span> <span data-ttu-id="a5bce-179">El controlador controla el control de versiones del conjunto de descriptores enlazado para cada dibujo durante la grabación de la lista de comandos (de forma similar al modo en que el hardware o el controlador controlan la versión de los enlaces de la firma raíz).</span><span class="sxs-lookup"><span data-stu-id="a5bce-179">The driver handles the versioning of the set of descriptors bound for each draw during recording of the command list (similar to how the root signature bindings are versioned by the hardware/driver).</span></span> <span data-ttu-id="a5bce-180">Esto no es lo mismo que el contenido de los montones de descriptor visibles del sombreador, para los que la aplicación debe asignar manualmente a través del montón, ya que hace referencia a distintos descriptores entre los dibujos.</span><span class="sxs-lookup"><span data-stu-id="a5bce-180">This is different from the contents of shader-visible descriptor heaps, for which the application must manually allocate through the heap as it references different descriptors between draws.</span></span> <span data-ttu-id="a5bce-181">El control de versiones del contenido del montón que es sombreador-visible se deja a la aplicación porque permite que las aplicaciones realicen tareas como reutilizar descriptores que no cambian, también se usan conjuntos estáticos grandes de descriptores y se usa la indización de sombreador (por ejemplo, por identificador de material) para seleccionar los descriptores que se van a usar en el montón de descriptores o para usar combinaciones de técnicas para diferentes conjuntos de descriptores.</span><span class="sxs-lookup"><span data-stu-id="a5bce-181">Versioning of heap content that is shader-visible is left to the application because it allows applications to do things like reuse descriptors that don’t change, or use large static sets of descriptors and use shader indexing (such as by material ID) to select descriptors to use from the descriptor heap, or use combinations of techniques for different sets of descriptors.</span></span> <span data-ttu-id="a5bce-182">El hardware no está equipado para controlar este tipo de flexibilidad para los demás tipos de descriptores (RTV, DSV, IBV, VBV, SOV).</span><span class="sxs-lookup"><span data-stu-id="a5bce-182">The hardware isn’t equipped to handle this type of flexibility for the other descriptor types (RTV, DSV, IBV, VBV, SOV).</span></span>

## <a name="suballocation"></a><span data-ttu-id="a5bce-183">Subasignación</span><span class="sxs-lookup"><span data-stu-id="a5bce-183">Suballocation</span></span>

<span data-ttu-id="a5bce-184">En Direct3D 12, la aplicación tiene un control de bajo nivel sobre la administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="a5bce-184">In Direct3D 12, the app has low-level control over memory management.</span></span> <span data-ttu-id="a5bce-185">En versiones anteriores de Direct3D, incluido Direct3D 11, hubiera una asignación por recurso.</span><span class="sxs-lookup"><span data-stu-id="a5bce-185">In earlier versions of Direct3D, including Direct3D 11, there would be one allocation per resource.</span></span> <span data-ttu-id="a5bce-186">En Direct3D 12, la aplicación puede usar la API para asignar un gran bloque de memoria, más grande de lo que necesitaría un solo objeto.</span><span class="sxs-lookup"><span data-stu-id="a5bce-186">In Direct3D 12, the app can use the API to allocate a large block of memory, larger than any single object would need.</span></span> <span data-ttu-id="a5bce-187">Una vez hecho esto, la aplicación puede crear descriptores para apuntar a las secciones de ese bloque de memoria grande.</span><span class="sxs-lookup"><span data-stu-id="a5bce-187">After this is done, the app can create descriptors to point to sections of that large memory block.</span></span> <span data-ttu-id="a5bce-188">Este proceso consiste en decidir qué colocar (bloques más pequeños dentro del bloque grande) se denomina *subasignación*.</span><span class="sxs-lookup"><span data-stu-id="a5bce-188">This process of deciding what to put where (smaller blocks inside the large block) is known as *suballocation*.</span></span> <span data-ttu-id="a5bce-189">Habilitar la aplicación para hacer esto puede producir mejoras en el uso eficaz de la memoria y el cálculo.</span><span class="sxs-lookup"><span data-stu-id="a5bce-189">Enabling the app to do this can yield gains in efficient use of computation and memory.</span></span> <span data-ttu-id="a5bce-190">Por ejemplo, el cambio de nombre de recursos se representa obsoleto.</span><span class="sxs-lookup"><span data-stu-id="a5bce-190">For example, resource renaming is rendered obsolete.</span></span> <span data-ttu-id="a5bce-191">En lugar de esto, las aplicaciones pueden usar vallas para determinar cuándo se usa un recurso determinado y cuándo no se especifican en las ejecuciones de la lista de comandos donde la lista de comandos requiere el uso de ese recurso en particular.</span><span class="sxs-lookup"><span data-stu-id="a5bce-191">In place of this, apps can use fences to determine when a particular resource is being used and when it's not by fencing on command list executions where the command list requires the use of that particular resource.</span></span>

## <a name="freeing-resources"></a><span data-ttu-id="a5bce-192">Liberar recursos</span><span class="sxs-lookup"><span data-stu-id="a5bce-192">Freeing Resources</span></span>

<span data-ttu-id="a5bce-193">Antes de que se pueda liberar cualquier memoria enlazada a la canalización, la GPU debe terminar con ella.</span><span class="sxs-lookup"><span data-stu-id="a5bce-193">Before any memory that has been bound to the pipeline can be freed, the GPU must be finished with it.</span></span>

<span data-ttu-id="a5bce-194">Esperar a que la representación de fotogramas sea probablemente la forma más amplia de asegurarse de que la GPU ha finalizado.</span><span class="sxs-lookup"><span data-stu-id="a5bce-194">Waiting for frame rendering is probably the coarsest way to be certain that the GPU has finished.</span></span> <span data-ttu-id="a5bce-195">En un grano más preciso, puede volver a usar las barreras: cuando un comando se grabe en una lista de comandos en la que desee realizar un seguimiento de la finalización, inserte una barrera inmediatamente después.</span><span class="sxs-lookup"><span data-stu-id="a5bce-195">At a finer grain, you can again use fences—when a command is recorded into a command list that you want to track the completion of, insert a fence immediately after it.</span></span> <span data-ttu-id="a5bce-196">A continuación, puede realizar varias operaciones de sincronización con la barrera.</span><span class="sxs-lookup"><span data-stu-id="a5bce-196">Then, you can do various synchronization operations with the fence.</span></span> <span data-ttu-id="a5bce-197">Puede enviar nuevo trabajo (listas de comandos) que espera hasta que se ha pasado una barrera especificada en la GPU, lo que indica que todo antes de que se complete, o bien puede solicitar que se genere un evento de CPU cuando se haya superado la barrera (que la aplicación puede estar esperando en un subproceso en espera).</span><span class="sxs-lookup"><span data-stu-id="a5bce-197">You submit new work (command lists) that waits until a specified fence has passed on the GPU, which indicates that everything before it is complete, or you can request that a CPU event be raised when the fence has passed (which the app can be waiting on with a sleeping thread).</span></span> <span data-ttu-id="a5bce-198">En Direct3D 11, este era `EnqueueSetEvent` ().</span><span class="sxs-lookup"><span data-stu-id="a5bce-198">In Direct3D 11, this was `EnqueueSetEvent`().</span></span>

## <a name="related-topics"></a><span data-ttu-id="a5bce-199">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="a5bce-199">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a5bce-200">Enlace de recursos</span><span class="sxs-lookup"><span data-stu-id="a5bce-200">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




