---
description: Un problema importante en la migración de aplicaciones de un entorno de sockets de Berkeley a un entorno de Windows implica el bloqueo; es decir, al invocar una función que no devuelve ningún resultado hasta que se completa la operación asociada.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Rutinas de bloqueo de Windows Sockets 1,1 y EINPROGRESS
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "105715474"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a><span data-ttu-id="cfbcc-103">Rutinas de bloqueo de Windows Sockets 1,1 y EINPROGRESS</span><span class="sxs-lookup"><span data-stu-id="cfbcc-103">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</span></span>

<span data-ttu-id="cfbcc-104">Un problema importante en la migración de aplicaciones de un entorno de sockets de Berkeley a un entorno de Windows implica el bloqueo; es decir, al invocar una función que no devuelve ningún resultado hasta que se completa la operación asociada.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-104">One major issue in porting applications from a Berkeley Sockets environment to a Windows environment involves blocking; that is, invoking a function that does not return until the associated operation is completed.</span></span> <span data-ttu-id="cfbcc-105">Surge un problema cuando la operación tarda un tiempo arbitrariamente largo en completarse: un ejemplo es una función [**RECV**](/windows/desktop/api/winsock/nf-winsock-recv) , que podría bloquearse hasta que se hayan recibido datos del sistema del mismo nivel.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-105">A problem arises when the operation takes an arbitrarily long time to complete: an example is a [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) function, which might block until data has been received from the peer system.</span></span> <span data-ttu-id="cfbcc-106">El comportamiento predeterminado dentro del modelo Berkeley sockets es para que un socket funcione en modo de bloqueo, a menos que el programador solicite explícitamente que las operaciones se traten como sin bloqueos.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-106">The default behavior within the Berkeley Sockets model is for a socket to operate in blocking mode unless the programmer explicitly requests that operations be treated as nonblocking.</span></span> <span data-ttu-id="cfbcc-107">Los entornos de Windows Sockets 1,1 no pueden suponer la programación preferente.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-107">Windows Sockets 1.1 environments could not assume preemptive scheduling.</span></span> <span data-ttu-id="cfbcc-108">Por lo tanto, se recomienda encarecidamente que los programadores usen las operaciones de no bloqueo (asincrónicas) si es posible con Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-108">Therefore, it was strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible with Windows Sockets 1.1.</span></span> <span data-ttu-id="cfbcc-109">Dado que esto no siempre era posible, se proporcionaron las instalaciones de bloqueo que se describen en lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-109">Because this was not always possible, the pseudo-blocking facilities described in the following were provided.</span></span>

> [!Note]  
> <span data-ttu-id="cfbcc-110">Windows Sockets 2 solo se ejecuta en sistemas operativos preferentemente de 32 bits en los que los interbloqueos no son un problema.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-110">Windows Sockets 2 only runs on preemptive 32-bit operating systems where deadlocks are not a problem.</span></span> <span data-ttu-id="cfbcc-111">Las prácticas de programación recomendadas para Windows Sockets 1,1 no son necesarias en Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-111">Programming practices recommended for Windows Sockets 1.1 are not necessary in Windows Sockets 2.</span></span>

 

<span data-ttu-id="cfbcc-112">Incluso en un socket de bloqueo, algunas funciones ( [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt)y [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) , por ejemplo) se completan inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-112">Even on a blocking socket, some functions — [**bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt), and [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) for example — complete immediately.</span></span> <span data-ttu-id="cfbcc-113">No hay ninguna diferencia entre un bloqueo y una operación de no bloqueo para esas funciones.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-113">There is no difference between a blocking and a nonblocking operation for those functions.</span></span> <span data-ttu-id="cfbcc-114">Otras operaciones, como [**RECV**](/windows/desktop/api/winsock/nf-winsock-recv), pueden completarse inmediatamente o tardar un tiempo arbitrario en completarse, en función de las distintas condiciones de transporte.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-114">Other operations, such as [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), can complete immediately or take an arbitrary time to complete, depending on various transport conditions.</span></span> <span data-ttu-id="cfbcc-115">Cuando se aplica a un socket de bloqueo, estas operaciones se conocen como operaciones de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-115">When applied to a blocking socket, these operations are referred to as blocking operations.</span></span> <span data-ttu-id="cfbcc-116">Las siguientes funciones pueden bloquear:</span><span class="sxs-lookup"><span data-stu-id="cfbcc-116">The following functions can block:</span></span>

-   [<span data-ttu-id="cfbcc-117">**recv**</span><span class="sxs-lookup"><span data-stu-id="cfbcc-117">**recv**</span></span>](/windows/desktop/api/winsock/nf-winsock-recv)
-   [<span data-ttu-id="cfbcc-118">**recvfrom**</span><span class="sxs-lookup"><span data-stu-id="cfbcc-118">**recvfrom**</span></span>](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [<span data-ttu-id="cfbcc-119">**Enviar**</span><span class="sxs-lookup"><span data-stu-id="cfbcc-119">**send**</span></span>](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [<span data-ttu-id="cfbcc-120">**sendto**</span><span class="sxs-lookup"><span data-stu-id="cfbcc-120">**sendto**</span></span>](/windows/desktop/api/winsock/nf-winsock-sendto)

<span data-ttu-id="cfbcc-121">Con Windows Sockets de 16 bits 1,1, una operación de bloqueo que no se puede completar inmediatamente se controla mediante el bloqueo pseudo como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-121">With 16-bit Windows Sockets 1.1, a blocking operation that cannot complete immediately is handled by pseudo-blocking as follows.</span></span>

<span data-ttu-id="cfbcc-122">El proveedor de servicios inicia la operación y, a continuación, escribe un bucle en el que envía los mensajes de Windows (lo que produce el procesador a otro subproceso, si es necesario) y, a continuación, comprueba la finalización de la función de Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-122">The service provider initiates the operation, then enters a loop in which it dispatches any Windows messages (yielding the processor to another thread, if necessary), and then checks for the completion of the Windows Sockets function.</span></span> <span data-ttu-id="cfbcc-123">Si la función se ha completado, o si se ha invocado [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) , la función de bloqueo se completa con un resultado adecuado.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-123">If the function has completed, or if [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) has been invoked, the blocking function completes with an appropriate result.</span></span>

<span data-ttu-id="cfbcc-124">Un proveedor de servicios debe permitir la instalación de una función de enlace de bloqueo que no procese mensajes para evitar la posibilidad de que se vuelvan a entrar mensajes mientras una operación de bloqueo esté pendiente.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-124">A service provider must allow installation of a blocking hook function that does not process messages in order to avoid the possibility of re-entrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="cfbcc-125">La función de enlace de bloqueo más sencilla devolverá **false**.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-125">The simplest such blocking hook function would return **FALSE**.</span></span> <span data-ttu-id="cfbcc-126">Si una DLL de Windows Sockets depende de mensajes para una operación interna, puede ejecutar **PeekMessage**(**hMyWnd**...) antes de ejecutar el enlace de bloqueo de la aplicación para que pueda obtener sus mensajes sin afectar al resto del sistema.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-126">If a Windows Sockets DLL depends on messages for internal operation, it can execute **PeekMessage**(**hMyWnd**...) before executing the application blocking hook so that it can get its messages without affecting the rest of the system.</span></span>

<span data-ttu-id="cfbcc-127">En un entorno de Windows Sockets 1,1 de 16 bits, si se recibe un mensaje de Windows para un proceso para el que está en curso una operación de bloqueo, existe el riesgo de que la aplicación intente emitir otra llamada de Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-127">In a 16-bit Windows Sockets 1.1 environment, if a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.</span></span> <span data-ttu-id="cfbcc-128">Debido a la dificultad en la administración segura de esta condición, Windows Sockets 1,1 no admite este comportamiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-128">Because of the difficulty in managing this condition safely, Windows Sockets 1.1 does not support such application behavior.</span></span> <span data-ttu-id="cfbcc-129">No se permite que una aplicación realice más de una llamada de función anidada de Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-129">An application is not permitted to make more than one nested Windows Sockets function call.</span></span> <span data-ttu-id="cfbcc-130">Solo se permite una llamada de función pendiente para una tarea determinada.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-130">Only one outstanding function call is allowed for a particular task.</span></span> <span data-ttu-id="cfbcc-131">Las únicas excepciones son dos funciones que se proporcionan para ayudar al programador en esta situación: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) y [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span><span class="sxs-lookup"><span data-stu-id="cfbcc-131">The only exceptions are two functions that are provided to assist the programmer in this situation: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) and [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span></span>

<span data-ttu-id="cfbcc-132">Se puede llamar a la función [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) en cualquier momento para determinar si una llamada de bloqueo de Windows sockets 1,1 está en curso.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-132">The [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) function can be called at any time to determine whether or not a blocking Windows Sockets 1.1 call is in progress.</span></span> <span data-ttu-id="cfbcc-133">Del mismo modo, se puede llamar a la función [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) en cualquier momento para cancelar una llamada de bloqueo en curso.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-133">Similarly, the [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) function can be called at any time to cancel an in-progress blocking call.</span></span> <span data-ttu-id="cfbcc-134">Cualquier otro anidamiento de las funciones de Windows Sockets produce el error WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-134">Any other nesting of Windows Sockets functions fails with the error WSAEINPROGRESS.</span></span>

<span data-ttu-id="cfbcc-135">Se debe resaltar que esta restricción se aplica a las operaciones de bloqueo y de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-135">It should be emphasized that this restriction applies to both blocking and nonblocking operations.</span></span> <span data-ttu-id="cfbcc-136">En el caso de las aplicaciones de Windows Sockets 2 que negocian la versión 2,0 o posterior en el momento de llamar a [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no se realiza ninguna restricción sobre el anidamiento de las operaciones.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-136">For Windows Sockets 2 applications that negotiate version 2.0 or higher at the time of calling [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no restriction on the nesting of operations exits.</span></span> <span data-ttu-id="cfbcc-137">Las operaciones se pueden anidar en raras circunstancias, como durante una devolución de llamada de aceptación condicional [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) , o si un proveedor de servicios a su vez invoca una función de Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-137">Operations can become nested under rare circumstances, such as during a [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) conditional-acceptance callback, or if a service provider in turn invokes a Windows Sockets 2 function.</span></span>

<span data-ttu-id="cfbcc-138">Aunque este mecanismo es suficiente para aplicaciones sencillas, no puede admitir los requisitos complejos de distribución de mensajes de aplicaciones más avanzadas (por ejemplo, las que usan el modelo MDI).</span><span class="sxs-lookup"><span data-stu-id="cfbcc-138">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).</span></span> <span data-ttu-id="cfbcc-139">Para estas aplicaciones, la API de Windows Sockets incluye la función [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), que permite a la aplicación especificar una rutina especial a la que se puede llamar en lugar de la rutina de envío de mensajes predeterminada que se describe en la explicación anterior.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-139">For such applications, the Windows Sockets API includes the function [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), which allows the application to specify a special routine which can be called instead of the default message dispatch routine described in the preceding discussion.</span></span>

<span data-ttu-id="cfbcc-140">El proveedor de Windows Sockets llama al enlace de bloqueo solo si se cumplen todas las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="cfbcc-140">The Windows Sockets provider calls the blocking hook only if all of the following are true:</span></span>

-   <span data-ttu-id="cfbcc-141">La rutina es una que se define como capaz de bloquearse.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-141">The routine is one that is defined as being able to block.</span></span>
-   <span data-ttu-id="cfbcc-142">El socket especificado es un socket de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-142">The specified socket is a blocking socket.</span></span>
-   <span data-ttu-id="cfbcc-143">La solicitud no se puede completar inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-143">The request cannot be completed immediately.</span></span>

<span data-ttu-id="cfbcc-144">Un socket se establece en bloque de forma predeterminada, pero la función [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) con el ioctl **FIONBIO** o la función [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) puede establecer un socket en modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-144">A socket is set to blocking by default, but the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) function with the **FIONBIO** IOCTL or the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) function can set a socket to nonblocking mode.</span></span>

<span data-ttu-id="cfbcc-145">Nunca se llama al enlace de bloqueo y la aplicación no necesita preocuparse por los problemas de reentrar que el enlace de bloqueo puede introducir, si una aplicación sigue estas instrucciones:</span><span class="sxs-lookup"><span data-stu-id="cfbcc-145">The blocking hook is never called and the application does not need to be concerned with the re-entrancy issues the blocking hook can introduce, if an application follows these guidelines:</span></span>

-   <span data-ttu-id="cfbcc-146">Solo usa Sockets sin bloqueos.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-146">It uses only nonblocking sockets.</span></span>
-   <span data-ttu-id="cfbcc-147">Usa las rutinas [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) y/o **WSAAsyncGetXByY** en lugar de las rutinas [**Select**](/windows/desktop/api/Winsock2/nf-winsock2-select) y **getXbyY** .</span><span class="sxs-lookup"><span data-stu-id="cfbcc-147">It uses the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and/or the **WSAAsyncGetXByY** routines instead of [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and the **getXbyY** routines.</span></span>

<span data-ttu-id="cfbcc-148">Si una aplicación de Windows Sockets 1,1 invoca una operación asincrónica o de no bloqueo que toma un puntero a un objeto de memoria (un búfer o una variable global, por ejemplo) como argumento, es responsabilidad de la aplicación asegurarse de que el objeto está disponible para Windows Sockets durante toda la operación.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-148">If a Windows Sockets 1.1 application invokes an asynchronous or nonblocking operation that takes a pointer to a memory object (a buffer or a global variable, for example) as an argument, it is the responsibility of the application to ensure that the object is available to Windows Sockets throughout the operation.</span></span> <span data-ttu-id="cfbcc-149">La aplicación no debe invocar ninguna función de Windows que pueda afectar a la viabilidad de asignación o de dirección de la memoria implicada.</span><span class="sxs-lookup"><span data-stu-id="cfbcc-149">The application must not invoke any Windows function that might affect the mapping or address viability of the memory involved.</span></span>

 

 



