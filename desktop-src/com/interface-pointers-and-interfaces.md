---
title: Interface Pointers and Interfaces (Punteros de interfaz e interfaces)
description: Interface Pointers and Interfaces (Punteros de interfaz e interfaces)
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/24/2019
ms.locfileid: "105704559"
---
# <a name="interface-pointers-and-interfaces"></a><span data-ttu-id="6f22a-103">Interface Pointers and Interfaces (Punteros de interfaz e interfaces)</span><span class="sxs-lookup"><span data-stu-id="6f22a-103">Interface Pointers and Interfaces</span></span>

<span data-ttu-id="6f22a-104">Una instancia de una implementación de interfaz es, en realidad, un puntero a una matriz de punteros a métodos, es decir, una tabla de funciones que hace referencia a una implementación de todos los métodos especificados en la interfaz.</span><span class="sxs-lookup"><span data-stu-id="6f22a-104">An instance of an interface implementation is actually a pointer to an array of pointers to methods - that is, a function table that refers to an implementation of all of the methods specified in the interface.</span></span> <span data-ttu-id="6f22a-105">Los objetos con varias interfaces pueden proporcionar punteros a más de una tabla de funciones.</span><span class="sxs-lookup"><span data-stu-id="6f22a-105">Objects with multiple interfaces can provide pointers to more than one function table.</span></span> <span data-ttu-id="6f22a-106">Cualquier código que tenga un puntero a través del que pueda tener acceso a la matriz puede llamar a los métodos de esa interfaz.</span><span class="sxs-lookup"><span data-stu-id="6f22a-106">Any code that has a pointer through which it can access the array can call the methods in that interface.</span></span>

<span data-ttu-id="6f22a-107">Hablar precisamente sobre este direccionamiento indirecto no es práctico, por lo que en su lugar, el puntero a la tabla de la función de interfaz que otro objeto debe tener para llamar a sus métodos se llama simplemente un *puntero de interfaz*.</span><span class="sxs-lookup"><span data-stu-id="6f22a-107">Speaking precisely about this multiple indirection is inconvenient, so instead, the pointer to the interface function table that another object must have to call its methods is called simply an *interface pointer*.</span></span> <span data-ttu-id="6f22a-108">Puede crear tablas de funciones de forma manual en una aplicación de C o casi automáticamente mediante Visual C++ (u otros lenguajes orientados a objetos que admitan COM).</span><span class="sxs-lookup"><span data-stu-id="6f22a-108">You can manually create function tables in a C application or almost automatically by using Visual C++ (or other object-oriented languages that support COM).</span></span>

<span data-ttu-id="6f22a-109">Con la compatibilidad del compilador adecuada (que es inherente en C y C++), un cliente puede llamar a un método de interfaz a través de su nombre, no su posición en la matriz.</span><span class="sxs-lookup"><span data-stu-id="6f22a-109">With appropriate compiler support (which is inherent in C and C++), a client can call an interface method through its name, not its position in the array.</span></span> <span data-ttu-id="6f22a-110">Dado que una interfaz es un tipo, el compilador, dados los nombres de los métodos, puede comprobar los tipos de parámetros y valores devueltos de cada llamada al método de interfaz.</span><span class="sxs-lookup"><span data-stu-id="6f22a-110">Because an interface is a type, the compiler, given the names of methods, can check the types of parameters and return values of each interface method call.</span></span> <span data-ttu-id="6f22a-111">En cambio, si un cliente utiliza un esquema de llamada basado en la posición, esta comprobación de tipos no está disponible, ni siquiera en C o C++.</span><span class="sxs-lookup"><span data-stu-id="6f22a-111">In contrast, if a client uses a position-based calling scheme, such type-checking is not available, even in C or C++.</span></span>

<span data-ttu-id="6f22a-112">Cada interfaz es un contrato inmutable de un grupo funcional de métodos.</span><span class="sxs-lookup"><span data-stu-id="6f22a-112">Each interface is an immutable contract of a functional group of methods.</span></span> <span data-ttu-id="6f22a-113">Se hace referencia a una interfaz en tiempo de ejecución con un identificador de interfaz único global (IID).</span><span class="sxs-lookup"><span data-stu-id="6f22a-113">You reference an interface at run time with a globally unique interface identifier (IID).</span></span> <span data-ttu-id="6f22a-114">Este IID, que es una instancia específica de un identificador único global (GUID) compatible con COM, permite a un cliente preguntar a un objeto con precisión si admite la semántica de la interfaz, sin una sobrecarga innecesaria y sin que la confusión que podría surgir en un sistema tenga varias versiones de la misma interfaz con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="6f22a-114">This IID, which is a specific instance of a globally unique identifier (GUID) supported by COM, allows a client to ask an object precisely whether it supports the semantics of the interface, without unnecessary overhead and without the confusion that could arise in a system from having multiple versions of the same interface with the same name.</span></span>

<span data-ttu-id="6f22a-115">En Resumen, es importante comprender qué es una interfaz COM y qué no:</span><span class="sxs-lookup"><span data-stu-id="6f22a-115">To summarize, it is important to understand what a COM interface is, and is not:</span></span>

-   <span data-ttu-id="6f22a-116">Una interfaz COM no es lo mismo que una clase de C++.</span><span class="sxs-lookup"><span data-stu-id="6f22a-116">A COM interface is not the same as a C++ class.</span></span> <span data-ttu-id="6f22a-117">La definición virtual pura no tiene ninguna implementación.</span><span class="sxs-lookup"><span data-stu-id="6f22a-117">The pure virtual definition carries no implementation.</span></span> <span data-ttu-id="6f22a-118">Si es un programador de C++, puede definir la implementación de una interfaz como una clase, pero se encuentra en el encabezado de los detalles de implementación, que COM no especifica.</span><span class="sxs-lookup"><span data-stu-id="6f22a-118">If you are a C++ programmer, you can define your implementation of an interface as a class, but this falls under the heading of implementation details, which COM does not specify.</span></span> <span data-ttu-id="6f22a-119">Se debe crear una instancia de un objeto que implementa una interfaz para que la interfaz exista realmente.</span><span class="sxs-lookup"><span data-stu-id="6f22a-119">An instance of an object that implements an interface must be created for the interface actually to exist.</span></span> <span data-ttu-id="6f22a-120">Además, las distintas clases de objeto pueden implementar una interfaz de forma diferente, pero se pueden usar indistintamente en formato binario, siempre y cuando el comportamiento se ajuste a la definición de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="6f22a-120">Furthermore, different object classes may implement an interface differently yet be used interchangeably in binary form, as long as the behavior conforms to the interface definition.</span></span>
-   <span data-ttu-id="6f22a-121">Una interfaz COM no es un objeto.</span><span class="sxs-lookup"><span data-stu-id="6f22a-121">A COM interface is not an object.</span></span> <span data-ttu-id="6f22a-122">Es simplemente un grupo relacionado de funciones y es el estándar binario a través del cual se comunican los clientes y los objetos.</span><span class="sxs-lookup"><span data-stu-id="6f22a-122">It is simply a related group of functions and is the binary standard through which clients and objects communicate.</span></span> <span data-ttu-id="6f22a-123">Siempre y cuando pueda proporcionar punteros a métodos de interfaz, el objeto se puede implementar en cualquier lenguaje con cualquier representación de estado interno.</span><span class="sxs-lookup"><span data-stu-id="6f22a-123">As long as it can provide pointers to interface methods, the object can be implemented in any language with any internal state representation.</span></span>
-   <span data-ttu-id="6f22a-124">Las interfaces COM están fuertemente tipadas.</span><span class="sxs-lookup"><span data-stu-id="6f22a-124">COM interfaces are strongly typed.</span></span> <span data-ttu-id="6f22a-125">Cada interfaz tiene su propio identificador de interfaz (un GUID), que elimina la posibilidad de que se produzcan duplicaciones con cualquier otro esquema de nomenclatura.</span><span class="sxs-lookup"><span data-stu-id="6f22a-125">Every interface has its own interface identifier (a GUID), which eliminates the possibility of duplication that could occur with any other naming scheme.</span></span>
-   <span data-ttu-id="6f22a-126">Las interfaces COM son inmutables.</span><span class="sxs-lookup"><span data-stu-id="6f22a-126">COM interfaces are immutable.</span></span> <span data-ttu-id="6f22a-127">No se puede definir una nueva versión de una interfaz antigua y asignarle el mismo identificador.</span><span class="sxs-lookup"><span data-stu-id="6f22a-127">You cannot define a new version of an old interface and give it the same identifier.</span></span> <span data-ttu-id="6f22a-128">Al agregar o quitar métodos de una interfaz o cambiar la semántica, se crea una nueva interfaz, no una nueva versión de una interfaz antigua.</span><span class="sxs-lookup"><span data-stu-id="6f22a-128">Adding or removing methods of an interface or changing semantics creates a new interface, not a new version of an old interface.</span></span> <span data-ttu-id="6f22a-129">Por lo tanto, una nueva interfaz no puede entrar en conflicto con una interfaz antigua.</span><span class="sxs-lookup"><span data-stu-id="6f22a-129">Therefore, a new interface cannot conflict with an old interface.</span></span> <span data-ttu-id="6f22a-130">Sin embargo, los objetos pueden admitir varias interfaces simultáneamente y pueden exponer interfaces que son revisiones sucesivas de una interfaz, con identificadores diferentes.</span><span class="sxs-lookup"><span data-stu-id="6f22a-130">However, objects can support multiple interfaces simultaneously and can expose interfaces that are successive revisions of an interface, with different identifiers.</span></span> <span data-ttu-id="6f22a-131">Por lo tanto, cada interfaz es un contrato independiente y no es necesario que los objetos del sistema en todo el sistema estén relacionados con si la versión de la interfaz a la que se está llamando es la esperada.</span><span class="sxs-lookup"><span data-stu-id="6f22a-131">Thus, each interface is a separate contract, and systemwide objects need not be concerned about whether the version of the interface they are calling is the one they expect.</span></span> <span data-ttu-id="6f22a-132">El identificador de interfaz (IID) define el contrato de la interfaz de forma explícita y exclusiva.</span><span class="sxs-lookup"><span data-stu-id="6f22a-132">The interface ID (IID) defines the interface contract explicitly and uniquely.</span></span>

## <a name="related-topics"></a><span data-ttu-id="6f22a-133">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="6f22a-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6f22a-134">Objetos e interfaces COM</span><span class="sxs-lookup"><span data-stu-id="6f22a-134">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




