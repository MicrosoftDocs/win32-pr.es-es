---
title: Reglas de administración de memoria
description: Reglas de administración de memoria
ms.assetid: 769127a1-1a14-4ed4-9d38-7cf3e571b661
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 56e7ad2483b794ec5c2e9c325bca8e469ff4ae0b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/21/2020
ms.locfileid: "104149673"
---
# <a name="memory-management-rules"></a><span data-ttu-id="d80d4-103">Reglas de administración de memoria</span><span class="sxs-lookup"><span data-stu-id="d80d4-103">Memory Management Rules</span></span>

<span data-ttu-id="d80d4-104">La duración de los punteros a las interfaces siempre se administra a través de los métodos [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) y [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) en cada interfaz com.</span><span class="sxs-lookup"><span data-stu-id="d80d4-104">The lifetime of pointers to interfaces is always managed through the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods on every COM interface.</span></span> <span data-ttu-id="d80d4-105">Para obtener más información, vea [rules for Managing Reference Counts](rules-for-managing-reference-counts.md).</span><span class="sxs-lookup"><span data-stu-id="d80d4-105">For more information, see [Rules for Managing Reference Counts](rules-for-managing-reference-counts.md).</span></span>

<span data-ttu-id="d80d4-106">En el caso de todos los demás parámetros, es importante cumplir ciertas reglas para administrar la memoria.</span><span class="sxs-lookup"><span data-stu-id="d80d4-106">For all other parameters, it is important to adhere to certain rules for managing memory.</span></span> <span data-ttu-id="d80d4-107">Las siguientes reglas se aplican a todos los parámetros de la interfaz methodsâ ", incluido el valor devuelto valueâ €" que no se pasan por valor:</span><span class="sxs-lookup"><span data-stu-id="d80d4-107">The following rules apply to all parameters of interface methodsâ€”including the return valueâ€”that are not passed by value:</span></span>

-   <span data-ttu-id="d80d4-108">El autor de la llamada debe asignar y liberar los parámetros in-.</span><span class="sxs-lookup"><span data-stu-id="d80d4-108">In-parameters must be allocated and freed by the caller.</span></span>
-   <span data-ttu-id="d80d4-109">Out-Parameters debe ser asignado por el llamado; los libera el autor de la llamada mediante el asignador de memoria de tareas COM estándar.</span><span class="sxs-lookup"><span data-stu-id="d80d4-109">Out-parameters must be allocated by the one called; they are freed by the caller using the standard COM task memory allocator.</span></span> <span data-ttu-id="d80d4-110">Para obtener más información, vea [asignador de memoria OLE](the-ole-memory-allocator.md) .</span><span class="sxs-lookup"><span data-stu-id="d80d4-110">See [The OLE Memory Allocator](the-ole-memory-allocator.md) for more information.</span></span>
-   <span data-ttu-id="d80d4-111">Los parámetros in/out-se asignan inicialmente mediante el autor de la llamada y, a continuación, se liberan y reasignan mediante el llamado, si es necesario.</span><span class="sxs-lookup"><span data-stu-id="d80d4-111">In/out-parameters are initially allocated by the caller, and then freed and reallocated by the one called, if necessary.</span></span> <span data-ttu-id="d80d4-112">Como sucede con los parámetros out, el llamador es responsable de liberar el valor devuelto final.</span><span class="sxs-lookup"><span data-stu-id="d80d4-112">As is true for out parameters, the caller is responsible for freeing the final returned value.</span></span> <span data-ttu-id="d80d4-113">Se debe utilizar el asignador de memoria COM estándar.</span><span class="sxs-lookup"><span data-stu-id="d80d4-113">The standard COM memory allocator must be used.</span></span>

<span data-ttu-id="d80d4-114">En los dos últimos casos, en los que un fragmento de código asigna la memoria y otro fragmento de código la libera, el asignador COM garantiza que los dos fragmentos de código usen los mismos métodos de asignación.</span><span class="sxs-lookup"><span data-stu-id="d80d4-114">In the latter two cases, where one piece of code allocates the memory and a different piece of code frees it, using the COM allocator ensures that the two pieces of code are using the same allocation methods.</span></span>

<span data-ttu-id="d80d4-115">Otra área que necesita atención especial es el tratamiento de los parámetros out y out en las condiciones de error.</span><span class="sxs-lookup"><span data-stu-id="d80d4-115">Another area that needs special attention is the treatment of out and in-out parameters in failure conditions.</span></span> <span data-ttu-id="d80d4-116">Si una función devuelve un código de error, el llamador normalmente no tiene ninguna manera de limpiar los parámetros out o out.</span><span class="sxs-lookup"><span data-stu-id="d80d4-116">If a function returns a failure code, the caller typically has no way to clean up the out or in-out parameters.</span></span> <span data-ttu-id="d80d4-117">Esto conduce a las siguientes reglas adicionales:</span><span class="sxs-lookup"><span data-stu-id="d80d4-117">This leads to the following additional rules:</span></span>

-   <span data-ttu-id="d80d4-118">En el caso de una condición de error, los parámetros siempre se deben establecer de forma confiable en un valor que se limpie sin ninguna acción por parte del llamador.</span><span class="sxs-lookup"><span data-stu-id="d80d4-118">In case of an error condition, parameters must always be reliably set to a value that will be cleaned up without any action by the caller.</span></span>
-   <span data-ttu-id="d80d4-119">Todos los parámetros de puntero se deben establecer explícitamente en **null**.</span><span class="sxs-lookup"><span data-stu-id="d80d4-119">All out pointer parameters must explicitly be set to **NULL**.</span></span> <span data-ttu-id="d80d4-120">Normalmente se pasan en un parámetro de puntero a puntero, pero también se pueden pasar como miembros de una estructura que el autor de la llamada asigna y se rellena el código llamado.</span><span class="sxs-lookup"><span data-stu-id="d80d4-120">These are usually passed in a pointer-to-pointer parameter but can also be passed as members of a structure that the caller allocates and the called code fills.</span></span> <span data-ttu-id="d80d4-121">La manera más sencilla de asegurarse de esto es (en parte) establecer estos valores en **null** en la entrada de la función.</span><span class="sxs-lookup"><span data-stu-id="d80d4-121">The most straightforward way to ensure this is (in part) to set these values to **NULL** on function entry.</span></span> <span data-ttu-id="d80d4-122">Esta regla es importante porque promueve una interoperabilidad de aplicaciones más sólida.</span><span class="sxs-lookup"><span data-stu-id="d80d4-122">This rule is important because it promotes more robust application interoperability.</span></span>
-   <span data-ttu-id="d80d4-123">En condiciones de error, todos los parámetros de salida deben dejarse solo por el código llamado (que permanece en el valor al que el llamador ha inicializado) o establecerse explícitamente, como en el caso de devolución de error del parámetro out.</span><span class="sxs-lookup"><span data-stu-id="d80d4-123">Under error conditions, all in-out parameters must either be left alone by the code called (thus remaining at the value to which they were initialized by the caller) or be explicitly set, as in the out parameter error return case.</span></span>

<span data-ttu-id="d80d4-124">Recuerde que estas convenciones de administración de memoria para las aplicaciones COM se aplican solo a través de las interfaces públicas y APIsâ "no hay ningún requisito en todo lo que la asignación de memoria es estrictamente interna para una aplicación COM debe realizarse mediante estos mecanismos.</span><span class="sxs-lookup"><span data-stu-id="d80d4-124">Remember that these memory management conventions for COM applications apply only across public interfaces and APIsâ€”there is no requirement at all that memory allocation strictly internal to a COM application need be done using these mechanisms.</span></span>

<span data-ttu-id="d80d4-125">COM utiliza internamente llamadas a procedimiento remoto (RPC) para comunicarse entre clientes y servidores.</span><span class="sxs-lookup"><span data-stu-id="d80d4-125">COM internally uses Remote Procedure Calls (RPC) to communicate between clients and servers.</span></span> <span data-ttu-id="d80d4-126">Para obtener más información acerca de la administración de memoria en códigos auxiliares de servidor RPC, consulte el tema [Server-stub Memory Management](../rpc/server-stub-memory-management.md) .</span><span class="sxs-lookup"><span data-stu-id="d80d4-126">For more information about managing memory in RPC server stubs, see the [Server-stub Memory Management](../rpc/server-stub-memory-management.md) topic.</span></span>

## <a name="related-topics"></a><span data-ttu-id="d80d4-127">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="d80d4-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d80d4-128">Administrar la asignación de memoria</span><span class="sxs-lookup"><span data-stu-id="d80d4-128">Managing Memory Allocation</span></span>](managing-memory-allocation.md)
</dt> </dl>

 

 