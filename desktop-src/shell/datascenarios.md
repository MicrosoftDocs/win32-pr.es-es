---
description: Este documento presenta escenarios comunes de transferencia de datos de Shell y describe cómo implementar cada uno de ellos en la aplicación.
ms.assetid: 7fce555c-a93d-4414-9119-7ae9acdd4d89
title: Control de escenarios de transferencia de datos de shell
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35855b66e4108580d5bac305855837563ca59785
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "104984318"
---
# <a name="handling-shell-data-transfer-scenarios"></a><span data-ttu-id="28180-103">Control de escenarios de transferencia de datos de shell</span><span class="sxs-lookup"><span data-stu-id="28180-103">Handling Shell Data Transfer Scenarios</span></span>

<span data-ttu-id="28180-104">En el documento de [objeto de datos de Shell](dataobject.md) se describe el enfoque general que se usa para transferir datos de Shell con arrastrar y colocar o el portapapeles.</span><span class="sxs-lookup"><span data-stu-id="28180-104">The [Shell Data Object](dataobject.md) document discussed the general approach that is used to transfer Shell data with drag-and-drop or the Clipboard.</span></span> <span data-ttu-id="28180-105">Sin embargo, para implementar la transferencia de datos de Shell en la aplicación, también debe comprender cómo aplicar estos principios y técnicas generales a las diversas formas en que se pueden transferir los datos de Shell.</span><span class="sxs-lookup"><span data-stu-id="28180-105">However, to implement Shell data transfer in your application, you must also understand how to apply these general principles and techniques to the variety of ways that Shell data can be transferred.</span></span> <span data-ttu-id="28180-106">Este documento presenta escenarios comunes de transferencia de datos de Shell y describe cómo implementar cada uno de ellos en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-106">This document presents common Shell data transfer scenarios and discusses how to implement each one in your application.</span></span>

-   [<span data-ttu-id="28180-107">Directrices generales</span><span class="sxs-lookup"><span data-stu-id="28180-107">General Guidelines</span></span>](#general-guidelines)
-   [<span data-ttu-id="28180-108">Copiar nombres de archivo del portapapeles en una aplicación</span><span class="sxs-lookup"><span data-stu-id="28180-108">Copying File Names from the Clipboard to an Application</span></span>](#copying-file-names-from-the-clipboard-to-an-application)
    -   [<span data-ttu-id="28180-109">Extraer los nombres de archivo del objeto de datos</span><span class="sxs-lookup"><span data-stu-id="28180-109">Extracting the File Names from the Data Object</span></span>](#extracting-the-file-names-from-the-data-object)
-   [<span data-ttu-id="28180-110">Copiar el contenido de un archivo colocado en una aplicación</span><span class="sxs-lookup"><span data-stu-id="28180-110">Copying the Contents of a Dropped File into an Application</span></span>](#copying-the-contents-of-a-dropped-file-into-an-application)
    -   [<span data-ttu-id="28180-111">Usar el \_ formato CFSTR FILECONTENTS para extraer datos de un archivo</span><span class="sxs-lookup"><span data-stu-id="28180-111">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>](/windows)
-   [<span data-ttu-id="28180-112">Control de operaciones de movimiento optimizadas</span><span class="sxs-lookup"><span data-stu-id="28180-112">Handling Optimized Move Operations</span></span>](#handling-optimized-move-operations)
-   [<span data-ttu-id="28180-113">Control de operaciones de eliminación y pegado</span><span class="sxs-lookup"><span data-stu-id="28180-113">Handling Delete-on-Paste Operations</span></span>](#handling-delete-on-paste-operations)
-   [<span data-ttu-id="28180-114">Transferencia de datos hacia y desde carpetas virtuales</span><span class="sxs-lookup"><span data-stu-id="28180-114">Transfering Data to and from Virtual Folders</span></span>](#transfering-data-to-and-from-virtual-folders)
    -   [<span data-ttu-id="28180-115">Aceptar datos de una carpeta virtual</span><span class="sxs-lookup"><span data-stu-id="28180-115">Accepting Data from a Virtual Folder</span></span>](#accepting-data-from-a-virtual-folder)
    -   [<span data-ttu-id="28180-116">Transferir datos hacia y desde una extensión de espacio de nombres</span><span class="sxs-lookup"><span data-stu-id="28180-116">Transferring Data to and from a NameSpace Extension</span></span>](#transferring-data-to-and-from-a-namespace-extension)
-   [<span data-ttu-id="28180-117">Quitar archivos de la papelera de reciclaje</span><span class="sxs-lookup"><span data-stu-id="28180-117">Dropping Files on the Recycle Bin</span></span>](#dropping-files-on-the-recycle-bin)
-   [<span data-ttu-id="28180-118">Crear e importar archivos de rechazo</span><span class="sxs-lookup"><span data-stu-id="28180-118">Creating and Importing Scrap Files</span></span>](#creating-and-importing-scrap-files)
    -   [<span data-ttu-id="28180-119">Compatibilidad con acciones de ida y vuelta</span><span class="sxs-lookup"><span data-stu-id="28180-119">Round-trip Support</span></span>](#round-trip-support)
    -   [<span data-ttu-id="28180-120">Formatos de datos almacenados en caché</span><span class="sxs-lookup"><span data-stu-id="28180-120">Cached Data Formats</span></span>](#cached-data-formats)
    -   [<span data-ttu-id="28180-121">Representación diferida</span><span class="sxs-lookup"><span data-stu-id="28180-121">Delayed Rendering</span></span>](#delayed-rendering)
-   [<span data-ttu-id="28180-122">Arrastrar y colocar objetos de Shell de forma asincrónica</span><span class="sxs-lookup"><span data-stu-id="28180-122">Dragging and Dropping Shell Objects Asynchronously</span></span>](#dragging-and-dropping-shell-objects-asynchronously)
    -   [<span data-ttu-id="28180-123">Usar IASyncOperation/IDataObjectAsyncCapability</span><span class="sxs-lookup"><span data-stu-id="28180-123">Using IASyncOperation/IDataObjectAsyncCapability</span></span>](#using-iasyncoperationidataobjectasynccapability)

> [!Note]  
> <span data-ttu-id="28180-124">Aunque cada uno de estos escenarios trata una operación de transferencia de datos específica, muchas de ellas se aplican a una serie de escenarios relacionados.</span><span class="sxs-lookup"><span data-stu-id="28180-124">Although each of these scenarios discusses a specific data transfer operation, many of them apply to a variety of related scenarios.</span></span> <span data-ttu-id="28180-125">Por ejemplo, la principal diferencia entre la mayoría de las transferencias de Portapapeles y de arrastrar y colocar es el modo en que el objeto de datos llega al destino.</span><span class="sxs-lookup"><span data-stu-id="28180-125">For instance, the primary difference between most Clipboard and drag-and-drop transfers is in how the data object arrives at the target.</span></span> <span data-ttu-id="28180-126">Una vez que el destino tiene un puntero a la interfaz [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) del objeto de datos, los procedimientos para extraer información son en gran medida los mismos para ambos tipos de transferencia de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-126">Once the target has a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, the procedures for extracting information are largely the same for both types of data transfer.</span></span> <span data-ttu-id="28180-127">Sin embargo, algunos de los escenarios se limitan a un tipo de operación específico.</span><span class="sxs-lookup"><span data-stu-id="28180-127">However, some of the scenarios are limited to a specific type of operation.</span></span> <span data-ttu-id="28180-128">Consulte el escenario individual para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="28180-128">Refer to the individual scenario for details.</span></span>

 

## <a name="general-guidelines"></a><span data-ttu-id="28180-129">Instrucciones generales</span><span class="sxs-lookup"><span data-stu-id="28180-129">General Guidelines</span></span>

<span data-ttu-id="28180-130">En cada una de las secciones siguientes se describe un escenario de transferencia de datos único y bastante específico.</span><span class="sxs-lookup"><span data-stu-id="28180-130">Each of the following sections discusses a single, fairly specific data transfer scenario.</span></span> <span data-ttu-id="28180-131">Sin embargo, las transferencias de datos suelen ser más complejas y pueden implicar aspectos de varios escenarios.</span><span class="sxs-lookup"><span data-stu-id="28180-131">However, data transfers are often more complex and might involve aspects of several scenarios.</span></span> <span data-ttu-id="28180-132">Por lo general, no sabe de antemano qué escenario necesitará controlar.</span><span class="sxs-lookup"><span data-stu-id="28180-132">You typically do not know, in advance, which scenario you will actually need to handle.</span></span> <span data-ttu-id="28180-133">Estas son algunas directrices generales que se deben tener en cuenta.</span><span class="sxs-lookup"><span data-stu-id="28180-133">Here are a few general guidelines to keep in mind.</span></span>

<span data-ttu-id="28180-134">Para orígenes de datos:</span><span class="sxs-lookup"><span data-stu-id="28180-134">For data sources:</span></span>

-   <span data-ttu-id="28180-135">Los formatos del portapapeles de Shell, con la excepción de [CF \_ HDROP](clipboard.md), no están predefinidos.</span><span class="sxs-lookup"><span data-stu-id="28180-135">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="28180-136">Cada formato que desee usar debe registrarse mediante una llamada a [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span><span class="sxs-lookup"><span data-stu-id="28180-136">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="28180-137">Los formatos de los objetos de datos se proporcionan en el orden de preferencia del origen.</span><span class="sxs-lookup"><span data-stu-id="28180-137">The formats in the data objects are provided in the order of preference from the source.</span></span> <span data-ttu-id="28180-138">Enumere el objeto de datos y elija el primero que puede consumir.</span><span class="sxs-lookup"><span data-stu-id="28180-138">Enumerate the data object and pick the first one you can consume.</span></span>
-   <span data-ttu-id="28180-139">Incluya tantos formatos como pueda admitir.</span><span class="sxs-lookup"><span data-stu-id="28180-139">Include as many formats as you can support.</span></span> <span data-ttu-id="28180-140">Por lo general, no sabe dónde se quitará el objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-140">You generally do not know where the data object will be dropped.</span></span> <span data-ttu-id="28180-141">Esta práctica mejora la probabilidad de que el objeto de datos contenga un formato que pueda aceptar el destino de colocación.</span><span class="sxs-lookup"><span data-stu-id="28180-141">This practice improves the odds that the data object will contain a format that the drop target can accept.</span></span>
-   <span data-ttu-id="28180-142">Los archivos existentes se deben ofrecer con el formato [ \_ HDROP de CF](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-142">Existing files should be offered with the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="28180-143">Ofrezca datos similares a los archivos con formatos de [CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-143">Offer file-like data with [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="28180-144">Este enfoque permite al destino crear un archivo a partir de un objeto de datos sin necesidad de saber nada sobre el almacenamiento de datos subyacente.</span><span class="sxs-lookup"><span data-stu-id="28180-144">This approach allows the target to create a file from a data object without needing to know anything about the underlying data storage.</span></span> <span data-ttu-id="28180-145">Normalmente debería presentar los datos como una interfaz [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="28180-145">You should normally present the data as an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span> <span data-ttu-id="28180-146">Este mecanismo de transferencia de datos es más flexible que un objeto de memoria global y utiliza mucha menos memoria.</span><span class="sxs-lookup"><span data-stu-id="28180-146">This data transfer mechanism is more flexible than a global memory object and uses much less memory.</span></span>
-   <span data-ttu-id="28180-147">Los orígenes de arrastre deben ofrecer el formato [CFSTR \_ SHELLIDLIST](clipboard.md) al arrastrar elementos de Shell.</span><span class="sxs-lookup"><span data-stu-id="28180-147">Drag sources should offer the [CFSTR\_SHELLIDLIST](clipboard.md) format when dragging Shell items.</span></span> <span data-ttu-id="28180-148">Los objetos de datos de los elementos se pueden adquirir a través de los métodos [**IShellFolder:: GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) o [**IShellItem:: BindToHandler**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) .</span><span class="sxs-lookup"><span data-stu-id="28180-148">Data objects for items can be acquired through either the [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) or [**IShellItem::BindToHandler**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) methods.</span></span> <span data-ttu-id="28180-149">Los orígenes de datos pueden crear una implementación de objeto de datos estándar que admita el formato [ \_ SHELLIDLIST de CFSTR](clipboard.md) con [**SHCreateDataObject**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).</span><span class="sxs-lookup"><span data-stu-id="28180-149">Data sources can create a standard data object implementation that supports the [CFSTR\_SHELLIDLIST](clipboard.md) format by using [**SHCreateDataObject**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).</span></span>
-   <span data-ttu-id="28180-150">Los destinos de colocación que deseen saber sobre los elementos que se arrastran mediante el modelo de programación de elementos de Shell pueden convertir un objeto IDataObject en un [**IShellItemArray**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) con [**SHCreateShellItemArrayFromDataObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).</span><span class="sxs-lookup"><span data-stu-id="28180-150">Drop targets that want to reason about the items being dragged using the shell item programming model can convert an IDataObject into an [**IShellItemArray**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) using [**SHCreateShellItemArrayFromDataObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).</span></span>
-   <span data-ttu-id="28180-151">Usar cursores de comentarios estándar.</span><span class="sxs-lookup"><span data-stu-id="28180-151">Use standard feedback cursors.</span></span>
-   <span data-ttu-id="28180-152">Compatibilidad con arrastrar a la izquierda y a la derecha.</span><span class="sxs-lookup"><span data-stu-id="28180-152">Support left and right drag.</span></span>
-   <span data-ttu-id="28180-153">Usar el propio objeto de datos a partir de un objeto incrustado.</span><span class="sxs-lookup"><span data-stu-id="28180-153">Use the data object itself from an embedded object.</span></span> <span data-ttu-id="28180-154">Este enfoque permite que la aplicación recupere cualquier formato adicional que tenga el objeto de datos para ofrecer y evitar la creación de una capa adicional de contención.</span><span class="sxs-lookup"><span data-stu-id="28180-154">This approach allows your application to retrieve any extra formats the data object has to offer and avoids creating an extra layer of containment.</span></span> <span data-ttu-id="28180-155">Por ejemplo, un objeto incrustado del servidor A se arrastra desde el servidor o contenedor B y se coloca en el contenedor C. C debe crear un objeto incrustado del servidor A, no un objeto incrustado del servidor B que contiene un objeto incrustado del servidor A.</span><span class="sxs-lookup"><span data-stu-id="28180-155">For instance, an embedded object from server A is dragged from server/container B and dropped on container C. C should create an embedded object of server A, not an embedded object of server B containing an embedded object of server A.</span></span>
-   <span data-ttu-id="28180-156">Recuerde que el shell podría usar las operaciones [de eliminación o eliminación](#handling-delete-on-paste-operations) [optimizadas](#handling-optimized-move-operations) al mover archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-156">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="28180-157">La aplicación debe ser capaz de reconocer estas operaciones y responder de forma adecuada.</span><span class="sxs-lookup"><span data-stu-id="28180-157">Your application should be able to recognize these operations and respond appropriately.</span></span>

<span data-ttu-id="28180-158">Para destinos de datos:</span><span class="sxs-lookup"><span data-stu-id="28180-158">For data targets:</span></span>

-   <span data-ttu-id="28180-159">Los formatos del portapapeles de Shell, con la excepción de [CF \_ HDROP](clipboard.md), no están predefinidos.</span><span class="sxs-lookup"><span data-stu-id="28180-159">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="28180-160">Cada formato que desee usar debe registrarse mediante una llamada a [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span><span class="sxs-lookup"><span data-stu-id="28180-160">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="28180-161">Implemente y registre un destino de colocación OLE.</span><span class="sxs-lookup"><span data-stu-id="28180-161">Implement and register an OLE drop target.</span></span> <span data-ttu-id="28180-162">Evite el uso de destinos de Windows 3,1 o el mensaje de [**\_ DROPFILES de WM**](wm-dropfiles.md) , si es posible.</span><span class="sxs-lookup"><span data-stu-id="28180-162">Avoid using Windows 3.1 targets or the [**WM\_DROPFILES**](wm-dropfiles.md) message, if possible.</span></span>
-   <span data-ttu-id="28180-163">Los formatos contenidos en un objeto de datos varían en función de dónde proceda el objeto.</span><span class="sxs-lookup"><span data-stu-id="28180-163">The formats contained by a data object vary, depending on where the object comes from.</span></span> <span data-ttu-id="28180-164">Dado que generalmente no se sabe de antemano de dónde procede un objeto de datos, no suponga que un determinado formato estará presente.</span><span class="sxs-lookup"><span data-stu-id="28180-164">Since you generally do not know in advance where a data object comes from, do not assume that a particular format will be present.</span></span> <span data-ttu-id="28180-165">El objeto de datos debe enumerar los formatos en orden de calidad, empezando por el mejor.</span><span class="sxs-lookup"><span data-stu-id="28180-165">The data object should enumerate the formats in order of quality, starting with the best.</span></span> <span data-ttu-id="28180-166">Por lo tanto, para obtener el mejor formato disponible, las aplicaciones suelen enumerar los formatos disponibles y usar el primer formato en la enumeración que pueden admitir.</span><span class="sxs-lookup"><span data-stu-id="28180-166">Thus, to get the best available format, applications normally enumerate the available formats and use the first format in the enumeration that they can support.</span></span>
-   <span data-ttu-id="28180-167">Compatibilidad con la función de arrastrar hacia la derecha.</span><span class="sxs-lookup"><span data-stu-id="28180-167">Support right-drag.</span></span> <span data-ttu-id="28180-168">Puede personalizar el menú contextual de arrastrar mediante la creación de un [controlador de arrastrar y colocar](context-menu-handlers.md).</span><span class="sxs-lookup"><span data-stu-id="28180-168">You can customize the drag shortcut menu by creating a [drag-and-drop handler](context-menu-handlers.md).</span></span>
-   <span data-ttu-id="28180-169">Si la aplicación va a aceptar archivos existentes, debe ser capaz de controlar el [formato \_ HDROP de CF](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-169">If your application will accept existing files, it must be able to handle the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="28180-170">En general, las aplicaciones que aceptan archivos también deben administrar los formatos de [CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-170">In general, applications that accept files should also handle the [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="28180-171">Aunque los archivos del sistema de archivos tienen el formato [CF \_ HDROP](clipboard.md) , los archivos de proveedores como las extensiones de espacio de nombres suelen usar [CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="28180-171">While files from the file system have the [CF\_HDROP](clipboard.md) format, files from providers such as namespace extensions generally use [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md).</span></span> <span data-ttu-id="28180-172">Entre los ejemplos se incluyen carpetas Windows CE, carpetas de protocolo de transferencia de archivos (FTP), carpetas web y carpetas CAB.</span><span class="sxs-lookup"><span data-stu-id="28180-172">Examples include Windows CE folders, File Transfer Protocol (FTP) folders, web folders, and CAB folders.</span></span> <span data-ttu-id="28180-173">Normalmente, el origen implementa una interfaz [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) para presentar los datos de su almacenamiento como un archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-173">The source normally implements an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface to present data from its storage as a file.</span></span>
-   <span data-ttu-id="28180-174">Recuerde que el shell podría usar las operaciones [de eliminación o eliminación](#handling-delete-on-paste-operations) [optimizadas](#handling-optimized-move-operations) al mover archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-174">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="28180-175">La aplicación debe ser capaz de reconocer estas operaciones y responder de forma adecuada.</span><span class="sxs-lookup"><span data-stu-id="28180-175">Your application should be able to recognize these operations and respond appropriately.</span></span>

## <a name="copying-file-names-from-the-clipboard-to-an-application"></a><span data-ttu-id="28180-176">Copiar nombres de archivo del portapapeles en una aplicación</span><span class="sxs-lookup"><span data-stu-id="28180-176">Copying File Names from the Clipboard to an Application</span></span>

<span data-ttu-id="28180-177">**Escenario:** Un usuario selecciona uno o varios archivos en el explorador de Windows y los copia en el portapapeles.</span><span class="sxs-lookup"><span data-stu-id="28180-177">**Scenario:** A user selects one or more files in Windows Explorer and copies them to the Clipboard.</span></span> <span data-ttu-id="28180-178">La aplicación extrae los nombres de archivo y los pega en el documento.</span><span class="sxs-lookup"><span data-stu-id="28180-178">Your application extracts the file names and pastes them into the document.</span></span>

<span data-ttu-id="28180-179">Este escenario podría usarse, por ejemplo, para permitir que un usuario cree un vínculo HTML cortando y pegando el archivo en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-179">This scenario could be used, for instance, to allow a user to create an HTML link by cutting and pasting the file to your application.</span></span> <span data-ttu-id="28180-180">A continuación, la aplicación puede extraer el nombre de archivo del objeto de datos y procesarlo para crear una etiqueta delimitadora.</span><span class="sxs-lookup"><span data-stu-id="28180-180">Your application can then extract the file name from the data object and process it to create an anchor tag.</span></span>

<span data-ttu-id="28180-181">Cuando un usuario selecciona un archivo en el explorador de Windows y lo copia en el portapapeles, el shell crea un objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-181">When a user selects a file in Windows Explorer and copies it to the Clipboard, the Shell creates a data object.</span></span> <span data-ttu-id="28180-182">A continuación, llama a [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) para colocar un puntero a la interfaz [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) del objeto de datos en el portapapeles.</span><span class="sxs-lookup"><span data-stu-id="28180-182">It then calls [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) to place a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface on the Clipboard.</span></span>

<span data-ttu-id="28180-183">Cuando el usuario selecciona el comando **pegar** desde el menú o la barra de herramientas de la aplicación:</span><span class="sxs-lookup"><span data-stu-id="28180-183">When the user selects the **Paste** command from your application's menu or toolbar:</span></span>

1.  <span data-ttu-id="28180-184">Llame a [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) para recuperar la interfaz [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) del objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-184">Call [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) to retrieve the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span>
2.  <span data-ttu-id="28180-185">Llame a [**IDataObject:: del EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) para solicitar un objeto de enumerador.</span><span class="sxs-lookup"><span data-stu-id="28180-185">Call [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) to request an enumerator object.</span></span>
3.  <span data-ttu-id="28180-186">Use la interfaz [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) del objeto de enumerador para enumerar los formatos contenidos en el objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-186">Use the enumerator object's [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface to enumerate the formats contained by the data object.</span></span>

> [!Note]  
> <span data-ttu-id="28180-187">Los dos pasos finales de este procedimiento se incluyen por integridad.</span><span class="sxs-lookup"><span data-stu-id="28180-187">The final two steps in this procedure are included for completeness.</span></span> <span data-ttu-id="28180-188">Normalmente no son necesarios para las transferencias de archivos simples.</span><span class="sxs-lookup"><span data-stu-id="28180-188">They are typically not necessary for simple file transfers.</span></span> <span data-ttu-id="28180-189">Todos los objetos de datos utilizados para este tipo de transferencia de datos deben contener el formato [CF \_ HDROP](clipboard.md) , que se puede utilizar para determinar los nombres de los archivos que contiene el objeto.</span><span class="sxs-lookup"><span data-stu-id="28180-189">All data objects used for this type of data transfer should contain the [CF\_HDROP](clipboard.md) format, which can be used to determine the names of the files contained by the object.</span></span> <span data-ttu-id="28180-190">Sin embargo, para las transferencias de datos más generales, debe enumerar los formatos y seleccionar el mejor que pueda controlar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-190">However, for more general data transfers, you should enumerate the formats and select the best one that your application can handle.</span></span>

 

### <a name="extracting-the-file-names-from-the-data-object"></a><span data-ttu-id="28180-191">Extraer los nombres de archivo del objeto de datos</span><span class="sxs-lookup"><span data-stu-id="28180-191">Extracting the File Names from the Data Object</span></span>

<span data-ttu-id="28180-192">El siguiente paso consiste en extraer uno o varios nombres de archivo del objeto de datos y pegarlos en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-192">The next step is to extract one or more file names from the data object and paste them into your application.</span></span> <span data-ttu-id="28180-193">Tenga en cuenta que el procedimiento descrito en esta sección para extraer un nombre de archivo de un objeto de datos se aplica igualmente bien a las transferencias de arrastrar y colocar.</span><span class="sxs-lookup"><span data-stu-id="28180-193">Note that the procedure discussed in this section for extracting a file name from a data object applies equally well to drag-and-drop transfers.</span></span>

<span data-ttu-id="28180-194">La manera más sencilla de recuperar nombres de archivo de un objeto de datos es el formato [ \_ HDROP de CF](clipboard.md) :</span><span class="sxs-lookup"><span data-stu-id="28180-194">The simplest way to retrieve file names from a data object is the [CF\_HDROP](clipboard.md) format:</span></span>

1.  <span data-ttu-id="28180-195">Llame a [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span><span class="sxs-lookup"><span data-stu-id="28180-195">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span></span> <span data-ttu-id="28180-196">Establezca el miembro **cfFormat** de la estructura [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) en [CF \_ HDROP](clipboard.md) y el miembro **tymed** en [tymed \_ HGLOBAL](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="28180-196">Set the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to [CF\_HDROP](clipboard.md) and the **tymed** member to [TYMED\_HGLOBAL](dataobject.md).</span></span> <span data-ttu-id="28180-197">El miembro **dwAspect** se establece normalmente en el \_ contenido de DVASPECT.</span><span class="sxs-lookup"><span data-stu-id="28180-197">The **dwAspect** member is normally set to DVASPECT\_CONTENT.</span></span> <span data-ttu-id="28180-198">Sin embargo, si necesita que la ruta de acceso del archivo tenga el formato corto (8,3), establezca **dwAspect** en DVASPECT \_ Short.</span><span class="sxs-lookup"><span data-stu-id="28180-198">However, if you need to have the file's path in short (8.3) format, set **dwAspect** to DVASPECT\_SHORT.</span></span>

    <span data-ttu-id="28180-199">Cuando [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) devuelve, el miembro **hGlobal** de la estructura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) apunta a un objeto de memoria global que contiene los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-199">When [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns, the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object that contains the data.</span></span>

2.  <span data-ttu-id="28180-200">Cree una variable HDROP y establézcala en el miembro **hGlobal** de la estructura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="28180-200">Create an HDROP variable and set it to the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="28180-201">La variable HDROP es ahora un identificador de una estructura [**DROPFILES**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) , seguido de una cadena terminada en null que contiene las rutas de acceso de archivo completas de los archivos copiados.</span><span class="sxs-lookup"><span data-stu-id="28180-201">The HDROP variable is now a handle to a [**DROPFILES**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) structure followed by a double null-terminated string containing the fully qualified file paths of the copied files.</span></span>
3.  <span data-ttu-id="28180-202">Determine el número de rutas de acceso de archivo que se encuentran en la lista mediante una llamada a [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) con el parámetro *IFile* establecido en 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="28180-202">Determine how many file paths are in the list by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) with the *iFile* parameter set to 0xFFFFFFFF.</span></span> <span data-ttu-id="28180-203">La función devuelve el número de rutas de acceso de archivo de la lista.</span><span class="sxs-lookup"><span data-stu-id="28180-203">The function returns the number of file paths in the list.</span></span> <span data-ttu-id="28180-204">El índice de base cero de la ruta de acceso del archivo de esta lista se usa en el paso siguiente para identificar una ruta de acceso determinada.</span><span class="sxs-lookup"><span data-stu-id="28180-204">The file path's zero-based index in this list is used in the next step to identify a particular path.</span></span>
4.  <span data-ttu-id="28180-205">Extraiga las rutas de acceso de archivo del objeto de memoria global llamando a [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) una vez para cada archivo, con *iFile* establecido en el índice del archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-205">Extract the file paths from the global memory object by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) once for each file, with *iFile* set to the file's index.</span></span>
5.  <span data-ttu-id="28180-206">Procese las rutas de acceso de archivo según sea necesario y péguelas en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-206">Process the file paths as needed and paste them into your application.</span></span>
6.  <span data-ttu-id="28180-207">Llame a [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) y pase el puntero a la estructura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) que pasó a [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) en el paso 1.</span><span class="sxs-lookup"><span data-stu-id="28180-207">Call [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) and pass in the pointer to the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that you passed to [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) in step 1.</span></span> <span data-ttu-id="28180-208">Una vez que haya liberado la estructura, el valor de HDROP que ha creado en el paso 2 ya no es válido y no debe usarse.</span><span class="sxs-lookup"><span data-stu-id="28180-208">Once you have released the structure, the HDROP value that you created in step 2 is no longer valid and should not be used.</span></span>

## <a name="copying-the-contents-of-a-dropped-file-into-an-application"></a><span data-ttu-id="28180-209">Copiar el contenido de un archivo colocado en una aplicación</span><span class="sxs-lookup"><span data-stu-id="28180-209">Copying the Contents of a Dropped File into an Application</span></span>

<span data-ttu-id="28180-210">**Escenario:** Un usuario arrastra uno o más archivos desde el explorador de Windows y los coloca en la ventana de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-210">**Scenario:** A user drags one or more files from Windows Explorer and drops them on your application's window.</span></span> <span data-ttu-id="28180-211">La aplicación extrae el contenido de los archivos y lo pega en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-211">Your application extracts the content of the file (s) and pastes it into the application.</span></span>

<span data-ttu-id="28180-212">En este escenario se usa la función de arrastrar y colocar para transferir los archivos del explorador de Windows a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-212">This scenario uses drag-and-drop to transfer the files from Windows Explorer to the application.</span></span> <span data-ttu-id="28180-213">Antes de la operación, la aplicación debe:</span><span class="sxs-lookup"><span data-stu-id="28180-213">Prior to the operation, your application must:</span></span>

1.  <span data-ttu-id="28180-214">Llame a [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) para registrar los formatos de Portapapeles de Shell necesarios.</span><span class="sxs-lookup"><span data-stu-id="28180-214">Call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to register any needed Shell Clipboard formats.</span></span>
2.  <span data-ttu-id="28180-215">Llame a [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) para registrar una ventana de destino y la interfaz [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="28180-215">Call [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) to register a target window and your application's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span>

<span data-ttu-id="28180-216">Una vez que el usuario inicia la operación seleccionando uno o varios archivos y empezando a arrastrarlos:</span><span class="sxs-lookup"><span data-stu-id="28180-216">After the user initiates the operation by selecting one or more files and starting to drag them:</span></span>

1.  <span data-ttu-id="28180-217">El explorador de Windows crea un objeto de datos y carga en él los formatos admitidos.</span><span class="sxs-lookup"><span data-stu-id="28180-217">Windows Explorer creates a data object and loads the supported formats into it.</span></span>
2.  <span data-ttu-id="28180-218">El explorador de Windows llama a [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) para iniciar el bucle de arrastre.</span><span class="sxs-lookup"><span data-stu-id="28180-218">Windows Explorer calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) to initiate the drag loop.</span></span>
3.  <span data-ttu-id="28180-219">Cuando la imagen de arrastre llega a la ventana de destino, el sistema le notifica mediante una llamada a [**IDropTarget::D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span><span class="sxs-lookup"><span data-stu-id="28180-219">When the drag image reaches your target window, the system notifies you by calling [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span></span>
4.  <span data-ttu-id="28180-220">Para determinar qué contiene el objeto de datos, llame al método [**IDataObject:: del EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) del objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-220">To determine what the data object contains, call the data object's [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) method.</span></span> <span data-ttu-id="28180-221">Utilice el objeto de enumerador devuelto por el método para enumerar los formatos contenidos en el objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-221">Use the enumerator object returned by the method to enumerate the formats contained by the data object.</span></span> <span data-ttu-id="28180-222">Si la aplicación no desea aceptar ninguno de estos formatos, devuelva DROPEFFECT \_ ninguno.</span><span class="sxs-lookup"><span data-stu-id="28180-222">If your application does not want to accept any of these formats, return DROPEFFECT\_NONE.</span></span> <span data-ttu-id="28180-223">Para los fines de este escenario, la aplicación debe omitir cualquier objeto de datos que no contenga formatos usados para transferir archivos, como [CF \_ HDROP](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="28180-223">For the purposes of this scenario, your application should ignore any data objects that do not contain formats used to transfer files, such as [CF\_HDROP](clipboard.md).</span></span>
5.  <span data-ttu-id="28180-224">Cuando el usuario quita los datos, el sistema llama a [**IDropTarget::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).</span><span class="sxs-lookup"><span data-stu-id="28180-224">When the user drops the data, the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).</span></span>
6.  <span data-ttu-id="28180-225">Use la interfaz [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) para extraer el contenido de los archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-225">Use the [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface to extract the contents of the files.</span></span>

<span data-ttu-id="28180-226">Hay varias maneras de extraer el contenido de un objeto de Shell de un objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-226">There are several different ways to extract the contents of a Shell object from a data object.</span></span> <span data-ttu-id="28180-227">En general, use el orden siguiente:</span><span class="sxs-lookup"><span data-stu-id="28180-227">In general, use the following order:</span></span>

-   <span data-ttu-id="28180-228">Si el archivo contiene un formato de [ \_ texto CF](clipboard.md) , los datos son texto ANSI.</span><span class="sxs-lookup"><span data-stu-id="28180-228">If the file contains a [CF\_TEXT](clipboard.md) format, the data is ANSI text.</span></span> <span data-ttu-id="28180-229">Puede usar el formato de \_ texto CF para extraer los datos, en lugar de abrir el propio archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-229">You can use the CF\_TEXT format to extract the data, rather than opening the file itself.</span></span>
-   <span data-ttu-id="28180-230">Si el archivo contiene un objeto OLE vinculado o incrustado, el objeto de datos contiene un \_ formato EMBEDDEDOBJECT de CF.</span><span class="sxs-lookup"><span data-stu-id="28180-230">If the file contains a linked or embedded OLE object, the data object contains a CF\_EMBEDDEDOBJECT format.</span></span> <span data-ttu-id="28180-231">Utilice técnicas OLE estándar para extraer los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-231">Use standard OLE techniques to extract the data.</span></span> <span data-ttu-id="28180-232">[Los archivos de rechazo](#creating-and-importing-scrap-files) siempre contienen un \_ formato CF EMBEDDEDOBJECT.</span><span class="sxs-lookup"><span data-stu-id="28180-232">[Scrap files](#creating-and-importing-scrap-files) always contain a CF\_EMBEDDEDOBJECT format.</span></span>
-   <span data-ttu-id="28180-233">Si el objeto de Shell procede del sistema de archivos, el objeto de datos contiene un formato [CF \_ HDROP](clipboard.md) con los nombres de los archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-233">If the Shell object is from the file system, the data object contains a [CF\_HDROP](clipboard.md) format with the names of the files.</span></span> <span data-ttu-id="28180-234">Extraiga el nombre de archivo de [CF \_ HDROP](clipboard.md) y llame a [**OleCreateFromFile**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) para crear un nuevo objeto vinculado o incrustado.</span><span class="sxs-lookup"><span data-stu-id="28180-234">Extract the file name from [CF\_HDROP](clipboard.md) and call [**OleCreateFromFile**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) to create a new linked or embedded object.</span></span> <span data-ttu-id="28180-235">Para obtener una explicación sobre cómo recuperar un nombre de archivo desde un formato de [CF \_ HDROP](clipboard.md) , vea [Copiar nombres de archivo del portapapeles en una aplicación](#copying-file-names-from-the-clipboard-to-an-application).</span><span class="sxs-lookup"><span data-stu-id="28180-235">For a discussion of how to retrieve a file name from a [CF\_HDROP](clipboard.md) format, see [Copying File Names from the Clipboard to an Application](#copying-file-names-from-the-clipboard-to-an-application).</span></span>
-   <span data-ttu-id="28180-236">Si el objeto de datos contiene un formato de [CFSTR \_ FILEDESCRIPTOR](clipboard.md) , puede extraer el contenido de un archivo desde el formato de [CFSTR \_ FILECONTENTS](clipboard.md) del archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-236">If the data object contains a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format, you can extract a file's contents from the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="28180-237">Para obtener una explicación de este procedimiento, vea [usar el \_ formato CFSTR FILECONTENTS para extraer datos de un archivo](/windows).</span><span class="sxs-lookup"><span data-stu-id="28180-237">For a discussion of this procedure, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>
-   <span data-ttu-id="28180-238">Antes de la [versión 4,71](versions.md)de Shell, una aplicación indicaba que se transfiriendo un tipo de archivo de acceso directo estableciendo **FD \_ LINKUI** en el miembro **dwFlags** de la estructura [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) .</span><span class="sxs-lookup"><span data-stu-id="28180-238">Prior to Shell [version 4.71](versions.md), an application indicated that it was transferring a shortcut file type by setting **FD\_LINKUI** in the **dwFlags** member of the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structure.</span></span> <span data-ttu-id="28180-239">En el caso de las versiones posteriores del shell, la manera preferida de indicar que los métodos abreviados se están transfiriendo es usar el formato [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) establecido en DROPEFFECT \_ Link.</span><span class="sxs-lookup"><span data-stu-id="28180-239">For later versions of the Shell, the preferred way to indicate that shortcuts are being transferred is to use the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_LINK.</span></span> <span data-ttu-id="28180-240">Este enfoque es mucho más eficaz que extraer la estructura **FILEDESCRIPTOR** solo para comprobar una marca.</span><span class="sxs-lookup"><span data-stu-id="28180-240">This approach is much more efficient than extracting the **FILEDESCRIPTOR** structure just to check a flag.</span></span>

<span data-ttu-id="28180-241">Si el proceso de extracción de datos va a ser largo, es posible que desee realizar la operación de forma asincrónica en un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="28180-241">If the data extraction process will be lengthy, you might want to do the operation asynchronously on a background thread.</span></span> <span data-ttu-id="28180-242">El subproceso principal puede continuar sin retrasos innecesarios.</span><span class="sxs-lookup"><span data-stu-id="28180-242">Your primary thread can then proceed without unnecessary delays.</span></span> <span data-ttu-id="28180-243">Para obtener información sobre cómo administrar la extracción de datos asincrónica, vea [arrastrar y colocar objetos de Shell de forma asincrónica](#dragging-and-dropping-shell-objects-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="28180-243">For a discussion of how to handle asynchronous data extraction, see [Dragging and Dropping Shell Objects Asynchronously](#dragging-and-dropping-shell-objects-asynchronously).</span></span>

### <a name="using-the-cfstr_filecontents-format-to-extract-data-from-a-file"></a><span data-ttu-id="28180-244">Usar el \_ formato CFSTR FILECONTENTS para extraer datos de un archivo</span><span class="sxs-lookup"><span data-stu-id="28180-244">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>

<span data-ttu-id="28180-245">El formato [CFSTR \_ FILECONTENTS](clipboard.md) proporciona una manera muy flexible y eficaz de transferir el contenido de un archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-245">The [CFSTR\_FILECONTENTS](clipboard.md) format provides a very flexible and powerful way to transfer the contents of a file.</span></span> <span data-ttu-id="28180-246">Ni siquiera es necesario almacenar los datos como un único archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-246">It is not even necessary for the data to be stored as a single file.</span></span> <span data-ttu-id="28180-247">Lo único que se necesita para este formato es que el objeto de datos presente los datos en el destino como si fuera un archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-247">All that is required for this format is that the data object present the data to the target as if it were a file.</span></span> <span data-ttu-id="28180-248">Por ejemplo, los datos reales pueden ser una sección de un documento de texto o un bloque de datos extraídos de una base de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-248">For instance, the actual data might be a section of a text document or a block of data extracted from a database.</span></span> <span data-ttu-id="28180-249">El destino puede tratar los datos como un archivo y no necesita saber nada sobre el mecanismo de almacenamiento subyacente.</span><span class="sxs-lookup"><span data-stu-id="28180-249">The target can treat the data as a file and does not need to know anything about the underlying storage mechanism.</span></span>

<span data-ttu-id="28180-250">Las extensiones de espacio de nombres suelen usar [CFSTR \_ FILECONTENTS](clipboard.md) para transferir datos porque este formato no supone ningún mecanismo de almacenamiento concreto.</span><span class="sxs-lookup"><span data-stu-id="28180-250">Namespace extensions normally use [CFSTR\_FILECONTENTS](clipboard.md) to transfer data because this format does not assume any particular storage mechanism.</span></span> <span data-ttu-id="28180-251">Una extensión de espacio de nombres puede usar cualquier mecanismo de almacenamiento adecuado y usar este formato para presentar sus objetos a las aplicaciones como si fueran archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-251">A namespace extension can use whatever storage mechanism is convenient, and use this format to present its objects to applications as if they were files.</span></span>

<span data-ttu-id="28180-252">El mecanismo de transferencia de datos para [CFSTR \_ FILECONTENTS](clipboard.md) suele ser [TYMED \_ ISTREAM](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="28180-252">The data transfer mechanism for [CFSTR\_FILECONTENTS](clipboard.md) is normally [TYMED\_ISTREAM](dataobject.md).</span></span> <span data-ttu-id="28180-253">La transferencia de un puntero de interfaz [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) requiere mucha menos memoria que cargar los datos en un objeto de memoria global, y **IStream** es una forma más sencilla de representar datos que [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span><span class="sxs-lookup"><span data-stu-id="28180-253">Transferring an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface pointer requires much less memory than loading the data into a global memory object, and **IStream** is a simpler way to represent data than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span>

<span data-ttu-id="28180-254">Un formato de [CFSTR \_ FILECONTENTS](clipboard.md) siempre va acompañado de un formato [CFSTR de \_ FILEDESCRIPTOR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-254">A [CFSTR\_FILECONTENTS](clipboard.md) format is always accompanied by a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format.</span></span> <span data-ttu-id="28180-255">Primero debe examinar el contenido de este formato.</span><span class="sxs-lookup"><span data-stu-id="28180-255">You must examine the contents of this format first.</span></span> <span data-ttu-id="28180-256">Si se transfiere más de un archivo, el objeto de datos contendrá realmente varios formatos de [CFSTR \_ FILECONTENTS](clipboard.md) , uno para cada archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-256">If more than one file is being transferred, the data object will actually contain multiple [CFSTR\_FILECONTENTS](clipboard.md) formats, one for each file.</span></span> <span data-ttu-id="28180-257">El formato de [CFSTR \_ FILEDESCRIPTOR](clipboard.md) contiene el nombre y los atributos de cada archivo, y proporciona un valor de índice para cada archivo que se necesita para extraer el formato [CFSTR \_ FILECONTENTS](clipboard.md) de un archivo determinado.</span><span class="sxs-lookup"><span data-stu-id="28180-257">The [CFSTR\_FILEDESCRIPTOR](clipboard.md) format contains the name and attributes of each file, and provides an index value for each file that is needed to extract a particular file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span>

<span data-ttu-id="28180-258">Para extraer un formato de [CFSTR \_ FILECONTENTS](clipboard.md) :</span><span class="sxs-lookup"><span data-stu-id="28180-258">To extract a [CFSTR\_FILECONTENTS](clipboard.md) format:</span></span>

1.  <span data-ttu-id="28180-259">Extraiga el formato de [CFSTR \_ FILEDESCRIPTOR](clipboard.md) como valor [ \_ HGLOBAL de TYMED](dataobject.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-259">Extract the [CFSTR\_FILEDESCRIPTOR](clipboard.md) format as a [TYMED\_HGLOBAL](dataobject.md) value.</span></span>
2.  <span data-ttu-id="28180-260">El miembro **hGlobal** de la estructura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) devuelta apunta a un objeto de memoria global.</span><span class="sxs-lookup"><span data-stu-id="28180-260">The **hGlobal** member of the returned [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object.</span></span> <span data-ttu-id="28180-261">Bloquee el objeto pasando el valor **hGlobal** a [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock).</span><span class="sxs-lookup"><span data-stu-id="28180-261">Lock that object by passing the **hGlobal** value to [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock).</span></span>
3.  <span data-ttu-id="28180-262">Convierta el puntero devuelto por [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) en un puntero [**FILEGROUPDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) .</span><span class="sxs-lookup"><span data-stu-id="28180-262">Cast the pointer returned by [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to a [**FILEGROUPDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) pointer.</span></span> <span data-ttu-id="28180-263">Apuntará a una estructura **FILEGROUPDESCRIPTOR** seguida de una o más estructuras [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) .</span><span class="sxs-lookup"><span data-stu-id="28180-263">It will point to a **FILEGROUPDESCRIPTOR** structure followed by one or more [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures.</span></span> <span data-ttu-id="28180-264">Cada estructura de **FILEDESCRIPTOR** contiene una descripción de un archivo que se encuentra en uno de los formatos de [CFSTR \_ FILECONTENTS](clipboard.md) que lo acompañan.</span><span class="sxs-lookup"><span data-stu-id="28180-264">Each **FILEDESCRIPTOR** structure contains a description of a file that is contained by one of the accompanying [CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span>
4.  <span data-ttu-id="28180-265">Examine las estructuras [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) para determinar cuál corresponde al archivo que desea extraer.</span><span class="sxs-lookup"><span data-stu-id="28180-265">Examine the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures to determine which one corresponds to the file you want to extract.</span></span> <span data-ttu-id="28180-266">El índice de base cero de esa estructura **FILEDESCRIPTOR** se usa para identificar el formato de [ \_ FILECONTENTS de CFSTR](clipboard.md) del archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-266">The zero-based index of that **FILEDESCRIPTOR** structure is used to identify the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="28180-267">Dado que el tamaño de un bloque de memoria global no es preciso para bytes, utilice los miembros **nFileSizeLow** y **nFileSizeHigh** de la estructura para determinar cuántos bytes representan el archivo en el objeto de memoria global.</span><span class="sxs-lookup"><span data-stu-id="28180-267">Because the size of a global memory block is not byte-precise, use the structure's **nFileSizeLow** and **nFileSizeHigh** members to determine how many bytes represent the file in the global memory object.</span></span>
5.  <span data-ttu-id="28180-268">Llame a [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) con el miembro **cfFormat** de la estructura [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) establecido en el valor [CFSTR \_ FILECONTENTS](clipboard.md) y el miembro **lIndex** establecido en el índice que determinó en el paso anterior.</span><span class="sxs-lookup"><span data-stu-id="28180-268">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) with the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure set to the [CFSTR\_FILECONTENTS](clipboard.md) value and the **lIndex** member set to the index that you determined in the previous step.</span></span> <span data-ttu-id="28180-269">Normalmente, el miembro **tymed** se establece en [tymed \_ HGLOBAL](dataobject.md) \| tymed \_ ISTREAM \| tymed \_ ISTORAGE.</span><span class="sxs-lookup"><span data-stu-id="28180-269">The **tymed** member is typically set to [TYMED\_HGLOBAL](dataobject.md) \| TYMED\_ISTREAM \| TYMED\_ISTORAGE.</span></span> <span data-ttu-id="28180-270">Después, el objeto de datos puede elegir su mecanismo de transferencia de datos preferido.</span><span class="sxs-lookup"><span data-stu-id="28180-270">The data object can then choose its preferred data transfer mechanism.</span></span>
6.  <span data-ttu-id="28180-271">La estructura [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) que devuelve [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) contendrá un puntero a los datos del archivo.</span><span class="sxs-lookup"><span data-stu-id="28180-271">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns will contain a pointer to the file's data.</span></span> <span data-ttu-id="28180-272">Examine el miembro **tymed** de la estructura para determinar el mecanismo de transferencia de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-272">Examine the **tymed** member of the structure to determine the data transfer mechanism.</span></span>
7.  <span data-ttu-id="28180-273">Si **tymed** se establece en [TYMED \_ ISTREAM](dataobject.md) o tymed \_ ISTORAGE, use la interfaz para extraer los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-273">If **tymed** is set to [TYMED\_ISTREAM](dataobject.md) or TYMED\_ISTORAGE, use the interface to extract the data.</span></span> <span data-ttu-id="28180-274">Si **tymed** se establece en tymed \_ HGLOBAL, los datos se incluyen en un objeto de memoria global.</span><span class="sxs-lookup"><span data-stu-id="28180-274">If **tymed** is set to TYMED\_HGLOBAL, the data is contained in a global memory object.</span></span> <span data-ttu-id="28180-275">Para obtener una explicación sobre cómo extraer datos de un objeto de memoria global, consulte la sección *extraer un objeto de memoria global de un objeto de datos* del [objeto de datos de Shell](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="28180-275">For a discussion of how to extract data from a global memory object, see the *Extracting a global memory object from a data object* section of [Shell Data Object](dataobject.md).</span></span>
8.  <span data-ttu-id="28180-276">Llame a [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) para desbloquear el objeto de memoria global que bloqueó en el paso 2.</span><span class="sxs-lookup"><span data-stu-id="28180-276">Call [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to unlock the global memory object that you locked in step 2.</span></span>

## <a name="handling-optimized-move-operations"></a><span data-ttu-id="28180-277">Control de operaciones de movimiento optimizadas</span><span class="sxs-lookup"><span data-stu-id="28180-277">Handling Optimized Move Operations</span></span>

<span data-ttu-id="28180-278">**Escenario:** Un archivo se mueve del sistema de archivos a una extensión de espacio de nombres mediante un movimiento optimizado.</span><span class="sxs-lookup"><span data-stu-id="28180-278">**Scenario:** A file is moved from the file system to a namespace extension using an optimized move.</span></span>

<span data-ttu-id="28180-279">En una operación de movimiento convencional, el destino realiza una copia de los datos y el origen elimina el original.</span><span class="sxs-lookup"><span data-stu-id="28180-279">In a conventional move operation, the target makes a copy of the data and the source deletes the original.</span></span> <span data-ttu-id="28180-280">Este procedimiento puede ser ineficaz porque requiere dos copias de los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-280">This procedure can be inefficient because it requires two copies of the data.</span></span> <span data-ttu-id="28180-281">Con objetos grandes como bases de datos, es posible que una operación de movimiento convencional no sea práctica.</span><span class="sxs-lookup"><span data-stu-id="28180-281">With large objects such as databases, a conventional move operation might not even be practical.</span></span>

<span data-ttu-id="28180-282">Con un movimiento optimizado, el destino utiliza su conocimiento sobre cómo se almacenan los datos para controlar toda la operación de movimiento.</span><span class="sxs-lookup"><span data-stu-id="28180-282">With an optimized move, the target uses its understanding of how the data is stored to handle the entire move operation.</span></span> <span data-ttu-id="28180-283">Nunca hay una segunda copia de los datos y no es necesario que el origen elimine los datos originales.</span><span class="sxs-lookup"><span data-stu-id="28180-283">There is never a second copy of the data, and there is no need for the source to delete the original data.</span></span> <span data-ttu-id="28180-284">Los datos de Shell se adaptan bien a los movimientos optimizados porque el destino puede controlar toda la operación mediante la API de Shell.</span><span class="sxs-lookup"><span data-stu-id="28180-284">Shell data is well suited to optimized moves because the target can handle the entire operation using the Shell API.</span></span> <span data-ttu-id="28180-285">Un ejemplo típico es mover archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-285">A typical example is moving files.</span></span> <span data-ttu-id="28180-286">Una vez que el destino tiene la ruta de acceso de un archivo que se va a trasladar, puede usar [**SHFileOperation**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) para moverlo.</span><span class="sxs-lookup"><span data-stu-id="28180-286">Once the target has the path of a file to be moved, it can use [**SHFileOperation**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) to move it.</span></span> <span data-ttu-id="28180-287">No es necesario que el origen elimine el archivo original.</span><span class="sxs-lookup"><span data-stu-id="28180-287">There is no need for the source to delete the original file.</span></span>

> [!Note]  
> <span data-ttu-id="28180-288">Normalmente, el shell usa un movimiento optimizado para migrar archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-288">The Shell normally uses an optimized move to move files.</span></span> <span data-ttu-id="28180-289">Para controlar correctamente la transferencia de datos de Shell, la aplicación debe ser capaz de detectar y administrar un movimiento optimizado.</span><span class="sxs-lookup"><span data-stu-id="28180-289">To handle Shell data transfer properly, your application must be capable of detecting and handling an optimized move.</span></span>

 

<span data-ttu-id="28180-290">Los movimientos optimizados se controlan de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="28180-290">Optimized moves are handled in the following way:</span></span>

1.  <span data-ttu-id="28180-291">El origen llama a [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) con el parámetro *DWEFFECT* establecido en DROPEFFECT \_ Move para indicar que los objetos de origen se pueden trasladar.</span><span class="sxs-lookup"><span data-stu-id="28180-291">The source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) with the *dwEffect* parameter set to DROPEFFECT\_MOVE to indicate that the source objects can be moved.</span></span>
2.  <span data-ttu-id="28180-292">El destino recibe el \_ valor de movimiento DROPEFFECT a través de uno de sus métodos [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) , lo que indica que se permite un movimiento.</span><span class="sxs-lookup"><span data-stu-id="28180-292">The target receives the DROPEFFECT\_MOVE value through one of its [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) methods, indicating that a move is allowed.</span></span>
3.  <span data-ttu-id="28180-293">El destino copia el objeto (movimiento no optimizado) o mueve el objeto (movimiento optimizado).</span><span class="sxs-lookup"><span data-stu-id="28180-293">The target either copies the object (unoptimized move) or moves the object (optimized move).</span></span>
4.  <span data-ttu-id="28180-294">A continuación, el destino indica al origen si es necesario eliminar los datos originales.</span><span class="sxs-lookup"><span data-stu-id="28180-294">The target then tells the source whether it needs to delete the original data.</span></span>

    <span data-ttu-id="28180-295">Un movimiento optimizado es la operación predeterminada, con los datos eliminados por el destino.</span><span class="sxs-lookup"><span data-stu-id="28180-295">An optimized move is the default operation, with the data deleted by the target.</span></span> <span data-ttu-id="28180-296">Para informar al origen de que se ha realizado un movimiento optimizado:</span><span class="sxs-lookup"><span data-stu-id="28180-296">To inform the source that an optimized move was performed:</span></span>

    -   -   <span data-ttu-id="28180-297">El destino establece el valor de *pdwEffect* recibido a través de su método [**IDropTarget::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) en un valor distinto de DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="28180-297">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to some value other than DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="28180-298">Normalmente se establece en DROPEFFECT \_ None o DROPEFFECT \_ Copy.</span><span class="sxs-lookup"><span data-stu-id="28180-298">It is typically set to either DROPEFFECT\_NONE or DROPEFFECT\_COPY.</span></span> <span data-ttu-id="28180-299">El valor se devolverá al origen mediante [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="28180-299">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="28180-300">El destino también llama al método [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) del objeto de datos y le pasa un identificador de formato [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) establecido en DROPEFFECT \_ None.</span><span class="sxs-lookup"><span data-stu-id="28180-300">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_NONE.</span></span> <span data-ttu-id="28180-301">Esta llamada al método es necesaria porque es posible que algunos destinos de colocación no establezcan correctamente el parámetro *pdwEffect* de [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="28180-301">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="28180-302">El formato de [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) es el método confiable para indicar que ha tenido lugar un movimiento optimizado.</span><span class="sxs-lookup"><span data-stu-id="28180-302">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an optimized move has taken place.</span></span>

    <span data-ttu-id="28180-303">Si el destino ha realizado un movimiento no optimizado, el origen debe eliminar los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-303">If the target did an unoptimized move, the data must be deleted by the source.</span></span> <span data-ttu-id="28180-304">Para informar al origen de que se ha realizado un movimiento no optimizado:</span><span class="sxs-lookup"><span data-stu-id="28180-304">To inform the source that an unoptimized move was performed:</span></span>

    -   -   <span data-ttu-id="28180-305">El destino establece el valor de *pdwEffect* recibido a través de su método [**IDropTarget::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) en DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="28180-305">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="28180-306">El valor se devolverá al origen mediante [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="28180-306">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="28180-307">El destino también llama al método [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) del objeto de datos y le pasa un identificador de formato [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) establecido en DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="28180-307">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="28180-308">Esta llamada al método es necesaria porque es posible que algunos destinos de colocación no establezcan correctamente el parámetro *pdwEffect* de [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="28180-308">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="28180-309">El formato de [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) es la forma confiable de indicar que se ha producido un movimiento no optimizado.</span><span class="sxs-lookup"><span data-stu-id="28180-309">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an unoptimized move has taken place.</span></span>

5.  <span data-ttu-id="28180-310">El origen inspecciona los dos valores que puede devolver el destino.</span><span class="sxs-lookup"><span data-stu-id="28180-310">The source inspects the two values that can be returned by the target.</span></span> <span data-ttu-id="28180-311">Si ambos están establecidos en DROPEFFECT \_ Move, se completa el movimiento no optimizado mediante la eliminación de los datos originales.</span><span class="sxs-lookup"><span data-stu-id="28180-311">If both are set to DROPEFFECT\_MOVE, it completes the unoptimized move by deleting the original data.</span></span> <span data-ttu-id="28180-312">De lo contrario, el destino tenía un movimiento optimizado y se eliminaron los datos originales.</span><span class="sxs-lookup"><span data-stu-id="28180-312">Otherwise, the target did an optimized move and the original data has been deleted.</span></span>

## <a name="handling-delete-on-paste-operations"></a><span data-ttu-id="28180-313">Control de operaciones de eliminación y pegado</span><span class="sxs-lookup"><span data-stu-id="28180-313">Handling Delete-on-Paste Operations</span></span>

<span data-ttu-id="28180-314">**Escenario:** Uno o varios archivos se cortan de una carpeta en el explorador de Windows y se pegan en una extensión de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="28180-314">**Scenario:** One or more files are cut from a folder in Windows Explorer and pasted into a namespace extension.</span></span> <span data-ttu-id="28180-315">El explorador de Windows deja los archivos resaltados hasta recibir comentarios sobre el resultado de la operación de pegado.</span><span class="sxs-lookup"><span data-stu-id="28180-315">Windows Explorer leaves the files highlighted until it receives feedback on the outcome of the paste operation.</span></span>

<span data-ttu-id="28180-316">Tradicionalmente, cuando un usuario corta datos, desaparece inmediatamente de la vista.</span><span class="sxs-lookup"><span data-stu-id="28180-316">Traditionally, when a user cuts data it immediately disappears from view.</span></span> <span data-ttu-id="28180-317">Esto puede no ser eficaz y puede dar lugar a problemas de facilidad de uso si el usuario se preocupa de lo que ha ocurrido en los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-317">This might not be efficient, and it can lead to usability problems if the user becomes concerned about what has happened to the data.</span></span> <span data-ttu-id="28180-318">Un enfoque alternativo es usar una operación de eliminación al pegar.</span><span class="sxs-lookup"><span data-stu-id="28180-318">An alternative approach is to use a delete-on-paste operation.</span></span>

<span data-ttu-id="28180-319">Con una operación de eliminación en pegado, los datos seleccionados no se quitan de la vista inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="28180-319">With a delete-on-paste operation, the selected data is not immediately removed from view.</span></span> <span data-ttu-id="28180-320">En su lugar, la aplicación de origen la marca como seleccionada, quizás cambiando la fuente o el color de fondo.</span><span class="sxs-lookup"><span data-stu-id="28180-320">Instead, the source application marks it as selected, perhaps by changing the font or background color.</span></span> <span data-ttu-id="28180-321">Una vez que la aplicación de destino ha pegado los datos, notifica al origen el resultado de la operación.</span><span class="sxs-lookup"><span data-stu-id="28180-321">After the target application has pasted the data, it notifies the source about the outcome of the operation.</span></span> <span data-ttu-id="28180-322">Si el destino realizó un [movimiento optimizado](#handling-optimized-move-operations), el origen puede simplemente actualizar su presentación.</span><span class="sxs-lookup"><span data-stu-id="28180-322">If the target performed an [optimized move](#handling-optimized-move-operations), the source can simply update its display.</span></span> <span data-ttu-id="28180-323">Si el destino realizó un movimiento normal, el origen también debe eliminar su copia de los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-323">If the target performed a normal move, the source must also delete its copy of the data.</span></span> <span data-ttu-id="28180-324">Si se produce un error en la copia, la aplicación de origen restaura los datos seleccionados a su apariencia original.</span><span class="sxs-lookup"><span data-stu-id="28180-324">If the paste fails, the source application restores the selected data to its original appearance.</span></span>

> [!Note]  
> <span data-ttu-id="28180-325">Normalmente, el shell usa la operación de eliminar al pegar cuando se usa una operación de cortar y pegar para trasladar archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-325">The Shell normally uses delete-on-paste when a cut/paste operation is used to move files.</span></span> <span data-ttu-id="28180-326">Las operaciones de eliminación y pegado con objetos de Shell suelen usar un [movimiento optimizado](#handling-optimized-move-operations) para trasladar los archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-326">Delete-on-paste operations with Shell objects normally use an [optimized move](#handling-optimized-move-operations) to move the files.</span></span> <span data-ttu-id="28180-327">Para controlar correctamente la transferencia de datos de Shell, la aplicación debe ser capaz de detectar y controlar las operaciones de eliminación en el mismo.</span><span class="sxs-lookup"><span data-stu-id="28180-327">To handle Shell data transfer properly, your application must be capable of detecting and handling delete-on-paste operations.</span></span>

 

<span data-ttu-id="28180-328">El requisito esencial para eliminar al pegar es que el destino debe notificar el resultado de la operación al origen.</span><span class="sxs-lookup"><span data-stu-id="28180-328">The essential requirement for delete-on-paste is that the target must report the outcome of the operation to the source.</span></span> <span data-ttu-id="28180-329">Sin embargo, las técnicas del portapapeles estándar no se pueden utilizar para implementar la eliminación al pegar porque no proporcionan una manera para que el destino se comunique con el origen.</span><span class="sxs-lookup"><span data-stu-id="28180-329">However, standard Clipboard techniques cannot be used to implement delete-on-paste because they do not provide a way for the target to communicate with the source.</span></span> <span data-ttu-id="28180-330">En su lugar, la aplicación de destino usa el método [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) del objeto de datos para notificar el resultado al objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-330">Instead, the target application uses the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method to report the outcome to the data object.</span></span> <span data-ttu-id="28180-331">A continuación, el objeto de datos puede comunicarse con el origen a través de una interfaz privada.</span><span class="sxs-lookup"><span data-stu-id="28180-331">The data object can then communicate with the source through a private interface.</span></span>

<span data-ttu-id="28180-332">El procedimiento básico para una operación de eliminación en pegado es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="28180-332">The basic procedure for a delete-on-paste operation is as follows:</span></span>

1.  <span data-ttu-id="28180-333">El origen marca la presentación en pantalla de los datos seleccionados.</span><span class="sxs-lookup"><span data-stu-id="28180-333">The source marks the screen display of the selected data.</span></span>
2.  <span data-ttu-id="28180-334">El origen crea un objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-334">The source creates a data object.</span></span> <span data-ttu-id="28180-335">Indica una operación de cortar agregando el formato [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) con un valor de datos de DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="28180-335">It indicates a cut operation by adding the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format with a data value of DROPEFFECT\_MOVE.</span></span>
3.  <span data-ttu-id="28180-336">El origen coloca el objeto de datos en el portapapeles mediante [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).</span><span class="sxs-lookup"><span data-stu-id="28180-336">The source places the data object on the Clipboard using [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).</span></span>
4.  <span data-ttu-id="28180-337">El destino recupera el objeto de datos del portapapeles mediante [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span><span class="sxs-lookup"><span data-stu-id="28180-337">The target retrieves the data object from the Clipboard using [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span>
5.  <span data-ttu-id="28180-338">El destino extrae los datos de [ \_ PREFERREDDROPEFFECT de CFSTR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-338">The target extracts the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) data.</span></span> <span data-ttu-id="28180-339">Si se establece en solo DROPEFFECT \_ Move, el destino puede realizar un movimiento optimizado o simplemente copiar los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-339">If it is set to only DROPEFFECT\_MOVE, the target can either do an optimized move or simply copy the data.</span></span>
6.  <span data-ttu-id="28180-340">Si el destino no realiza un movimiento optimizado, llama al método [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) con el formato [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) establecido en DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="28180-340">If the target does not do an optimized move, it calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
7.  <span data-ttu-id="28180-341">Una vez completada la función de pegar, el destino llama al método [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) con el formato [CFSTR \_ PASTESUCCEEDED](clipboard.md) establecido en DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="28180-341">When the paste is complete, the target calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
8.  <span data-ttu-id="28180-342">Cuando se llama al método [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) del origen con el formato [CFSTR \_ PASTESUCCEEDED](clipboard.md) establecido en DROPEFFECT \_ Move, debe comprobar si también se ha recibido el formato [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) establecido en DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="28180-342">When the source's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method is called with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE, it must check to see if it also received the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="28180-343">Si el destino envía ambos formatos, el origen tendrá que eliminar los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-343">If both formats are sent by the target, the source will have to delete the data.</span></span> <span data-ttu-id="28180-344">Si solo se recibe el formato [CFSTR \_ PASTESUCCEEDED](clipboard.md) , el origen puede quitar simplemente los datos de su pantalla.</span><span class="sxs-lookup"><span data-stu-id="28180-344">If only the [CFSTR\_PASTESUCCEEDED](clipboard.md) format is received, the source can simply remove the data from its display.</span></span> <span data-ttu-id="28180-345">Si se produce un error en la transferencia, el origen actualiza la presentación a su apariencia original.</span><span class="sxs-lookup"><span data-stu-id="28180-345">If the transfer fails, the source updates the display to its original appearance.</span></span>

## <a name="transfering-data-to-and-from-virtual-folders"></a><span data-ttu-id="28180-346">Transferencia de datos hacia y desde carpetas virtuales</span><span class="sxs-lookup"><span data-stu-id="28180-346">Transfering Data to and from Virtual Folders</span></span>

<span data-ttu-id="28180-347">**Escenario:** Un usuario arrastra un objeto o lo coloca en una carpeta virtual.</span><span class="sxs-lookup"><span data-stu-id="28180-347">**Scenario:** A user drags an object from or drops it on a virtual folder.</span></span>

<span data-ttu-id="28180-348">Las carpetas virtuales contienen objetos que normalmente no forman parte del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-348">Virtual folders contain objects that are generally not part of the file system.</span></span> <span data-ttu-id="28180-349">Algunas carpetas virtuales, como la papelera de reciclaje, pueden representar los datos que se almacenan en el disco duro, pero no los objetos normales del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-349">Some virtual folders, such as the Recycle Bin, can represent data that is stored on the hard disk but not as ordinary file system objects.</span></span> <span data-ttu-id="28180-350">Algunos pueden representar datos almacenados que se encuentran en un sistema remoto, como un PC de mano o un sitio FTP.</span><span class="sxs-lookup"><span data-stu-id="28180-350">Some can represent stored data that is on a remote system, such as a handheld PC, or an FTP site.</span></span> <span data-ttu-id="28180-351">Otros, como la carpeta Impresoras, contienen objetos que no representan datos almacenados.</span><span class="sxs-lookup"><span data-stu-id="28180-351">Others, such as the Printers folder, contain objects that do not represent stored data at all.</span></span> <span data-ttu-id="28180-352">Aunque algunas carpetas virtuales forman parte del sistema, los desarrolladores también pueden crear e instalar carpetas virtuales personalizadas mediante la implementación de una extensión de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="28180-352">While some virtual folders are part of the system, developers can also create and install custom virtual folders by implementing a namespace extension.</span></span>

<span data-ttu-id="28180-353">Independientemente del tipo de datos o de su almacenamiento, el shell presenta los objetos de carpeta y archivo contenidos en una carpeta virtual como si fueran archivos y carpetas normales.</span><span class="sxs-lookup"><span data-stu-id="28180-353">Regardless of the type of data or how it is stored, the folder and file objects that are contained by a virtual folder are presented by the Shell as if they were normal files and folders.</span></span> <span data-ttu-id="28180-354">Es responsabilidad de la carpeta virtual tomar cualquier dato que contenga y presentarlo correctamente en el shell.</span><span class="sxs-lookup"><span data-stu-id="28180-354">It is the responsibility of the virtual folder to take whatever data it contains and present it to the Shell appropriately.</span></span> <span data-ttu-id="28180-355">Este requisito significa que las carpetas virtuales normalmente admiten las transferencias de datos de arrastrar y colocar y del portapapeles.</span><span class="sxs-lookup"><span data-stu-id="28180-355">This requirement means that virtual folders normally support drag-and-drop and Clipboard data transfers.</span></span>

<span data-ttu-id="28180-356">Por tanto, hay dos grupos de desarrolladores que deben preocuparse de la transferencia de datos a y desde las carpetas virtuales:</span><span class="sxs-lookup"><span data-stu-id="28180-356">There are thus two groups of developers who need to be concerned with data transfer to and from virtual folders:</span></span>

-   <span data-ttu-id="28180-357">Desarrolladores cuyas aplicaciones necesitan aceptar datos que se transfieren de una carpeta virtual.</span><span class="sxs-lookup"><span data-stu-id="28180-357">Developers whose applications need to accept data that is transferred from a virtual folder.</span></span>
-   <span data-ttu-id="28180-358">Desarrolladores cuyas extensiones de espacio de nombres necesitan admitir correctamente la transferencia de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-358">Developers whose namespace extensions need to properly support data transfer.</span></span>

### <a name="accepting-data-from-a-virtual-folder"></a><span data-ttu-id="28180-359">Aceptar datos de una carpeta virtual</span><span class="sxs-lookup"><span data-stu-id="28180-359">Accepting Data from a Virtual Folder</span></span>

<span data-ttu-id="28180-360">Las carpetas virtuales pueden representar prácticamente cualquier tipo de datos y pueden almacenar los datos de la forma que elijan.</span><span class="sxs-lookup"><span data-stu-id="28180-360">Virtual folders can represent virtually any type of data and can store that data in any way they choose.</span></span> <span data-ttu-id="28180-361">Algunas carpetas virtuales pueden contener archivos y carpetas normales del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-361">Some virtual folders might actually contain normal file system files and folders.</span></span> <span data-ttu-id="28180-362">Por ejemplo, otros pueden empaquetar todos sus objetos en un único documento o base de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-362">Others might, for instance, pack all their objects into a single document or database.</span></span>

<span data-ttu-id="28180-363">Cuando se transfiere un objeto de sistema de archivos a una aplicación, el objeto de datos normalmente contiene un formato [CF \_ HDROP](clipboard.md) con la ruta de acceso completa del objeto.</span><span class="sxs-lookup"><span data-stu-id="28180-363">When a file system object is transferred to an application, the data object normally contains a [CF\_HDROP](clipboard.md) format with the object's fully qualified path.</span></span> <span data-ttu-id="28180-364">La aplicación puede extraer esta cadena y usar las funciones normales del sistema de archivos para abrir el archivo y extraer sus datos.</span><span class="sxs-lookup"><span data-stu-id="28180-364">Your application can extract this string and use the normal file system functions to open the file and extract its data.</span></span> <span data-ttu-id="28180-365">Sin embargo, dado que las carpetas virtuales normalmente no contienen objetos normales del sistema de archivos, normalmente no usan [CF \_ HDROP](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="28180-365">However, because virtual folders typically do not contain normal file system objects, they generally do not use [CF\_HDROP](clipboard.md).</span></span>

<span data-ttu-id="28180-366">En lugar de [CF \_ HDROP](clipboard.md), los datos se transfieren normalmente de las carpetas virtuales con los formatos [CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [CFSTR \_ FILECONTENTS](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-366">Instead of [CF\_HDROP](clipboard.md), data is normally transferred from virtual folders with the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="28180-367">El formato [CFSTR \_ FILECONTENTS](clipboard.md) tiene dos ventajas respecto a [CF \_ HDROP](clipboard.md):</span><span class="sxs-lookup"><span data-stu-id="28180-367">The [CFSTR\_FILECONTENTS](clipboard.md) format has two advantages over [CF\_HDROP](clipboard.md):</span></span>

-   <span data-ttu-id="28180-368">No se presupone ningún método determinado de almacenamiento de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-368">No particular method of data storage is assumed.</span></span>
-   <span data-ttu-id="28180-369">El formato es más flexible.</span><span class="sxs-lookup"><span data-stu-id="28180-369">The format is more flexible.</span></span> <span data-ttu-id="28180-370">Admite tres mecanismos de transferencia de datos: un objeto de memoria global, una interfaz [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) o una interfaz [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="28180-370">It supports three data transfer mechanisms: a global memory object, an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface, or an [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span>

<span data-ttu-id="28180-371">Los objetos de memoria global se suelen usar para transferir datos hacia o desde objetos virtuales porque los datos se deben copiar en la memoria en su totalidad.</span><span class="sxs-lookup"><span data-stu-id="28180-371">Global memory objects are rarely used to transfer data to or from virtual objects because the data must be copied into memory in its entirety.</span></span> <span data-ttu-id="28180-372">La transferencia de un puntero de interfaz requiere casi memoria y es mucho más eficaz.</span><span class="sxs-lookup"><span data-stu-id="28180-372">Transferring an interface pointer requires almost no memory and is much more efficient.</span></span> <span data-ttu-id="28180-373">Con archivos muy grandes, un puntero de interfaz puede ser el único mecanismo de transferencia de datos práctico.</span><span class="sxs-lookup"><span data-stu-id="28180-373">With very large files, an interface pointer might be the only practical data transfer mechanism.</span></span> <span data-ttu-id="28180-374">Normalmente, los datos se representan mediante un puntero [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) , ya que la interfaz es algo más flexible que [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span><span class="sxs-lookup"><span data-stu-id="28180-374">Typically, data is represented by an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) pointer, because that interface is somewhat more flexible than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span> <span data-ttu-id="28180-375">El destino extrae el puntero del objeto de datos y usa los métodos de interfaz para extraer los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-375">The target extracts the pointer from the data object and uses the interface methods to extract the data.</span></span>

<span data-ttu-id="28180-376">Para obtener más información sobre cómo administrar los formatos de [CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [CFSTR \_ FILECONTENTS](clipboard.md) , consulte [uso del \_ formato CFSTR FILECONTENTS para extraer datos de un archivo](/windows).</span><span class="sxs-lookup"><span data-stu-id="28180-376">For further discussion of how to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>

### <a name="transferring-data-to-and-from-a-namespace-extension"></a><span data-ttu-id="28180-377">Transferir datos hacia y desde una extensión de espacio de nombres</span><span class="sxs-lookup"><span data-stu-id="28180-377">Transferring Data to and from a NameSpace Extension</span></span>

<span data-ttu-id="28180-378">Cuando implemente una extensión de espacio de nombres, normalmente querrá admitir funciones de arrastrar y colocar.</span><span class="sxs-lookup"><span data-stu-id="28180-378">When you implement a namespace extension, you will normally want to support drag-and-drop capabilities.</span></span> <span data-ttu-id="28180-379">Siga las recomendaciones para los orígenes y destinos de colocación descritos en [directrices generales](#general-guidelines).</span><span class="sxs-lookup"><span data-stu-id="28180-379">Follow the recommendations for drop sources and targets discussed in [General Guidelines](#general-guidelines).</span></span> <span data-ttu-id="28180-380">En concreto, una extensión de espacio de nombres debe:</span><span class="sxs-lookup"><span data-stu-id="28180-380">In particular, a namespace extension must:</span></span>

-   <span data-ttu-id="28180-381">Ser capaz de administrar los formatos FILECONTENTS de [CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [ \_ CFSTR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-381">Be able to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="28180-382">Estos dos formatos se utilizan normalmente para transferir objetos a y desde extensiones de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="28180-382">These two formats are normally used to transfer objects to and from namespace extensions.</span></span>
-   <span data-ttu-id="28180-383">Ser capaz de controlar los [movimientos optimizados](#handling-optimized-move-operations).</span><span class="sxs-lookup"><span data-stu-id="28180-383">Be able to handle [optimized moves](#handling-optimized-move-operations).</span></span> <span data-ttu-id="28180-384">El shell espera que los objetos de Shell se muevan con un movimiento optimizado.</span><span class="sxs-lookup"><span data-stu-id="28180-384">The Shell expects that Shell objects will be moved with an optimized move.</span></span>
-   <span data-ttu-id="28180-385">Ser capaz de controlar una operación de [eliminación en pegado](#handling-delete-on-paste-operations) .</span><span class="sxs-lookup"><span data-stu-id="28180-385">Be able to handle a [delete-on-paste](#handling-delete-on-paste-operations) operation.</span></span> <span data-ttu-id="28180-386">El shell usa la operación de eliminar al pegar cuando los objetos se mueven desde el shell con una operación de cortar y pegar.</span><span class="sxs-lookup"><span data-stu-id="28180-386">The Shell uses delete-on-paste when objects are moved from the Shell with a cut/paste operation.</span></span>
-   <span data-ttu-id="28180-387">Ser capaz de controlar la transferencia de datos a través de una interfaz [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) o [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="28180-387">Be able to handle data transfer through an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="28180-388">La transferencia de datos a o desde una carpeta virtual se controla normalmente transfiriendo uno de estos dos punteros de interfaz, normalmente un puntero **IStream** .</span><span class="sxs-lookup"><span data-stu-id="28180-388">Data transfer to or from a virtual folder is normally handled by transferring one of these two interface pointers, typically an **IStream** pointer.</span></span> <span data-ttu-id="28180-389">A continuación, el destino llama a los métodos de interfaz para extraer los datos:</span><span class="sxs-lookup"><span data-stu-id="28180-389">The target then calls the interface methods to extract the data:</span></span>
    -   -   <span data-ttu-id="28180-390">Como origen de colocación, la extensión de espacio de nombres debe extraer los datos del almacenamiento y pasarlos a través de esta interfaz al destino.</span><span class="sxs-lookup"><span data-stu-id="28180-390">As a drop source, the namespace extension must extract the data from storage and pass it through this interface to the target.</span></span>
        -   <span data-ttu-id="28180-391">Como destino de colocación, una extensión de espacio de nombres debe aceptar datos de un origen a través de esta interfaz y almacenarlos correctamente.</span><span class="sxs-lookup"><span data-stu-id="28180-391">As a drop target, a namespace extension must accept data from a source through this interface and store it properly.</span></span>

## <a name="dropping-files-on-the-recycle-bin"></a><span data-ttu-id="28180-392">Quitar archivos de la papelera de reciclaje</span><span class="sxs-lookup"><span data-stu-id="28180-392">Dropping Files on the Recycle Bin</span></span>

<span data-ttu-id="28180-393">**Escenario:** El usuario coloca un archivo en la **papelera de reciclaje**.</span><span class="sxs-lookup"><span data-stu-id="28180-393">**Scenario:** The user drops a file on the **Recycle Bin**.</span></span> <span data-ttu-id="28180-394">La extensión de la aplicación o el espacio de nombres elimina el archivo original.</span><span class="sxs-lookup"><span data-stu-id="28180-394">Your application or namespace extension deletes the original file.</span></span>

<span data-ttu-id="28180-395">La papelera de reciclaje es una carpeta virtual que se usa como repositorio para los archivos que ya no son necesarios.</span><span class="sxs-lookup"><span data-stu-id="28180-395">The Recycle Bin is a virtual folder that is used as a repository for files that are no longer needed.</span></span> <span data-ttu-id="28180-396">Siempre que no se haya vaciado la papelera de reciclaje, el usuario puede recuperar el archivo más adelante y devolverlo al sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-396">As long as the Recycle Bin has not been emptied, the user can later recover the file and return it to the file system.</span></span>

<span data-ttu-id="28180-397">En su mayor parte, la transferencia de objetos de Shell a la papelera de reciclaje funciona de forma muy parecida a cualquier otra carpeta.</span><span class="sxs-lookup"><span data-stu-id="28180-397">For the most part, transferring Shell objects to the Recycle Bin works much like any other folder.</span></span> <span data-ttu-id="28180-398">Sin embargo, cuando un usuario coloca un archivo en la **papelera de reciclaje**, el origen debe eliminar el original, incluso aunque los comentarios de la carpeta indiquen una operación de copia.</span><span class="sxs-lookup"><span data-stu-id="28180-398">However, when a user drops a file on the **Recycle Bin**, the source needs to delete the original, even if the feedback from the folder indicates a copy operation.</span></span> <span data-ttu-id="28180-399">Normalmente, un origen de colocación no tiene forma alguna de saber en qué carpeta se ha quitado su objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-399">Normally, a drop source has no way of knowing which folder its data object has been dropped on.</span></span> <span data-ttu-id="28180-400">Sin embargo, para los sistemas Windows 2000 y versiones posteriores, cuando se coloca un objeto de datos en la **papelera de reciclaje**, el shell llamará al método [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) del objeto de datos con un formato [CFSTR \_ TARGETCLSID](clipboard.md) establecido en el identificador de clase (CLSID) de la papelera de reciclaje (CLSID \_ RecycleBin).</span><span class="sxs-lookup"><span data-stu-id="28180-400">However, for Windows 2000 and later systems, when a data object is dropped on the **Recycle Bin**, the Shell will call the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with a [CFSTR\_TARGETCLSID](clipboard.md) format set to the Recycle Bin's class identifier (CLSID) (CLSID\_RecycleBin).</span></span> <span data-ttu-id="28180-401">Para controlar correctamente el caso de la papelera de reciclaje, el objeto de datos debe ser capaz de reconocer este formato y comunicar la información al origen a través de una interfaz privada.</span><span class="sxs-lookup"><span data-stu-id="28180-401">To handle the Recycle Bin case properly, your data object should be able to recognize this format and communicate the information to the source through a private interface.</span></span>

> [!Note]  
> <span data-ttu-id="28180-402">Cuando se llama a [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) con un formato [CFSTR \_ TARGETCLSID](clipboard.md) establecido en CLSID \_ RecycleBin, el origen de datos debe cerrar todos los identificadores abiertos a los objetos que se van a transferir antes de volver del método.</span><span class="sxs-lookup"><span data-stu-id="28180-402">When [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) is called with a [CFSTR\_TARGETCLSID](clipboard.md) format set to CLSID\_RecycleBin, the data source should close any open handles to the objects that are being transferred before returning from the method.</span></span> <span data-ttu-id="28180-403">De lo contrario, podría crear infracciones de uso compartido.</span><span class="sxs-lookup"><span data-stu-id="28180-403">Otherwise, you might create sharing violations.</span></span>

 

## <a name="creating-and-importing-scrap-files"></a><span data-ttu-id="28180-404">Crear e importar archivos de rechazo</span><span class="sxs-lookup"><span data-stu-id="28180-404">Creating and Importing Scrap Files</span></span>

<span data-ttu-id="28180-405">**Escenario:** Un usuario arrastra algunos datos desde el archivo de datos de una aplicación OLE y los coloca en el escritorio o en el explorador de Windows.</span><span class="sxs-lookup"><span data-stu-id="28180-405">**Scenario:** A user drags some data from an OLE application's data file and drops it on the desktop or Windows Explorer.</span></span>

<span data-ttu-id="28180-406">Windows permite a los usuarios arrastrar un objeto desde el archivo de datos de una aplicación OLE y colocarlo en el escritorio o en una carpeta del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="28180-406">Windows allows users to drag an object from an OLE application's data file and drop it on the desktop or a file system folder.</span></span> <span data-ttu-id="28180-407">Esta operación crea un *archivo de recorte*, que contiene los datos o un vínculo a los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-407">This operation creates a *scrap file*, which contains the data or a link to the data.</span></span> <span data-ttu-id="28180-408">El nombre de archivo se toma del nombre corto registrado para el CLSID del objeto y los datos [de \_ texto de CF](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="28180-408">The file name is taken from the short name registered for the CLSID of the object and the [CF\_TEXT](clipboard.md) data.</span></span> <span data-ttu-id="28180-409">Para que el shell cree un archivo de recorte que contiene datos, la interfaz [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) de la aplicación debe admitir el \_ formato del portapapeles de EMBEDSOURCE de CF.</span><span class="sxs-lookup"><span data-stu-id="28180-409">For the Shell to create a scrap file containing data, the application's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface must support the CF\_EMBEDSOURCE Clipboard format.</span></span> <span data-ttu-id="28180-410">Para crear un archivo que contenga un vínculo, **IDataObject** debe admitir el \_ formato CF LINKSOURCE.</span><span class="sxs-lookup"><span data-stu-id="28180-410">To create a file containing a link, **IDataObject** must support the CF\_LINKSOURCE format.</span></span>

<span data-ttu-id="28180-411">También hay tres características opcionales que una aplicación puede implementar para admitir archivos de recorte:</span><span class="sxs-lookup"><span data-stu-id="28180-411">There are also three optional features that an application can implement to support scrap files:</span></span>

-   <span data-ttu-id="28180-412">Compatibilidad con acciones de ida y vuelta</span><span class="sxs-lookup"><span data-stu-id="28180-412">Round-trip support</span></span>
-   <span data-ttu-id="28180-413">Formatos de datos almacenados en caché</span><span class="sxs-lookup"><span data-stu-id="28180-413">Cached data formats</span></span>
-   <span data-ttu-id="28180-414">Representación diferida</span><span class="sxs-lookup"><span data-stu-id="28180-414">Delayed rendering</span></span>

### <a name="round-trip-support"></a><span data-ttu-id="28180-415">Compatibilidad con acciones de ida y vuelta</span><span class="sxs-lookup"><span data-stu-id="28180-415">Round-trip Support</span></span>

<span data-ttu-id="28180-416">Un *recorrido de ida* y vuelta implica la transferencia de un objeto de datos a otro contenedor y, a continuación, de nuevo al documento original.</span><span class="sxs-lookup"><span data-stu-id="28180-416">A *round trip* involves transferring a data object to another container and then back to the original document.</span></span> <span data-ttu-id="28180-417">Por ejemplo, un usuario podría transferir un grupo de celdas de una hoja de cálculo al escritorio, creando un archivo de recorte con los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-417">For instance, a user could transfer a group of cells from a spreadsheet to the desktop, creating a scrap file with the data.</span></span> <span data-ttu-id="28180-418">Si el usuario transfiere el recorte a la hoja de cálculo, los datos deben integrarse en el documento tal como estaba antes de la transferencia original.</span><span class="sxs-lookup"><span data-stu-id="28180-418">If the user then transfers the scrap back to the spreadsheet, the data needs to be integrated into the document as it was before the original transfer.</span></span>

<span data-ttu-id="28180-419">Cuando el shell crea el archivo de recorte, representa los datos como un objeto de incrustación.</span><span class="sxs-lookup"><span data-stu-id="28180-419">When the Shell creates the scrap file, it represents the data as an embedding object.</span></span> <span data-ttu-id="28180-420">Cuando el residuo se transfiere a otro contenedor, se transfiere como un objeto de incrustación, aunque se devuelva al documento original.</span><span class="sxs-lookup"><span data-stu-id="28180-420">When the scrap is transferred to another container, it is transferred as an embedding object, even if it is being returned to the original document.</span></span> <span data-ttu-id="28180-421">La aplicación es responsable de determinar el formato de datos contenido en el rechazo y de volver a colocar los datos en su formato nativo, si es necesario.</span><span class="sxs-lookup"><span data-stu-id="28180-421">Your application is responsible for determining the data format contained in the scrap and putting the data back into its native format if necessary.</span></span>

<span data-ttu-id="28180-422">Para establecer el formato del objeto incrustado, determine su CLSID recuperando el formato CF OBJECTDESCRIPTOR del objeto \_ .</span><span class="sxs-lookup"><span data-stu-id="28180-422">To establish the format of the embedded object, determine its CLSID by retrieving the object's CF\_OBJECTDESCRIPTOR format.</span></span> <span data-ttu-id="28180-423">Si el CLSID indica un formato de datos que pertenece a la aplicación, debe transferir los datos nativos en lugar de llamar a [**OleCreateFromData**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).</span><span class="sxs-lookup"><span data-stu-id="28180-423">If the CLSID indicates a data format that belongs to the application, it should transfer the native data instead of calling [**OleCreateFromData**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).</span></span>

### <a name="cached-data-formats"></a><span data-ttu-id="28180-424">Formatos de datos almacenados en caché</span><span class="sxs-lookup"><span data-stu-id="28180-424">Cached Data Formats</span></span>

<span data-ttu-id="28180-425">Cuando el shell crea un archivo de recorte, comprueba el registro para obtener la lista de formatos disponibles.</span><span class="sxs-lookup"><span data-stu-id="28180-425">When the Shell creates a scrap file, it checks the registry for the list of available formats.</span></span> <span data-ttu-id="28180-426">De forma predeterminada, hay dos formatos disponibles: CF \_ EMBEDSOURCE y CF \_ LINKSOURCE.</span><span class="sxs-lookup"><span data-stu-id="28180-426">By default, there are two formats available: CF\_EMBEDSOURCE and CF\_LINKSOURCE.</span></span> <span data-ttu-id="28180-427">Sin embargo, hay una serie de escenarios en los que es posible que las aplicaciones necesiten tener archivos de recorte en diferentes formatos:</span><span class="sxs-lookup"><span data-stu-id="28180-427">However, there are a number of scenarios where applications might need to have scrap files in different formats:</span></span>

-   <span data-ttu-id="28180-428">Para permitir que los residuos se transfieran a contenedores que no son de OLE, que no admiten formatos de objetos incrustados.</span><span class="sxs-lookup"><span data-stu-id="28180-428">To allow scraps to be transferred to non-OLE containers, which cannot accepted embedded object formats.</span></span>
-   <span data-ttu-id="28180-429">Para permitir que los conjuntos de aplicaciones se comuniquen con un formato privado.</span><span class="sxs-lookup"><span data-stu-id="28180-429">To allow suites of applications to communicate with a private format.</span></span>
-   <span data-ttu-id="28180-430">Para facilitar el control de los recorridos de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="28180-430">To make round trips easier to handle.</span></span>

<span data-ttu-id="28180-431">Las aplicaciones pueden agregar formatos al rechazo mediante su almacenamiento en caché en el registro.</span><span class="sxs-lookup"><span data-stu-id="28180-431">Applications can add formats to the scrap by caching them in the registry.</span></span> <span data-ttu-id="28180-432">Hay dos tipos de formatos almacenados en caché:</span><span class="sxs-lookup"><span data-stu-id="28180-432">There are two types of cached formats:</span></span>

-   <span data-ttu-id="28180-433">Formatos de caché de prioridad.</span><span class="sxs-lookup"><span data-stu-id="28180-433">Priority cache formats.</span></span> <span data-ttu-id="28180-434">En estos formatos, los datos se copian en su totalidad en el rechazo del objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-434">For these formats, the data is copied in its entirety into the scrap from the data object.</span></span>
-   <span data-ttu-id="28180-435">Formatos representados por retraso.</span><span class="sxs-lookup"><span data-stu-id="28180-435">Delay-rendered formats.</span></span> <span data-ttu-id="28180-436">En estos formatos, el objeto de datos no se copia en el rechazo.</span><span class="sxs-lookup"><span data-stu-id="28180-436">For these formats, the data object is not copied to the scrap.</span></span> <span data-ttu-id="28180-437">En su lugar, la representación se retrasa hasta que un destino solicita los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-437">Instead, rendering is delayed until a target requests the data.</span></span> <span data-ttu-id="28180-438">Delay: la representación se describe con más detalle en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="28180-438">Delay-rendering is discussed in more detail in the next section.</span></span>

<span data-ttu-id="28180-439">Para agregar una memoria caché de prioridad o un formato representado por retraso, cree una subclave **dataFormat** en la clave **CLSID** de la aplicación que es el origen de los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-439">To add a priority cache or delay-rendered format, create a **DataFormat** subkey under the **CLSID** key of the application that is the source of the data.</span></span> <span data-ttu-id="28180-440">En esa subclave, cree una subclave **PriorityCacheFormats** o **DelayRenderFormats** .</span><span class="sxs-lookup"><span data-stu-id="28180-440">Under that subkey, create a **PriorityCacheFormats** or **DelayRenderFormats** subkey.</span></span> <span data-ttu-id="28180-441">Para cada formato de caché de prioridad o representada por retraso, cree una subclave numerada a partir de cero.</span><span class="sxs-lookup"><span data-stu-id="28180-441">For each priority cache or delay-rendered format, create a numbered subkey starting with zero.</span></span> <span data-ttu-id="28180-442">Establezca el valor de esta clave en una cadena con el nombre registrado del formato o un \# valor x, donde X representa el número de formato de un formato estándar del portapapeles.</span><span class="sxs-lookup"><span data-stu-id="28180-442">Set the value of this key to either a string with the registered name of the format or a \#X value, where X represents the format number of a standard Clipboard format.</span></span>

<span data-ttu-id="28180-443">En el ejemplo siguiente se muestran los formatos almacenados en caché para dos aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="28180-443">The following sample shows cached formats for two applications.</span></span> <span data-ttu-id="28180-444">La aplicación MyProg1 tiene el formato de texto enriquecido como formato de caché de prioridad y un formato privado "mi formato" como formato representado por retraso.</span><span class="sxs-lookup"><span data-stu-id="28180-444">The MyProg1 application has the rich-text format as a priority cache format, and a private format "My Format" as a delay-rendered format.</span></span> <span data-ttu-id="28180-445">La aplicación MyProg2 tiene el formato de mapa de bits de CF \_ ( \# 8 ") como formato de caché de prioridad.</span><span class="sxs-lookup"><span data-stu-id="28180-445">The MyProg2 application has the CF\_BITMAP format (\#8") as a priority cache format.</span></span>

```
HKEY_CLASSES_ROOT
   CLSID
      {GUID}
         (Default) = MyProg1
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = Rich Text Format
            DelayRenderFormats
               0
                  (Default) = My Format
      {GUID}
         (Default) = MyProg2
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = #8
```

<span data-ttu-id="28180-446">Se pueden agregar formatos adicionales mediante la creación de subclaves numeradas adicionales.</span><span class="sxs-lookup"><span data-stu-id="28180-446">Additional formats can be added by creating additional numbered subkeys.</span></span>

### <a name="delayed-rendering"></a><span data-ttu-id="28180-447">Representación diferida</span><span class="sxs-lookup"><span data-stu-id="28180-447">Delayed Rendering</span></span>

<span data-ttu-id="28180-448">Un formato de representación retrasado permite a una aplicación crear un archivo de recortes pero retrasar el gasto de representar los datos hasta que los solicite un destino.</span><span class="sxs-lookup"><span data-stu-id="28180-448">A delayed rendering format allows an application to create a scrap file but delay the expense of rendering the data until it is requested by a target.</span></span> <span data-ttu-id="28180-449">La interfaz [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) de un residuo proporcionará los formatos de representación retrasados al destino junto con los datos nativos y almacenados en caché.</span><span class="sxs-lookup"><span data-stu-id="28180-449">The [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface of a scrap will offer the delayed rendering formats to the target along with native and cached data.</span></span> <span data-ttu-id="28180-450">Si el destino solicita un formato de representación retrasado, el shell ejecutará la aplicación y proporcionará los datos al destino desde el objeto activo.</span><span class="sxs-lookup"><span data-stu-id="28180-450">If the target requests a delayed rendering format, the Shell will run the application and provide the data to the target from the active object.</span></span>

> [!Note]  
> <span data-ttu-id="28180-451">Dado que la representación retrasada es algo arriesgada, se debe usar con precaución.</span><span class="sxs-lookup"><span data-stu-id="28180-451">Because delayed rendering is somewhat risky, it should be used with caution.</span></span> <span data-ttu-id="28180-452">No funcionará si el servidor no está disponible o en aplicaciones que no estén habilitadas para OLE.</span><span class="sxs-lookup"><span data-stu-id="28180-452">It will not work if the server is not available, or on applications that are not OLE-enabled.</span></span>

 

## <a name="dragging-and-dropping-shell-objects-asynchronously"></a><span data-ttu-id="28180-453">Arrastrar y colocar objetos de Shell de forma asincrónica</span><span class="sxs-lookup"><span data-stu-id="28180-453">Dragging and Dropping Shell Objects Asynchronously</span></span>

<span data-ttu-id="28180-454">**Escenario:** Un usuario transfiere un gran bloque de datos del origen al destino.</span><span class="sxs-lookup"><span data-stu-id="28180-454">**Scenario:** A user transfers a large block of data from source to target.</span></span> <span data-ttu-id="28180-455">Para evitar el bloqueo de ambas aplicaciones durante un período de tiempo considerable, el destino extrae los datos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="28180-455">To avoid blocking both applications for a significant amount of time, the target extracts the data asynchronously.</span></span>

<span data-ttu-id="28180-456">Normalmente, arrastrar y colocar es una operación sincrónica.</span><span class="sxs-lookup"><span data-stu-id="28180-456">Normally, drag-and-drop is a synchronous operation.</span></span> <span data-ttu-id="28180-457">En resumen:</span><span class="sxs-lookup"><span data-stu-id="28180-457">In brief:</span></span>

1.  <span data-ttu-id="28180-458">El origen de colocación llama a [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) y bloquea su subproceso principal hasta que la función devuelve.</span><span class="sxs-lookup"><span data-stu-id="28180-458">The drop source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) and blocks its primary thread until the function returns.</span></span> <span data-ttu-id="28180-459">Bloquear el subproceso principal normalmente bloquea el procesamiento de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="28180-459">Blocking the primary thread normally blocks UI processing.</span></span>
2.  <span data-ttu-id="28180-460">Después de llamar al método [**IDropTarget::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) del destino, el destino extrae los datos del objeto de datos en su subproceso principal.</span><span class="sxs-lookup"><span data-stu-id="28180-460">After the target's [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method is called, the target extracts the data from the data object on its primary thread.</span></span> <span data-ttu-id="28180-461">Este procedimiento normalmente bloquea el procesamiento de la interfaz de usuario del destino mientras dure el proceso de extracción.</span><span class="sxs-lookup"><span data-stu-id="28180-461">This procedure normally blocks the target's UI processing for the duration of the extraction process.</span></span>
3.  <span data-ttu-id="28180-462">Una vez extraídos los datos, el destino devuelve la llamada a [**IDropTarget::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , el sistema devuelve [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)y ambos subprocesos pueden continuar.</span><span class="sxs-lookup"><span data-stu-id="28180-462">Once the data has been extracted, the target returns the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, the system returns [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop), and both threads can proceed.</span></span>

<span data-ttu-id="28180-463">En Resumen, la transferencia de datos sincrónicos puede bloquear los subprocesos principales de ambas aplicaciones durante un período de tiempo considerable.</span><span class="sxs-lookup"><span data-stu-id="28180-463">In short, synchronous data transfer can block the primary threads of both applications for a significant amount of time.</span></span> <span data-ttu-id="28180-464">En concreto, ambos subprocesos deben esperar mientras el destino extrae los datos.</span><span class="sxs-lookup"><span data-stu-id="28180-464">In particular, both threads must wait while the target extracts the data.</span></span> <span data-ttu-id="28180-465">Para pequeñas cantidades de datos, el tiempo necesario para extraer los datos es pequeño y la transferencia de datos sincrónica funciona bastante bien.</span><span class="sxs-lookup"><span data-stu-id="28180-465">For small amounts of data, the time required to extract data is small and synchronous data transfer works quite well.</span></span> <span data-ttu-id="28180-466">Sin embargo, la extracción sincrónica de grandes cantidades de datos puede provocar retrasos prolongados e interferir con la interfaz de usuario de destino y origen.</span><span class="sxs-lookup"><span data-stu-id="28180-466">However, synchronously extracting large amounts of data can cause lengthy delays and interfere with the UI of both target and source.</span></span>

<span data-ttu-id="28180-467">La interfaz [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) es una interfaz opcional que puede ser implementada por un objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-467">The [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface is an optional interface that can be implemented by a data object.</span></span> <span data-ttu-id="28180-468">Proporciona al destino de colocación la capacidad de extraer datos del objeto de datos de forma asincrónica en un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="28180-468">It gives the drop target the ability to extract data from the data object asynchronously on a background thread.</span></span> <span data-ttu-id="28180-469">Una vez que la extracción de datos se entrega al subproceso en segundo plano, los subprocesos principales de ambas aplicaciones pueden continuar.</span><span class="sxs-lookup"><span data-stu-id="28180-469">Once data extraction is handed off to the background thread, the primary threads of both applications are free to proceed.</span></span>

### <a name="using-iasyncoperationidataobjectasynccapability"></a><span data-ttu-id="28180-470">Usar IASyncOperation/IDataObjectAsyncCapability</span><span class="sxs-lookup"><span data-stu-id="28180-470">Using IASyncOperation/IDataObjectAsyncCapability</span></span>

> [!Note]  
> <span data-ttu-id="28180-471">La interfaz se llamaba originalmente [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), pero posteriormente se cambió a [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span><span class="sxs-lookup"><span data-stu-id="28180-471">The interface was originally named [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), but this was later changed to [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span> <span data-ttu-id="28180-472">De lo contrario, las dos interfaces son idénticas.</span><span class="sxs-lookup"><span data-stu-id="28180-472">Otherwise, the two interfaces are identical.</span></span>

 

<span data-ttu-id="28180-473">El propósito de [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) es permitir que el origen de colocación y el destino de colocación negocien si los datos se pueden extraer de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="28180-473">The purpose of [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) is to allow the drop source and drop target to negotiate whether data can be extracted asynchronously.</span></span> <span data-ttu-id="28180-474">En el procedimiento siguiente se describe cómo el origen de colocación utiliza la interfaz:</span><span class="sxs-lookup"><span data-stu-id="28180-474">The following procedure outlines how the drop source uses the interface:</span></span>

1.  <span data-ttu-id="28180-475">Cree un objeto de datos que exponga [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span><span class="sxs-lookup"><span data-stu-id="28180-475">Create a data object that exposes [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span>
2.  <span data-ttu-id="28180-476">Llame a [**SetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) con *FDoOpAsync* establecido en **Variant \_ true** para indicar que se admite una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="28180-476">Call [**SetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) with *fDoOpAsync* set to **VARIANT\_TRUE** to indicate that an asynchronous operation is supported.</span></span>
3.  <span data-ttu-id="28180-477">Después de que el método [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) devuelva, llame a [**inoperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation):</span><span class="sxs-lookup"><span data-stu-id="28180-477">After [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) returns, call [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation):</span></span>
    -   <span data-ttu-id="28180-478">Si se produce un error en la [**inoperación**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) o devuelve **Variant \_ false**, se realiza una transferencia de datos sincrónica normal y finaliza el proceso de extracción de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-478">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) fails or returns **VARIANT\_FALSE**, a normal synchronous data transfer has taken place and the data extraction process is finished.</span></span> <span data-ttu-id="28180-479">El origen debe realizar cualquier limpieza necesaria y continuar.</span><span class="sxs-lookup"><span data-stu-id="28180-479">The source should do any cleanup that is required, and proceed.</span></span>
    -   <span data-ttu-id="28180-480">Si [**inoperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) devuelve **Variant \_ true**, los datos se extraen de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="28180-480">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) returns **VARIANT\_TRUE**, the data is being extracted asynchronously.</span></span> <span data-ttu-id="28180-481">Las operaciones de limpieza deben controlarse mediante [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span><span class="sxs-lookup"><span data-stu-id="28180-481">Cleanup operations should be handled by [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>
4.  <span data-ttu-id="28180-482">Libera el objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-482">Release the data object.</span></span>
5.  <span data-ttu-id="28180-483">Una vez completada la transferencia de datos asincrónica, el objeto de datos notifica normalmente al origen a través de una interfaz privada.</span><span class="sxs-lookup"><span data-stu-id="28180-483">When the asynchronous data transfer is complete, the data object normally notifies the source through a private interface.</span></span>

<span data-ttu-id="28180-484">En el procedimiento siguiente se describe cómo el destino de colocación usa la interfaz [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) para extraer datos de forma asincrónica:</span><span class="sxs-lookup"><span data-stu-id="28180-484">The following procedure outlines how the drop target uses the [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface to extract data asynchronously:</span></span>

1.  <span data-ttu-id="28180-485">Cuando el sistema llama a [**IDropTarget::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), llame a [**IDataObject:: QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) y solicite una [](/previous-versions//bb776309(v=vs.85)) / interfaz [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) de IAsyncOperation (IID \_ IAsyncOperation/IID \_ IDataObjectAsyncCapability) del objeto de datos.</span><span class="sxs-lookup"><span data-stu-id="28180-485">When the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), call [**IDataObject::QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) and request an [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface (IID\_IAsyncOperation/IID\_IDataObjectAsyncCapability) from the data object.</span></span>
2.  <span data-ttu-id="28180-486">Llame a [**GetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode).</span><span class="sxs-lookup"><span data-stu-id="28180-486">Call [**GetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode).</span></span> <span data-ttu-id="28180-487">Si el método devuelve **Variant \_ true**, el objeto de datos admite la extracción de datos asincrónica.</span><span class="sxs-lookup"><span data-stu-id="28180-487">If the method returns **VARIANT\_TRUE**, the data object supports asynchronous data extraction.</span></span>
3.  <span data-ttu-id="28180-488">Cree un subproceso independiente para controlar la extracción de datos y llamar a [**StartOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).</span><span class="sxs-lookup"><span data-stu-id="28180-488">Create a separate thread to handle data extraction and call [**StartOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).</span></span>
4.  <span data-ttu-id="28180-489">Devuelva la llamada a [**IDropTarget::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , como lo haría para una operación de transferencia de datos normal.</span><span class="sxs-lookup"><span data-stu-id="28180-489">Return the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, as you would for a normal data transfer operation.</span></span> <span data-ttu-id="28180-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) devolverá y desbloqueará el origen de colocación.</span><span class="sxs-lookup"><span data-stu-id="28180-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) will return and unblock the drop source.</span></span> <span data-ttu-id="28180-491">No llame a [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) para indicar el resultado de una operación de movimiento o eliminación optimizada.</span><span class="sxs-lookup"><span data-stu-id="28180-491">Do not call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome of an optimized move or delete-on-paste operation.</span></span> <span data-ttu-id="28180-492">Espere hasta que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="28180-492">Wait until the operation is finished.</span></span>
5.  <span data-ttu-id="28180-493">Extraiga los datos en el subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="28180-493">Extract the data on the background thread.</span></span> <span data-ttu-id="28180-494">El subproceso principal del destino está desbloqueado y disponible para continuar.</span><span class="sxs-lookup"><span data-stu-id="28180-494">The target's primary thread is unblocked and free to proceed.</span></span>
6.  <span data-ttu-id="28180-495">Si la transferencia de datos era una operación de [movimiento optimizado](#handling-optimized-move-operations) o [de eliminación en pegado](#handling-delete-on-paste-operations) , llame a [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) para indicar el resultado.</span><span class="sxs-lookup"><span data-stu-id="28180-495">If the data transfer was an [optimized move](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operation, call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome.</span></span>
7.  <span data-ttu-id="28180-496">Notifique al objeto de datos que la extracción ha finalizado mediante una llamada a [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span><span class="sxs-lookup"><span data-stu-id="28180-496">Notify the data object that extraction is finished by calling [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>

 

 
