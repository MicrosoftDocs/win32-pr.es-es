---
title: Información general sobre montones de descriptores
description: Los montones descriptores contienen muchos tipos de objetos que no forman parte de un objeto de estado de canalización (PSO), como las vistas de recursos del sombreador (SRVs), las vistas de acceso desordenado (UAVs), las vistas de búfer de constantes (CBVs) y los muestreadores.
ms.assetid: 14561E77-44E0-4A58-8456-F40D59ECA175
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a8bf720ebb71d016457fa4383a8d33aa62e2eee4
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "74103673"
---
# <a name="descriptor-heaps-overview"></a><span data-ttu-id="3ad84-103">Información general sobre montones de descriptores</span><span class="sxs-lookup"><span data-stu-id="3ad84-103">Descriptor Heaps Overview</span></span>

<span data-ttu-id="3ad84-104">Los montones descriptores contienen muchos tipos de objetos que no forman parte de un objeto de estado de canalización (PSO), como las vistas de recursos del sombreador (SRVs), las vistas de acceso desordenado (UAVs), las vistas de búfer de constantes (CBVs) y los muestreadores.</span><span class="sxs-lookup"><span data-stu-id="3ad84-104">Descriptor heaps contain many object types that are not part of a Pipeline State Object (PSO), such as Shader Resource Views (SRVs), Unordered Access Views (UAVs), Constant Buffer Views (CBVs), and Samplers.</span></span>

-   [<span data-ttu-id="3ad84-105">El propósito de los montones de descriptor</span><span class="sxs-lookup"><span data-stu-id="3ad84-105">The Purpose of Descriptor Heaps</span></span>](#the-purpose-of-descriptor-heaps)
-   [<span data-ttu-id="3ad84-106">Sincronización</span><span class="sxs-lookup"><span data-stu-id="3ad84-106">Synchronization</span></span>](#synchronization)
-   [<span data-ttu-id="3ad84-107">Binding</span><span class="sxs-lookup"><span data-stu-id="3ad84-107">Binding</span></span>](#binding)
-   [<span data-ttu-id="3ad84-108">Cambiar montones</span><span class="sxs-lookup"><span data-stu-id="3ad84-108">Switching heaps</span></span>](#switching-heaps)
-   [<span data-ttu-id="3ad84-109">Agrupaciones</span><span class="sxs-lookup"><span data-stu-id="3ad84-109">Bundles</span></span>](#bundles)
-   [<span data-ttu-id="3ad84-110">Administración</span><span class="sxs-lookup"><span data-stu-id="3ad84-110">Management</span></span>](#management)
-   [<span data-ttu-id="3ad84-111">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="3ad84-111">Related topics</span></span>](#related-topics)

## <a name="the-purpose-of-descriptor-heaps"></a><span data-ttu-id="3ad84-112">El propósito de los montones de descriptor</span><span class="sxs-lookup"><span data-stu-id="3ad84-112">The Purpose of Descriptor Heaps</span></span>

<span data-ttu-id="3ad84-113">El propósito principal de un montón de descriptores es abarcar la asignación de memoria masiva necesaria para almacenar las especificaciones de descriptor de tipos de objeto a los que los sombreadores hacen referencia para el tamaño de una ventana de representación lo más grande posible (lo ideal es un marco completo de representación o más).</span><span class="sxs-lookup"><span data-stu-id="3ad84-113">The primary purpose of a descriptor heap is to encompass the bulk of memory allocation required for storing the descriptor specifications of object types that shaders reference for as large of a window of rendering as possible (ideally an entire frame of rendering or more).</span></span> <span data-ttu-id="3ad84-114">Si una aplicación está cambiando las texturas que la canalización ve rápidamente desde la API, debe haber espacio en el montón de descriptores para definir las tablas de descriptor sobre la marcha para cada conjunto de Estados necesarios.</span><span class="sxs-lookup"><span data-stu-id="3ad84-114">If an application is switching which textures the pipeline sees rapidly from the API, there has to be space in the descriptor heap to define descriptor tables on the fly for every set of state needed.</span></span> <span data-ttu-id="3ad84-115">La aplicación puede optar por reutilizar definiciones si los recursos se utilizan de nuevo en otro objeto, por ejemplo, o simplemente asignan el espacio del montón secuencialmente a medida que cambia varios tipos de objeto.</span><span class="sxs-lookup"><span data-stu-id="3ad84-115">The application can choose to reuse definitions if the resources are used again in another object, for example, or just assign the heap space sequentially as it switches various object types.</span></span>

<span data-ttu-id="3ad84-116">Los montones de descriptor también permiten a los componentes de software individuales administrar el almacenamiento de descriptores de forma independiente entre sí.</span><span class="sxs-lookup"><span data-stu-id="3ad84-116">Descriptor heaps also allow individual software components to manage descriptor storage separately from each other.</span></span>

<span data-ttu-id="3ad84-117">Todos los montones están visibles para la CPU.</span><span class="sxs-lookup"><span data-stu-id="3ad84-117">All heaps are visible to the CPU.</span></span> <span data-ttu-id="3ad84-118">La aplicación también puede solicitar las propiedades de acceso a la CPU que debe tener un montón de descriptores (si existen): escritura combinada, escritura inversa, etc.</span><span class="sxs-lookup"><span data-stu-id="3ad84-118">The application can also request which CPU access properties a descriptor heap should have (if any) – write combined, write back, and so on.</span></span> <span data-ttu-id="3ad84-119">Las aplicaciones pueden crear tantos montones de descriptor como sea necesario, con las propiedades que desee.</span><span class="sxs-lookup"><span data-stu-id="3ad84-119">Apps can create as many descriptor heaps as desired with whatever properties are desired.</span></span> <span data-ttu-id="3ad84-120">Las aplicaciones siempre tienen la opción de crear montones de descriptor que son exclusivamente para fines de almacenamiento provisional sin restricciones de tamaño, y copiar en montones de descriptores que se usan para la representación según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="3ad84-120">Apps always have the option to create descriptor heaps that are purely for staging purposes that are unconstrained in size, and copying to descriptor heaps that are used for rendering as necessary.</span></span>

<span data-ttu-id="3ad84-121">Hay algunas restricciones en lo que puede ir en el mismo montón de descriptores.</span><span class="sxs-lookup"><span data-stu-id="3ad84-121">There are some restrictions in what can go in the same descriptor heap.</span></span> <span data-ttu-id="3ad84-122">Las entradas CBV, UAV y SRV pueden estar en el mismo montón de descriptores.</span><span class="sxs-lookup"><span data-stu-id="3ad84-122">CBV, UAV and SRV entries can be in the same descriptor heap.</span></span> <span data-ttu-id="3ad84-123">Sin embargo, las entradas de muestreadores no pueden compartir un montón con las entradas CBV, UAV o SRV.</span><span class="sxs-lookup"><span data-stu-id="3ad84-123">However, Samplers entries cannot share a heap with CBV, UAV or SRV entries.</span></span> <span data-ttu-id="3ad84-124">Normalmente, hay dos conjuntos de montones de descriptor, uno para los recursos comunes y el segundo para los muestreadores.</span><span class="sxs-lookup"><span data-stu-id="3ad84-124">Typically, there are two sets of descriptor heaps, one for the common resources and the second for Samplers.</span></span>

<span data-ttu-id="3ad84-125">El uso de montones de descriptor de Direct3D 12 refleja lo que hace la mayoría del hardware de GPU, que es requerir descriptores en vivo solo en montones de descriptores, o simplemente que se necesitan menos bits de direccionamiento si se usan estos montones.</span><span class="sxs-lookup"><span data-stu-id="3ad84-125">The use of descriptor heaps by Direct3D 12 mirrors what most GPU hardware does, which is to either require descriptors live only in descriptor heaps, or simply that fewer addressing bits are needed if these heaps are used.</span></span> <span data-ttu-id="3ad84-126">Direct3D 12 requiere el uso de montones de descriptor, no hay ninguna opción para colocar los descriptores en cualquier parte de la memoria.</span><span class="sxs-lookup"><span data-stu-id="3ad84-126">Direct3D 12 does require the use of descriptor heaps, there is no option to put descriptors anywhere in memory.</span></span>

<span data-ttu-id="3ad84-127">Los montones de descriptor solo se pueden editar inmediatamente mediante la CPU, no hay ninguna opción para editar un montón de descriptores en la GPU.</span><span class="sxs-lookup"><span data-stu-id="3ad84-127">Descriptor heaps can only be edited immediately by the CPU, there is no option to edit a descriptor heap by the GPU.</span></span>

## <a name="synchronization"></a><span data-ttu-id="3ad84-128">Synchronization</span><span class="sxs-lookup"><span data-stu-id="3ad84-128">Synchronization</span></span>

<span data-ttu-id="3ad84-129">El contenido del montón descriptor se puede cambiar antes, durante y después de grabar las listas de comandos que hacen referencia a él.</span><span class="sxs-lookup"><span data-stu-id="3ad84-129">Descriptor heap contents can be changed before, during and after recording command lists that reference it.</span></span> <span data-ttu-id="3ad84-130">Sin embargo, los descriptores no se pueden cambiar mientras una lista de comandos enviada para su ejecución puede hacer referencia a esa ubicación, ya que esto podría invocar una condición de carrera.</span><span class="sxs-lookup"><span data-stu-id="3ad84-130">However, descriptors cannot be changed while a command list submitted for execution might reference that location, as this could invoke a race condition.</span></span>

## <a name="binding"></a><span data-ttu-id="3ad84-131">Enlace</span><span class="sxs-lookup"><span data-stu-id="3ad84-131">Binding</span></span>

<span data-ttu-id="3ad84-132">Como máximo, un montón combinado CBV/SRV/UAV y un montón de muestra se pueden enlazar al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="3ad84-132">At most one CBV/SRV/UAV combined heap and one Sampler heap can be bound at any one time.</span></span> <span data-ttu-id="3ad84-133">Estos montones se comparten entre las canalizaciones de gráficos y de proceso (descritas en su PSO).</span><span class="sxs-lookup"><span data-stu-id="3ad84-133">These heaps are shared between both the graphics and compute pipelines (described in their PSOs).</span></span>

## <a name="switching-heaps"></a><span data-ttu-id="3ad84-134">Cambiar montones</span><span class="sxs-lookup"><span data-stu-id="3ad84-134">Switching heaps</span></span>

<span data-ttu-id="3ad84-135">Es aceptable que una aplicación cambie los montones dentro de la misma lista de comandos o en otros diferentes mediante las API [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) y [**RESET**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) .</span><span class="sxs-lookup"><span data-stu-id="3ad84-135">It is acceptable for an application to switch heaps within the same command list or in different ones using the [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) and [**Reset**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) APIs.</span></span> <span data-ttu-id="3ad84-136">En algunos requisitos de hardware, esto puede ser una operación costosa, que requiere una detención de GPU para vaciar todo el trabajo que depende del montón de descriptor enlazado actualmente.</span><span class="sxs-lookup"><span data-stu-id="3ad84-136">On some hardware, this can be an expensive operation, requiring a GPU stall to flush all work that depends on the currently bound descriptor heap.</span></span> <span data-ttu-id="3ad84-137">Como resultado, si se deben cambiar los montones de descriptor, las aplicaciones deben intentar hacerlo cuando la carga de trabajo de la GPU sea relativamente ligera, lo que puede limitar los cambios al inicio de una lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="3ad84-137">As a result, if descriptor heaps must be changed, applications should try to do so when the GPU workload is relatively light, perhaps limiting changes to the start of a command list.</span></span>

## <a name="bundles"></a><span data-ttu-id="3ad84-138">Agrupaciones</span><span class="sxs-lookup"><span data-stu-id="3ad84-138">Bundles</span></span>

<span data-ttu-id="3ad84-139">Con las agrupaciones solo puede haber una llamada al método [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) , y el conjunto de montones descriptores debe coincidir exactamente con los de la lista de comandos que llama a la agrupación.</span><span class="sxs-lookup"><span data-stu-id="3ad84-139">With bundles there can only be one call to the [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) method, and the descriptor heaps set must match exactly those of the command list calling the bundle.</span></span> <span data-ttu-id="3ad84-140">Si el paquete no cambia las tablas de descriptores, no es necesario establecer los montones de descriptor.</span><span class="sxs-lookup"><span data-stu-id="3ad84-140">If the bundle does not change descriptor tables, it does not need to set the descriptor heaps.</span></span>

<span data-ttu-id="3ad84-141">Para obtener una lista de llamadas API que no se pueden usar con agrupaciones, consulte [crear y grabar listas de comandos y agrupaciones](recording-command-lists-and-bundles.md).</span><span class="sxs-lookup"><span data-stu-id="3ad84-141">For a list of API calls that cannot be used with bundles, refer to [Creating and Recording Command Lists and Bundles](recording-command-lists-and-bundles.md).</span></span>

## <a name="management"></a><span data-ttu-id="3ad84-142">Administración</span><span class="sxs-lookup"><span data-stu-id="3ad84-142">Management</span></span>

<span data-ttu-id="3ad84-143">Para representar todos los objetos de una escena, se necesitarán muchos descriptores y se pueden seguir algunas estrategias de administración diferentes.</span><span class="sxs-lookup"><span data-stu-id="3ad84-143">To render all of the objects in a scene, many descriptors will be needed, and there are some different management strategies that can be followed.</span></span>

<span data-ttu-id="3ad84-144">La estrategia más básica sería rellenar una nueva área del montón descriptor con todos los requisitos para la siguiente llamada a Draw.</span><span class="sxs-lookup"><span data-stu-id="3ad84-144">The most basic strategy would be to fill in a fresh area of the descriptor heap with all of the requirements for the next draw call.</span></span> <span data-ttu-id="3ad84-145">Por lo tanto, justo antes de emitir la llamada a Draw en la lista de comandos, un puntero de tabla de descriptores se establecería en el inicio de la tabla recién rellenada.</span><span class="sxs-lookup"><span data-stu-id="3ad84-145">So, just before issuing the draw call on the command list, a descriptor table pointer would be set to the start of the freshly populated table.</span></span> <span data-ttu-id="3ad84-146">El lado es que no es necesario registrar dónde se encuentra un descriptor determinado en el montón.</span><span class="sxs-lookup"><span data-stu-id="3ad84-146">The upside is that there is no need to record where any particular descriptor is in the heap.</span></span>

<span data-ttu-id="3ad84-147">El inconveniente de esta estrategia es que podría haber una gran cantidad de repeticiones de descriptores en el montón de descriptores, especialmente cuando se está representando una escena muy similar y el espacio de montón del descriptor se va a usar rápidamente.</span><span class="sxs-lookup"><span data-stu-id="3ad84-147">The downside to this strategy is that there could be a lot of repetition of descriptors in the descriptor heap, especially when a very similar scene is being rendered, and that descriptor heap space is going to be used up quickly.</span></span> <span data-ttu-id="3ad84-148">Los montones de descriptor independientes para los que se representan en la GPU y para los que se registran con la CPU, probablemente serán necesarios para evitar conflictos.</span><span class="sxs-lookup"><span data-stu-id="3ad84-148">Separate descriptor heaps for those being rendered on the GPU and for those being recorded by the CPU, would probably be necessary to avoid conflict.</span></span> <span data-ttu-id="3ad84-149">También se podría usar un sistema de subasignación.</span><span class="sxs-lookup"><span data-stu-id="3ad84-149">Alternatively a sub-allocation system could be used.</span></span>

<span data-ttu-id="3ad84-150">Además, el sistema básico se podría optimizar aún más mediante el uso minucioso de las tablas de descriptores superpuestas de una llamada a Draw a la siguiente, de modo que solo se agreguen los nuevos descriptores.</span><span class="sxs-lookup"><span data-stu-id="3ad84-150">Also, the basic system could be further optimized by careful use of overlapping descriptor tables from one draw call to the next, so that only the new descriptors required are added.</span></span>

<span data-ttu-id="3ad84-151">Una estrategia más eficaz que la básica sería rellenar previamente los montones de descriptor con los descriptores necesarios para los objetos (o materiales) que se sabe que forman parte de la escena.</span><span class="sxs-lookup"><span data-stu-id="3ad84-151">A more efficient strategy than the basic one would be to pre-fill descriptor heaps with descriptors required for the objects (or materials) that are known to be part of the scene.</span></span> <span data-ttu-id="3ad84-152">La idea es que solo es necesario establecer la tabla de descriptores en el momento de la hora de dibujo, ya que el montón de descriptores se rellena con anterioridad.</span><span class="sxs-lookup"><span data-stu-id="3ad84-152">The idea here is that it is only necessary to set the descriptor table at draw time, as the descriptor heap is populated ahead of time.</span></span>

<span data-ttu-id="3ad84-153">Una variación de la estrategia de prerelleno consiste en tratar el montón de descriptores como una gran matriz, que contiene todos los descriptores necesarios en ubicaciones conocidas fijas.</span><span class="sxs-lookup"><span data-stu-id="3ad84-153">A variation of the pre-filling strategy is to treat the descriptor heap as one huge array, containing all the required descriptors in fixed known locations.</span></span> <span data-ttu-id="3ad84-154">A continuación, la llamada a Draw solo tiene que recibir un conjunto de constantes que son los índices en la matriz de donde se deben usar los descriptores.</span><span class="sxs-lookup"><span data-stu-id="3ad84-154">Then the draw call needs only to receive a set of constants which are the indices into the array of where the descriptors are that need to be used.</span></span>

<span data-ttu-id="3ad84-155">Una optimización adicional consiste en asegurarse de que las constantes raíz y los descriptores raíz contengan los que cambian con más frecuencia, en lugar de colocar constantes en el montón de descriptores.</span><span class="sxs-lookup"><span data-stu-id="3ad84-155">A further optimization is to ensure root constants and root descriptors contain those that change most frequently, rather than place constants in the descriptor heap.</span></span> <span data-ttu-id="3ad84-156">Para la mayoría del hardware, se trata de una forma eficaz de controlar las constantes.</span><span class="sxs-lookup"><span data-stu-id="3ad84-156">For most hardware this is an efficient way of handling constants.</span></span>

<span data-ttu-id="3ad84-157">En la práctica, un motor de gráficos podría usar una estrategia diferente en situaciones diferentes y combinar elementos de cada estrategia para satisfacer los requisitos de dibujo concretos.</span><span class="sxs-lookup"><span data-stu-id="3ad84-157">In practice a graphics engine might use a different strategy in different situations, and combine elements of each strategy to suit the particular drawing requirements.</span></span>

## <a name="related-topics"></a><span data-ttu-id="3ad84-158">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="3ad84-158">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3ad84-159">Montones de descriptores</span><span class="sxs-lookup"><span data-stu-id="3ad84-159">Descriptor Heaps</span></span>](descriptor-heaps.md)
</dt> </dl>

 

 




