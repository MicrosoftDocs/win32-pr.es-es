---
title: Reglas para administrar recuentos de referencias
description: El uso de un recuento de referencias para administrar la duración de un objeto permite que varios clientes obtengan y liberen el acceso a un único objeto sin tener que coordinarse entre sí en la administración de la duración del objeto.
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/21/2020
ms.locfileid: "104421443"
---
# <a name="rules-for-managing-reference-counts"></a><span data-ttu-id="1f810-103">Reglas para administrar recuentos de referencias</span><span class="sxs-lookup"><span data-stu-id="1f810-103">Rules for Managing Reference Counts</span></span>

<span data-ttu-id="1f810-104">El uso de un recuento de referencias para administrar la duración de un objeto permite que varios clientes obtengan y liberen el acceso a un único objeto sin tener que coordinarse entre sí en la administración de la duración del objeto.</span><span class="sxs-lookup"><span data-stu-id="1f810-104">Using a reference count to manage an object's lifetime allows multiple clients to obtain and release access to a single object without having to coordinate with one another in managing the object's lifetime.</span></span> <span data-ttu-id="1f810-105">Siempre que el objeto de cliente se ajuste a ciertas reglas de uso, el objeto, en efecto, proporciona esta administración.</span><span class="sxs-lookup"><span data-stu-id="1f810-105">As long as the client object conforms to certain rules of use, the object, in effect, provides this management.</span></span> <span data-ttu-id="1f810-106">Estas reglas especifican cómo administrar las referencias entre objetos.</span><span class="sxs-lookup"><span data-stu-id="1f810-106">These rules specify how to manage references between objects.</span></span> <span data-ttu-id="1f810-107">(COM no especifica implementaciones internas de objetos, aunque estas reglas son un punto de partida razonable para una directiva dentro de un objeto).</span><span class="sxs-lookup"><span data-stu-id="1f810-107">(COM does not specify internal implementations of objects, although these rules are a reasonable starting point for a policy within an object.)</span></span>

<span data-ttu-id="1f810-108">Conceptualmente, los punteros de interfaz se pueden considerar como residentes en variables de puntero que incluyen todo el estado de cálculo interno que contiene un puntero de interfaz.</span><span class="sxs-lookup"><span data-stu-id="1f810-108">Conceptually, interface pointers can be thought of as residing within pointer variables that include all the internal computation state that holds an interface pointer.</span></span> <span data-ttu-id="1f810-109">Esto incluiría las variables en las ubicaciones de memoria, en los registros internos del procesador y en las variables generadas por el programador y las generadas por el compilador.</span><span class="sxs-lookup"><span data-stu-id="1f810-109">This would include variables in memory locations, in internal processor registers, and both programmer-generated and compiler-generated variables.</span></span> <span data-ttu-id="1f810-110">La asignación o inicialización de una variable de puntero implica la creación de una nueva copia de un puntero ya existente.</span><span class="sxs-lookup"><span data-stu-id="1f810-110">Assignment to or initialization of a pointer variable involves creating a new copy of an already existing pointer.</span></span> <span data-ttu-id="1f810-111">Cuando haya una copia del puntero en alguna variable (el valor usado en la asignación/inicialización), ahora habrá dos.</span><span class="sxs-lookup"><span data-stu-id="1f810-111">Where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there are now two.</span></span> <span data-ttu-id="1f810-112">Una asignación a una variable de puntero destruye la copia del puntero en la variable, al igual que la destrucción de la propia variable.</span><span class="sxs-lookup"><span data-stu-id="1f810-112">An assignment to a pointer variable destroys the pointer copy presently in the variable, as does the destruction of the variable itself.</span></span> <span data-ttu-id="1f810-113">(Es decir, se destruye el ámbito en el que se encuentra la variable, como el marco de pila).</span><span class="sxs-lookup"><span data-stu-id="1f810-113">(That is, the scope in which the variable is found, such as the stack frame, is destroyed.)</span></span>

<span data-ttu-id="1f810-114">Desde la perspectiva del cliente COM, siempre se realiza el recuento de referencias para cada interfaz.</span><span class="sxs-lookup"><span data-stu-id="1f810-114">From a COM client's perspective, reference counting is always done for each interface.</span></span> <span data-ttu-id="1f810-115">Los clientes nunca deben suponer que un objeto utiliza el mismo contador para todas las interfaces.</span><span class="sxs-lookup"><span data-stu-id="1f810-115">Clients should never assume that an object uses the same counter for all interfaces.</span></span>

<span data-ttu-id="1f810-116">El caso predeterminado es que se debe llamar a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) para cada nueva copia de un puntero de interfaz y se debe llamar a la [**versión**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) para cada destrucción de un puntero de interfaz, excepto en los casos en los que las siguientes reglas permiten lo contrario:</span><span class="sxs-lookup"><span data-stu-id="1f810-116">The default case is that [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) must be called for every new copy of an interface pointer and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) must be called for every destruction of an interface pointer, except where the following rules permit otherwise:</span></span>

-   <span data-ttu-id="1f810-117">**Parámetros de salida a funciones.**</span><span class="sxs-lookup"><span data-stu-id="1f810-117">**In-out parameters to functions.**</span></span> <span data-ttu-id="1f810-118">El autor de la llamada debe llamar a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) en el parámetro porque se liberará (con una llamada a [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) en el código de implementación cuando el valor de salida se almacena encima de él.</span><span class="sxs-lookup"><span data-stu-id="1f810-118">The caller must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the parameter because it will be released (with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) in the implementing code when the out value is stored on top of it.</span></span>
-   <span data-ttu-id="1f810-119">**Obteniendo una variable global.**</span><span class="sxs-lookup"><span data-stu-id="1f810-119">**Fetching a global variable.**</span></span> <span data-ttu-id="1f810-120">Al crear una copia local de un puntero de interfaz a partir de una copia existente del puntero en una variable global, debe llamar a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) en la copia local, ya que otra función puede destruir la copia en la variable global mientras la copia local sigue siendo válida.</span><span class="sxs-lookup"><span data-stu-id="1f810-120">When creating a local copy of an interface pointer from an existing copy of the pointer in a global variable, you must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the local copy because another function might destroy the copy in the global variable while the local copy is still valid.</span></span>
-   <span data-ttu-id="1f810-121">**Nuevos punteros sintetizados de "finos".**</span><span class="sxs-lookup"><span data-stu-id="1f810-121">**New pointers synthesized out of "thin air."**</span></span> <span data-ttu-id="1f810-122">Una función que sintetiza un puntero de interfaz mediante un conocimiento interno especial en lugar de obtenerlo de otro origen debe llamar a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) inicialmente en el puntero recién sintetizado.</span><span class="sxs-lookup"><span data-stu-id="1f810-122">A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initially on the newly synthesized pointer.</span></span> <span data-ttu-id="1f810-123">Entre los ejemplos importantes de estas rutinas se incluyen las rutinas de creación de instancias, las implementaciones de [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), etc.</span><span class="sxs-lookup"><span data-stu-id="1f810-123">Important examples of such routines include instance creation routines, implementations of [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), and so on.</span></span>
-   <span data-ttu-id="1f810-124">**Recuperar una copia de un puntero almacenado internamente.**</span><span class="sxs-lookup"><span data-stu-id="1f810-124">**Retrieving a copy of an internally stored pointer.**</span></span> <span data-ttu-id="1f810-125">Cuando una función recupera una copia de un puntero almacenado internamente por el objeto denominado, el código de ese objeto debe llamar a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) en el puntero antes de que se devuelva la función.</span><span class="sxs-lookup"><span data-stu-id="1f810-125">When a function retrieves a copy of a pointer that is stored internally by the object called, that object's code must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the pointer before the function returns.</span></span> <span data-ttu-id="1f810-126">Una vez que se ha recuperado el puntero, el objeto de origen no tiene ninguna otra manera de determinar cómo se relaciona su duración con la de la copia almacenada internamente del puntero.</span><span class="sxs-lookup"><span data-stu-id="1f810-126">Once the pointer has been retrieved, the originating object has no other way of determining how its lifetime relates to that of the internally stored copy of the pointer.</span></span>

<span data-ttu-id="1f810-127">Las únicas excepciones a los casos predeterminados requieren que el código de administración Conozca las relaciones de las duraciones de dos o más copias de un puntero a la misma interfaz en un objeto y, simplemente, asegúrese de que el objeto no se destruya permitiendo que su recuento de referencias vaya a cero.</span><span class="sxs-lookup"><span data-stu-id="1f810-127">The only exceptions to the default case require that the managing code know the relationships of the lifetimes of two or more copies of a pointer to the same interface on an object and simply ensure that the object is not destroyed by allowing its reference count to go to zero.</span></span> <span data-ttu-id="1f810-128">Normalmente hay dos casos, como se indica a continuación:</span><span class="sxs-lookup"><span data-stu-id="1f810-128">There are generally two cases, as follows:</span></span>

-   <span data-ttu-id="1f810-129">Cuando ya existe una copia de un puntero y se crea un segundo posteriormente y se destruye mientras la primera copia sigue existiendo, se pueden omitir las llamadas a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) y [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)para la segunda copia.</span><span class="sxs-lookup"><span data-stu-id="1f810-129">When one copy of a pointer already exists and a second is created subsequently and then is destroyed while the first copy still exists, calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)for the second copy can be omitted.</span></span>
-   <span data-ttu-id="1f810-130">Cuando existe una copia de un puntero y se crea un segundo y, a continuación, el primero se destruye antes del segundo, se pueden omitir las llamadas a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)para la segunda copia y a [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) para la primera copia.</span><span class="sxs-lookup"><span data-stu-id="1f810-130">When one copy of a pointer exists and a second is created and then the first is destroyed before the second, the calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)for the second copy and to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) for the first copy can be omitted.</span></span>

<span data-ttu-id="1f810-131">A continuación se muestran ejemplos específicos de estas situaciones, las dos primeras son especialmente comunes:</span><span class="sxs-lookup"><span data-stu-id="1f810-131">The following are specific examples of these situations, the first two being especially common:</span></span>

-   <span data-ttu-id="1f810-132">**En parámetros de funciones.**</span><span class="sxs-lookup"><span data-stu-id="1f810-132">**In parameters to functions.**</span></span> <span data-ttu-id="1f810-133">La duración de la copia de un puntero de interfaz que se pasa como un parámetro a una función está anidada en la del puntero que se usa para inicializar el valor, por lo que no es necesario contar con un recuento de referencias independiente en el parámetro.</span><span class="sxs-lookup"><span data-stu-id="1f810-133">The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value, so there is no need for a separate reference count on the parameter.</span></span>
-   <span data-ttu-id="1f810-134">**Parámetros out de funciones, incluidos los valores devueltos.**</span><span class="sxs-lookup"><span data-stu-id="1f810-134">**Out parameters from functions, including return values.**</span></span> <span data-ttu-id="1f810-135">Para establecer el parámetro de salida, la función debe tener una copia estable del puntero de interfaz.</span><span class="sxs-lookup"><span data-stu-id="1f810-135">To set the out parameter, the function must have a stable copy of the interface pointer.</span></span> <span data-ttu-id="1f810-136">En la devolución, el llamador es responsable de liberar el puntero.</span><span class="sxs-lookup"><span data-stu-id="1f810-136">On return, the caller is responsible for releasing the pointer.</span></span> <span data-ttu-id="1f810-137">Por lo tanto, el parámetro out no necesita un recuento de referencias independiente.</span><span class="sxs-lookup"><span data-stu-id="1f810-137">Therefore, the out parameter does not need a separate reference count.</span></span>
-   <span data-ttu-id="1f810-138">**Variables locales.**</span><span class="sxs-lookup"><span data-stu-id="1f810-138">**Local variables.**</span></span> <span data-ttu-id="1f810-139">Una implementación de método tiene el control de la duración de cada una de las variables de puntero asignadas en el marco de pila y puede usarla para determinar cómo se deben omitir los pares de versiones [**redundantes**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) / [](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) .</span><span class="sxs-lookup"><span data-stu-id="1f810-139">A method implementation has control of the lifetimes of each of the pointer variables allocated on the stack frame and can use this to determine how to omit redundant [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)/[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pairs.</span></span>
-   <span data-ttu-id="1f810-140">**Punteros al extremo.**</span><span class="sxs-lookup"><span data-stu-id="1f810-140">**Backpointers.**</span></span> <span data-ttu-id="1f810-141">Algunas estructuras de datos contienen dos objetos, cada uno con un puntero al otro.</span><span class="sxs-lookup"><span data-stu-id="1f810-141">Some data structures contain two objects, each with a pointer to the other.</span></span> <span data-ttu-id="1f810-142">Si se sabe que la duración del primer objeto contiene la duración del segundo, no es necesario tener un recuento de referencias en el puntero del segundo objeto al primer objeto.</span><span class="sxs-lookup"><span data-stu-id="1f810-142">If the lifetime of the first object is known to contain the lifetime of the second, it is not necessary to have a reference count on the second object's pointer to the first object.</span></span> <span data-ttu-id="1f810-143">A menudo, evitar este ciclo es importante para mantener el comportamiento de desasignación adecuado.</span><span class="sxs-lookup"><span data-stu-id="1f810-143">Often, avoiding this cycle is important in maintaining the appropriate deallocation behavior.</span></span> <span data-ttu-id="1f810-144">Sin embargo, los punteros descontados deben usarse con sumo cuidado porque la parte del sistema operativo que controla el procesamiento remoto no tiene forma de conocer esta relación.</span><span class="sxs-lookup"><span data-stu-id="1f810-144">However, uncounted pointers should be used with extreme caution because the portion of the operating system that handles remote processing has no way of knowing about this relationship.</span></span> <span data-ttu-id="1f810-145">Por lo tanto, en casi todos los casos, tener el puntero hacia arriba ve un segundo objeto "Friend" del primer puntero (lo que evita la circularidad) es la solución preferida.</span><span class="sxs-lookup"><span data-stu-id="1f810-145">Therefore, in almost all cases, having the backpointer see a second, "friend" object of the first pointer (thus avoiding the circularity) is the preferred solution.</span></span> <span data-ttu-id="1f810-146">La arquitectura de los objetos conectables de COM, por ejemplo, usa este enfoque.</span><span class="sxs-lookup"><span data-stu-id="1f810-146">COM's connectable objects architecture, for example, uses this approach.</span></span>

<span data-ttu-id="1f810-147">Al implementar o usar objetos con recuento de referencias, puede resultar útil aplicar *recuentos de referencias artificiales*, que garantizan la estabilidad del objeto durante el procesamiento de una función.</span><span class="sxs-lookup"><span data-stu-id="1f810-147">When implementing or using reference-counted objects, it may be useful to apply *artificial reference counts*, which guarantee object stability during processing of a function.</span></span> <span data-ttu-id="1f810-148">Al implementar un método de una interfaz, puede llamar a funciones que tienen la posibilidad de reducir el recuento de referencias a un objeto, lo que provoca una liberación prematura del objeto y el error de la implementación.</span><span class="sxs-lookup"><span data-stu-id="1f810-148">In implementing a method of an interface, you might call functions that have a chance of decrementing your reference count to an object, causing a premature release of the object and failure of the implementation.</span></span> <span data-ttu-id="1f810-149">Una manera eficaz de evitarlo es insertar una llamada a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) al principio de la implementación del método y emparejarla con una llamada a [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) justo antes de que el método devuelva.</span><span class="sxs-lookup"><span data-stu-id="1f810-149">A robust way to avoid this is to insert a call to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) at the beginning of the method implementation and pair it with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) just before the method returns.</span></span>

<span data-ttu-id="1f810-150">En algunas situaciones, los valores devueltos de [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) y [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pueden ser inestables y no se deben confiar en ellos; solo se deben usar con fines de depuración o diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="1f810-150">In some situations, the return values of [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) may be unstable and should not be relied upon; they should be used only for debugging or diagnostic purposes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="1f810-151">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="1f810-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="1f810-152">Administrar la duración de los objetos mediante el recuento de referencias</span><span class="sxs-lookup"><span data-stu-id="1f810-152">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 