---
title: Consideraciones de programación sin bloqueo para Xbox 360 y Microsoft Windows
description: En este artículo se proporciona información general sobre algunos de los problemas que se deben tener en cuenta al intentar usar técnicas de programación de bloqueo.
ms.assetid: 44700352-a791-7ef7-0858-146214b0e3da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 23bf8d66cada8aff00735fe6d6ac2d4f1369bc32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/21/2020
ms.locfileid: "103995728"
---
# <a name="lockless-programming-considerations-for-xbox-360-and-microsoft-windows"></a><span data-ttu-id="76331-103">Consideraciones de programación sin bloqueo para Xbox 360 y Microsoft Windows</span><span class="sxs-lookup"><span data-stu-id="76331-103">Lockless Programming Considerations for Xbox 360 and Microsoft Windows</span></span>

<span data-ttu-id="76331-104">La programación sin bloqueos es una manera de compartir de forma segura los datos modificados entre varios subprocesos sin el costo de adquirir y liberar bloqueos.</span><span class="sxs-lookup"><span data-stu-id="76331-104">Lockless programming is a way to safely share changing data between multiple threads without the cost of acquiring and releasing locks.</span></span> <span data-ttu-id="76331-105">Esto suena como una panacea, pero la programación sin bloqueos es compleja e sutil, y a veces no ofrece las ventajas que promete.</span><span class="sxs-lookup"><span data-stu-id="76331-105">This sounds like a panacea, but lockless programming is complex and subtle, and sometimes doesn't give the benefits that it promises.</span></span> <span data-ttu-id="76331-106">La programación con bloqueo es especialmente compleja en Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="76331-106">Lockless programming is particularly complex on Xbox 360.</span></span>

<span data-ttu-id="76331-107">La programación sin bloqueo es una técnica válida para la programación multiproceso, pero no debe usarse con poca.</span><span class="sxs-lookup"><span data-stu-id="76331-107">Lockless programming is a valid technique for multithreaded programming, but it should not be used lightly.</span></span> <span data-ttu-id="76331-108">Antes de usarlo, debe comprender las complejidades y debe medir detenidamente para asegurarse de que realmente le ofrezca las ganancias que espera.</span><span class="sxs-lookup"><span data-stu-id="76331-108">Before using it you must understand the complexities, and you should measure carefully to make sure that it is actually giving you the gains that you expect.</span></span> <span data-ttu-id="76331-109">En muchos casos, hay soluciones más sencillas y rápidas, como el uso compartido de datos con menos frecuencia, que deben usarse en su lugar.</span><span class="sxs-lookup"><span data-stu-id="76331-109">In many cases, there are simpler and faster solutions, such as sharing data less frequently, which should be used instead.</span></span>

<span data-ttu-id="76331-110">El uso de la programación sin bloqueo correctamente y de forma segura requiere un conocimiento significativo tanto del hardware como del compilador.</span><span class="sxs-lookup"><span data-stu-id="76331-110">Using lockless programming correctly and safely requires significant knowledge of both your hardware and your compiler.</span></span> <span data-ttu-id="76331-111">En este artículo se proporciona información general sobre algunos de los problemas que se deben tener en cuenta al intentar usar técnicas de programación de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-111">This article gives an overview of some of the issues to consider when trying to use lockless programming techniques.</span></span>

## <a name="programming-with-locks"></a><span data-ttu-id="76331-112">Programar con bloqueos</span><span class="sxs-lookup"><span data-stu-id="76331-112">Programming with Locks</span></span>

<span data-ttu-id="76331-113">Al escribir código multiproceso, a menudo es necesario compartir datos entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="76331-113">When writing multi-threaded code it is often necessary to share data between threads.</span></span> <span data-ttu-id="76331-114">Si varios subprocesos leen y escriben las estructuras de datos compartidas simultáneamente, pueden producirse daños en la memoria.</span><span class="sxs-lookup"><span data-stu-id="76331-114">If multiple threads are simultaneously reading and writing the shared data structures, memory corruption can occur.</span></span> <span data-ttu-id="76331-115">La forma más sencilla de resolver este problema es usar bloqueos.</span><span class="sxs-lookup"><span data-stu-id="76331-115">The simplest way of solving this problem is to use locks.</span></span> <span data-ttu-id="76331-116">Por ejemplo, si ManipulateSharedData solo debe ejecutarse en un subproceso cada vez, \_ se puede usar una sección crítica para garantizar esto, como en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="76331-116">For instance, if ManipulateSharedData should only be executed by one thread at a time, a CRITICAL\_SECTION can be used to guarantee this, as in the following code:</span></span>

``` syntax
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);

// Use
void ManipulateSharedData()
{
    EnterCriticalSection(&cs);
    // Manipulate stuff...
    LeaveCriticalSection(&cs);
}

// Destroy
DeleteCriticalSection(&cs);
```

<span data-ttu-id="76331-117">Este código es bastante sencillo y sencillo, y es fácil saber que es correcto.</span><span class="sxs-lookup"><span data-stu-id="76331-117">This code is fairly simple and straightforward, and it is easy to tell that it is correct.</span></span> <span data-ttu-id="76331-118">Sin embargo, la programación con bloqueos incluye varias desventajas potenciales.</span><span class="sxs-lookup"><span data-stu-id="76331-118">However, programming with locks comes with several potential disadvantages.</span></span> <span data-ttu-id="76331-119">Por ejemplo, si dos subprocesos intentan adquirir los mismos dos bloqueos pero los adquieren en un orden diferente, puede obtener un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-119">For example, if two threads try to acquire the same two locks but acquire them in a different order, you may get a deadlock.</span></span> <span data-ttu-id="76331-120">Si un programa mantiene un bloqueo durante demasiado tiempo, debido a un diseño deficiente o porque el subproceso se ha intercambiado por un subproceso de prioridad más alto, es posible que se bloqueen otros subprocesos durante mucho tiempo.</span><span class="sxs-lookup"><span data-stu-id="76331-120">If a program holds a lock for too long—because of poor design or because the thread has been swapped out by a higher priority thread—other threads may be blocked for a long time.</span></span> <span data-ttu-id="76331-121">Este riesgo es especialmente importante en Xbox 360 porque el desarrollador asigna un subproceso de hardware a los subprocesos de software, y el sistema operativo no los moverá a otro subproceso de hardware, incluso si uno está inactivo.</span><span class="sxs-lookup"><span data-stu-id="76331-121">This risk is particularly great on Xbox 360 because the software threads are assigned a hardware thread by the developer, and the operating system won't move them to another hardware thread, even if one is idle.</span></span> <span data-ttu-id="76331-122">La consola Xbox 360 tampoco tiene protección contra la inversion de prioridad, en la que un subproceso de prioridad alta gira en un bucle mientras espera a que un subproceso de prioridad baja libere un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-122">The Xbox 360 also has no protection against priority inversion, where a high-priority thread spins in a loop while waiting for a low-priority thread to release a lock.</span></span> <span data-ttu-id="76331-123">Por último, si una llamada a procedimiento diferida o una rutina de servicio de interrupción intenta adquirir un bloqueo, puede obtener un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-123">Finally, if a deferred procedure call or interrupt service routine tries to acquire a lock, you may get a deadlock.</span></span>

<span data-ttu-id="76331-124">A pesar de estos problemas, los primitivos de sincronización, como las secciones críticas, suelen ser la mejor manera de coordinar varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="76331-124">Despite these problems, synchronization primitives, such as critical sections, are generally the best way of coordinating multiple threads.</span></span> <span data-ttu-id="76331-125">Si los primitivos de sincronización son demasiado lentos, la mejor solución suele usarse con menos frecuencia.</span><span class="sxs-lookup"><span data-stu-id="76331-125">If the synchronization primitives are too slow, the best solution is usually to use them less frequently.</span></span> <span data-ttu-id="76331-126">Sin embargo, para aquellos que pueden permitir la complejidad adicional, otra opción es la programación sin bloqueos.</span><span class="sxs-lookup"><span data-stu-id="76331-126">However, for those who can afford the extra complexity, another option is lockless programming.</span></span>

## <a name="lockless-programming"></a><span data-ttu-id="76331-127">Programación con bloqueo</span><span class="sxs-lookup"><span data-stu-id="76331-127">Lockless Programming</span></span>

<span data-ttu-id="76331-128">La programación sin bloqueos, como sugiere el nombre, es una familia de técnicas para manipular de forma segura los datos compartidos sin utilizar bloqueos.</span><span class="sxs-lookup"><span data-stu-id="76331-128">Lockless programming, as the name suggests, is a family of techniques for safely manipulating shared data without using locks.</span></span> <span data-ttu-id="76331-129">Hay algoritmos de bloqueo disponibles para pasar mensajes, compartir listas y colas de datos, y otras tareas.</span><span class="sxs-lookup"><span data-stu-id="76331-129">There are lockless algorithms available for passing messages, sharing lists and queues of data, and other tasks.</span></span>

<span data-ttu-id="76331-130">Al realizar la programación sin bloqueos, hay dos desafíos que debe abordar: operaciones no atómicas y reordenación.</span><span class="sxs-lookup"><span data-stu-id="76331-130">When doing lockless programming, there are two challenges that you must deal with: non-atomic operations and reordering.</span></span>

## <a name="non-atomic-operations"></a><span data-ttu-id="76331-131">Operaciones no atómicas</span><span class="sxs-lookup"><span data-stu-id="76331-131">Non-Atomic Operations</span></span>

<span data-ttu-id="76331-132">Una operación atómica es la que es indivisible, una en la que se garantiza que otros subprocesos nunca verán la operación cuando esté a la mitad.</span><span class="sxs-lookup"><span data-stu-id="76331-132">An atomic operation is one that is indivisible—one where other threads are guaranteed to never see the operation when it is half done.</span></span> <span data-ttu-id="76331-133">Las operaciones atómicas son importantes para la programación sin bloqueos, porque sin ellos, otros subprocesos podrían ver valores de tipo medio o incoherentes.</span><span class="sxs-lookup"><span data-stu-id="76331-133">Atomic operations are important for lockless programming, because without them, other threads might see half-written values, or otherwise inconsistent state.</span></span>

<span data-ttu-id="76331-134">En todos los procesadores modernos, puede suponer que las lecturas y escrituras de tipos nativos alineados de forma natural son atómicas.</span><span class="sxs-lookup"><span data-stu-id="76331-134">On all modern processors, you can assume that reads and writes of naturally aligned native types are atomic.</span></span> <span data-ttu-id="76331-135">Siempre que el bus de memoria sea al menos tan ancho como el tipo que se lee o se escribe, la CPU Lee y escribe estos tipos en una única transacción de bus, lo que hace imposible que otros subprocesos los vean en un estado de finalización.</span><span class="sxs-lookup"><span data-stu-id="76331-135">As long as the memory bus is at least as wide as the type being read or written, the CPU reads and writes these types in a single bus transaction, making it impossible for other threads to see them in a half-completed state.</span></span> <span data-ttu-id="76331-136">En las ediciones x86 y x64, no hay ninguna garantía de que las lecturas y escrituras de más de ocho bytes sean atómicas.</span><span class="sxs-lookup"><span data-stu-id="76331-136">On x86 and x64 there, is no guarantee that reads and writes larger than eight bytes are atomic.</span></span> <span data-ttu-id="76331-137">Esto significa que las lecturas y escrituras de 16 bytes de los registros de la extensión SIMD de streaming (SSE) y las operaciones de cadena podrían no ser atómicas.</span><span class="sxs-lookup"><span data-stu-id="76331-137">This means that 16-byte reads and writes of streaming SIMD extension (SSE) registers, and string operations, might not be atomic.</span></span>

<span data-ttu-id="76331-138">No se garantiza que las lecturas y escrituras de tipos que no están alineados de forma natural (por ejemplo, escribiendo DWORDs que cruzan los límites de cuatro bytes) sean atómicos.</span><span class="sxs-lookup"><span data-stu-id="76331-138">Reads and writes of types that are not naturally aligned—for instance, writing DWORDs that cross four-byte boundaries—are not guaranteed to be atomic.</span></span> <span data-ttu-id="76331-139">Es posible que la CPU tenga que realizar estas lecturas y escrituras como transacciones de varios buses, lo que podría permitir que otro subproceso modificara o ver los datos en medio de la lectura o escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-139">The CPU may have to do these reads and writes as multiple bus transactions, which could allow another thread to modify or see the data in the middle of the read or write.</span></span>

<span data-ttu-id="76331-140">Las operaciones compuestas, como la secuencia de lectura, modificación y escritura que se produce cuando se incrementa una variable compartida, no son atómicas.</span><span class="sxs-lookup"><span data-stu-id="76331-140">Composite operations, such as the read-modify-write sequence that occurs when you increment a shared variable, are not atomic.</span></span> <span data-ttu-id="76331-141">En Xbox 360, estas operaciones se implementan como varias instrucciones (lwz, Addi y STW) y el subproceso se puede intercambiar MSRC durante a través de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="76331-141">On Xbox 360, these operations are implemented as multiple instructions (lwz, addi, and stw), and the thread could be swapped out partway through the sequence.</span></span> <span data-ttu-id="76331-142">En x86 y x64, hay una sola instrucción (Inc) que se puede usar para incrementar una variable en la memoria.</span><span class="sxs-lookup"><span data-stu-id="76331-142">On x86 and x64, there is a single instruction (inc) that can be used to increment a variable in memory.</span></span> <span data-ttu-id="76331-143">Si utiliza esta instrucción, el incremento de una variable es atómico en sistemas de un solo procesador, pero todavía no es atómico en sistemas de varios procesadores.</span><span class="sxs-lookup"><span data-stu-id="76331-143">If you use this instruction, incrementing a variable is atomic on single-processor systems, but it is still not atomic on multi-processor systems.</span></span> <span data-ttu-id="76331-144">Hacer que Inc Atomic en sistemas de varios procesadores basados en x86 y x64 requiera el uso del prefijo de bloqueo, lo que impide que otro procesador realice su propia secuencia de lectura-modificación-escritura entre la lectura y la escritura de la instrucción Inc.</span><span class="sxs-lookup"><span data-stu-id="76331-144">Making inc atomic on x86- and x64-based multi-processor systems requires using the lock prefix, which prevents another processor from doing its own read-modify-write sequence between the read and the write of the inc instruction.</span></span>

<span data-ttu-id="76331-145">En el código siguiente se muestran algunos ejemplos:</span><span class="sxs-lookup"><span data-stu-id="76331-145">The following code shows some examples:</span></span>

``` syntax
// This write is not atomic because it is not natively aligned.
DWORD* pData = (DWORD*)(pChar + 1);
*pData = 0;

// This is not atomic because it is three separate operations.
++g_globalCounter;

// This write is atomic.
g_alignedGlobal = 0;

// This read is atomic.
DWORD local = g_alignedGlobal;
```

## <a name="guaranteeing-atomicity"></a><span data-ttu-id="76331-146">Garantizar la atomicidad</span><span class="sxs-lookup"><span data-stu-id="76331-146">Guaranteeing Atomicity</span></span>

<span data-ttu-id="76331-147">Puede asegurarse de que está usando operaciones atómicas mediante una combinación de lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="76331-147">You can be sure you are using atomic operations by a combination of the following:</span></span>

-   <span data-ttu-id="76331-148">Operaciones atómicas naturales</span><span class="sxs-lookup"><span data-stu-id="76331-148">Naturally atomic operations</span></span>
-   <span data-ttu-id="76331-149">Bloqueos para encapsular operaciones compuestas</span><span class="sxs-lookup"><span data-stu-id="76331-149">Locks to wrap composite operations</span></span>
-   <span data-ttu-id="76331-150">Funciones del sistema operativo que implementan versiones atómicas de las operaciones compuestas populares</span><span class="sxs-lookup"><span data-stu-id="76331-150">Operating system functions that implement atomic versions of popular composite operations</span></span>

<span data-ttu-id="76331-151">El incremento de una variable no es una operación atómica y el incremento puede provocar daños en los datos si se ejecutan en varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="76331-151">Incrementing a variable is not an atomic operation, and incrementing may lead to data corruption if executed on multiple threads.</span></span>

``` syntax
// This will be atomic.
g_globalCounter = 0;

// This is not atomic and gives undefined behavior
// if executed on multiple threads
++g_globalCounter;
```

<span data-ttu-id="76331-152">Win32 incluye una familia de funciones que ofrecen versiones atómicas de lectura-modificación-escritura de varias operaciones comunes.</span><span class="sxs-lookup"><span data-stu-id="76331-152">Win32 comes with a family of functions that offer atomic read-modify-write versions of several common operations.</span></span> <span data-ttu-id="76331-153">Se trata de la familia de funciones InterlockedXxx.</span><span class="sxs-lookup"><span data-stu-id="76331-153">These are the InterlockedXxx family of functions.</span></span> <span data-ttu-id="76331-154">Si todas las modificaciones de la variable compartida usan estas funciones, las modificaciones serán seguras para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="76331-154">If all modifications of the shared variable use these functions, the modifications will be thread safe.</span></span>

``` syntax
// Incrementing our variable in a safe lockless way.
InterlockedIncrement(&g_globalCounter);
```

## <a name="reordering"></a><span data-ttu-id="76331-155">Reordenación</span><span class="sxs-lookup"><span data-stu-id="76331-155">Reordering</span></span>

<span data-ttu-id="76331-156">Un problema más sutil es la reordenación.</span><span class="sxs-lookup"><span data-stu-id="76331-156">A more subtle problem is reordering.</span></span> <span data-ttu-id="76331-157">Las lecturas y escrituras no siempre se producen en el orden en el que se han escrito en el código y esto puede provocar problemas muy confusos.</span><span class="sxs-lookup"><span data-stu-id="76331-157">Reads and writes do not always happen in the order that you have written them in your code, and this can lead to very confusing problems.</span></span> <span data-ttu-id="76331-158">En muchos algoritmos multiproceso, un subproceso escribe algunos datos y, a continuación, escribe en una marca que indica a otros subprocesos que los datos están listos.</span><span class="sxs-lookup"><span data-stu-id="76331-158">In many multi-threaded algorithms, a thread writes some data and then writes to a flag that tells other threads that the data is ready.</span></span> <span data-ttu-id="76331-159">Esto se conoce como versión de escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-159">This is known as a write-release.</span></span> <span data-ttu-id="76331-160">Si se reordenan las escrituras, otros subprocesos pueden ver que la marca se establece antes de que puedan ver los datos escritos.</span><span class="sxs-lookup"><span data-stu-id="76331-160">If the writes are reordered, other threads may see that the flag is set before they can see the written data.</span></span>

<span data-ttu-id="76331-161">Del mismo modo, en muchos casos, un subproceso Lee de una marca y, a continuación, Lee algunos datos compartidos si la marca indica que el subproceso ha adquirido el acceso a los datos compartidos.</span><span class="sxs-lookup"><span data-stu-id="76331-161">Similarly, in many cases, a thread reads from a flag and then reads some shared data if the flag says that the thread has acquired access to the shared data.</span></span> <span data-ttu-id="76331-162">Esto se conoce como una adquisición de lectura.</span><span class="sxs-lookup"><span data-stu-id="76331-162">This is known as a read-acquire.</span></span> <span data-ttu-id="76331-163">Si se reordenan las lecturas, se pueden leer los datos desde el almacenamiento compartido antes de la marca y es posible que los valores visibles no estén actualizados.</span><span class="sxs-lookup"><span data-stu-id="76331-163">If reads are reordered, then the data may be read from shared storage before the flag, and the values seen might not be up to date.</span></span>

<span data-ttu-id="76331-164">El compilador y el procesador pueden realizar la reordenación de las lecturas y escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-164">Reordering of reads and writes can be done both by the compiler and by the processor.</span></span> <span data-ttu-id="76331-165">Los compiladores y los procesadores han hecho esta reordenación durante los años, pero en los equipos con un solo procesador se produjo un problema menor.</span><span class="sxs-lookup"><span data-stu-id="76331-165">Compilers and processors have done this reordering for years, but on single-processor machines it was less of an issue.</span></span> <span data-ttu-id="76331-166">Esto se debe a que la reorganización de lecturas y escrituras de la CPU es invisible en equipos de un solo procesador (para el código de controlador que no es de dispositivo y que no forma parte de un controlador de dispositivo) y es menos probable que la reorganización del compilador de lecturas y escrituras cause problemas en equipos de un solo procesador.</span><span class="sxs-lookup"><span data-stu-id="76331-166">This is because CPU rearrangement of reads and writes is invisible on single-processor machines (for non-device driver code that is not part of a device driver), and compiler rearrangement of reads and writes is less likely to cause problems on single-processor machines.</span></span>

<span data-ttu-id="76331-167">Si el compilador o la CPU reorganiza las escrituras que se muestran en el código siguiente, otro subproceso puede ver que la marca Alive está establecida mientras sigue viendo los valores antiguos para x o y.</span><span class="sxs-lookup"><span data-stu-id="76331-167">If the compiler or the CPU rearranges the writes shown in the following code, another thread may see that the alive flag is set while still seeing the old values for x or y.</span></span> <span data-ttu-id="76331-168">Se puede producir una reorganización similar al leer.</span><span class="sxs-lookup"><span data-stu-id="76331-168">Similar rearrangement can happen when reading.</span></span>

<span data-ttu-id="76331-169">En este código, un subproceso agrega una nueva entrada a la matriz de Sprite:</span><span class="sxs-lookup"><span data-stu-id="76331-169">In this code, one thread adds a new entry to the sprite array:</span></span>

``` syntax
// Create a new sprite by writing its position into an empty
// entry and then setting the ‘alive' flag. If ‘alive' is
// written before x or y then errors may occur.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="76331-170">En el siguiente bloque de código, otro subproceso Lee de la matriz de Sprite:</span><span class="sxs-lookup"><span data-stu-id="76331-170">In this next code block, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites. If the reads of x and y are moved ahead of
// the read of ‘alive' then errors may occur.
for( int i = 0; i < numSprites; ++i )
{
    if( g_sprites[nextSprite].alive )
    {
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="76331-171">Para que este sistema de Sprite sea seguro, necesitamos evitar la reordenación de las lecturas y escrituras de la CPU y del compilador.</span><span class="sxs-lookup"><span data-stu-id="76331-171">To make this sprite system safe, we need to prevent both compiler and CPU reordering of reads and writes.</span></span>

### <a name="understanding-cpu-rearrangement-of-writes"></a><span data-ttu-id="76331-172">Descripción de la reorganización de escrituras de CPU</span><span class="sxs-lookup"><span data-stu-id="76331-172">Understanding CPU Rearrangement of Writes</span></span>

<span data-ttu-id="76331-173">Algunas CPU reorganizan las escrituras para que sean visibles externamente para otros procesadores o dispositivos en orden no programa.</span><span class="sxs-lookup"><span data-stu-id="76331-173">Some CPUs rearrange writes so that they are externally visible to other processors or devices in non-program order.</span></span> <span data-ttu-id="76331-174">Esta reorganización nunca es visible para el código de un solo subproceso que no sea de controlador, pero puede causar problemas en el código multiproceso.</span><span class="sxs-lookup"><span data-stu-id="76331-174">This rearranging is never visible to single-threaded non-driver code, but it can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="76331-175">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="76331-175">Xbox 360</span></span>

<span data-ttu-id="76331-176">Aunque la CPU de Xbox 360 no reordena las instrucciones, se reorganizan las operaciones de escritura, que se completan después de las instrucciones.</span><span class="sxs-lookup"><span data-stu-id="76331-176">While the Xbox 360 CPU does not reorder instructions, it does rearrange write operations, which complete after the instructions themselves.</span></span> <span data-ttu-id="76331-177">Esta reorganización de escrituras se permite específicamente en el modelo de memoria PowerPC.</span><span class="sxs-lookup"><span data-stu-id="76331-177">This rearranging of writes is specifically allowed by the PowerPC memory model.</span></span>

<span data-ttu-id="76331-178">Las operaciones de escritura en Xbox 360 no van directamente a la caché L2.</span><span class="sxs-lookup"><span data-stu-id="76331-178">Writes on Xbox 360 do not go directly to the L2 cache.</span></span> <span data-ttu-id="76331-179">En su lugar, para mejorar el ancho de banda de escritura de la caché L2, pasan por las colas de almacenamiento y, a continuación, para almacenar y recopilar búferes.</span><span class="sxs-lookup"><span data-stu-id="76331-179">Instead, in order to improve L2 cache write bandwidth, they go through store queues and then to store-gather buffers.</span></span> <span data-ttu-id="76331-180">Los búferes de almacenamiento y recopilación permiten escribir bloques de 64 bytes en la memoria caché L2 en una operación.</span><span class="sxs-lookup"><span data-stu-id="76331-180">The store-gather buffers allow 64-byte blocks to be written to the L2 cache in one operation.</span></span> <span data-ttu-id="76331-181">Hay ocho búferes de almacenamiento y recopilación que permiten la escritura eficaz en varias áreas de memoria diferentes.</span><span class="sxs-lookup"><span data-stu-id="76331-181">There are eight store-gather buffers, which allow efficient writing to several different areas of memory.</span></span>

<span data-ttu-id="76331-182">Los búferes de almacenamiento y recopilación se escriben normalmente en la memoria caché L2 en orden FIFO (el primero en salir es el primero en salir).</span><span class="sxs-lookup"><span data-stu-id="76331-182">The store-gather buffers are normally written to the L2 cache in first-in-first-out (FIFO) order.</span></span> <span data-ttu-id="76331-183">Sin embargo, si la línea de caché de destino de una escritura no está en la memoria caché L2, esa escritura se puede retrasar mientras se captura la memoria caché de la memoria.</span><span class="sxs-lookup"><span data-stu-id="76331-183">However, if the target cache-line of a write is not in the L2 cache, that write may be delayed while the cache-line is fetched from memory.</span></span>

<span data-ttu-id="76331-184">Incluso cuando los búferes de almacenamiento y recopilación se escriben en la memoria caché L2 en orden FIFO estricto, esto no garantiza que las escrituras individuales se escriban en la memoria caché L2 en orden.</span><span class="sxs-lookup"><span data-stu-id="76331-184">Even when the store-gather buffers are written to the L2 cache in strict FIFO order, this does not guarantee that individual writes are written to the L2 cache in order.</span></span> <span data-ttu-id="76331-185">Por ejemplo, Imagine que la CPU escribe en la ubicación 0x1000, luego en la ubicación 0x2000 y, a continuación, en la ubicación 0x1004.</span><span class="sxs-lookup"><span data-stu-id="76331-185">For instance, imagine that the CPU writes to location 0x1000, then to location 0x2000, and then to location 0x1004.</span></span> <span data-ttu-id="76331-186">La primera escritura asigna un búfer de almacenamiento y recopilación y lo coloca en la parte delantera de la cola.</span><span class="sxs-lookup"><span data-stu-id="76331-186">The first write allocates a store-gather buffer and puts it at the front of the queue.</span></span> <span data-ttu-id="76331-187">La segunda escritura asigna otro búfer de almacenamiento-recopilación y lo coloca junto en la cola.</span><span class="sxs-lookup"><span data-stu-id="76331-187">The second write allocates another store-gather buffer and puts it next in the queue.</span></span> <span data-ttu-id="76331-188">La tercera escritura agrega sus datos al primer búfer de almacenamiento y recopilación, que permanece en la parte delantera de la cola.</span><span class="sxs-lookup"><span data-stu-id="76331-188">The third write adds its data to the first store-gather buffer, which remains at the front of the queue.</span></span> <span data-ttu-id="76331-189">Por lo tanto, la tercera escritura termina en la memoria caché L2 antes de la segunda escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-189">Thus, the third write ends up going to the L2 cache before the second write.</span></span>

<span data-ttu-id="76331-190">La reordenación provocada por los búferes de almacenamiento y recopilación es fundamentalmente imprevisible, especialmente porque ambos subprocesos de un núcleo comparten los búferes de almacenamiento y recopilación, lo que hace que la asignación y el vaciado de los búferes de recopilación de almacenes sean muy variables.</span><span class="sxs-lookup"><span data-stu-id="76331-190">Reordering caused by store-gather buffers is fundamentally unpredictable, especially because both threads on a core share the store-gather buffers, making the allocation and emptying of the store-gather buffers highly variable.</span></span>

<span data-ttu-id="76331-191">Este es un ejemplo de cómo se pueden reordenar las escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-191">This is one example of how writes can be reordered.</span></span> <span data-ttu-id="76331-192">Puede haber otras posibilidades.</span><span class="sxs-lookup"><span data-stu-id="76331-192">There may be other possibilities.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="76331-193">x86 y x64</span><span class="sxs-lookup"><span data-stu-id="76331-193">x86 and x64</span></span>

<span data-ttu-id="76331-194">Aunque las CPU x86 y x64 reordenan las instrucciones, generalmente no reordenan las operaciones de escritura en relación con otras escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-194">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder write operations relative to other writes.</span></span> <span data-ttu-id="76331-195">Hay algunas excepciones para la memoria combinada de escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-195">There are some exceptions for write-combined memory.</span></span> <span data-ttu-id="76331-196">Además, las operaciones de cadena (MOVS y STOS) y las escrituras SSE de 16 bytes se pueden reordenar internamente, pero de lo contrario, las escrituras no se reordenan entre sí.</span><span class="sxs-lookup"><span data-stu-id="76331-196">Additionally, string operations (MOVS and STOS) and 16-byte SSE writes can be internally reordered, but otherwise, writes are not reordered relative to each other.</span></span>

### <a name="understanding-cpu-rearrangement-of-reads"></a><span data-ttu-id="76331-197">Descripción de la reorganización de lecturas de CPU</span><span class="sxs-lookup"><span data-stu-id="76331-197">Understanding CPU Rearrangement of Reads</span></span>

<span data-ttu-id="76331-198">Algunas CPU reorganizan las lecturas para que provienen del almacenamiento compartido en orden no programa.</span><span class="sxs-lookup"><span data-stu-id="76331-198">Some CPUs rearrange reads so that they effectively come from shared storage in non-program order.</span></span> <span data-ttu-id="76331-199">Esta reorganización nunca es visible para el código que no es de un solo subproceso, pero puede causar problemas en el código multiproceso.</span><span class="sxs-lookup"><span data-stu-id="76331-199">This rearranging is never visible to single-threaded non-driver code, but can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="76331-200">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="76331-200">Xbox 360</span></span>

<span data-ttu-id="76331-201">Los errores de caché pueden provocar que se retrasen algunas lecturas, lo que hace que las lecturas provienen de la memoria compartida fuera de orden, y que la temporización de estos errores de caché no sea predecible fundamentalmente.</span><span class="sxs-lookup"><span data-stu-id="76331-201">Cache misses can cause some reads to be delayed, which effectively causes reads to come from shared memory out of order, and the timing of these cache misses is fundamentally unpredictable.</span></span> <span data-ttu-id="76331-202">La captura previa y la predicción de rama también pueden hacer que los datos provienen de la memoria compartida fuera de orden.</span><span class="sxs-lookup"><span data-stu-id="76331-202">Prefetching and branch prediction can also cause data to come from shared memory out of order.</span></span> <span data-ttu-id="76331-203">Estos son solo algunos ejemplos de cómo se pueden reordenar las lecturas.</span><span class="sxs-lookup"><span data-stu-id="76331-203">These are just a few examples of how reads can be reordered.</span></span> <span data-ttu-id="76331-204">Puede haber otras posibilidades.</span><span class="sxs-lookup"><span data-stu-id="76331-204">There may be other possibilities.</span></span> <span data-ttu-id="76331-205">Esta reorganización de lecturas se permite específicamente en el modelo de memoria PowerPC.</span><span class="sxs-lookup"><span data-stu-id="76331-205">This rearranging of reads is specifically allowed by the PowerPC memory model.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="76331-206">x86 y x64</span><span class="sxs-lookup"><span data-stu-id="76331-206">x86 and x64</span></span>

<span data-ttu-id="76331-207">Aunque las CPU x86 y x64 reordenan las instrucciones, generalmente no reordenan las operaciones de lectura en relación con otras lecturas.</span><span class="sxs-lookup"><span data-stu-id="76331-207">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder read operations relative to other reads.</span></span> <span data-ttu-id="76331-208">Las operaciones de cadena (MOVS y STOS) y las lecturas SSE de 16 bytes se pueden reordenar internamente, pero de lo contrario, las lecturas no se reordenan entre sí.</span><span class="sxs-lookup"><span data-stu-id="76331-208">String operations (MOVS and STOS) and 16-byte SSE reads can be internally reordered, but otherwise, reads are not reordered relative to each other.</span></span>

### <a name="other-reordering"></a><span data-ttu-id="76331-209">Otra reordenación</span><span class="sxs-lookup"><span data-stu-id="76331-209">Other Reordering</span></span>

<span data-ttu-id="76331-210">Aunque las CPU x86 y x64 no reordenan las escrituras en relación con otras escrituras, o reordenan las lecturas en relación con otras lecturas, pueden reordenar las lecturas en relación con las escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-210">Even though x86 and x64 CPUs do not reorder writes relative to other writes, or reorder reads relative to other reads, they can reorder reads relative to writes.</span></span> <span data-ttu-id="76331-211">En concreto, si un programa escribe en una ubicación seguida de leer desde una ubicación diferente, los datos de lectura pueden provienen de la memoria compartida antes de que los datos escritos los realicen allí.</span><span class="sxs-lookup"><span data-stu-id="76331-211">Specifically, if a program writes to one location followed by reading from a different location, the read data may come from shared memory before the written data makes it there.</span></span> <span data-ttu-id="76331-212">Esta reordenación puede interrumpir algunos algoritmos, como los algoritmos de exclusión mutua de Dekker.</span><span class="sxs-lookup"><span data-stu-id="76331-212">This reordering can break some algorithms, such as Dekker’s mutual exclusion algorithms.</span></span> <span data-ttu-id="76331-213">En el algoritmo de Dekker, cada subproceso establece una marca para indicar que desea entrar en la región crítica y, a continuación, comprueba la marca del otro subproceso para ver si el otro subproceso está en la región crítica o intenta entrar en él.</span><span class="sxs-lookup"><span data-stu-id="76331-213">In Dekker's algorithm, each thread sets a flag to indicate that it wants to enter the critical region, and then checks the other thread’s flag to see if the other thread is in the critical region or trying to enter it.</span></span> <span data-ttu-id="76331-214">A continuación se muestra el código inicial.</span><span class="sxs-lookup"><span data-stu-id="76331-214">The initial code follows.</span></span>

``` syntax
volatile bool f0 = false;
volatile bool f1 = false;

void P0Acquire()
{
    // Indicate intention to enter critical region
    f0 = true;
    // Check for other thread in or entering critical region
    while (f1)
    {
        // Handle contention.
    }
    // critical region
    ...
}


void P1Acquire()
{
    // Indicate intention to enter critical region
    f1 = true;
    // Check for other thread in or entering critical region
    while (f0)
    {
        // Handle contention.
    }
    // critical region
    ...
}
```

<span data-ttu-id="76331-215">El problema es que la lectura de F1 en P0Acquire puede leer desde el almacenamiento compartido antes de que la escritura en F0 lo haga en el almacenamiento compartido.</span><span class="sxs-lookup"><span data-stu-id="76331-215">The problem is that the read of f1 in P0Acquire can read from shared storage before the write to f0 makes it to shared storage.</span></span> <span data-ttu-id="76331-216">Mientras tanto, la lectura de F0 en P1Acquire puede leer desde el almacenamiento compartido antes de que la escritura en F1 lo haga en el almacenamiento compartido.</span><span class="sxs-lookup"><span data-stu-id="76331-216">Meanwhile, the read of f0 in P1Acquire can read from shared storage before the write to f1 makes it to shared storage.</span></span> <span data-ttu-id="76331-217">El efecto neto es que ambos subprocesos establecen sus marcas en TRUE y ambos subprocesos ven la marca del otro subproceso como FALSE, de modo que ambos entran en la región crítica.</span><span class="sxs-lookup"><span data-stu-id="76331-217">The net effect is that both threads set their flags to TRUE, and both threads see the other thread's flag as being FALSE, so they both enter the critical region.</span></span> <span data-ttu-id="76331-218">Por lo tanto, aunque los problemas con la reordenación en sistemas basados en x86 y x64 son menos comunes que en Xbox 360, se pueden seguir produciendo.</span><span class="sxs-lookup"><span data-stu-id="76331-218">Therefore, while problems with reordering on x86- and x64-based systems are less common than on Xbox 360, they definitely can still happen.</span></span> <span data-ttu-id="76331-219">El algoritmo de Dekker no funcionará sin barreras de memoria de hardware en ninguna de estas plataformas.</span><span class="sxs-lookup"><span data-stu-id="76331-219">Dekker’s algorithm will not work without hardware memory barriers on any of these platforms.</span></span>

<span data-ttu-id="76331-220">las CPU x86 y x64 no volverán a ordenar una escritura antes de una lectura anterior.</span><span class="sxs-lookup"><span data-stu-id="76331-220">x86 and x64 CPUs will not reorder a write ahead of a previous read.</span></span> <span data-ttu-id="76331-221">las CPU x86 y x64 solo reordenan las lecturas por encima de las escrituras anteriores si se dirigen a ubicaciones diferentes.</span><span class="sxs-lookup"><span data-stu-id="76331-221">x86 and x64 CPUs only reorder reads ahead of previous writes if they target different locations.</span></span>

<span data-ttu-id="76331-222">Las CPU PowerPC pueden reordenar las lecturas con anterioridad a las escrituras y pueden reordenar las escrituras por encima de las lecturas, siempre y cuando estén en direcciones diferentes.</span><span class="sxs-lookup"><span data-stu-id="76331-222">PowerPC CPUs can reorder reads ahead of writes, and can reorder writes ahead of reads, as long as they are to different addresses.</span></span>

### <a name="reordering-summary"></a><span data-ttu-id="76331-223">Resumen de reordenación</span><span class="sxs-lookup"><span data-stu-id="76331-223">Reordering Summary</span></span>

<span data-ttu-id="76331-224">La CPU de Xbox 360 reordena las operaciones de memoria de forma mucho más agresiva que las CPU x86 y x64, tal y como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="76331-224">The Xbox 360 CPU reorders memory operations much more aggressively than do x86 and x64 CPUs, as shown in the following table.</span></span> <span data-ttu-id="76331-225">Para obtener más información, consulte la documentación del procesador.</span><span class="sxs-lookup"><span data-stu-id="76331-225">For more details, consult the processor documentation.</span></span>



| <span data-ttu-id="76331-226">Reordenación de la actividad</span><span class="sxs-lookup"><span data-stu-id="76331-226">Reordering Activity</span></span>           | <span data-ttu-id="76331-227">x86 y x64</span><span class="sxs-lookup"><span data-stu-id="76331-227">x86 and x64</span></span> | <span data-ttu-id="76331-228">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="76331-228">Xbox 360</span></span> |
|-------------------------------|-------------|----------|
| <span data-ttu-id="76331-229">Lee el avance de las lecturas.</span><span class="sxs-lookup"><span data-stu-id="76331-229">Reads moving ahead of reads</span></span>   | <span data-ttu-id="76331-230">No</span><span class="sxs-lookup"><span data-stu-id="76331-230">No</span></span>          | <span data-ttu-id="76331-231">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-231">Yes</span></span>      |
| <span data-ttu-id="76331-232">Escribe el avance de las escrituras</span><span class="sxs-lookup"><span data-stu-id="76331-232">Writes moving ahead of writes</span></span> | <span data-ttu-id="76331-233">No</span><span class="sxs-lookup"><span data-stu-id="76331-233">No</span></span>          | <span data-ttu-id="76331-234">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-234">Yes</span></span>      |
| <span data-ttu-id="76331-235">La escritura avanza por las lecturas</span><span class="sxs-lookup"><span data-stu-id="76331-235">Writes moving ahead of reads</span></span>  | <span data-ttu-id="76331-236">No</span><span class="sxs-lookup"><span data-stu-id="76331-236">No</span></span>          | <span data-ttu-id="76331-237">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-237">Yes</span></span>      |
| <span data-ttu-id="76331-238">Lee el avance de las escrituras</span><span class="sxs-lookup"><span data-stu-id="76331-238">Reads moving ahead of writes</span></span>  | <span data-ttu-id="76331-239">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-239">Yes</span></span>         | <span data-ttu-id="76331-240">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-240">Yes</span></span>      |



 

## <a name="read-acquire-and-write-release-barriers"></a><span data-ttu-id="76331-241">Read-Acquire y barreras de Write-Release</span><span class="sxs-lookup"><span data-stu-id="76331-241">Read-Acquire and Write-Release Barriers</span></span>

<span data-ttu-id="76331-242">Las construcciones principales usadas para evitar la reordenación de las lecturas y escrituras se denominan barreras de lectura-adquisición y de versión de escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-242">The main constructs used to prevent reordering of reads and writes are called read-acquire and write-release barriers.</span></span> <span data-ttu-id="76331-243">Read-acquire es una lectura de una marca u otra variable para obtener la propiedad de un recurso, junto con una barrera contra la reordenación.</span><span class="sxs-lookup"><span data-stu-id="76331-243">A read-acquire is a read of a flag or other variable to gain ownership of a resource, coupled with a barrier against reordering.</span></span> <span data-ttu-id="76331-244">Del mismo modo, una versión de escritura es una escritura de una marca u otra variable para dar la propiedad de un recurso, junto con una barrera contra la reordenación.</span><span class="sxs-lookup"><span data-stu-id="76331-244">Similarly, a write-release is a write of a flag or other variable to give away ownership of a resource, coupled with a barrier against reordering.</span></span>

<span data-ttu-id="76331-245">Las definiciones formales, cortesía de hierba Sutter, son:</span><span class="sxs-lookup"><span data-stu-id="76331-245">The formal definitions, courtesy of Herb Sutter, are:</span></span>

-   <span data-ttu-id="76331-246">Read-adquire se ejecuta antes de todas las lecturas y escrituras realizadas por el mismo subproceso que la siguen en el orden del programa.</span><span class="sxs-lookup"><span data-stu-id="76331-246">A read-acquire executes before all reads and writes by the same thread that follow it in program order.</span></span>
-   <span data-ttu-id="76331-247">Una versión de escritura se ejecuta después de todas las lecturas y escrituras realizadas por el mismo subproceso que la precede en el orden del programa.</span><span class="sxs-lookup"><span data-stu-id="76331-247">A write-release executes after all reads and writes by the same thread that precede it in program order.</span></span>

<span data-ttu-id="76331-248">Cuando el código adquiere la propiedad de alguna memoria, ya sea mediante la adquisición de un bloqueo o la extracción de un elemento de una lista vinculada compartida (sin un bloqueo), siempre hay una lectura implicada: probar una marca o un puntero para ver si se ha adquirido la propiedad de la memoria.</span><span class="sxs-lookup"><span data-stu-id="76331-248">When your code acquires ownership of some memory, either by acquiring a lock or by pulling an item off of a shared linked list (without a lock), there is always a read involved—testing a flag or pointer to see if ownership of the memory has been acquired.</span></span> <span data-ttu-id="76331-249">Esta lectura puede formar parte de una operación **InterlockedXxx** , en cuyo caso implica tanto lectura como escritura, pero es la lectura que indica si se ha obtenido la propiedad.</span><span class="sxs-lookup"><span data-stu-id="76331-249">This read may be part of an **InterlockedXxx** operation, in which case it involves both a read and a write, but it is the read that indicates whether ownership has been gained.</span></span> <span data-ttu-id="76331-250">Una vez adquirida la propiedad de la memoria, los valores normalmente se leen o se escriben en esa memoria, y es muy importante que estas lecturas y escrituras se ejecuten después de adquirir la propiedad.</span><span class="sxs-lookup"><span data-stu-id="76331-250">After ownership of the memory is acquired, values are typically read from or written to that memory, and it is very important that these reads and writes execute after acquiring ownership.</span></span> <span data-ttu-id="76331-251">Una barrera de lectura-adquisición garantiza esto.</span><span class="sxs-lookup"><span data-stu-id="76331-251">A read-acquire barrier guarantees this.</span></span>

<span data-ttu-id="76331-252">Cuando se libera la propiedad de alguna memoria, ya sea liberando un bloqueo o insertando un elemento en una lista de vínculos compartida, siempre hay una escritura implicada que notifica a otros subprocesos que la memoria está disponible.</span><span class="sxs-lookup"><span data-stu-id="76331-252">When ownership of some memory is released, either by releasing a lock or by pushing an item on to a shared linked list, there is always a write involved which notifies other threads that the memory is now available to them.</span></span> <span data-ttu-id="76331-253">Aunque el código tenía la propiedad de la memoria, es probable que lea o escriba en él, y es muy importante que estas lecturas y escrituras se ejecuten antes de liberar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="76331-253">While your code had ownership of the memory, it probably read from or wrote to it, and it is very important that these reads and writes execute before releasing ownership.</span></span> <span data-ttu-id="76331-254">Una barrera de versión de escritura garantiza esto.</span><span class="sxs-lookup"><span data-stu-id="76331-254">A write-release barrier guarantees this.</span></span>

<span data-ttu-id="76331-255">Es más fácil pensar en las barreras de la adquisición de lectura y de escritura como operaciones únicas.</span><span class="sxs-lookup"><span data-stu-id="76331-255">It is simplest to think of read-acquire and write-release barriers as single operations.</span></span> <span data-ttu-id="76331-256">Sin embargo, a veces tienen que construirse a partir de dos partes: una lectura o una escritura y una barrera que no permite que las lecturas o escrituras se muevan a través de ella.</span><span class="sxs-lookup"><span data-stu-id="76331-256">However, they sometimes have to be constructed from two parts: a read or write and a barrier that does not allow reads or writes to move across it.</span></span> <span data-ttu-id="76331-257">En este caso, la colocación de la barrera es crítica.</span><span class="sxs-lookup"><span data-stu-id="76331-257">In this case, the placement of the barrier is critical.</span></span> <span data-ttu-id="76331-258">En el caso de una barrera de lectura-adquisición, la lectura de la marca es la primera, la barrera y, a continuación, Lee y escribe los datos compartidos.</span><span class="sxs-lookup"><span data-stu-id="76331-258">For a read-acquire barrier, the read of the flag comes first, then the barrier, and then the reads and writes of the shared data.</span></span> <span data-ttu-id="76331-259">En el caso de una barrera de versión de escritura, las lecturas y escrituras de los datos compartidos aparecen en primer lugar, la barrera y, a continuación, la escritura de la marca.</span><span class="sxs-lookup"><span data-stu-id="76331-259">For a write-release barrier the reads and writes of the shared data come first, then the barrier, and then the write of the flag.</span></span>

``` syntax
// Read that acquires the data.
if( g_flag )
{
    // Guarantee that the read of the flag executes before
    // all reads and writes that follow in program order.
    BarrierOfSomeSort();

    // Now we can read and write the shared data.
    int localVariable = sharedData.y;
    sharedData.x = 0;

    // Guarantee that the write to the flag executes after all
    // reads and writes that precede it in program order.
    BarrierOfSomeSort();
    
    // Write that releases the data.
    g_flag = false;
}
```

<span data-ttu-id="76331-260">La única diferencia entre una lectura y una versión de escritura es la ubicación de la barrera de memoria.</span><span class="sxs-lookup"><span data-stu-id="76331-260">The only difference between a read-acquire and a write-release is the location of the memory barrier.</span></span> <span data-ttu-id="76331-261">Una operación de lectura y adquisición tiene la barrera después de la operación de bloqueo, y una versión de escritura tiene la barrera antes.</span><span class="sxs-lookup"><span data-stu-id="76331-261">A read-acquire has the barrier after the lock operation, and a write-release has the barrier before.</span></span> <span data-ttu-id="76331-262">En ambos casos, la barrera está entre las referencias a la memoria bloqueada y las referencias al bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-262">In both cases the barrier is in-between the references to the locked memory and the references to the lock.</span></span>

<span data-ttu-id="76331-263">Para comprender por qué se necesitan barreras al adquirir y al liberar datos, es mejor (y más preciso) pensar en estas barreras como garantizar la sincronización con la memoria compartida, no con otros procesadores.</span><span class="sxs-lookup"><span data-stu-id="76331-263">To understand why barriers are needed both when acquiring and when releasing data, it is best (and most accurate) to think of these barriers as guaranteeing synchronization with shared memory, not with other processors.</span></span> <span data-ttu-id="76331-264">Si un procesador usa una versión de escritura para liberar una estructura de datos en la memoria compartida y otro procesador utiliza una lectura y adquisición para obtener acceso a esa estructura de datos desde la memoria compartida, el código funcionará correctamente.</span><span class="sxs-lookup"><span data-stu-id="76331-264">If one processor uses a write-release to release a data structure to shared memory, and another processor uses a read-acquire to gain access to that data structure from shared memory, the code will then work properly.</span></span> <span data-ttu-id="76331-265">Si alguno de los procesadores no utiliza la barrera adecuada, se puede producir un error en el uso compartido de datos.</span><span class="sxs-lookup"><span data-stu-id="76331-265">If either processor doesn't use the appropriate barrier, the data sharing may fail.</span></span>

<span data-ttu-id="76331-266">Es fundamental usar la barrera adecuada para evitar la reordenación del compilador y la CPU para la plataforma.</span><span class="sxs-lookup"><span data-stu-id="76331-266">Using the right barrier to prevent compiler and CPU reordering for your platform is critical.</span></span>

<span data-ttu-id="76331-267">Una de las ventajas de usar los primitivos de sincronización proporcionados por el sistema operativo es que todos ellos incluyen las barreras de memoria adecuadas.</span><span class="sxs-lookup"><span data-stu-id="76331-267">One of the advantages of using the synchronization primitives provided by the operating system is that all of them include the appropriate memory barriers.</span></span>

## <a name="preventing-compiler-reordering"></a><span data-ttu-id="76331-268">Evitar la reordenación del compilador</span><span class="sxs-lookup"><span data-stu-id="76331-268">Preventing Compiler Reordering</span></span>

<span data-ttu-id="76331-269">El trabajo de un compilador es optimizar agresivamente el código para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="76331-269">A compiler's job is to aggressively optimize your code in order to improve performance.</span></span> <span data-ttu-id="76331-270">Esto incluye la reorganización de instrucciones siempre que sea útil y donde no cambie el comportamiento.</span><span class="sxs-lookup"><span data-stu-id="76331-270">This includes rearranging instructions wherever it is helpful and wherever it will not change behavior.</span></span> <span data-ttu-id="76331-271">Dado que el estándar de C++ nunca menciona el multithreading, y dado que el compilador no sabe qué código debe ser seguro para subprocesos, el compilador supone que el código es de subproceso único al decidir qué reorganización puede hacer con seguridad.</span><span class="sxs-lookup"><span data-stu-id="76331-271">Because the C++ Standard never mentions multithreading, and because the compiler doesn't know what code needs to be thread-safe, the compiler assumes that your code is single-threaded when deciding what rearrangements it can safely do.</span></span> <span data-ttu-id="76331-272">Por lo tanto, debe indicar al compilador que no se le permite reordenar las lecturas y escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-272">Therefore, you need to tell the compiler when it is not allowed to reorder reads and writes.</span></span>

<span data-ttu-id="76331-273">Con Visual C++ puede evitar la reordenación del compilador mediante el uso de la función intrínseca [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx)del compilador.</span><span class="sxs-lookup"><span data-stu-id="76331-273">With Visual C++ you can prevent compiler reordering by using the compiler intrinsic [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx).</span></span> <span data-ttu-id="76331-274">Cuando inserte **\_ ReadWriteBarrier** en el código, el compilador no moverá las lecturas y escrituras en él.</span><span class="sxs-lookup"><span data-stu-id="76331-274">Where you insert **\_ReadWriteBarrier** into your code, the compiler will not move reads and writes across it.</span></span>

``` syntax
#if _MSC_VER < 1400
    // With VC++ 2003 you need to declare _ReadWriteBarrier
    extern "C" void _ReadWriteBarrier();
#else
    // With VC++ 2005 you can get the declaration from intrin.h
#include <intrin.h>
#endif
// Tell the compiler that this is an intrinsic, not a function.
#pragma intrinsic(_ReadWriteBarrier)

// Create a new sprite by filling in a previously empty entry.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
// Write-release, barrier followed by write.
// Guarantee that the compiler leaves the write to the flag
// after all reads and writes that precede it in program order.
_ReadWriteBarrier();
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="76331-275">En el código siguiente, otro subproceso Lee de la matriz de Sprite:</span><span class="sxs-lookup"><span data-stu-id="76331-275">In the following code, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites.
for( int i = 0; i < numSprites; ++i )
{

    // Read-acquire, read followed by barrier.
    if( g_sprites[nextSprite].alive )
    {
    
        // Guarantee that the compiler leaves the read of the flag
        // before all reads and writes that follow in program order.
        _ReadWriteBarrier();
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="76331-276">Es importante entender que [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) no inserta ninguna instrucción adicional y no impide que la CPU reorganice las lecturas y escrituras, solo impide que el compilador las reorganice.</span><span class="sxs-lookup"><span data-stu-id="76331-276">It is important to understand that [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) does not insert any additional instructions, and it does not prevent the CPU from rearranging reads and writes—it only prevents the compiler from rearranging them.</span></span> <span data-ttu-id="76331-277">Por lo tanto, **\_ ReadWriteBarrier** es suficiente cuando se implementa una barrera de versión de escritura en x86 y x64 (porque x86 y x64 no reordenan las escrituras, y una escritura normal es suficiente para liberar un bloqueo), pero en la mayoría de los demás casos también es necesario impedir que la CPU reordene las lecturas y escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-277">Thus, **\_ReadWriteBarrier** is sufficient when you implement a write-release barrier on x86 and x64 (because x86 and x64 do not reorder writes, and a normal write is sufficient for releasing a lock), but in most other cases, it is also necessary to prevent the CPU from reordering reads and writes.</span></span>

<span data-ttu-id="76331-278">También puede usar [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) al escribir en memoria combinada de escritura no almacenable en caché para evitar la reordenación de las escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-278">You can also use [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) when you write to non-cacheable write-combined memory to prevent reordering of writes.</span></span> <span data-ttu-id="76331-279">En este caso, **\_ ReadWriteBarrier** ayuda a mejorar el rendimiento, ya que garantiza que las escrituras se producen en el orden lineal preferido del procesador.</span><span class="sxs-lookup"><span data-stu-id="76331-279">In this case **\_ReadWriteBarrier** helps to improve performance, by guaranteeing that the writes happen in the processor's preferred linear order.</span></span>

<span data-ttu-id="76331-280">También es posible usar las funciones intrínsecas [**\_ ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) y [**\_ WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) para un control más preciso de la reordenación del compilador.</span><span class="sxs-lookup"><span data-stu-id="76331-280">It is also possible to use the [**\_ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) and [**\_WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) intrinsics for more precise control of compiler reordering.</span></span> <span data-ttu-id="76331-281">El compilador no moverá las lecturas a través de un **\_ ReadBarrier** y no moverá las Escrituras a través de un **\_ WriteBarrier**.</span><span class="sxs-lookup"><span data-stu-id="76331-281">The compiler will not move reads across a **\_ReadBarrier**, and it will not move writes across a **\_WriteBarrier**.</span></span>

## <a name="preventing-cpu-reordering"></a><span data-ttu-id="76331-282">Impedir la reordenación de la CPU</span><span class="sxs-lookup"><span data-stu-id="76331-282">Preventing CPU Reordering</span></span>

<span data-ttu-id="76331-283">La reordenación de la CPU es más sutil que la reordenación del compilador.</span><span class="sxs-lookup"><span data-stu-id="76331-283">CPU reordering is more subtle than compiler reordering.</span></span> <span data-ttu-id="76331-284">Nunca puede ver que se produce directamente, solo verá errores de inexplicable.</span><span class="sxs-lookup"><span data-stu-id="76331-284">You can't ever see it happen directly, you just see inexplicable bugs.</span></span> <span data-ttu-id="76331-285">Con el fin de evitar la reordenación de la CPU de lecturas y escrituras, es necesario utilizar instrucciones de barrera de memoria en algunos procesadores.</span><span class="sxs-lookup"><span data-stu-id="76331-285">In order to prevent CPU reordering of reads and writes you need to use memory barrier instructions, on some processors.</span></span> <span data-ttu-id="76331-286">El nombre de todos los propósitos de una instrucción de barrera de memoria, en Xbox 360 y en Windows, es [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span><span class="sxs-lookup"><span data-stu-id="76331-286">The all-purpose name for a memory barrier instruction, on Xbox 360 and on Windows, is [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span></span> <span data-ttu-id="76331-287">Esta macro se implementa correctamente para cada plataforma.</span><span class="sxs-lookup"><span data-stu-id="76331-287">This macro is implemented appropriately for each platform.</span></span>

<span data-ttu-id="76331-288">En Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) se define como **lwsync** (sincronización ligera), también disponible a través de la función intrínseca **\_ \_ lwsync** , que se define en ppcintrinsics. h.</span><span class="sxs-lookup"><span data-stu-id="76331-288">On Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined as **lwsync** (lightweight sync), also available through the **\_\_lwsync** intrinsic, which is defined in ppcintrinsics.h.</span></span> <span data-ttu-id="76331-289">**\_ \_ lwsync** también actúa como una barrera de memoria del compilador, lo que impide reorganizar las lecturas y escrituras realizadas por el compilador.</span><span class="sxs-lookup"><span data-stu-id="76331-289">**\_\_lwsync** also serves as a compiler memory barrier, preventing rearranging of reads and writes by the compiler.</span></span>

<span data-ttu-id="76331-290">La instrucción **lwsync** es una barrera de memoria en Xbox 360 que sincroniza un núcleo de procesador con la memoria caché L2.</span><span class="sxs-lookup"><span data-stu-id="76331-290">The **lwsync** instruction is a memory barrier on Xbox 360 that synchronizes one processor core with the L2 cache.</span></span> <span data-ttu-id="76331-291">Garantiza que todas las escrituras antes de **lwsync** se convierten en la memoria caché L2 antes de cualquier escritura que siga.</span><span class="sxs-lookup"><span data-stu-id="76331-291">It guarantees that all writes before **lwsync** make it to the L2 cache before any writes that follow.</span></span> <span data-ttu-id="76331-292">También garantiza que las lecturas que siguen a **lwsync** no obtienen datos más antiguos de la versión L2 que las lecturas anteriores.</span><span class="sxs-lookup"><span data-stu-id="76331-292">It also guarantees that any reads that follow **lwsync** don't get older data from L2 than previous reads.</span></span> <span data-ttu-id="76331-293">El tipo de reordenación que no impide es una lectura por encima de una escritura en una dirección diferente.</span><span class="sxs-lookup"><span data-stu-id="76331-293">The one type of reordering that it does not prevent is a read moving ahead of a write to a different address.</span></span> <span data-ttu-id="76331-294">Por lo tanto, **lwsync** aplica la ordenación de memoria que coincide con la ordenación de memoria predeterminada en procesadores x86 y x64.</span><span class="sxs-lookup"><span data-stu-id="76331-294">Thus, **lwsync** enforces memory ordering that matches the default memory ordering on x86 and x64 processors.</span></span> <span data-ttu-id="76331-295">Para obtener una ordenación de memoria completa, se requiere una instrucción de sincronización más costosa (también conocida como sincronización pesada), pero en la mayoría de los casos no es necesario.</span><span class="sxs-lookup"><span data-stu-id="76331-295">To get full memory ordering requires the more expensive sync instruction (also known as heavyweight sync), but in most cases, this is not required.</span></span> <span data-ttu-id="76331-296">En la tabla siguiente se muestran las opciones de reordenación de memoria en Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="76331-296">The memory reordering options on Xbox 360 are shown in the following table.</span></span>



| <span data-ttu-id="76331-297">Reordenación de Xbox 360</span><span class="sxs-lookup"><span data-stu-id="76331-297">Xbox 360 Reordering</span></span>           | <span data-ttu-id="76331-298">Sin sincronización</span><span class="sxs-lookup"><span data-stu-id="76331-298">No sync</span></span> | <span data-ttu-id="76331-299">lwsync</span><span class="sxs-lookup"><span data-stu-id="76331-299">lwsync</span></span> | <span data-ttu-id="76331-300">sync</span><span class="sxs-lookup"><span data-stu-id="76331-300">sync</span></span> |
|-------------------------------|---------|--------|------|
| <span data-ttu-id="76331-301">Lee el avance de las lecturas.</span><span class="sxs-lookup"><span data-stu-id="76331-301">Reads moving ahead of reads</span></span>   | <span data-ttu-id="76331-302">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-302">Yes</span></span>     | <span data-ttu-id="76331-303">No</span><span class="sxs-lookup"><span data-stu-id="76331-303">No</span></span>     | <span data-ttu-id="76331-304">No</span><span class="sxs-lookup"><span data-stu-id="76331-304">No</span></span>   |
| <span data-ttu-id="76331-305">Escribe el avance de las escrituras</span><span class="sxs-lookup"><span data-stu-id="76331-305">Writes moving ahead of writes</span></span> | <span data-ttu-id="76331-306">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-306">Yes</span></span>     | <span data-ttu-id="76331-307">No</span><span class="sxs-lookup"><span data-stu-id="76331-307">No</span></span>     | <span data-ttu-id="76331-308">No</span><span class="sxs-lookup"><span data-stu-id="76331-308">No</span></span>   |
| <span data-ttu-id="76331-309">La escritura avanza por las lecturas</span><span class="sxs-lookup"><span data-stu-id="76331-309">Writes moving ahead of reads</span></span>  | <span data-ttu-id="76331-310">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-310">Yes</span></span>     | <span data-ttu-id="76331-311">No</span><span class="sxs-lookup"><span data-stu-id="76331-311">No</span></span>     | <span data-ttu-id="76331-312">No</span><span class="sxs-lookup"><span data-stu-id="76331-312">No</span></span>   |
| <span data-ttu-id="76331-313">Lee el avance de las escrituras</span><span class="sxs-lookup"><span data-stu-id="76331-313">Reads moving ahead of writes</span></span>  | <span data-ttu-id="76331-314">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-314">Yes</span></span>     | <span data-ttu-id="76331-315">Sí</span><span class="sxs-lookup"><span data-stu-id="76331-315">Yes</span></span>    | <span data-ttu-id="76331-316">No</span><span class="sxs-lookup"><span data-stu-id="76331-316">No</span></span>   |



 

<span data-ttu-id="76331-317">PowerPC también tiene las instrucciones de sincronización **iSync** y **eieio** (que se usa para controlar la reordenación de la memoria que impide el almacenamiento en caché).</span><span class="sxs-lookup"><span data-stu-id="76331-317">PowerPC also has the synchronization instructions **isync** and **eieio** (which is used to control reordering to caching-inhibited memory).</span></span> <span data-ttu-id="76331-318">Estas instrucciones de sincronización no deben ser necesarias para fines de sincronización normales.</span><span class="sxs-lookup"><span data-stu-id="76331-318">These synchronization instructions should not be needed for normal synchronization purposes.</span></span>

<span data-ttu-id="76331-319">En Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) se define en Winnt. h y proporciona una instrucción de barrera de memoria diferente en función de si se está compilando para x86 o x64.</span><span class="sxs-lookup"><span data-stu-id="76331-319">On Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined in Winnt.h and gives you a different memory barrier instruction depending on whether you are compiling for x86 or x64.</span></span> <span data-ttu-id="76331-320">La instrucción de barrera de memoria actúa como una barrera completa, lo que impide que se reordene las lecturas y escrituras a través de la barrera.</span><span class="sxs-lookup"><span data-stu-id="76331-320">The memory barrier instruction serves as a full barrier, preventing all reordering of reads and writes across the barrier.</span></span> <span data-ttu-id="76331-321">Por lo tanto, **MemoryBarrier** en Windows proporciona una garantía de reordenación más fuerte que en la Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="76331-321">Thus, **MemoryBarrier** on Windows gives a stronger reordering guarantee than it does on Xbox 360.</span></span>

<span data-ttu-id="76331-322">En la consola Xbox 360 y en muchas otras CPU, existe una manera adicional de evitar la reordenación de lectura por la CPU.</span><span class="sxs-lookup"><span data-stu-id="76331-322">On Xbox 360, and on many other CPUs, there is one additional way that read-reordering by the CPU can be prevented.</span></span> <span data-ttu-id="76331-323">Si lee un puntero y, a continuación, usa ese puntero para cargar otros datos, la CPU garantiza que las lecturas fuera del puntero no sean anteriores a la lectura del puntero.</span><span class="sxs-lookup"><span data-stu-id="76331-323">If you read a pointer and then use that pointer to load other data, the CPU guarantees that the reads off of the pointer are not older than the read of the pointer.</span></span> <span data-ttu-id="76331-324">Si la marca de bloqueo es un puntero y todas las lecturas de datos compartidos están fuera del puntero, se puede omitir el [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) , lo que supone un ahorro de rendimiento modesto.</span><span class="sxs-lookup"><span data-stu-id="76331-324">If your lock flag is a pointer and if all reads of shared data are off of the pointer, the [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) can be omitted, for a modest performance savings.</span></span>

``` syntax
Data* localPointer = g_sharedPointer;
if( localPointer )
{
    // No import barrier is needed--all reads off of localPointer
    // are guaranteed to not be reordered past the read of
    // localPointer.
    int localVariable = localPointer->y;
    // A memory barrier is needed to stop the read of g_global
    // from being speculatively moved ahead of the read of
    // g_sharedPointer.
    int localVariable2 = g_global;
}
```

<span data-ttu-id="76331-325">La instrucción [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) solo evita la reordenación de las lecturas y escrituras en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="76331-325">The [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) instruction only prevents reordering of reads and writes to cacheable memory.</span></span> <span data-ttu-id="76331-326">Si asigna memoria como PAGE \_ nocache o Page \_ WRITECOMBINE, una técnica común para los autores de controladores de dispositivos y para los desarrolladores de juegos en Xbox 360, **MemoryBarrier** no tiene ningún efecto en los accesos a esta memoria.</span><span class="sxs-lookup"><span data-stu-id="76331-326">If you allocate memory as PAGE\_NOCACHE or PAGE\_WRITECOMBINE, a common technique for device driver authors and for game developers on Xbox 360, **MemoryBarrier** has no effect on accesses to this memory.</span></span> <span data-ttu-id="76331-327">La mayoría de los desarrolladores no necesitan la sincronización de memoria no almacenable en caché.</span><span class="sxs-lookup"><span data-stu-id="76331-327">Most developers don't need synchronization of non-cacheable memory.</span></span> <span data-ttu-id="76331-328">Eso va más allá del ámbito de este artículo.</span><span class="sxs-lookup"><span data-stu-id="76331-328">That is beyond the scope of this article.</span></span>

## <a name="interlocked-functions-and-cpu-reordering"></a><span data-ttu-id="76331-329">Funciones de bloqueo y reordenación de CPU</span><span class="sxs-lookup"><span data-stu-id="76331-329">Interlocked Functions and CPU Reordering</span></span>

<span data-ttu-id="76331-330">A veces, la lectura o escritura que adquiere o libera un recurso se realiza mediante una de las funciones de **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="76331-330">Sometimes the read or write that acquires or releases a resource is done using one of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="76331-331">En Windows, esto simplifica las cosas; Dado que en Windows, las funciones de **InterlockedXxx** son todas las barreras de memoria completa.</span><span class="sxs-lookup"><span data-stu-id="76331-331">On Windows, this simplifies things; because on Windows, the **InterlockedXxx** functions are all full-memory barriers.</span></span> <span data-ttu-id="76331-332">En realidad, tienen una barrera de memoria de CPU antes y después de ellas, lo que significa que son una barrera completa de lectura/adquisición o de versión de escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-332">They effectively have a CPU memory barrier both before and after them, which means that they are a full read-acquire or write-release barrier all by themselves.</span></span>

<span data-ttu-id="76331-333">En Xbox 360, las funciones de **InterlockedXxx** no contienen barreras de memoria de la CPU.</span><span class="sxs-lookup"><span data-stu-id="76331-333">On Xbox 360, the **InterlockedXxx** functions do not contain CPU memory barriers.</span></span> <span data-ttu-id="76331-334">Impiden la reordenación del compilador de lecturas y escrituras, pero no de la reordenación de la CPU.</span><span class="sxs-lookup"><span data-stu-id="76331-334">They prevent compiler reordering of reads and writes but not CPU reordering.</span></span> <span data-ttu-id="76331-335">Por lo tanto, en la mayoría de los casos, al usar las funciones de **InterlockedXxx** en Xbox 360, debe preceder o seguirlos con un **\_ \_ lwsync** para convertirlos en una barrera de lectura/adquisición o de versión de escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-335">Therefore, in most cases when using **InterlockedXxx** functions on Xbox 360, you should precede or follow them with an **\_\_lwsync**, to make them a read-acquire or write-release barrier.</span></span> <span data-ttu-id="76331-336">Para mayor comodidad y para facilitar la lectura, hay versiones de **adquisición** y **lanzamiento** de muchas de las funciones de **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="76331-336">For convenience and for easier readability, there are **Acquire** and **Release** versions of many of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="76331-337">Esto incluye una barrera de memoria integrada.</span><span class="sxs-lookup"><span data-stu-id="76331-337">These come with a built-in memory barrier.</span></span> <span data-ttu-id="76331-338">Por ejemplo, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) realiza un incremento entrelazado seguido de una barrera de memoria **\_ \_ lwsync** para proporcionar la funcionalidad completa de lectura y adquisición.</span><span class="sxs-lookup"><span data-stu-id="76331-338">For instance, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) does an interlocked increment followed by an **\_\_lwsync** memory barrier to give the full read-acquire functionality.</span></span>

<span data-ttu-id="76331-339">Se recomienda usar las versiones de **adquisición** y **lanzamiento** de las funciones de **InterlockedXxx** (la mayoría de las cuales están disponibles también en Windows, sin penalización de rendimiento) para que su intención sea más obvia y para que sea más fácil obtener las instrucciones de barrera de memoria en el lugar correcto.</span><span class="sxs-lookup"><span data-stu-id="76331-339">It is recommended that you use the **Acquire** and **Release** versions of the **InterlockedXxx** functions (most of which are available on Windows as well, with no performance penalty) to make your intent more obvious and to make it easier to get the memory barrier instructions in the correct place.</span></span> <span data-ttu-id="76331-340">Cualquier uso de **InterlockedXxx** en Xbox 360 sin una barrera de memoria debe examinarse con cuidado, ya que a menudo se trata de un error.</span><span class="sxs-lookup"><span data-stu-id="76331-340">Any use of **InterlockedXxx** on Xbox 360 without a memory barrier should be examined very carefully, because it is often a bug.</span></span>

<span data-ttu-id="76331-341">Este ejemplo muestra cómo un subproceso puede pasar tareas u otros datos a otro subproceso mediante las versiones de **adquisición** y **lanzamiento** de las funciones de **InterlockedXxxSList** .</span><span class="sxs-lookup"><span data-stu-id="76331-341">This sample demonstrates how one thread can pass tasks or other data to another thread using the **Acquire** and **Release** versions of the **InterlockedXxxSList** functions.</span></span> <span data-ttu-id="76331-342">Las funciones de **InterlockedXxxSList** son una familia de funciones para mantener una lista compartida de un solo vínculo sin un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-342">The **InterlockedXxxSList** functions are a family of functions for maintaining a shared singly linked list without a lock.</span></span> <span data-ttu-id="76331-343">Tenga en cuenta que las variantes de **adquisición** y **liberación** de estas funciones no están disponibles en Windows, pero las versiones normales de estas funciones son una barrera de memoria completa en Windows.</span><span class="sxs-lookup"><span data-stu-id="76331-343">Note that **Acquire** and **Release** variants of these functions are not available on Windows, but the regular versions of these functions are a full memory barrier on Windows.</span></span>

``` syntax
// Declarations for the Task class go here.

// Add a new task to the list using lockless programming.
void AddTask( DWORD ID, DWORD data )
{
    Task* newItem = new Task( ID, data );
    InterlockedPushEntrySListRelease( g_taskList, newItem );
}

// Remove a task from the list, using lockless programming.
// This will return NULL if there are no items in the list.
Task* GetTask()
{
    Task* result = (Task*)
        InterlockedPopEntrySListAcquire( g_taskList );
    return result;
}
```

## <a name="volatile-variables-and-reordering"></a><span data-ttu-id="76331-344">Variables volátiles y reordenación</span><span class="sxs-lookup"><span data-stu-id="76331-344">Volatile Variables and Reordering</span></span>

<span data-ttu-id="76331-345">El estándar de C++ indica que no se pueden almacenar en caché las lecturas de variables volátiles, no se pueden retrasar las escrituras volátiles y las lecturas y escrituras volátiles no se pueden moverse más allá de otras.</span><span class="sxs-lookup"><span data-stu-id="76331-345">The C++ Standard says that reads of volatile variables cannot be cached, volatile writes cannot be delayed, and volatile reads and writes cannot be moved past each other.</span></span> <span data-ttu-id="76331-346">Esto es suficiente para comunicarse con dispositivos de hardware, que es el propósito de la palabra clave volatile en el estándar de C++.</span><span class="sxs-lookup"><span data-stu-id="76331-346">This is sufficient for communicating with hardware devices, which is the purpose of the volatile keyword in the C++ Standard.</span></span>

<span data-ttu-id="76331-347">Sin embargo, las garantías del estándar no son suficientes para usar volatile para multithreading.</span><span class="sxs-lookup"><span data-stu-id="76331-347">However, the guarantees of the standard are not sufficient for using volatile for multi-threading.</span></span> <span data-ttu-id="76331-348">El estándar de C++ no impide que el compilador reordene las lecturas y escrituras no volátiles con respecto a las lecturas y escrituras volátiles, y no indica nada sobre cómo evitar la reordenación de la CPU.</span><span class="sxs-lookup"><span data-stu-id="76331-348">The C++ Standard does not stop the compiler from reordering non-volatile reads and writes relative to volatile reads and writes, and it says nothing about preventing CPU reordering.</span></span>

<span data-ttu-id="76331-349">Visual C++ 2005 va más allá del estándar de C++ para definir la semántica compatible con varios subprocesos para el acceso de variables volátiles.</span><span class="sxs-lookup"><span data-stu-id="76331-349">Visual C++ 2005 goes beyond standard C++ to define multi-threading-friendly semantics for volatile variable access.</span></span> <span data-ttu-id="76331-350">A partir de Visual C++ 2005, las lecturas de variables volátiles se definen para tener semántica de adquisición y de lectura, y las escrituras en variables volátiles se definen para tener la semántica de versión de escritura.</span><span class="sxs-lookup"><span data-stu-id="76331-350">Starting with Visual C++ 2005, reads from volatile variables are defined to have read-acquire semantics, and writes to volatile variables are defined to have write-release semantics.</span></span> <span data-ttu-id="76331-351">Esto significa que el compilador no reorganizará las lecturas y escrituras más allá y, en Windows, se asegurará de que la CPU no lo hace.</span><span class="sxs-lookup"><span data-stu-id="76331-351">This means that the compiler will not rearrange any reads and writes past them, and on Windows it will ensure that the CPU does not do so either.</span></span>

<span data-ttu-id="76331-352">Es importante comprender que estas nuevas garantías solo se aplican a Visual C++ 2005 y versiones futuras de Visual C++.</span><span class="sxs-lookup"><span data-stu-id="76331-352">It is important to understand that these new guarantees only apply to Visual C++ 2005 and future versions of Visual C++.</span></span> <span data-ttu-id="76331-353">Los compiladores de otros proveedores generalmente implementarán semánticas diferentes, sin las garantías adicionales de Visual C++ 2005.</span><span class="sxs-lookup"><span data-stu-id="76331-353">Compilers from other vendors will generally implement different semantics, without the extra guarantees of Visual C++ 2005.</span></span> <span data-ttu-id="76331-354">Además, en Xbox 360, el compilador no inserta instrucciones para impedir que la CPU reordene las lecturas y escrituras.</span><span class="sxs-lookup"><span data-stu-id="76331-354">Also, on Xbox 360, the compiler does not insert any instructions to prevent the CPU from reordering reads and writes.</span></span>

## <a name="example-of-a-lock-free-data-pipe"></a><span data-ttu-id="76331-355">Ejemplo de una canalización de datos Lock-Free</span><span class="sxs-lookup"><span data-stu-id="76331-355">Example of a Lock-Free Data Pipe</span></span>

<span data-ttu-id="76331-356">Una canalización es una construcción que permite a uno o más subprocesos escribir datos que otros subprocesos leen.</span><span class="sxs-lookup"><span data-stu-id="76331-356">A pipe is a construct that lets one or more threads write data that is then read by other threads.</span></span> <span data-ttu-id="76331-357">Una versión sin bloqueo de una canalización puede ser una forma elegante y eficaz de pasar el trabajo del subproceso al subproceso.</span><span class="sxs-lookup"><span data-stu-id="76331-357">A lockless version of a pipe can be an elegant and efficient way to pass work from thread to thread.</span></span> <span data-ttu-id="76331-358">El SDK de DirectX proporciona **LockFreePipe**, una canalización de un solo lector y un bloqueo de un solo escritor que está disponible en DXUTLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="76331-358">The DirectX SDK supplies **LockFreePipe**, a single-reader, single-writer lockless pipe that is available in DXUTLockFreePipe.h.</span></span> <span data-ttu-id="76331-359">El mismo **LockFreePipe** está disponible en el SDK de Xbox 360 en AtgLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="76331-359">The same **LockFreePipe** is available in the Xbox 360 SDK in AtgLockFreePipe.h.</span></span>

<span data-ttu-id="76331-360">**LockFreePipe** se puede usar cuando dos subprocesos tienen una relación productor/consumidor.</span><span class="sxs-lookup"><span data-stu-id="76331-360">**LockFreePipe** can be used when two threads have a producer/consumer relationship.</span></span> <span data-ttu-id="76331-361">El subproceso de productor puede escribir datos en la canalización para que el subproceso del consumidor los procese en una fecha posterior, sin ningún bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-361">The producer thread can write data to the pipe for the consumer thread to process at a later date, without ever blocking.</span></span> <span data-ttu-id="76331-362">Si la canalización se llena, se producirá un error en las escrituras y el subproceso del productor tendrá que intentarlo de nuevo más tarde, pero esto solo ocurrirá si el subproceso del productor está por adelante.</span><span class="sxs-lookup"><span data-stu-id="76331-362">If the pipe fills up, writes fail, and the producer thread will have to try again later, but this would only happen if the producer thread is ahead.</span></span> <span data-ttu-id="76331-363">Si la canalización está vacía, se produce un error de lectura y el subproceso del consumidor tendrá que intentarlo de nuevo más tarde, pero esto solo ocurrirá si no hay ningún trabajo para que lo haga el subproceso del consumidor.</span><span class="sxs-lookup"><span data-stu-id="76331-363">If the pipe empties, reads fail, and the consumer thread will have to try again later, but this would only happen if there is no work for the consumer thread to do.</span></span> <span data-ttu-id="76331-364">Si los dos subprocesos están bien equilibrados y la canalización es lo suficientemente grande, la canalización les permite pasar datos sin problemas, además de retrasos o bloques.</span><span class="sxs-lookup"><span data-stu-id="76331-364">If the two threads are well-balanced, and the pipe is big enough, the pipe lets them smoothly pass data along with no delays or blocks.</span></span>

## <a name="xbox-360-performance"></a><span data-ttu-id="76331-365">Rendimiento de Xbox 360</span><span class="sxs-lookup"><span data-stu-id="76331-365">Xbox 360 Performance</span></span>

<span data-ttu-id="76331-366">El rendimiento de las instrucciones de sincronización y de las funciones de Xbox 360 variará en función del código que se esté ejecutando.</span><span class="sxs-lookup"><span data-stu-id="76331-366">The performance of synchronization instructions and functions on Xbox 360 will vary depending on what other code is running.</span></span> <span data-ttu-id="76331-367">La adquisición de bloqueos tardará mucho más si otro subproceso posee actualmente el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-367">Acquiring locks will take much longer if another thread currently owns the lock.</span></span> <span data-ttu-id="76331-368">Las operaciones de [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) y sección crítica tardarán mucho más si otros subprocesos escriben en la misma línea de caché.</span><span class="sxs-lookup"><span data-stu-id="76331-368">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) and critical section operations will take much longer if other threads are writing to the same cache line.</span></span> <span data-ttu-id="76331-369">El contenido de las colas de almacén también puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="76331-369">The contents of the store queues can also affect performance.</span></span> <span data-ttu-id="76331-370">Por lo tanto, todos estos números son solo aproximaciones, generadas a partir de pruebas muy simples:</span><span class="sxs-lookup"><span data-stu-id="76331-370">Therefore, all of these numbers are just approximations, generated from very simple tests:</span></span>

-   <span data-ttu-id="76331-371">**lwsync** se midió con 33-48 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-371">**lwsync** was measured as taking 33-48 cycles.</span></span>
-   <span data-ttu-id="76331-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) se midió con 225-260 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 225-260 cycles.</span></span>
-   <span data-ttu-id="76331-373">La adquisición o liberación de una sección crítica se midió como la realización de unos 345 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-373">Acquiring or releasing a critical section was measured as taking about 345 cycles.</span></span>
-   <span data-ttu-id="76331-374">La adquisición o liberación de una exclusión mutua se midió como una toma de 2350 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-374">Acquiring or releasing a mutex was measured as taking about 2350 cycles.</span></span>

## <a name="windows-performance"></a><span data-ttu-id="76331-375">Rendimiento de Windows</span><span class="sxs-lookup"><span data-stu-id="76331-375">Windows Performance</span></span>

<span data-ttu-id="76331-376">El rendimiento de las instrucciones y las funciones de sincronización en Windows varía considerablemente según el tipo y la configuración del procesador, y en qué otro código se está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="76331-376">The performance of synchronization instructions and functions on Windows vary widely depending on the processor type and configuration, and on what other code is running.</span></span> <span data-ttu-id="76331-377">Los sistemas de varios núcleos y varios Sockets suelen tardar más en ejecutar instrucciones de sincronización y la adquisición de bloqueos tarda mucho más tiempo si otro subproceso posee actualmente el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-377">Multi-core and multi-socket systems often take longer to execute synchronizing instructions, and acquiring locks take much longer if another thread currently owns the lock.</span></span>

<span data-ttu-id="76331-378">Sin embargo, incluso algunas mediciones generadas a partir de pruebas muy simples son útiles:</span><span class="sxs-lookup"><span data-stu-id="76331-378">However, even some measurements generated from very simple tests are helpful:</span></span>

-   <span data-ttu-id="76331-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) se midió con 20-90 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) was measured as taking 20-90 cycles.</span></span>
-   <span data-ttu-id="76331-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) se midió con 36-90 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 36-90 cycles.</span></span>
-   <span data-ttu-id="76331-381">La adquisición o liberación de una sección crítica se midió como una toma de 40-100 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-381">Acquiring or releasing a critical section was measured as taking 40-100 cycles.</span></span>
-   <span data-ttu-id="76331-382">La adquisición o liberación de una exclusión mutua se midió como una toma de 750-2500 ciclos.</span><span class="sxs-lookup"><span data-stu-id="76331-382">Acquiring or releasing a mutex was measured as taking about 750-2500 cycles.</span></span>

<span data-ttu-id="76331-383">Estas pruebas se realizaron en Windows XP en una variedad de procesadores diferentes.</span><span class="sxs-lookup"><span data-stu-id="76331-383">These tests were done on Windows XP on a range of different processors.</span></span> <span data-ttu-id="76331-384">Las horas cortas se encontraban en un equipo con un solo procesador y los tiempos más largos en un equipo con varios procesadores.</span><span class="sxs-lookup"><span data-stu-id="76331-384">The short times were on a single-processor machine, and the longer times were on a multi-processor machine.</span></span>

<span data-ttu-id="76331-385">Aunque la adquisición y liberación de bloqueos es más costosa que el uso de la programación sin bloqueo, es aún mejor compartir datos con menos frecuencia, evitando así el costo por completo.</span><span class="sxs-lookup"><span data-stu-id="76331-385">While acquiring and releasing locks is more expensive than using lockless programming, it is even better to share data less frequently, thus avoiding the cost altogether.</span></span>

## <a name="performance-thoughts"></a><span data-ttu-id="76331-386">Consideraciones sobre el rendimiento</span><span class="sxs-lookup"><span data-stu-id="76331-386">Performance Thoughts</span></span>

<span data-ttu-id="76331-387">La adquisición o liberación de una sección crítica consiste en una barrera de memoria, una operación **InterlockedXxx** y alguna comprobación adicional para controlar la recursividad y revertir a una exclusión mutua, si es necesario.</span><span class="sxs-lookup"><span data-stu-id="76331-387">Acquiring or releasing a critical section consists of a memory barrier, an **InterlockedXxx** operation, and some extra checking to handle recursion and to fall back to a mutex, if necessary.</span></span> <span data-ttu-id="76331-388">Debe tener cuidado al implementar su propia sección crítica, ya que el giro de un bucle en espera de que un bloqueo sea gratuito, sin recurrir a una exclusión mutua, puede desperdiciar un rendimiento considerable.</span><span class="sxs-lookup"><span data-stu-id="76331-388">You should be wary of implementing your own critical section, because spinning in a loop waiting for a lock to be free, without falling back to a mutex, can waste considerable performance.</span></span> <span data-ttu-id="76331-389">En el caso de las secciones críticas que están muy dispones pero que no se conservan durante mucho tiempo, debería considerar el uso de [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) para que el sistema operativo gire durante mientras espera a que la sección crítica esté disponible en lugar de aplazarse inmediatamente a una exclusión mutua si la sección crítica es propiedad cuando intenta adquirirla.</span><span class="sxs-lookup"><span data-stu-id="76331-389">For critical sections that are heavily contended but not held for long, you should consider using [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) so that the operating system will spin for a while waiting for the critical section to be available rather than immediately deferring to a mutex if the critical section is owned when you try to acquire it.</span></span> <span data-ttu-id="76331-390">Con el fin de identificar las secciones críticas que pueden beneficiarse de un número de bucles, es necesario medir la longitud de la espera típica para un bloqueo determinado.</span><span class="sxs-lookup"><span data-stu-id="76331-390">In order to identify critical sections that can benefit from a spin count, it is necessary to measure the length of the typical wait for a particular lock.</span></span>

<span data-ttu-id="76331-391">Si se utiliza un montón compartido para las asignaciones de memoria (el comportamiento predeterminado), cada asignación de memoria y Free implica la adquisición de un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-391">If a shared heap is used for memory allocations—the default behavior—every memory allocation and free involves acquiring a lock.</span></span> <span data-ttu-id="76331-392">A medida que aumenta el número de subprocesos y el número de asignaciones, los niveles de rendimiento se desactivan y finalmente se inicia su disminución.</span><span class="sxs-lookup"><span data-stu-id="76331-392">As the number of threads and the number of allocations increases, performance levels off, and eventually starts to decrease.</span></span> <span data-ttu-id="76331-393">El uso de montones por subproceso o la reducción del número de asignaciones puede evitar este cuello de botella de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="76331-393">Using per-thread heaps, or reducing the number of allocations, can avoid this locking bottleneck.</span></span>

<span data-ttu-id="76331-394">Si un subproceso está generando datos y otro subproceso está consumiendo datos, pueden acabar compartiendo datos con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="76331-394">If one thread is generating data and another thread is consuming data, they may end up sharing data frequently.</span></span> <span data-ttu-id="76331-395">Esto puede ocurrir si un subproceso está cargando recursos y otro subproceso está representando la escena.</span><span class="sxs-lookup"><span data-stu-id="76331-395">This can happen if one thread is loading resources and another thread is rendering the scene.</span></span> <span data-ttu-id="76331-396">Si el subproceso de representación hace referencia a los datos compartidos en cada llamada a Draw, la sobrecarga de bloqueo será alta.</span><span class="sxs-lookup"><span data-stu-id="76331-396">If the rendering thread references the shared data on every draw call, the locking overhead will be high.</span></span> <span data-ttu-id="76331-397">Se puede obtener un rendimiento mucho mejor si cada subproceso tiene estructuras de datos privadas que después se sincronizan una vez por fotograma o menos.</span><span class="sxs-lookup"><span data-stu-id="76331-397">Much better performance can be realized if each thread has private data structures which are then synchronized once per frame or less.</span></span>

<span data-ttu-id="76331-398">No se garantiza que los algoritmos sin bloqueo sean más rápidos que los algoritmos que usan bloqueos.</span><span class="sxs-lookup"><span data-stu-id="76331-398">Lockless algorithms are not guaranteed to be faster than algorithms that use locks.</span></span> <span data-ttu-id="76331-399">Debe comprobar si los bloqueos están causando realmente problemas antes de intentar evitarlos y debe medir para ver si el código sin bloqueo realmente mejora el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="76331-399">You should check to see if locks are actually causing you problems before trying to avoid them, and you should measure to see if your lockless code actually improves performance.</span></span>

## <a name="platform-differences-summary"></a><span data-ttu-id="76331-400">Resumen de diferencias de plataforma</span><span class="sxs-lookup"><span data-stu-id="76331-400">Platform Differences Summary</span></span>

-   <span data-ttu-id="76331-401">Las funciones de **InterlockedXxx** evitan la reordenación de lectura/escritura de la CPU en Windows, pero no en Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="76331-401">**InterlockedXxx** functions prevent CPU read/write reordering on Windows, but not on Xbox 360.</span></span>
-   <span data-ttu-id="76331-402">La lectura y escritura de variables volátiles con Visual Studio C++ 2005 impide la reordenación de lectura/escritura de la CPU en Windows, pero en Xbox 360 solo impide la reordenación de lectura/escritura del compilador.</span><span class="sxs-lookup"><span data-stu-id="76331-402">Reading and writing of volatile variables using Visual Studio C++ 2005 prevents CPU read/write reordering on Windows, but on Xbox 360, it only prevents compiler read/write reordering.</span></span>
-   <span data-ttu-id="76331-403">Las escrituras se reordenan en la consola Xbox 360, pero no en x86 o x64.</span><span class="sxs-lookup"><span data-stu-id="76331-403">Writes are reordered on Xbox 360, but not on x86 or x64.</span></span>
-   <span data-ttu-id="76331-404">Las lecturas se reordenan en la consola Xbox 360, pero en x86 o x64 solo se reordenan en relación con las escrituras y solo si las lecturas y escrituras se dirigen a ubicaciones diferentes.</span><span class="sxs-lookup"><span data-stu-id="76331-404">Reads are reordered on Xbox 360, but on x86 or x64 they are only reordered relative to writes, and only if the reads and writes target different locations.</span></span>

## <a name="recommendations"></a><span data-ttu-id="76331-405">Recomendaciones</span><span class="sxs-lookup"><span data-stu-id="76331-405">Recommendations</span></span>

-   <span data-ttu-id="76331-406">Use bloqueos cuando sea posible porque son más fáciles de usar correctamente.</span><span class="sxs-lookup"><span data-stu-id="76331-406">Use locks when possible because they are easier to use correctly.</span></span>
-   <span data-ttu-id="76331-407">Evite el bloqueo con demasiada frecuencia, de modo que los costos de bloqueo no sean significativos.</span><span class="sxs-lookup"><span data-stu-id="76331-407">Avoid locking too frequently, so that locking costs do not become significant.</span></span>
-   <span data-ttu-id="76331-408">Evite mantener bloqueos durante demasiado tiempo, con el fin de evitar paradas largas.</span><span class="sxs-lookup"><span data-stu-id="76331-408">Avoid holding locks for too long, in order to avoid long stalls.</span></span>
-   <span data-ttu-id="76331-409">Use la programación sin bloqueo cuando corresponda, pero asegúrese de que las ventajas justifiquen la complejidad.</span><span class="sxs-lookup"><span data-stu-id="76331-409">Use lockless programming when appropriate, but be sure that the gains justify the complexity.</span></span>
-   <span data-ttu-id="76331-410">Use la programación sin bloqueo o los bloqueos de giro en situaciones en las que se prohíben otros bloqueos, como cuando se comparten datos entre llamadas a procedimiento diferidas y código normal.</span><span class="sxs-lookup"><span data-stu-id="76331-410">Use lockless programming or spin locks in situations where other locks are prohibited, such as when sharing data between deferred procedure calls and normal code.</span></span>
-   <span data-ttu-id="76331-411">Use únicamente algoritmos de programación estándar de bloqueo que se hayan demostrado que son correctos.</span><span class="sxs-lookup"><span data-stu-id="76331-411">Only use standard lockless programming algorithms that have been proven to be correct.</span></span>
-   <span data-ttu-id="76331-412">Al realizar la programación con bloqueo, asegúrese de usar variables de marca volátil y instrucciones de barrera de memoria según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="76331-412">When doing lockless programming, be sure to use volatile flag variables and memory barrier instructions as needed.</span></span>
-   <span data-ttu-id="76331-413">Al usar **InterlockedXxx** en Xbox 360, use las variantes de **adquisición** y **liberación** .</span><span class="sxs-lookup"><span data-stu-id="76331-413">When using **InterlockedXxx** on Xbox 360, use the **Acquire** and **Release** variants.</span></span>

## <a name="references"></a><span data-ttu-id="76331-414">Referencias</span><span class="sxs-lookup"><span data-stu-id="76331-414">References</span></span>

-   <span data-ttu-id="76331-415">Biblioteca de MSDN.</span><span class="sxs-lookup"><span data-stu-id="76331-415">MSDN Library.</span></span> <span data-ttu-id="76331-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)".</span><span class="sxs-lookup"><span data-stu-id="76331-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)."</span></span> <span data-ttu-id="76331-417">Referencia del lenguaje C++.</span><span class="sxs-lookup"><span data-stu-id="76331-417">C++ Language Reference.</span></span>
-   <span data-ttu-id="76331-418">Saavedra Morrison.</span><span class="sxs-lookup"><span data-stu-id="76331-418">Vance Morrison.</span></span> <span data-ttu-id="76331-419">"[Comprenda el impacto de las técnicas de Low-Lock en aplicaciones multiproceso](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)".</span><span class="sxs-lookup"><span data-stu-id="76331-419">"[Understand the Impact of Low-Lock Techniques in Multithreaded Apps](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)."</span></span> <span data-ttu-id="76331-420">MSDN Magazine, 2005 de octubre.</span><span class="sxs-lookup"><span data-stu-id="76331-420">MSDN Magazine, October 2005.</span></span>
-   <span data-ttu-id="76331-421">Lyons, Michael.</span><span class="sxs-lookup"><span data-stu-id="76331-421">Lyons, Michael.</span></span> <span data-ttu-id="76331-422">"[Modelo de almacenamiento PowerPC y programación de Aix](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)".</span><span class="sxs-lookup"><span data-stu-id="76331-422">"[PowerPC Storage Model and AIX Programming](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)."</span></span> <span data-ttu-id="76331-423">IBM developerWorks, 16 de noviembre de 2005.</span><span class="sxs-lookup"><span data-stu-id="76331-423">IBM developerWorks, 16 Nov 2005.</span></span>
-   <span data-ttu-id="76331-424">McKenney, Paul E. "[ordenación de memoria en microprocesadores modernos, parte II](https://www.linuxjournal.com/article/8212)".</span><span class="sxs-lookup"><span data-stu-id="76331-424">McKenney, Paul E. "[Memory Ordering in Modern Microprocessors, Part II](https://www.linuxjournal.com/article/8212)."</span></span> <span data-ttu-id="76331-425">Diario de Linux, septiembre de 2005.</span><span class="sxs-lookup"><span data-stu-id="76331-425">Linux Journal, September 2005.</span></span> <span data-ttu-id="76331-426">\[Este artículo contiene algunos detalles de x86.\]</span><span class="sxs-lookup"><span data-stu-id="76331-426">\[This article has some x86 details.\]</span></span>
-   <span data-ttu-id="76331-427">Intel Corporation.</span><span class="sxs-lookup"><span data-stu-id="76331-427">Intel Corporation.</span></span> <span data-ttu-id="76331-428">"[Clasificación de memoria de la arquitectura de Intel® 64](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)".</span><span class="sxs-lookup"><span data-stu-id="76331-428">"[Intel® 64 Architecture Memory Ordering](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)."</span></span> <span data-ttu-id="76331-429">2007 de agosto.</span><span class="sxs-lookup"><span data-stu-id="76331-429">August 2007.</span></span> <span data-ttu-id="76331-430">\[Se aplica a los procesadores IA-32 e Intel 64.\]</span><span class="sxs-lookup"><span data-stu-id="76331-430">\[Applies to both IA-32 and Intel 64 processors.\]</span></span>
-   <span data-ttu-id="76331-431">Niebler, Eric.</span><span class="sxs-lookup"><span data-stu-id="76331-431">Niebler, Eric.</span></span> <span data-ttu-id="76331-432">"[Informe de viajes: reunión ad hoc en subprocesos en C++](https://www.artima.com/cppsource/threads_meeting.html)".</span><span class="sxs-lookup"><span data-stu-id="76331-432">"[Trip Report: Ad-Hoc Meeting on Threads in C++](https://www.artima.com/cppsource/threads_meeting.html)."</span></span> <span data-ttu-id="76331-433">Código fuente de C++, 17 de octubre de 2006.</span><span class="sxs-lookup"><span data-stu-id="76331-433">The C++ Source, 17 Oct 2006.</span></span>
-   <span data-ttu-id="76331-434">Hart, Thomas E. 2006.</span><span class="sxs-lookup"><span data-stu-id="76331-434">Hart, Thomas E. 2006.</span></span> <span data-ttu-id="76331-435">"[Sincronización rápida de bloqueos: implicaciones de rendimiento de la recuperación de memoria](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)".</span><span class="sxs-lookup"><span data-stu-id="76331-435">"[Making Lockless Synchronization Fast: Performance Implications of Memory Reclamation](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)."</span></span> <span data-ttu-id="76331-436">Procedimientos del Symposium de procesamiento distribuido y paralelo 2006 Internacional (IPDPS 2006), Isla Rhodes, Grecia, abril de 2006.</span><span class="sxs-lookup"><span data-stu-id="76331-436">Proceedings of the 2006 International Parallel and Distributed Processing Symposium (IPDPS 2006), Rhodes Island, Greece, April 2006.</span></span>

 

 