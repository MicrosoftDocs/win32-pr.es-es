---
title: Apartamentos multiproceso
description: Apartamentos multiproceso
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/21/2020
ms.locfileid: "105685798"
---
# <a name="multithreaded-apartments"></a><span data-ttu-id="66c4d-103">Apartamentos multiproceso</span><span class="sxs-lookup"><span data-stu-id="66c4d-103">Multithreaded Apartments</span></span>

<span data-ttu-id="66c4d-104">En un modelo de Apartamento multiproceso, todos los subprocesos del proceso que se han inicializado como subproceso libre se encuentran en un único apartamento.</span><span class="sxs-lookup"><span data-stu-id="66c4d-104">In a multithreaded apartment model, all the threads in the process that have been initialized as free-threaded reside in a single apartment.</span></span> <span data-ttu-id="66c4d-105">Por lo tanto, no hay necesidad de calcular las referencias entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="66c4d-105">Therefore, there is no need to marshal between threads.</span></span> <span data-ttu-id="66c4d-106">Los subprocesos no necesitan recuperar y enviar mensajes porque COM no utiliza los mensajes de ventana de este modelo.</span><span class="sxs-lookup"><span data-stu-id="66c4d-106">The threads need not retrieve and dispatch messages because COM does not use window messages in this model.</span></span>

<span data-ttu-id="66c4d-107">Las llamadas a métodos de objetos en el contenedor multiproceso se pueden ejecutar en cualquier subproceso del apartamento.</span><span class="sxs-lookup"><span data-stu-id="66c4d-107">Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment.</span></span> <span data-ttu-id="66c4d-108">No hay ninguna serialización de llamadas; pueden producirse muchas llamadas al mismo método o al mismo objeto simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="66c4d-108">There is no serialization of calls; many calls may occur to the same method or to the same object simultaneously.</span></span> <span data-ttu-id="66c4d-109">Los objetos creados en el contenedor multiproceso deben ser capaces de controlar llamadas en sus métodos desde otros subprocesos en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="66c4d-109">Objects created in the multithreaded apartment must be able to handle calls on their methods from other threads at any time.</span></span>

<span data-ttu-id="66c4d-110">Dado que las llamadas a objetos no se serializan de ninguna manera, la simultaneidad de objetos multiproceso ofrece el mayor rendimiento y toma la mejor ventaja del hardware multiprocesador para la llamada entre subprocesos, entre procesos y entre equipos.</span><span class="sxs-lookup"><span data-stu-id="66c4d-110">Because calls to objects are not serialized in any way, multithreaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling.</span></span> <span data-ttu-id="66c4d-111">Sin embargo, esto significa que el código de los objetos debe proporcionar sincronización en sus implementaciones de interfaz, normalmente mediante el uso de primitivas de sincronización, como objetos de evento, secciones críticas, exclusiones mutuas o semáforos, que se describen más adelante en esta sección.</span><span class="sxs-lookup"><span data-stu-id="66c4d-111">This means, however, that the code for objects must provide synchronization in their interface implementations, typically through the use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores, which are described later in this section.</span></span> <span data-ttu-id="66c4d-112">Además, dado que el objeto no controla la duración de los subprocesos que acceden a él, no se puede almacenar ningún estado específico del subproceso en el objeto (en almacenamiento local para el subproceso).</span><span class="sxs-lookup"><span data-stu-id="66c4d-112">In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage).</span></span>

<span data-ttu-id="66c4d-113">A continuación se presentan algunas consideraciones importantes con respecto a la sincronización de apartamentos multiproceso:</span><span class="sxs-lookup"><span data-stu-id="66c4d-113">Following are some important considerations regarding synchronization for multithreaded apartments:</span></span>

-   <span data-ttu-id="66c4d-114">COM permite la sincronización de llamadas para apartamentos de un solo subproceso.</span><span class="sxs-lookup"><span data-stu-id="66c4d-114">COM provides call synchronization for single-threaded apartments only.</span></span>
-   <span data-ttu-id="66c4d-115">Los apartamentos multiproceso no reciben llamadas mientras realizan llamadas (en el mismo subproceso).</span><span class="sxs-lookup"><span data-stu-id="66c4d-115">Multithreaded apartments do not receive calls while making calls (on the same thread).</span></span>
-   <span data-ttu-id="66c4d-116">Los apartamentos multiproceso no pueden realizar llamadas sincronizadas por entrada.</span><span class="sxs-lookup"><span data-stu-id="66c4d-116">Multithreaded apartments cannot make input-synchronized calls.</span></span>
-   <span data-ttu-id="66c4d-117">Las llamadas asincrónicas se convierten en llamadas sincrónicas en apartamentos multiproceso.</span><span class="sxs-lookup"><span data-stu-id="66c4d-117">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span>
-   <span data-ttu-id="66c4d-118">No se llama al filtro de mensajes para ningún subproceso de un apartamento multiproceso.</span><span class="sxs-lookup"><span data-stu-id="66c4d-118">The message filter is not called for any thread in a multithreaded apartment.</span></span>

<span data-ttu-id="66c4d-119">Para inicializar un subproceso como de subproceso libre, llame a [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)y especifique el multiproceso de coinit \_ .</span><span class="sxs-lookup"><span data-stu-id="66c4d-119">To initialize a thread as free-threaded, call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specifying COINIT\_MULTITHREADED.</span></span> <span data-ttu-id="66c4d-120">Para obtener información sobre los subprocesos de servidor en proceso, vea [problemas de subprocesos de servidor en proceso](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="66c4d-120">For information on in-process server threading, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="66c4d-121">Varios clientes pueden llamar simultáneamente a, desde distintos subprocesos, un objeto que admite el subprocesamiento libre.</span><span class="sxs-lookup"><span data-stu-id="66c4d-121">Multiple clients can simultaneously call, from different threads, an object that supports free-threading.</span></span> <span data-ttu-id="66c4d-122">En los servidores fuera de proceso de subprocesos libres, COM, a través del subsistema RPC, crea un grupo de subprocesos en el proceso de servidor y una llamada de cliente (o varias llamadas de cliente) se puede entregar por cualquiera de estos subprocesos en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="66c4d-122">In free-threaded out-of-process servers, COM, through the RPC subsystem, creates a pool of threads in the server process and a client call (or multiple client calls) can be delivered by any of these threads at any time.</span></span> <span data-ttu-id="66c4d-123">Un servidor fuera de proceso también debe implementar la sincronización en su generador de clases.</span><span class="sxs-lookup"><span data-stu-id="66c4d-123">An out-of-process server must also implement synchronization in its class factory.</span></span> <span data-ttu-id="66c4d-124">Los objetos en proceso de subprocesamiento libre pueden recibir llamadas directas desde varios subprocesos del cliente.</span><span class="sxs-lookup"><span data-stu-id="66c4d-124">Free-threaded, in-process objects can receive direct calls from multiple threads of the client.</span></span>

<span data-ttu-id="66c4d-125">El cliente puede realizar trabajos COM en varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="66c4d-125">The client can do COM work in multiple threads.</span></span> <span data-ttu-id="66c4d-126">Todos los subprocesos pertenecen al mismo apartamento multiproceso.</span><span class="sxs-lookup"><span data-stu-id="66c4d-126">All threads belong to the same multithreaded apartment.</span></span> <span data-ttu-id="66c4d-127">Los punteros de interfaz se pasan directamente desde el subproceso al subproceso en un apartamento multiproceso, por lo que no se calculan las referencias de los punteros de interfaz entre sus subprocesos.</span><span class="sxs-lookup"><span data-stu-id="66c4d-127">Interface pointers are passed directly from thread to thread within a multithreaded apartment, so interface pointers are not marshaled between its threads.</span></span> <span data-ttu-id="66c4d-128">Los filtros de mensajes (implementaciones de [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) no se usan en apartamentos multiproceso.</span><span class="sxs-lookup"><span data-stu-id="66c4d-128">Message filters (implementations of [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) are not used in multithreaded apartments.</span></span> <span data-ttu-id="66c4d-129">El subproceso de cliente se suspenderá cuando realice una llamada COM a objetos fuera de apartamento y se reanudará cuando se devuelva la llamada.</span><span class="sxs-lookup"><span data-stu-id="66c4d-129">The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns.</span></span> <span data-ttu-id="66c4d-130">Las llamadas entre procesos todavía se controlan mediante RPC.</span><span class="sxs-lookup"><span data-stu-id="66c4d-130">Calls between processes are still handled by RPC.</span></span>

<span data-ttu-id="66c4d-131">Los subprocesos inicializados con el modelo de subprocesamiento libre deben implementar su propia sincronización.</span><span class="sxs-lookup"><span data-stu-id="66c4d-131">Threads initialized with the free-threaded model must implement their own synchronization.</span></span> <span data-ttu-id="66c4d-132">Como se mencionó anteriormente en esta sección, Windows habilita esta implementación a través de los primitivos de sincronización siguientes:</span><span class="sxs-lookup"><span data-stu-id="66c4d-132">As mentioned earlier in this section, Windows enables this implementation through the following synchronization primitives:</span></span>

-   <span data-ttu-id="66c4d-133">Los objetos de evento proporcionan una manera de señalizar uno o más subprocesos que se ha producido un evento.</span><span class="sxs-lookup"><span data-stu-id="66c4d-133">Event objects provide a way of signaling one or more threads that an event has occurred.</span></span> <span data-ttu-id="66c4d-134">Cualquier subproceso de un proceso puede crear un objeto de evento.</span><span class="sxs-lookup"><span data-stu-id="66c4d-134">Any thread within a process can create an event object.</span></span> <span data-ttu-id="66c4d-135">La función de creación de eventos, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa), devuelve un identificador para el evento.</span><span class="sxs-lookup"><span data-stu-id="66c4d-135">A handle to the event is returned by the event-creating function, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span></span> <span data-ttu-id="66c4d-136">Una vez creado un objeto de evento, los subprocesos con un identificador al objeto pueden esperar en él antes de continuar con la ejecución.</span><span class="sxs-lookup"><span data-stu-id="66c4d-136">Once an event object has been created, threads with a handle to the object can wait on it before continuing execution.</span></span>
-   <span data-ttu-id="66c4d-137">Las secciones críticas se usan para una sección de código que requiere acceso exclusivo a algún conjunto de datos compartidos antes de que se pueda ejecutar y que solo los subprocesos de un único proceso usan.</span><span class="sxs-lookup"><span data-stu-id="66c4d-137">Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed and that is used only by the threads within a single process.</span></span> <span data-ttu-id="66c4d-138">Una sección crítica es como un paso a través del cual se puede pasar un solo subproceso a la vez, lo que funciona de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="66c4d-138">A critical section is like a turnstile through which only one thread at a time may pass, working as follows:</span></span>
    -   <span data-ttu-id="66c4d-139">Para asegurarse de que no hay más de un subproceso a la vez que tiene acceso a los datos compartidos, el subproceso principal de un proceso asigna una estructura de datos de sección crítica global \_ e inicializa sus miembros.</span><span class="sxs-lookup"><span data-stu-id="66c4d-139">To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL\_SECTION data structure and initializes its members.</span></span> <span data-ttu-id="66c4d-140">Un subproceso que entra en una sección crítica llama a la función [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) y modifica los miembros de la estructura de datos.</span><span class="sxs-lookup"><span data-stu-id="66c4d-140">A thread entering a critical section calls the [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) function and modifies the data structure's members.</span></span>
    -   <span data-ttu-id="66c4d-141">Un subproceso que intenta entrar en una sección crítica llama a [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) , que comprueba si se ha modificado la estructura de datos de la \_ sección crítica.</span><span class="sxs-lookup"><span data-stu-id="66c4d-141">A thread attempting to enter a critical section calls [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) which checks to see whether the CRITICAL\_SECTION data structure has been modified.</span></span> <span data-ttu-id="66c4d-142">Si es así, hay otro subproceso en la sección crítica y el subproceso subsiguiente se pone en suspensión.</span><span class="sxs-lookup"><span data-stu-id="66c4d-142">If so, another thread is currently in the critical section and the subsequent thread is put to sleep.</span></span> <span data-ttu-id="66c4d-143">Un subproceso que sale de una sección crítica llama a [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), que restablece la estructura de datos.</span><span class="sxs-lookup"><span data-stu-id="66c4d-143">A thread leaving a critical section calls [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), which resets the data structure.</span></span> <span data-ttu-id="66c4d-144">Cuando un subproceso deja una sección crítica, el sistema reactiva uno de los subprocesos inactivos, que luego entra en la sección crítica.</span><span class="sxs-lookup"><span data-stu-id="66c4d-144">When a thread leaves a critical section, the system wakes one of the sleeping threads, which then enters the critical section.</span></span>
-   <span data-ttu-id="66c4d-145">Las exclusiones mutuas realizan la misma función que una sección crítica, salvo que la exclusión mutua es accesible para los subprocesos que se ejecutan en procesos diferentes.</span><span class="sxs-lookup"><span data-stu-id="66c4d-145">Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes.</span></span> <span data-ttu-id="66c4d-146">La propiedad de un objeto mutex es como tener el piso en un debate.</span><span class="sxs-lookup"><span data-stu-id="66c4d-146">Owning a mutex object is like having the floor in a debate.</span></span> <span data-ttu-id="66c4d-147">Un proceso crea un objeto de exclusión mutua mediante una llamada a la función [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) , que devuelve un identificador.</span><span class="sxs-lookup"><span data-stu-id="66c4d-147">A process creates a mutex object by calling the [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) function, which returns a handle.</span></span> <span data-ttu-id="66c4d-148">El primer subproceso que solicita un objeto mutex obtiene su propiedad.</span><span class="sxs-lookup"><span data-stu-id="66c4d-148">The first thread requesting a mutex object obtains ownership of it.</span></span> <span data-ttu-id="66c4d-149">Cuando el subproceso ha terminado con la exclusión mutua, la propiedad pasa a otros subprocesos en función de la primera vez que se atiende.</span><span class="sxs-lookup"><span data-stu-id="66c4d-149">When the thread has finished with the mutex, ownership passes to other threads on a first-come, first-served basis.</span></span>
-   <span data-ttu-id="66c4d-150">Los semáforos se utilizan para mantener un recuento de referencias en algún recurso disponible.</span><span class="sxs-lookup"><span data-stu-id="66c4d-150">Semaphores are used to maintain a reference count on some available resource.</span></span> <span data-ttu-id="66c4d-151">Un subproceso crea un semáforo para un recurso mediante una llamada a la función [**createsemaphore (**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) y pasando un puntero al recurso, un recuento inicial de recursos y el recuento máximo de recursos.</span><span class="sxs-lookup"><span data-stu-id="66c4d-151">A thread creates a semaphore for a resource by calling the [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) function and passing a pointer to the resource, an initial resource count, and the maximum resource count.</span></span> <span data-ttu-id="66c4d-152">Esta función devuelve un identificador.</span><span class="sxs-lookup"><span data-stu-id="66c4d-152">This function returns a handle.</span></span> <span data-ttu-id="66c4d-153">Un subproceso que solicita un recurso pasa su identificador de semáforo en una llamada a la función [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="66c4d-153">A thread requesting a resource passes its semaphore handle in a call to the [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function.</span></span> <span data-ttu-id="66c4d-154">El objeto Semaphore sondea el recurso para determinar si está disponible.</span><span class="sxs-lookup"><span data-stu-id="66c4d-154">The semaphore object polls the resource to determine whether it is available.</span></span> <span data-ttu-id="66c4d-155">Si es así, el semáforo disminuye el recuento de recursos y reactiva el subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="66c4d-155">If so, the semaphore decrements the resource count and wakes the waiting thread.</span></span> <span data-ttu-id="66c4d-156">Si el recuento es cero, el subproceso permanece suspendido hasta que otro subproceso libera un recurso, lo que hace que el semáforo aumente el número a uno.</span><span class="sxs-lookup"><span data-stu-id="66c4d-156">If the count is zero, the thread remains asleep until another thread releases a resource, causing the semaphore to increment the count to one.</span></span>

## <a name="related-topics"></a><span data-ttu-id="66c4d-157">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="66c4d-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="66c4d-158">Acceso a interfaces entre apartamentos</span><span class="sxs-lookup"><span data-stu-id="66c4d-158">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="66c4d-159">Elegir el modelo de subprocesos</span><span class="sxs-lookup"><span data-stu-id="66c4d-159">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="66c4d-160">Problemas de subprocesos de servidor en proceso</span><span class="sxs-lookup"><span data-stu-id="66c4d-160">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="66c4d-161">Procesos, subprocesos y apartamentos</span><span class="sxs-lookup"><span data-stu-id="66c4d-161">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="66c4d-162">Comunicación multiproceso y de un solo subproceso</span><span class="sxs-lookup"><span data-stu-id="66c4d-162">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="66c4d-163">Apartamentos de un solo subproceso</span><span class="sxs-lookup"><span data-stu-id="66c4d-163">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 