---
description: Una vez que tiene una aplicación de Microsoft Direct3D funcional y desea mejorar su rendimiento, por lo general se usa una herramienta de generación de perfiles estándar o alguna técnica de medición personalizada para medir el tiempo que se tarda en ejecutar una o varias llamadas de la interfaz de programación de aplicaciones (API). Si lo ha hecho pero está obteniendo resultados de control de tiempo que varían de una secuencia de representación a la siguiente, o si está creando supuestos que no contengan resultados reales del experimento, la siguiente información puede ayudarle a entender por qué.
ms.assetid: f969be42-d541-4e8d-aec4-eb9508bcc7cf
title: Generación precisa de perfiles de llamadas de la API de Direct3D (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cdb6d60fcc1b3ace4112dbf7028d91e2c9c8b345
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "103807705"
---
# <a name="accurately-profiling-direct3d-api-calls-direct3d-9"></a><span data-ttu-id="70209-104">Generación precisa de perfiles de llamadas de la API de Direct3D (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="70209-104">Accurately Profiling Direct3D API Calls (Direct3D 9)</span></span>

-   [<span data-ttu-id="70209-105">La generación de perfiles de Direct3D con precisión es difícil</span><span class="sxs-lookup"><span data-stu-id="70209-105">Accurately Profiling Direct3D Is Difficult</span></span>](#accurately-profiling-direct3d-is-difficult)
-   [<span data-ttu-id="70209-106">Cómo generar perfiles de una secuencia de representación de Direct3D con precisión</span><span class="sxs-lookup"><span data-stu-id="70209-106">How to Accurately Profile a Direct3D Render Sequence</span></span>](#how-to-accurately-profile-a-direct3d-render-sequence)
-   [<span data-ttu-id="70209-107">Generar perfiles de cambios de estado de Direct3D</span><span class="sxs-lookup"><span data-stu-id="70209-107">Profiling Direct3D State Changes</span></span>](#profiling-direct3d-state-changes)
-   [<span data-ttu-id="70209-108">Resumen</span><span class="sxs-lookup"><span data-stu-id="70209-108">Summary</span></span>](#summary)
-   [<span data-ttu-id="70209-109">ICE</span><span class="sxs-lookup"><span data-stu-id="70209-109">Appendix</span></span>](#appendix)

<span data-ttu-id="70209-110">Una vez que tiene una aplicación de Microsoft Direct3D funcional y desea mejorar su rendimiento, por lo general se usa una herramienta de generación de perfiles estándar o alguna técnica de medición personalizada para medir el tiempo que se tarda en ejecutar una o varias llamadas de la interfaz de programación de aplicaciones (API).</span><span class="sxs-lookup"><span data-stu-id="70209-110">Once you have a functional Microsoft Direct3D application and you want to improve its performance, you generally use an off-the-shelf profiling tool or some custom measurement technique to measure the time it takes to execute one or more application programming interface (API) calls.</span></span> <span data-ttu-id="70209-111">Si lo ha hecho pero está obteniendo resultados de control de tiempo que varían de una secuencia de representación a la siguiente, o si está creando supuestos que no contengan resultados reales del experimento, la siguiente información puede ayudarle a entender por qué.</span><span class="sxs-lookup"><span data-stu-id="70209-111">If you have done this but are getting timing results that vary from one render sequence to the next, or you are making hypotheses that do not hold up to actual experiment results, the following information may help you to understand why.</span></span>

<span data-ttu-id="70209-112">La información que se proporciona aquí se basa en el supuesto de que tiene conocimientos y experiencia con lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="70209-112">The information provided here is based upon the assumption that you have knowledge of and experience with the following:</span></span>

-   <span data-ttu-id="70209-113">Programación con C/C++</span><span class="sxs-lookup"><span data-stu-id="70209-113">C/C++ programming</span></span>
-   <span data-ttu-id="70209-114">Programación de la API de Direct3D</span><span class="sxs-lookup"><span data-stu-id="70209-114">Direct3D API programming</span></span>
-   <span data-ttu-id="70209-115">Medición del tiempo de API</span><span class="sxs-lookup"><span data-stu-id="70209-115">Measuring API timing</span></span>
-   <span data-ttu-id="70209-116">La tarjeta de vídeo y su controlador de software</span><span class="sxs-lookup"><span data-stu-id="70209-116">The video card and its software driver</span></span>
-   <span data-ttu-id="70209-117">Resultados inexplicables posibles de la experiencia de generación de perfiles anterior</span><span class="sxs-lookup"><span data-stu-id="70209-117">Possible unexplainable results from previous profiling experience</span></span>

## <a name="accurately-profiling-direct3d-is-difficult"></a><span data-ttu-id="70209-118">La generación de perfiles de Direct3D con precisión es difícil</span><span class="sxs-lookup"><span data-stu-id="70209-118">Accurately Profiling Direct3D Is Difficult</span></span>

<span data-ttu-id="70209-119">Un generador de perfiles informa sobre la cantidad de tiempo empleado en cada llamada API.</span><span class="sxs-lookup"><span data-stu-id="70209-119">A profiler reports on the amount of time spent in each API call.</span></span> <span data-ttu-id="70209-120">Esto se hace para mejorar el rendimiento mediante la búsqueda y la optimización de las zonas activas.</span><span class="sxs-lookup"><span data-stu-id="70209-120">This is done to improve performance by finding and tuning away hot spots.</span></span> <span data-ttu-id="70209-121">Hay diferentes tipos de perfiles y técnicas de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-121">There are different kinds of profilers and profiling techniques.</span></span>

-   <span data-ttu-id="70209-122">Un generador de perfiles de muestreo se encuentra inactivo gran parte del tiempo, reactivando a intervalos específicos para muestrear (o registrar) las funciones que se están ejecutando.</span><span class="sxs-lookup"><span data-stu-id="70209-122">A sampling profiler sits idle much of the time, awakening at specific intervals to sample (or to record) the functions being executed.</span></span> <span data-ttu-id="70209-123">Devuelve el porcentaje de tiempo invertido en cada llamada.</span><span class="sxs-lookup"><span data-stu-id="70209-123">It returns the percentage of time spent in each call.</span></span> <span data-ttu-id="70209-124">Por lo general, un generador de perfiles de muestreo no es muy invasivo en la aplicación y tiene un impacto mínimo en la sobrecarga de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="70209-124">Generally, a sampling profiler is not very invasive to the application and has minimal impact on the overhead for the application.</span></span>
-   <span data-ttu-id="70209-125">Un generador de perfiles de instrumentación mide el tiempo real necesario para que se devuelva una llamada.</span><span class="sxs-lookup"><span data-stu-id="70209-125">An instrumenting profiler measures the actual time it takes for a call to return.</span></span> <span data-ttu-id="70209-126">Requiere la compilación de delimitadores de inicio y detención en una aplicación.</span><span class="sxs-lookup"><span data-stu-id="70209-126">It requires compiling start and stop delimiters into an application.</span></span> <span data-ttu-id="70209-127">Un generador de perfiles de instrumentación es comparativamente más invasivo en una aplicación que un generador de perfiles de muestreo.</span><span class="sxs-lookup"><span data-stu-id="70209-127">An instrumenting profiler is comparatively more invasive to an application than a sampling profiler.</span></span>
-   <span data-ttu-id="70209-128">También es posible usar una técnica de generación de perfiles personalizada con un temporizador de alto rendimiento.</span><span class="sxs-lookup"><span data-stu-id="70209-128">It is also possible to use a custom profiling technique with a high-performance timer.</span></span> <span data-ttu-id="70209-129">Esto produce resultados muy parecidos a un generador de perfiles de instrumentación.</span><span class="sxs-lookup"><span data-stu-id="70209-129">This produces results very much like an instrumenting profiler.</span></span>

<span data-ttu-id="70209-130">El tipo de generador de perfiles o la técnica de generación de perfiles que se usa es solo parte del desafío de generar medidas precisas.</span><span class="sxs-lookup"><span data-stu-id="70209-130">The type of profiler or profiling technique used is only part of the challenge of generating accurate measurements.</span></span>

<span data-ttu-id="70209-131">La generación de perfiles proporciona respuestas que le ayudan a mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="70209-131">Profiling gives you answers that help you budget performance.</span></span> <span data-ttu-id="70209-132">Por ejemplo, supongamos que sabe que una llamada API realiza un promedio de 1000 ciclos de reloj para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="70209-132">For instance, suppose you know that an API call averages one thousand clock cycles to execute.</span></span> <span data-ttu-id="70209-133">Puede afirmar algunas conclusiones sobre el rendimiento, como las siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-133">You can assert some conclusions about performance such as the following:</span></span>

-   <span data-ttu-id="70209-134">Una CPU de 2 GHz (que pasa el 50 por ciento de su representación de tiempo) se limita a llamar a esta API 1 millón veces por segundo.</span><span class="sxs-lookup"><span data-stu-id="70209-134">A 2 GHz CPU (which spends 50 percent of its time rendering) is limited to calling this API 1 million times a second.</span></span>
-   <span data-ttu-id="70209-135">Para lograr 30 fotogramas por segundo, no se puede llamar a esta API más de 33.000 veces por fotograma.</span><span class="sxs-lookup"><span data-stu-id="70209-135">To achieve 30 frames per second, you cannot call this API more than 33,000 times per frame.</span></span>
-   <span data-ttu-id="70209-136">Solo puede representar 3.3 K objetos por fotograma (suponiendo 10 de estas llamadas de API para la secuencia de representación de cada objeto).</span><span class="sxs-lookup"><span data-stu-id="70209-136">You can only render 3.3K objects per frame (assuming 10 of these API calls for each object's render sequence).</span></span>

<span data-ttu-id="70209-137">En otras palabras, si tuviera tiempo suficiente por cada llamada API, podría responder a una pregunta de presupuesto como el número de primitivas que se pueden representar de forma interactiva.</span><span class="sxs-lookup"><span data-stu-id="70209-137">In other words, if you had sufficient time per API call, you could answer a budgeting question such as the number of primitives that can be rendered interactively.</span></span> <span data-ttu-id="70209-138">Sin embargo, los números sin procesar devueltos por un generador de perfiles de instrumentación no responderán con precisión a las preguntas de presupuesto.</span><span class="sxs-lookup"><span data-stu-id="70209-138">But the raw numbers returned by an instrumenting profiler will not accurately answer the budgeting questions.</span></span> <span data-ttu-id="70209-139">Esto se debe a que la canalización de gráficos tiene problemas de diseño complejos, como el número de componentes que deben realizarse, el número de procesadores que controlan cómo fluye el trabajo entre los componentes y las estrategias de optimización implementadas en tiempo de ejecución y en un controlador que están diseñados para mejorar la eficacia de la canalización.</span><span class="sxs-lookup"><span data-stu-id="70209-139">This is because the graphics pipeline has complex design issues such as the number of components that need to do work, the number of processors that control how the work flows between components, and optimization strategies implemented in the runtime and in a driver that are designed to make the pipeline more efficient.</span></span>

### <a name="each-api-call-goes-through-several-components"></a><span data-ttu-id="70209-140">Cada llamada API atraviesa varios componentes</span><span class="sxs-lookup"><span data-stu-id="70209-140">Each API Call Goes through Several Components</span></span>

<span data-ttu-id="70209-141">Varios componentes procesan cada llamada desde la aplicación a la tarjeta de vídeo.</span><span class="sxs-lookup"><span data-stu-id="70209-141">Each call is processed by several components on its way from the application to the video card.</span></span> <span data-ttu-id="70209-142">Por ejemplo, considere la siguiente secuencia de representación que contiene dos llamadas para dibujar un solo triángulo:</span><span class="sxs-lookup"><span data-stu-id="70209-142">For instance, consider the following render sequence containing two calls for drawing a single triangle:</span></span>


```
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
```



<span data-ttu-id="70209-143">En el siguiente diagrama conceptual se muestran los distintos componentes a través de los que deben pasar las llamadas.</span><span class="sxs-lookup"><span data-stu-id="70209-143">The following conceptual diagram shows the different components through which the calls must pass.</span></span>

![diagrama de componentes gráficos a los que pasan las llamadas API](images/microbenchmarkinstructionflow2.png)

<span data-ttu-id="70209-145">La aplicación invoca Direct3D que controla la escena, controla las interacciones del usuario y determina cómo se realiza la representación.</span><span class="sxs-lookup"><span data-stu-id="70209-145">The application invokes Direct3D which controls the scene, handles user interactions, and determines how rendering is done.</span></span> <span data-ttu-id="70209-146">Todo este trabajo se especifica en la secuencia de representación, que se envía al tiempo de ejecución mediante llamadas a la API de Direct3D.</span><span class="sxs-lookup"><span data-stu-id="70209-146">All of this work is specified in the render sequence, which is sent to the runtime using Direct3D API calls.</span></span> <span data-ttu-id="70209-147">La secuencia de representación es prácticamente independiente del hardware (es decir, las llamadas a la API son independientes del hardware, pero una aplicación tiene conocimiento de las características que admite una tarjeta de vídeo).</span><span class="sxs-lookup"><span data-stu-id="70209-147">The render sequence is virtually hardware independent (that is, the API calls are hardware independent but an application has knowledge of what features a video card supports).</span></span>

<span data-ttu-id="70209-148">El tiempo de ejecución convierte estas llamadas en un formato independiente del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="70209-148">The runtime converts these calls into a device-independent format.</span></span> <span data-ttu-id="70209-149">El tiempo de ejecución controla toda la comunicación entre la aplicación y el controlador, de modo que una aplicación se ejecutará en más de un elemento de hardware compatible (dependiendo de las características requeridas).</span><span class="sxs-lookup"><span data-stu-id="70209-149">The runtime handles all the communication between the application and the driver, so that an application will run on more than one compatible piece of hardware (depending on the features required).</span></span> <span data-ttu-id="70209-150">Al medir una llamada de función, un generador de perfiles de instrumentación mide el tiempo invertido en una función, así como el tiempo que la función devuelve.</span><span class="sxs-lookup"><span data-stu-id="70209-150">When measuring a function call, an instrumenting profiler measures the time it spent in a function as well as the time for the function to return.</span></span> <span data-ttu-id="70209-151">Una limitación de un generador de perfiles de instrumentación es que es posible que no incluya el tiempo necesario para que un controlador envíe el trabajo resultante a la tarjeta de vídeo ni el tiempo para que la tarjeta de vídeo procese el trabajo.</span><span class="sxs-lookup"><span data-stu-id="70209-151">One limitation of an instrumenting profiler is that it may not include the time it takes a driver to send the resulting work to the video card nor the time for the video card to process the work.</span></span> <span data-ttu-id="70209-152">En otras palabras, un generador de perfiles de instrumentación fuera del estante no puede atribuir todo el trabajo asociado a cada llamada de función.</span><span class="sxs-lookup"><span data-stu-id="70209-152">In other words, an off-the-shelf instrumenting profiler fails to attribute all of the work associated with each function call.</span></span>

<span data-ttu-id="70209-153">El controlador de software usa conocimiento específico del hardware sobre la tarjeta de vídeo para convertir los comandos independientes del dispositivo en una secuencia de comandos de tarjeta de vídeo.</span><span class="sxs-lookup"><span data-stu-id="70209-153">The software driver uses hardware specific knowledge about the video card to convert the device-independent commands into a sequence of video card commands.</span></span> <span data-ttu-id="70209-154">Los controladores también pueden optimizar la secuencia de comandos que se envían a la tarjeta de vídeo, de modo que la representación en la tarjeta de vídeo se realiza de forma eficaz.</span><span class="sxs-lookup"><span data-stu-id="70209-154">Drivers may also optimize the sequence of commands that are sent to the video card, so that rendering on the video card is done efficiently.</span></span> <span data-ttu-id="70209-155">Estas optimizaciones pueden provocar problemas de generación de perfiles porque la cantidad de trabajo realizada no es lo que parece ser (es posible que tenga que conocer las optimizaciones que deben tener en cuenta).</span><span class="sxs-lookup"><span data-stu-id="70209-155">These optimizations can cause profiling problems because the amount of work done is not what it appears to be (you may need to understand the optimizations to account for them).</span></span> <span data-ttu-id="70209-156">Normalmente, el controlador devuelve el control al tiempo de ejecución antes de que la tarjeta de vídeo haya terminado de procesar todos los comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-156">The driver typically returns control to the runtime before the video card has finished processing all the commands.</span></span>

<span data-ttu-id="70209-157">La tarjeta de vídeo realiza la mayoría de las representaciones mediante la combinación de datos de los búferes de vértices y de índices, las texturas, la información de estado de representación y los comandos de gráficos.</span><span class="sxs-lookup"><span data-stu-id="70209-157">The video card performs the majority of the rendering by combining data from the vertex and index buffers, textures, render state information, and the graphics commands.</span></span> <span data-ttu-id="70209-158">Cuando finaliza la representación de la tarjeta de vídeo, se completa el trabajo creado a partir de la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-158">When the video card finishes rendering, the work created from the render sequence is complete.</span></span>

<span data-ttu-id="70209-159">Cada componente (el tiempo de ejecución, el controlador y la tarjeta de vídeo) debe procesar cada llamada de la API de Direct3D para representar cualquier cosa.</span><span class="sxs-lookup"><span data-stu-id="70209-159">Each Direct3D API call must be processed by each component (the runtime, the driver, and the video card) to render anything.</span></span>

### <a name="there-is-more-than-one-processor-controlling-the-components"></a><span data-ttu-id="70209-160">Hay más de un procesador que controla los componentes</span><span class="sxs-lookup"><span data-stu-id="70209-160">There Is More than One Processor Controlling the Components</span></span>

<span data-ttu-id="70209-161">La relación entre estos componentes es aún más compleja, ya que la aplicación, el tiempo de ejecución y el controlador se controlan mediante un procesador y la tarjeta de vídeo se controla mediante un procesador independiente.</span><span class="sxs-lookup"><span data-stu-id="70209-161">The relationship between these components is even more complex, because the application, runtime, and the driver are controlled by one processor and the video card is controlled by a separate processor.</span></span> <span data-ttu-id="70209-162">En el diagrama siguiente se muestran dos tipos de procesadores: una unidad de procesamiento central (CPU) y una unidad de procesamiento de gráficos (GPU).</span><span class="sxs-lookup"><span data-stu-id="70209-162">The following diagram shows two kinds of processors: a central processing unit (CPU) and a graphics processing unit (GPU).</span></span>

![diagrama de una CPU y una GPU y sus componentes](images/microbenchmarkprocessors.png)

<span data-ttu-id="70209-164">Los sistemas de PC tienen al menos una CPU y una GPU, pero pueden tener más de uno o ambos.</span><span class="sxs-lookup"><span data-stu-id="70209-164">PC systems have at least one CPU and one GPU, but can have more than one of either or both.</span></span> <span data-ttu-id="70209-165">Las CPU se encuentran en la placa base y las GPU se encuentran en la placa base o en la tarjeta de vídeo.</span><span class="sxs-lookup"><span data-stu-id="70209-165">The CPUs are located on the motherboard, and the GPUs are located either on the motherboard or on the video card.</span></span> <span data-ttu-id="70209-166">La velocidad de la CPU viene determinada por un chip de reloj de la placa base y la velocidad de la GPU viene determinada por un chip de reloj independiente.</span><span class="sxs-lookup"><span data-stu-id="70209-166">The speed of the CPU is determined by a clock chip on the motherboard, and the speed of the GPU is determined by a separate clock chip.</span></span> <span data-ttu-id="70209-167">El reloj de la CPU controla la velocidad del trabajo realizado por la aplicación, el tiempo de ejecución y el controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-167">The CPU clock controls the speed of the work done by the application, the runtime, and the driver.</span></span> <span data-ttu-id="70209-168">La aplicación envía trabajo a la GPU a través del tiempo de ejecución y del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-168">The application sends work to the GPU via the runtime and the driver.</span></span>

<span data-ttu-id="70209-169">La CPU y la GPU generalmente se ejecutan a velocidades diferentes, independientes entre sí.</span><span class="sxs-lookup"><span data-stu-id="70209-169">The CPU and the GPU generally run at different speeds, independent of one another.</span></span> <span data-ttu-id="70209-170">La GPU puede responder al trabajo en cuanto el trabajo esté disponible (suponiendo que la GPU haya terminado de procesar el trabajo anterior).</span><span class="sxs-lookup"><span data-stu-id="70209-170">The GPU may respond to the work as soon as the work is available (assuming the GPU has finished processing previous work).</span></span> <span data-ttu-id="70209-171">El trabajo de la GPU se realiza en paralelo con el trabajo de CPU resaltado por la línea curva de la ilustración anterior.</span><span class="sxs-lookup"><span data-stu-id="70209-171">The GPU work is done in parallel with the CPU work as highlighted by the curved line in the figure above.</span></span> <span data-ttu-id="70209-172">Generalmente, un generador de perfiles mide el rendimiento de la CPU, no de la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-172">A profiler generally measures the performance of the CPU, not the GPU.</span></span> <span data-ttu-id="70209-173">Esto hace que la generación de perfiles sea desafiante, ya que las medidas realizadas por un generador de perfiles de instrumentación incluyen el tiempo de CPU, pero pueden no incluir la hora de la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-173">This makes profiling challenging, because the measurements made by an instrumenting profiler include the CPU time but may not include the GPU time.</span></span>

<span data-ttu-id="70209-174">El propósito de la GPU es descargar el procesamiento de la CPU a un procesador diseñado específicamente para el trabajo de gráficos.</span><span class="sxs-lookup"><span data-stu-id="70209-174">The purpose of the GPU is to off-load processing from the CPU to a processor specifically designed for graphics work.</span></span> <span data-ttu-id="70209-175">En las tarjetas de vídeo modernas, la GPU reemplaza gran parte del trabajo de transformación y de iluminación de la canalización de la CPU a la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-175">On modern video cards, the GPU replaces much of the transform and lighting work in the pipeline from the CPU to the GPU.</span></span> <span data-ttu-id="70209-176">Esto reduce en gran medida la carga de trabajo de la CPU, lo que deja más ciclos de CPU disponibles para otro procesamiento.</span><span class="sxs-lookup"><span data-stu-id="70209-176">This greatly reduces the CPU workload, leaving more CPU cycles available for other processing.</span></span> <span data-ttu-id="70209-177">Para optimizar una aplicación gráfica para un rendimiento máximo, debe medir el rendimiento de la CPU y la GPU, y equilibrar el trabajo entre los dos tipos de procesadores.</span><span class="sxs-lookup"><span data-stu-id="70209-177">To tune a graphical application for peak performance, you need to measure the performance of both the CPU and the GPU, and balance the work between the two types of processors.</span></span>

<span data-ttu-id="70209-178">En este documento no se tratan los temas relacionados con la medición del rendimiento de la GPU o el equilibrio del trabajo entre la CPU y la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-178">This document does not cover topics related to measuring the performance of the GPU or balancing the work between the CPU and the GPU.</span></span> <span data-ttu-id="70209-179">Si desea comprender mejor el rendimiento de una GPU (o una tarjeta de vídeo determinada), visite el sitio web del proveedor para buscar más información sobre el rendimiento de la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-179">If you want to better understand the performance of a GPU (or a particular video card), visit the vendor's web site to look for more information about GPU performance.</span></span> <span data-ttu-id="70209-180">En su lugar, este documento se centra en el trabajo realizado por el tiempo de ejecución y el controlador reduciendo el trabajo de la GPU a una cantidad insignificante.</span><span class="sxs-lookup"><span data-stu-id="70209-180">Instead, this document focuses on the work done by the runtime and the driver by reducing the GPU work to a negligible amount.</span></span> <span data-ttu-id="70209-181">En parte, esto se basa en la experiencia con la que las aplicaciones que experimentan problemas de rendimiento suelen estar limitadas por la CPU.</span><span class="sxs-lookup"><span data-stu-id="70209-181">This is, in part, based on experience that applications experiencing performance problems are generally CPU-limited.</span></span>

### <a name="runtime-and-driver-optimizations-can-mask-api-measurements"></a><span data-ttu-id="70209-182">Las optimizaciones en tiempo de ejecución y controladores pueden enmascarar las medidas de API</span><span class="sxs-lookup"><span data-stu-id="70209-182">Runtime and Driver Optimizations Can Mask API Measurements</span></span>

<span data-ttu-id="70209-183">El motor en tiempo de ejecución tiene una optimización de rendimiento integrada que puede sobrecargar la medición de una llamada individual.</span><span class="sxs-lookup"><span data-stu-id="70209-183">The runtime has a performance optimization built into it that can overwhelm the measurement of an individual call.</span></span> <span data-ttu-id="70209-184">Este es un escenario de ejemplo que muestra este problema.</span><span class="sxs-lookup"><span data-stu-id="70209-184">Here's an example scenario that demonstrates this problem.</span></span> <span data-ttu-id="70209-185">Considere la siguiente secuencia de representación:</span><span class="sxs-lookup"><span data-stu-id="70209-185">Consider the following render sequence:</span></span>


```
  BeginScene();
    ...
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    ...
  EndScene();
  Present();
```



<span data-ttu-id="70209-186">Ejemplo 1: secuencia de representación simple</span><span class="sxs-lookup"><span data-stu-id="70209-186">Example 1: Simple Render Sequence</span></span>

<span data-ttu-id="70209-187">Si se examinan los resultados de las dos llamadas en la secuencia de representación, un generador de perfiles de instrumentación podría devolver resultados similares a los siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-187">Looking at the results for the two calls in the render sequence, an instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture       : 100
Number of cycles for DrawPrimitive    : 950,500
```



<span data-ttu-id="70209-188">El generador de perfiles devuelve el número de ciclos de CPU necesarios para procesar el trabajo asociado a cada llamada (Recuerde que la GPU no se incluye en estos números porque la GPU todavía no ha empezado a trabajar en estos comandos).</span><span class="sxs-lookup"><span data-stu-id="70209-188">The profiler returns the number of CPU cycles required to process the work associated with each call (remember that the GPU isn't included in these numbers because the GPU hasn't started working on these commands yet).</span></span> <span data-ttu-id="70209-189">Dado que [**IDirect3DDevice9::D rawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) requirieron casi un millón de ciclos para procesar, podría concluir que no es muy eficaz.</span><span class="sxs-lookup"><span data-stu-id="70209-189">Because [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) required almost a million cycles to process, you could conclude that it is not very efficient.</span></span> <span data-ttu-id="70209-190">Sin embargo, pronto verá por qué esta conclusión es incorrecta y cómo puede generar resultados que se pueden usar para el presupuesto.</span><span class="sxs-lookup"><span data-stu-id="70209-190">However, you'll soon see why this conclusion is incorrect and how you can generate results that can be used for budgeting.</span></span>

### <a name="measuring-state-changes-requires-careful-render-sequences"></a><span data-ttu-id="70209-191">La medición de los cambios de estado requiere secuencias de representación cuidadosas</span><span class="sxs-lookup"><span data-stu-id="70209-191">Measuring State Changes Requires Careful Render Sequences</span></span>

<span data-ttu-id="70209-192">Todas las llamadas que no sean [**IDirect3DDevice9::D rawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)o [**Clear**](/windows/desktop/api) (como [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api)y [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) producen un cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-192">All calls other than [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), or [**Clear**](/windows/desktop/api) (such as [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api), and [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) produce a state change.</span></span> <span data-ttu-id="70209-193">Cada cambio de Estado establece el estado de la canalización que controla cómo se realizará la representación.</span><span class="sxs-lookup"><span data-stu-id="70209-193">Each state change sets pipeline state that controls how rendering will be done.</span></span>

<span data-ttu-id="70209-194">Las optimizaciones en tiempo de ejecución y/o el controlador están diseñadas para acelerar la representación reduciendo la cantidad de trabajo necesario.</span><span class="sxs-lookup"><span data-stu-id="70209-194">Optimizations in the runtime and/or the driver are designed to speed up rendering by reducing the amount of work required.</span></span> <span data-ttu-id="70209-195">A continuación se muestran un par de optimizaciones de cambio de estado que pueden contaminar los promedios de perfil:</span><span class="sxs-lookup"><span data-stu-id="70209-195">The following are a couple of state change optimizations that may pollute profile averages:</span></span>

-   <span data-ttu-id="70209-196">Un controlador (o el Runtime) puede guardar un cambio de estado como estado local.</span><span class="sxs-lookup"><span data-stu-id="70209-196">A driver (or the runtime) could save a state change as a local state.</span></span> <span data-ttu-id="70209-197">Dado que el controlador podría funcionar en un algoritmo "diferido" (pospuesto el trabajo hasta que sea absolutamente necesario), el trabajo asociado a algunos cambios de estado podría retrasarse.</span><span class="sxs-lookup"><span data-stu-id="70209-197">Because the driver could operate in a "lazy" algorithm (postponing work until it is absolutely necessary), work associated with some state changes could get delayed.</span></span>
-   <span data-ttu-id="70209-198">El tiempo de ejecución (o un controlador) puede quitar los cambios de estado mediante la optimización.</span><span class="sxs-lookup"><span data-stu-id="70209-198">The runtime (or a driver) may remove state changes by optimizing.</span></span> <span data-ttu-id="70209-199">Un ejemplo de esto podría ser quitar un cambio de estado redundante que deshabilita la iluminación porque la iluminación se ha deshabilitado previamente.</span><span class="sxs-lookup"><span data-stu-id="70209-199">An example of this might be to remove a redundant state change that disables lighting because lighting has previously been disabled.</span></span>

<span data-ttu-id="70209-200">No hay ninguna manera infalible de examinar una secuencia de representación y concluir qué cambios de estado establecerán un bit sucio y diferirá el trabajo, o simplemente se quitarán por optimización.</span><span class="sxs-lookup"><span data-stu-id="70209-200">There is no foolproof way to look at a render sequence and conclude which state changes will set a dirty bit and defer work, or will simply be removed by optimization.</span></span> <span data-ttu-id="70209-201">Aunque pueda identificar los cambios de estado optimizados en el entorno de ejecución o el controlador de hoy, es probable que se actualice el entorno en tiempo de ejecución o el controlador de mañana.</span><span class="sxs-lookup"><span data-stu-id="70209-201">Even if you could identify optimized state changes in today's runtime or driver, tomorrow's runtime or driver is likely to be updated.</span></span> <span data-ttu-id="70209-202">Tampoco sabe fácilmente cuál era el estado anterior, por lo que es difícil identificar los cambios de estado redundantes.</span><span class="sxs-lookup"><span data-stu-id="70209-202">You also don't readily know what the previous state was so it is difficult to identify redundant state changes.</span></span> <span data-ttu-id="70209-203">La única manera de comprobar el costo de un cambio de estado es medir la secuencia de representación que incluye los cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-203">The only way to verify the cost of a state change is to measure the render sequence that includes the state changes.</span></span>

<span data-ttu-id="70209-204">Como puede ver, las complicaciones ocasionadas por tener varios procesadores, los comandos que se procesan en más de un componente y las optimizaciones integradas en los componentes dificultan la predicción de la generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-204">As you can see, the complications caused by having multiple processors, commands being processed by more than one component, and optimizations built into the components make profiling difficult to predict.</span></span> <span data-ttu-id="70209-205">En la sección siguiente, se abordará cada uno de estos desafíos de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-205">In the next section, each of these profiling challenges will be addressed.</span></span> <span data-ttu-id="70209-206">Se mostrarán las secuencias de representación de Direct3D de ejemplo, con las técnicas de medición que lo acompañan.</span><span class="sxs-lookup"><span data-stu-id="70209-206">Sample Direct3D render sequences will be shown, with the accompanying measurement techniques.</span></span> <span data-ttu-id="70209-207">Con este conocimiento, podrá generar mediciones precisas y repetibles en llamadas individuales.</span><span class="sxs-lookup"><span data-stu-id="70209-207">With this knowledge, you will be able to generate accurate, repeatable measurements on individual calls.</span></span>

## <a name="how-to-accurately-profile-a-direct3d-render-sequence"></a><span data-ttu-id="70209-208">Cómo generar perfiles de una secuencia de representación de Direct3D con precisión</span><span class="sxs-lookup"><span data-stu-id="70209-208">How to Accurately Profile a Direct3D Render Sequence</span></span>

<span data-ttu-id="70209-209">Ahora que se han resaltado algunos de los desafíos de generación de perfiles, en esta sección se muestran técnicas que le ayudarán a generar medidas de perfil que se pueden usar para el presupuesto.</span><span class="sxs-lookup"><span data-stu-id="70209-209">Now that some of the profiling challenges have been highlighted, this section will show you techniques that will help you generate profile measurements that can be used for budgeting.</span></span> <span data-ttu-id="70209-210">Es posible realizar mediciones de generación de perfiles precisas y repetibles si entiende la relación entre los componentes controlados por la CPU y cómo evitar las optimizaciones de rendimiento implementadas por el tiempo de ejecución y el controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-210">Accurate, repeatable profiling measurements are possible if you understand the relationship between the components controlled by the CPU, and how to avoid performance optimizations implemented by the runtime and the driver.</span></span>

<span data-ttu-id="70209-211">Para empezar, debe poder medir con precisión el tiempo de ejecución de una única llamada API.</span><span class="sxs-lookup"><span data-stu-id="70209-211">To begin, you need to be able to accurately measure the execution time of a single API call.</span></span>

### <a name="pick-an-accurate-measurement-tool-like-queryperformancecounter"></a><span data-ttu-id="70209-212">Elija una herramienta de medición precisa como QueryPerformanceCounter</span><span class="sxs-lookup"><span data-stu-id="70209-212">Pick an Accurate Measurement Tool Like QueryPerformanceCounter</span></span>

<span data-ttu-id="70209-213">El sistema operativo Microsoft Windows incluye un temporizador de alta resolución que se puede usar para medir los tiempos transcurridos de alta resolución.</span><span class="sxs-lookup"><span data-stu-id="70209-213">The Microsoft Windows operating system includes a high-resolution timer that can be used to measure high-resolution elapsed times.</span></span> <span data-ttu-id="70209-214">El valor actual de un temporizador de este tipo se puede devolver mediante [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span><span class="sxs-lookup"><span data-stu-id="70209-214">The current value of one such timer can be returned using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span></span> <span data-ttu-id="70209-215">Después de invocar **QueryPerformanceCounter** para devolver los valores de inicio y detención, la diferencia entre los dos valores se puede convertir al tiempo real transcurrido (en segundos) mediante **QueryPerformanceCounter**.</span><span class="sxs-lookup"><span data-stu-id="70209-215">After invoking **QueryPerformanceCounter** to return start and stop values, the difference between the two values can be converted to the actual elapsed time (in seconds) using **QueryPerformanceCounter**.</span></span>

<span data-ttu-id="70209-216">Las ventajas de usar [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) son que está disponible en Windows y es fácil de usar.</span><span class="sxs-lookup"><span data-stu-id="70209-216">The advantages of using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) are that it is available in Windows and it is easy to use.</span></span> <span data-ttu-id="70209-217">Simplemente incluya las llamadas con una llamada a **QueryPerformanceCounter** y guarde los valores de inicio y detención.</span><span class="sxs-lookup"><span data-stu-id="70209-217">Simply surround the calls with a **QueryPerformanceCounter** call and save the start and stop values.</span></span> <span data-ttu-id="70209-218">Por lo tanto, en este documento se muestra cómo usar **QueryPerformanceCounter** para generar perfiles de tiempos de ejecución, de forma similar a como lo medió un generador de perfiles de instrumentación.</span><span class="sxs-lookup"><span data-stu-id="70209-218">Therefore, this paper will demonstrate how to use **QueryPerformanceCounter** to profile execution times, similar to the way an instrumenting profiler would measure it.</span></span> <span data-ttu-id="70209-219">Este es un ejemplo que muestra cómo insertar **QueryPerformanceCounter** en el código fuente:</span><span class="sxs-lookup"><span data-stu-id="70209-219">Here's an example that shows how to embed **QueryPerformanceCounter** in your source code:</span></span>


```
  BeginScene();
    ...
    // Start profiling
    LARGE_INTEGER start, stop, freq;
    QueryPerformanceCounter(&start);

    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1); 

    QueryPerformanceCounter(&stop);
    stop.QuadPart -= start.QuadPart;
    QueryPerformanceFrequency(&freq);
    // Stop profiling
    ...
  EndScene();
  Present();
```



<span data-ttu-id="70209-220">Ejemplo 2: implementación de generación de perfiles personalizada con QPC</span><span class="sxs-lookup"><span data-stu-id="70209-220">Example 2: Custom Profiling Implementation with QPC</span></span>

<span data-ttu-id="70209-221">iniciar y detener son dos enteros grandes que contendrán los valores de inicio y detención devueltos por el temporizador de alto rendimiento.</span><span class="sxs-lookup"><span data-stu-id="70209-221">start and stop are two large integers that will hold the start and stop values returned by the high-performance timer.</span></span> <span data-ttu-id="70209-222">Observe que se llama a QueryPerformanceCounter (&Start) justo antes de que se llame a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) y queryperformancecounter (&STOP) justo después de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="70209-222">Notice that QueryPerformanceCounter(&start) is called just before [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and QueryPerformanceCounter(&stop) is called just after [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="70209-223">Después de obtener el valor de detención, se llama a QueryPerformanceFrequency para devolver frec, que es la frecuencia del temporizador de alta resolución.</span><span class="sxs-lookup"><span data-stu-id="70209-223">After getting the stop value, QueryPerformanceFrequency is called to return freq, which is the frequency of the high-resolution timer.</span></span> <span data-ttu-id="70209-224">En este ejemplo hipotético, supongamos que obtiene los siguientes resultados para Start, STOP y frec:</span><span class="sxs-lookup"><span data-stu-id="70209-224">In this hypothetical example, suppose you get the following results for start, stop, and freq:</span></span>



| <span data-ttu-id="70209-225">Variable local</span><span class="sxs-lookup"><span data-stu-id="70209-225">Local Variable</span></span> | <span data-ttu-id="70209-226">Número de TICs</span><span class="sxs-lookup"><span data-stu-id="70209-226">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="70209-227">start</span><span class="sxs-lookup"><span data-stu-id="70209-227">start</span></span>          | <span data-ttu-id="70209-228">1792998845094</span><span class="sxs-lookup"><span data-stu-id="70209-228">1792998845094</span></span>   |
| <span data-ttu-id="70209-229">stop</span><span class="sxs-lookup"><span data-stu-id="70209-229">stop</span></span>           | <span data-ttu-id="70209-230">1792998845102</span><span class="sxs-lookup"><span data-stu-id="70209-230">1792998845102</span></span>   |
| <span data-ttu-id="70209-231">Freq</span><span class="sxs-lookup"><span data-stu-id="70209-231">freq</span></span>           | <span data-ttu-id="70209-232">3579545</span><span class="sxs-lookup"><span data-stu-id="70209-232">3579545</span></span>         |



 

<span data-ttu-id="70209-233">Puede convertir estos valores en el número de ciclos que se tarda en ejecutar las llamadas a la API de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="70209-233">You could convert these values to the number of cycles it takes to execute the API calls like this:</span></span>


```
# ticks = (stop - start) = 1792998845102 - 1792998845094 = 8 ticks

# cycles = CPU speed * number of ticks / QPF
# 4568   = 2 GHz      * 8              / 3,579,545
```



<span data-ttu-id="70209-234">En otras palabras, se tarda aproximadamente 4568 ciclos de reloj en procesar [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) y [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) en este equipo de 2 GHz.</span><span class="sxs-lookup"><span data-stu-id="70209-234">In other words, it takes about 4568 clock cycles to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) on this 2 GHz machine.</span></span> <span data-ttu-id="70209-235">Puede convertir estos valores en el tiempo real que se tardó en ejecutar todas las llamadas de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="70209-235">You could convert these values to the actual time it took to execute all the calls like this:</span></span>


```
(stop - start)/ freq = elapsed time
8 ticks / 3,579,545 = 2.2E-6 seconds or between 2 and 3 microseconds.
```



<span data-ttu-id="70209-236">El uso de QueryPerformanceCounter requiere que se agreguen las medidas de inicio y detención a la secuencia de representación y se use QueryPerformanceFrequency para convertir la diferencia (número de TICs) en el número de ciclos de CPU o en el tiempo real.</span><span class="sxs-lookup"><span data-stu-id="70209-236">Using QueryPerformanceCounter requires that you add start and stop measurements to your render sequence and use QueryPerformanceFrequency to convert the difference (number of ticks) to the number of CPU cycles or to actual time.</span></span> <span data-ttu-id="70209-237">La identificación de la técnica de medición es un buen punto de partida para desarrollar una implementación de generación de perfiles personalizada.</span><span class="sxs-lookup"><span data-stu-id="70209-237">Identifying the measurement technique is a good start for developing a custom profiling implementation.</span></span> <span data-ttu-id="70209-238">Sin embargo, antes de empezar a crear mediciones y comenzar a realizarlas, debe saber cómo tratar con la tarjeta de vídeo.</span><span class="sxs-lookup"><span data-stu-id="70209-238">But before you jump in and start making measurements, you need to know how to deal with the video card.</span></span>

### <a name="focus-on-cpu-measurements"></a><span data-ttu-id="70209-239">Centrarse en las medidas de la CPU</span><span class="sxs-lookup"><span data-stu-id="70209-239">Focus on CPU Measurements</span></span>

<span data-ttu-id="70209-240">Como se indicó anteriormente, la CPU y la GPU funcionan en paralelo para procesar el trabajo generado por las llamadas API.</span><span class="sxs-lookup"><span data-stu-id="70209-240">As stated earlier, the CPU and the GPU work in parallel to process the work generated by the API calls.</span></span> <span data-ttu-id="70209-241">Una aplicación real requiere la generación de perfiles de ambos tipos de procesadores para averiguar si la aplicación está limitada por CPU o por GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-241">A real world application requires profiling both types of processors to find out if your application is CPU-limited or GPU-limited.</span></span> <span data-ttu-id="70209-242">Dado que el rendimiento de la GPU es específico del proveedor, sería muy difícil generar resultados en este documento que cubran la variedad de tarjetas de vídeo disponibles.</span><span class="sxs-lookup"><span data-stu-id="70209-242">Since GPU performance is vendor specific, it would be very challenging to produce results in this paper that cover the variety of video cards available.</span></span>

<span data-ttu-id="70209-243">En su lugar, este documento solo se centrará en la generación de perfiles del trabajo realizado por la CPU mediante una técnica personalizada para medir el tiempo de ejecución y el trabajo del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-243">Instead, this paper will focus only on profiling the work performed by the CPU by using a custom technique for measuring the runtime and driver work.</span></span> <span data-ttu-id="70209-244">El trabajo de la GPU se reducirá a una cantidad insignificante, de modo que los resultados de la CPU sean más visibles.</span><span class="sxs-lookup"><span data-stu-id="70209-244">The GPU work will be reduced to an insignificant amount, so that CPU results are more visible.</span></span> <span data-ttu-id="70209-245">Uno de los beneficios de este enfoque es que esta técnica produce resultados en el apéndice que debería poder correlacionar con las medidas.</span><span class="sxs-lookup"><span data-stu-id="70209-245">One benefit of this approach is that this technique yields results in the Appendix that you should be able to correlate with your measurements.</span></span> <span data-ttu-id="70209-246">Para reducir el trabajo requerido por la tarjeta de vídeo a un nivel insignificante, simplemente reduzca el trabajo de representación hasta el menor importe posible.</span><span class="sxs-lookup"><span data-stu-id="70209-246">To reduce the work required by the video card to an insignificant level, simply reduce the rendering work to the least amount possible.</span></span> <span data-ttu-id="70209-247">Esto puede realizarse mediante la limitación de las llamadas a Draw para representar un solo triángulo y se puede restringir aún más para que cada triángulo solo contenga un píxel.</span><span class="sxs-lookup"><span data-stu-id="70209-247">This can be accomplished by limiting draw calls to render a single triangle, and can be further constrained so that each triangle only contains one pixel.</span></span>

<span data-ttu-id="70209-248">La unidad de medida usada en este documento para medir el trabajo de CPU será el número de ciclos de reloj de la CPU en lugar de la hora real.</span><span class="sxs-lookup"><span data-stu-id="70209-248">The unit of measure used in this paper for measuring CPU work will be the number of CPU clock cycles rather than actual time.</span></span> <span data-ttu-id="70209-249">Los ciclos de reloj de la CPU tienen la ventaja de que es más portátil (para aplicaciones limitadas por CPU) que el tiempo real transcurrido entre equipos con diferentes velocidades de CPU.</span><span class="sxs-lookup"><span data-stu-id="70209-249">CPU clock cycles has the advantage that it is more portable (for CPU-limited applications) than actual elapsed time across machines with different CPU speeds.</span></span> <span data-ttu-id="70209-250">Esto se puede convertir fácilmente a la hora real si se desea.</span><span class="sxs-lookup"><span data-stu-id="70209-250">This can easily be converted to actual time if desired.</span></span>

<span data-ttu-id="70209-251">En este documento no se tratan los temas relacionados con el equilibrio de la carga de trabajo entre la CPU y la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-251">This document does not cover topics related to balancing the work load between the CPU and the GPU.</span></span> <span data-ttu-id="70209-252">Recuerde que el objetivo de este documento es no medir el rendimiento general de una aplicación, pero para mostrarle cómo medir con precisión el tiempo que tarda el motor en tiempo de ejecución y el controlador en procesar las llamadas API.</span><span class="sxs-lookup"><span data-stu-id="70209-252">Remember, the goal of this paper is not to measure the overall performance of an application, but to show you how to accurately measure the time it takes the runtime and the driver to process API calls.</span></span> <span data-ttu-id="70209-253">Con estas medidas precisas, puede llevar a cabo la tarea de presupuestar la CPU para comprender ciertos escenarios de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="70209-253">With these accurate measurements, you can take on the task of budgeting the CPU to understand certain performance scenarios.</span></span>

### <a name="controlling-runtime-and-driver-optimizations"></a><span data-ttu-id="70209-254">Controlar el tiempo de ejecución y las optimizaciones del controlador</span><span class="sxs-lookup"><span data-stu-id="70209-254">Controlling Runtime and Driver Optimizations</span></span>

<span data-ttu-id="70209-255">Con una técnica de medición identificada y una estrategia para reducir el trabajo de GPU, el siguiente paso es conocer las optimizaciones del motor en tiempo de ejecución y los controladores que se obtienen al generar perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-255">With a measurement technique identified, and a strategy for reducing GPU work, the next step is to understand the runtime and driver optimizations that get in the way when you are profiling.</span></span>

<span data-ttu-id="70209-256">El trabajo de CPU se puede dividir en tres depósitos: el trabajo de la aplicación, el trabajo en tiempo de ejecución y el controlador funcionan.</span><span class="sxs-lookup"><span data-stu-id="70209-256">The CPU work can be divided into three buckets: the application work, the runtime work, and the driver work.</span></span> <span data-ttu-id="70209-257">Omita el trabajo de la aplicación, ya que está bajo el control del programador.</span><span class="sxs-lookup"><span data-stu-id="70209-257">Ignore the application work since this is under programmer control.</span></span> <span data-ttu-id="70209-258">Desde el punto de vista de la aplicación, el tiempo de ejecución y el controlador son como casillas negras, ya que la aplicación no tiene control sobre lo que se implementa en ellos.</span><span class="sxs-lookup"><span data-stu-id="70209-258">From the application's standpoint, the runtime and the driver are like black boxes, as the application has no control over what is implemented in them.</span></span> <span data-ttu-id="70209-259">La clave es comprender las técnicas de optimización que se pueden implementar en el tiempo de ejecución y el controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-259">The key is to understand the optimization techniques that may be implemented in the runtime and the driver.</span></span> <span data-ttu-id="70209-260">Si no entiende estas optimizaciones, es muy fácil pasar a la conclusión equivocada sobre la cantidad de trabajo que está haciendo la CPU en función de las medidas de perfil.</span><span class="sxs-lookup"><span data-stu-id="70209-260">If you don't understand these optimizations, it is very easy to jump to the wrong conclusion about the amount of work the CPU is doing based on the profile measurements.</span></span> <span data-ttu-id="70209-261">En concreto, hay dos temas relacionados con algo denominado búfer de comandos y lo que puede hacer para ofuscar la generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-261">In particular, there are two topics related to something called the command buffer and what it can do to obfuscate profiling.</span></span> <span data-ttu-id="70209-262">Estos temas son:</span><span class="sxs-lookup"><span data-stu-id="70209-262">These topics are:</span></span>

-   <span data-ttu-id="70209-263">Optimización en tiempo de ejecución con el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-263">Runtime optimization with the Command Buffer.</span></span> <span data-ttu-id="70209-264">El búfer de comandos es una optimización en tiempo de ejecución que reduce el impacto de una transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-264">The command buffer is a runtime optimization that reduces the impact of a mode transition.</span></span> <span data-ttu-id="70209-265">Para controlar la temporización de la transición de modo, vea [controlar el búfer de comandos](#controlling-the-command-buffer).</span><span class="sxs-lookup"><span data-stu-id="70209-265">To control the timing of the mode transition, see [Controlling the Command Buffer](#controlling-the-command-buffer).</span></span>
-   <span data-ttu-id="70209-266">Niega los efectos de control de tiempo del búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-266">Negating the timing effects of the Command Buffer.</span></span> <span data-ttu-id="70209-267">El tiempo transcurrido de una transición de modo puede tener un gran impacto en las medidas de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-267">The elapsed time of a mode transition can have a big impact on profiling measurements.</span></span> <span data-ttu-id="70209-268">La estrategia para esto es [hacer que la secuencia de representación sea grande en comparación con la transición de modo](#make-the-render-sequence-large-compared-to-the-mode-transition).</span><span class="sxs-lookup"><span data-stu-id="70209-268">The strategy for this is to [Make the Render Sequence Large Compared to the Mode Transition](#make-the-render-sequence-large-compared-to-the-mode-transition).</span></span>

### <a name="controlling-the-command-buffer"></a><span data-ttu-id="70209-269">Controlar el búfer de comandos</span><span class="sxs-lookup"><span data-stu-id="70209-269">Controlling the Command Buffer</span></span>

<span data-ttu-id="70209-270">Cuando una aplicación realiza una llamada API, el tiempo de ejecución convierte la llamada de API en un formato independiente del dispositivo (que llamaremos un comando) y lo almacena en el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-270">When an application makes an API call, the runtime converts the API call to a device-independent format (which we will call a command), and stores it in the command buffer.</span></span> <span data-ttu-id="70209-271">El búfer de comandos se agrega al diagrama siguiente.</span><span class="sxs-lookup"><span data-stu-id="70209-271">The command buffer is added to the following diagram.</span></span>

![diagrama de componentes de CPU, incluido un búfer de comandos](images/microbenchmarkcommandbuffer2.png)

<span data-ttu-id="70209-273">Cada vez que la aplicación realiza otra llamada API, el Runtime repite esta secuencia y agrega otro comando al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-273">Each time the application makes another API call, the runtime repeats this sequence and adds another command to the command buffer.</span></span> <span data-ttu-id="70209-274">En algún momento, el tiempo de ejecución vacía el búfer (enviando los comandos al controlador).</span><span class="sxs-lookup"><span data-stu-id="70209-274">At some point, the runtime empties the buffer (sending the commands to the driver).</span></span> <span data-ttu-id="70209-275">En Windows XP, si se vacía el búfer de comandos, se produce una transición de modo cuando el sistema operativo cambia del tiempo de ejecución (que se ejecuta en modo de usuario) al controlador (que se ejecuta en modo kernel), como se muestra en el diagrama siguiente.</span><span class="sxs-lookup"><span data-stu-id="70209-275">In Windows XP, emptying the command buffer causes a mode transition as the operating system switches from the runtime (running in user mode) to the driver (running in kernel mode), as shown in the following diagram.</span></span>

-   <span data-ttu-id="70209-276">modo de usuario: el modo de procesador sin privilegios que ejecuta el código de aplicación.</span><span class="sxs-lookup"><span data-stu-id="70209-276">user mode - The non-privileged processor mode that executes application code.</span></span> <span data-ttu-id="70209-277">Las aplicaciones de modo de usuario no pueden obtener acceso a los datos del sistema excepto a través de los servicios del sistema.</span><span class="sxs-lookup"><span data-stu-id="70209-277">User-mode applications cannot gain access to system data except through system services.</span></span>
-   <span data-ttu-id="70209-278">modo kernel: modo de procesador con privilegios en el que se ejecuta el código ejecutivo basado en Windows.</span><span class="sxs-lookup"><span data-stu-id="70209-278">kernel mode - The privileged processor mode in which Windows-based executive code runs.</span></span> <span data-ttu-id="70209-279">Un controlador o un subproceso que se ejecuta en modo kernel tiene acceso a toda la memoria del sistema, acceso directo al hardware y las instrucciones de CPU para realizar la e/s con el hardware.</span><span class="sxs-lookup"><span data-stu-id="70209-279">A driver or thread running in kernel mode has access to all system memory, direct access to hardware, and the CPU instructions to perform I/O with the hardware.</span></span>

![diagrama de transiciones entre el modo de usuario y el modo kernel](images/microbenchmarkcommandbuffer3.png)

<span data-ttu-id="70209-281">La transición se produce cada vez que la CPU cambia del modo de usuario al modo kernel (y viceversa) y el número de ciclos que requiere es grande en comparación con una llamada de API individual.</span><span class="sxs-lookup"><span data-stu-id="70209-281">The transition happens each time the CPU switches from user to kernel mode (and vice versa) and the number of cycles it requires is large compared to an individual API call.</span></span> <span data-ttu-id="70209-282">Si el tiempo de ejecución envía cada llamada de API al controlador cuando se invocó, cada llamada API incurrirá en el costo de una transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-282">If the runtime sent each API call to the driver when it was invoked, every API call would incur the cost of a mode transition.</span></span>

<span data-ttu-id="70209-283">En su lugar, el búfer de comandos es una optimización en tiempo de ejecución diseñada para reducir el costo efectivo de la transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-283">Instead, the command buffer is a runtime optimization designed to reduce the effective cost of the mode transition.</span></span> <span data-ttu-id="70209-284">El búfer de comandos pone en cola muchos comandos de controlador para preparar una transición de modo único.</span><span class="sxs-lookup"><span data-stu-id="70209-284">The command buffer queues many driver commands in preparation for a single mode transition.</span></span> <span data-ttu-id="70209-285">Cuando el tiempo de ejecución agrega un comando al búfer de comandos, el control se devuelve a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="70209-285">When the runtime adds a command to the command buffer, control is returned to the application.</span></span> <span data-ttu-id="70209-286">Un generador de perfiles no tiene ninguna manera de saber que los comandos del controlador probablemente aún no se han enviado al controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-286">A profiler has no way of knowing that the driver commands have probably not even been sent to the driver yet.</span></span> <span data-ttu-id="70209-287">Como resultado, los números devueltos por un generador de perfiles de instrumentación fuera del sistema son engañosos, ya que mide el trabajo en tiempo de ejecución, pero no el trabajo del controlador asociado.</span><span class="sxs-lookup"><span data-stu-id="70209-287">As a result, the numbers returned by an off-the-shelf instrumenting profiler are misleading since it measures the runtime work but not the associated driver work.</span></span>

### <a name="profile-results-without-a-mode-transition"></a><span data-ttu-id="70209-288">Generar perfiles de resultados sin una transición de modo</span><span class="sxs-lookup"><span data-stu-id="70209-288">Profile Results without a Mode Transition</span></span>

<span data-ttu-id="70209-289">Mediante el uso de la secuencia de representación del ejemplo 2, estas son algunas medidas de temporización típicas que ilustran la magnitud de una transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-289">Using the render sequence from example 2, here are some typical timing measurements that illustrate the magnitude of a mode transition.</span></span> <span data-ttu-id="70209-290">Suponiendo que las llamadas a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) y [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) no causan una transición de modo, un generador de perfiles de instrumentación fuera del estante podría devolver resultados similares a los siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-290">Assuming that [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls do not cause a mode transition, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
```



<span data-ttu-id="70209-291">Cada uno de estos números es la cantidad de tiempo que tarda el motor en tiempo de ejecución en agregar estas llamadas al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-291">Each of these numbers are the amount of time it takes for the runtime to add these calls to the command buffer.</span></span> <span data-ttu-id="70209-292">Puesto que no hay ninguna transición de modo, el controlador no ha realizado todavía ningún trabajo.</span><span class="sxs-lookup"><span data-stu-id="70209-292">Since there is no mode transition, the driver has not done any work yet.</span></span> <span data-ttu-id="70209-293">Los resultados del generador de perfiles son precisos, pero no miden todo el trabajo que la secuencia de representación hará que la CPU realice.</span><span class="sxs-lookup"><span data-stu-id="70209-293">The profiler results are accurate, but they do not measure all of the work that the render sequence will eventually cause the CPU to perform.</span></span>

### <a name="profile-results-with-a-mode-transition"></a><span data-ttu-id="70209-294">Generar perfiles de resultados con una transición de modo</span><span class="sxs-lookup"><span data-stu-id="70209-294">Profile Results with a Mode Transition</span></span>

<span data-ttu-id="70209-295">Ahora, observe lo que sucede en el mismo ejemplo cuando se produce una transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-295">Now, look at what happens for the same example when a mode transition occurs.</span></span> <span data-ttu-id="70209-296">Esta vez, supongamos que [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) y [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) causan una transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-296">This time, assume [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) cause a mode transition.</span></span> <span data-ttu-id="70209-297">Una vez más, un generador de perfiles de instrumentación fuera del estante podría devolver resultados similares a los siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-297">Once again, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 98 
Number of cycles for DrawPrimitive        : 946,900
```



<span data-ttu-id="70209-298">El tiempo medido para [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) es aproximadamente el mismo, sin embargo, el aumento drástico en la cantidad de tiempo empleado en [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) se debe a la transición del modo.</span><span class="sxs-lookup"><span data-stu-id="70209-298">The time measured for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about the same, however, the dramatic increase in the amount of time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is due to the mode transition.</span></span> <span data-ttu-id="70209-299">Esto es lo que sucede:</span><span class="sxs-lookup"><span data-stu-id="70209-299">Here's what is happening:</span></span>

1.  <span data-ttu-id="70209-300">Suponga que el búfer de comandos tiene espacio para un comando antes de que se inicie la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-300">Assume the command buffer has room for one command before our render sequence starts.</span></span>
2.  <span data-ttu-id="70209-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) se convierte en un formato independiente del dispositivo y se agrega al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is converted to a device-independent format and added to the command buffer.</span></span> <span data-ttu-id="70209-302">En este escenario, esta llamada rellena el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-302">In this scenario, this call fills the command buffer.</span></span>
3.  <span data-ttu-id="70209-303">El Runtime intenta agregar [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) al búfer de comandos, pero no puede, porque está lleno.</span><span class="sxs-lookup"><span data-stu-id="70209-303">The runtime tries to add [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to the command buffer but cannot, because it is full.</span></span> <span data-ttu-id="70209-304">En su lugar, el tiempo de ejecución vacía el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-304">Instead, the runtime empties the command buffer.</span></span> <span data-ttu-id="70209-305">Esto provoca la transición de modo kernel.</span><span class="sxs-lookup"><span data-stu-id="70209-305">This causes the kernel-mode transition.</span></span> <span data-ttu-id="70209-306">Supongamos que la transición tarda aproximadamente 5000 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-306">Assume the transition takes about 5000 cycles.</span></span> <span data-ttu-id="70209-307">Esta vez contribuye al tiempo dedicado a **DrawPrimitive**.</span><span class="sxs-lookup"><span data-stu-id="70209-307">This time contributes to time spent in **DrawPrimitive**.</span></span>
4.  <span data-ttu-id="70209-308">Después, el controlador procesa el trabajo asociado a todos los comandos que se vaciaron del búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-308">The driver then processes the work associated with all the commands that were emptied from the command buffer.</span></span> <span data-ttu-id="70209-309">Suponga que el tiempo del controlador para procesar los comandos que casi rellenó el búfer del comando es de aproximadamente 935.000 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-309">Assume that the driver time to process the commands that nearly filled the command buffer is about 935,000 cycles.</span></span> <span data-ttu-id="70209-310">Supongamos que el trabajo del controlador asociado a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) es aproximadamente 2750 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-310">Assume that the driver work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2750 cycles.</span></span> <span data-ttu-id="70209-311">Esta vez contribuye al tiempo dedicado a [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="70209-311">This time contributes to time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>
5.  <span data-ttu-id="70209-312">Cuando el controlador finaliza su trabajo, la transición de modo de usuario devuelve el control al tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="70209-312">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="70209-313">El búfer de comandos está ahora vacío.</span><span class="sxs-lookup"><span data-stu-id="70209-313">The command buffer is now empty.</span></span> <span data-ttu-id="70209-314">Supongamos que la transición tarda aproximadamente 5000 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-314">Assume the transition takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="70209-315">La secuencia de representación finaliza mediante la conversión de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) y su adición al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-315">The render sequence finishes by converting [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) and adding it to the command buffer.</span></span> <span data-ttu-id="70209-316">Suponga que esto tarda aproximadamente 900 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-316">Assume this takes about 900 cycles.</span></span> <span data-ttu-id="70209-317">Esta vez contribuye al tiempo dedicado a **DrawPrimitive**.</span><span class="sxs-lookup"><span data-stu-id="70209-317">This time contributes to time spent in **DrawPrimitive**.</span></span>

<span data-ttu-id="70209-318">Resumir los resultados, verá:</span><span class="sxs-lookup"><span data-stu-id="70209-318">Summarizing the results, you see:</span></span>


```
DrawPrimitive = kernel-transition + driver work    + user-transition + runtime work
DrawPrimitive = 5000              + 935,000 + 2750 + 5000            + 900
DrawPrimitive = 947,950  
```



<span data-ttu-id="70209-319">Al igual que la medida de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sin la transición de modo (ciclos 900), la medición de **DrawPrimitive** con la transición de modo (947.950 ciclos) es precisa pero no es útil en cuanto a la presupuestación del trabajo de CPU.</span><span class="sxs-lookup"><span data-stu-id="70209-319">Just like the measurement for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) without the mode transition (900 cycles), the measurement for **DrawPrimitive** with the mode transition (947,950 cycles) is accurate but useless in terms of budgeting CPU work.</span></span> <span data-ttu-id="70209-320">El resultado contiene el trabajo correcto en tiempo de ejecución, el controlador funciona para [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), el controlador funciona para los comandos que precedieron **SetTexture** y las transiciones de modo dos.</span><span class="sxs-lookup"><span data-stu-id="70209-320">The result contains the correct runtime work, the driver work for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), the driver work for any commands that preceded **SetTexture**, and two mode transitions.</span></span> <span data-ttu-id="70209-321">Sin embargo, la medida no tiene el funcionamiento del controlador **DrawPrimitive** .</span><span class="sxs-lookup"><span data-stu-id="70209-321">However, the measurement is missing the **DrawPrimitive** driver work.</span></span>

<span data-ttu-id="70209-322">Una transición de modo podría producirse en respuesta a cualquier llamada.</span><span class="sxs-lookup"><span data-stu-id="70209-322">A mode transition could happen in response to any call.</span></span> <span data-ttu-id="70209-323">Depende de lo que se encontraba anteriormente en el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-323">It depends on what was previously in the command buffer.</span></span> <span data-ttu-id="70209-324">Debe controlar la transición del modo para comprender cuánto trabajo de CPU (tiempo de ejecución y controlador) está asociado a cada llamada.</span><span class="sxs-lookup"><span data-stu-id="70209-324">You need to control the mode transition to understand how much CPU work (runtime and driver) is associated with each call.</span></span> <span data-ttu-id="70209-325">Para ello, necesita un mecanismo para controlar el búfer de comandos y la temporización de la transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-325">To do that, you need a mechanism for controlling the command buffer and the timing of the mode transition.</span></span>

### <a name="the-query-mechanism"></a><span data-ttu-id="70209-326">Mecanismo de consulta</span><span class="sxs-lookup"><span data-stu-id="70209-326">The Query Mechanism</span></span>

<span data-ttu-id="70209-327">El mecanismo de consulta de Microsoft Direct3D 9 se diseñó para permitir que el tiempo de ejecución consultase el progreso de la GPU y devuelva ciertos datos de la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-327">The query mechanism in Microsoft Direct3D 9 was designed to allow the runtime to query the GPU for progress and return certain data from the GPU.</span></span> <span data-ttu-id="70209-328">Durante la generación de perfiles, si el trabajo de la GPU está minimizado para que tenga un impacto insignificante en el rendimiento, puede devolver el estado de la GPU para ayudar a medir el trabajo del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-328">While profiling, if the GPU work is minimized so that it has a negligible impact on performance, you can return status from the GPU to help measure the driver work.</span></span> <span data-ttu-id="70209-329">Después de todo, el trabajo del controlador se completa cuando la GPU ha detectado los comandos del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-329">After all, the driver work is complete when the GPU has seen the driver commands.</span></span> <span data-ttu-id="70209-330">Además, el mecanismo de consulta puede ser coaxial para controlar dos características de búfer de comandos importantes para la generación de perfiles: cuando el búfer de comandos se vacía y cuánto trabajo hay en el búfer.</span><span class="sxs-lookup"><span data-stu-id="70209-330">Additionally, the query mechanism can be coaxed into controlling two command buffer characteristics that are important to profiling: when the command buffer empties and how much work is in the buffer.</span></span>

<span data-ttu-id="70209-331">Esta es la misma secuencia de representación mediante el mecanismo de consulta:</span><span class="sxs-lookup"><span data-stu-id="70209-331">Here's the same render sequence using the query mechanism:</span></span>


```
// 1. Create an event query from the current device
IDirect3DQuery9* pEvent;
m_pD3DDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEvent);

// 2. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 3. Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

// 4. Start profiling
LARGE_INTEGER start, stop;
QueryPerformanceCounter(&start);

// 5. Invoke the API calls to be profiled.
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);

// 6. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 7. Force the driver to execute the commands from the command buffer.
// Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
    
// 8. End profiling
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="70209-332">Ejemplo 3: usar una consulta para controlar el búfer de comandos</span><span class="sxs-lookup"><span data-stu-id="70209-332">Example 3: Using a Query to Control the Command Buffer</span></span>

<span data-ttu-id="70209-333">A continuación se muestra una explicación más detallada de cada una de estas líneas de código:</span><span class="sxs-lookup"><span data-stu-id="70209-333">Here is a more detailed explanation of each of these lines of code:</span></span>

1.  <span data-ttu-id="70209-334">Cree una consulta de eventos mediante la creación de un objeto de consulta con el \_ evento D3DQUERYTYPE.</span><span class="sxs-lookup"><span data-stu-id="70209-334">Create an event query by creating a query object with D3DQUERYTYPE\_EVENT.</span></span>
2.  <span data-ttu-id="70209-335">Agregue un marcador de evento de consulta al búfer de comandos mediante una llamada a [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE \_ End**](d3dissue-end.md)).</span><span class="sxs-lookup"><span data-stu-id="70209-335">Add a query event marker to the command buffer by calling [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE\_END**](d3dissue-end.md)).</span></span> <span data-ttu-id="70209-336">Este marcador indica al controlador que realice un seguimiento cuando la GPU termine de ejecutar los comandos precedidos del marcador.</span><span class="sxs-lookup"><span data-stu-id="70209-336">This marker tells the driver to track when the GPU finishes executing whatever commands preceded the marker.</span></span>
3.  <span data-ttu-id="70209-337">La primera llamada vacía el búfer de comandos porque la llamada a [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) con el [**\_ vaciado D3DGETDATA**](d3dgetdata-flush.md) obliga a vaciar el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-337">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="70209-338">Cada llamada subsiguiente comprueba la GPU para ver cuándo finaliza el procesamiento de todo el trabajo de búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-338">Each subsequent call is checking the GPU to see when it finishes processing all the command-buffer work.</span></span> <span data-ttu-id="70209-339">Este bucle no devuelve S \_ correcto hasta que la GPU está inactiva.</span><span class="sxs-lookup"><span data-stu-id="70209-339">This loop does not return S\_OK until the GPU is idle.</span></span>
4.  <span data-ttu-id="70209-340">Muestra la hora de inicio.</span><span class="sxs-lookup"><span data-stu-id="70209-340">Sample the start time.</span></span>
5.  <span data-ttu-id="70209-341">Invocar las llamadas a la API que se van a perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-341">Invoke the API calls being profiled.</span></span>
6.  <span data-ttu-id="70209-342">Agregue un segundo marcador de evento de consulta al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-342">Add a second query event marker to the command buffer.</span></span> <span data-ttu-id="70209-343">Este marcador se usará para realizar el seguimiento de la finalización de las llamadas.</span><span class="sxs-lookup"><span data-stu-id="70209-343">This marker will be used to track the completion of the calls.</span></span>
7.  <span data-ttu-id="70209-344">La primera llamada vacía el búfer de comandos porque la llamada a [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) con el [**\_ vaciado D3DGETDATA**](d3dgetdata-flush.md) obliga a vaciar el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-344">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="70209-345">Cuando la GPU finaliza el procesamiento de todo el trabajo de búfer de comandos, **GetData** devuelve S \_ correcto y el bucle se cierra porque la GPU está inactiva.</span><span class="sxs-lookup"><span data-stu-id="70209-345">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
8.  <span data-ttu-id="70209-346">Muestra la hora de detención.</span><span class="sxs-lookup"><span data-stu-id="70209-346">Sample the stop time.</span></span>

<span data-ttu-id="70209-347">Estos son los resultados que se miden con QueryPerformanceCounter y QueryPerformanceFrequency:</span><span class="sxs-lookup"><span data-stu-id="70209-347">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="70209-348">Variable local</span><span class="sxs-lookup"><span data-stu-id="70209-348">Local Variable</span></span> | <span data-ttu-id="70209-349">Número de TICs</span><span class="sxs-lookup"><span data-stu-id="70209-349">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="70209-350">start</span><span class="sxs-lookup"><span data-stu-id="70209-350">start</span></span>          | <span data-ttu-id="70209-351">1792998845060</span><span class="sxs-lookup"><span data-stu-id="70209-351">1792998845060</span></span>   |
| <span data-ttu-id="70209-352">stop</span><span class="sxs-lookup"><span data-stu-id="70209-352">stop</span></span>           | <span data-ttu-id="70209-353">1792998845090</span><span class="sxs-lookup"><span data-stu-id="70209-353">1792998845090</span></span>   |
| <span data-ttu-id="70209-354">Freq</span><span class="sxs-lookup"><span data-stu-id="70209-354">freq</span></span>           | <span data-ttu-id="70209-355">3579545</span><span class="sxs-lookup"><span data-stu-id="70209-355">3579545</span></span>         |



 

<span data-ttu-id="70209-356">Convertir TICs en ciclos de nuevo (en un equipo de 2 GHz):</span><span class="sxs-lookup"><span data-stu-id="70209-356">Converting ticks to cycles once again (on a 2 GHz machine):</span></span>


```
# ticks  = (stop - start) = 1792998845090 - 1792998845060 = 30 ticks
# cycles = CPU speed * number of ticks / QPF
# 16,450 = 2 GHz      * 30             / 3,579,545
```



<span data-ttu-id="70209-357">Este es el desglose del número de ciclos por llamada:</span><span class="sxs-lookup"><span data-stu-id="70209-357">Here is the breakdown of the number of cycles per call:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
Number of cycles for Issue                : 200
Number of cycles for GetData              : 16,450
```



<span data-ttu-id="70209-358">El mecanismo de consulta nos ha permitido controlar el tiempo de ejecución y el trabajo de controlador que se está midiendo.</span><span class="sxs-lookup"><span data-stu-id="70209-358">The query mechanism has allowed us to control the runtime and the driver work that is being measured.</span></span> <span data-ttu-id="70209-359">Para comprender cada uno de estos números, esto es lo que sucede en respuesta a cada una de las llamadas API, junto con los tiempos estimados:</span><span class="sxs-lookup"><span data-stu-id="70209-359">To understand each of these numbers, here's what is happening in response to each of the API calls, along with the estimated timings:</span></span>

1.  <span data-ttu-id="70209-360">La primera llamada vacía el búfer de comandos mediante una llamada a [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) con el [**\_ vaciado de D3DGETDATA**](d3dgetdata-flush.md).</span><span class="sxs-lookup"><span data-stu-id="70209-360">The first call empties the command buffer by calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md).</span></span> <span data-ttu-id="70209-361">Cuando la GPU finaliza el procesamiento de todo el trabajo de búfer de comandos, **GetData** devuelve S \_ correcto y el bucle se cierra porque la GPU está inactiva.</span><span class="sxs-lookup"><span data-stu-id="70209-361">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
2.  <span data-ttu-id="70209-362">La secuencia de representación comienza por convertir [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) en un formato independiente del dispositivo y agregarlo al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-362">The render sequence starts by converting [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to a device-independent format and adding it to the command buffer.</span></span> <span data-ttu-id="70209-363">Suponga que esto tarda aproximadamente 100 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-363">Assume this takes about 100 cycles.</span></span>
3.  <span data-ttu-id="70209-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) se convierte y se agrega al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is converted and added to the command buffer.</span></span> <span data-ttu-id="70209-365">Suponga que esto tarda aproximadamente 900 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-365">Assume this takes about 900 cycles.</span></span>
4.  <span data-ttu-id="70209-366">[**Problema**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) agrega un marcador de consulta al búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-366">[**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) adds a query marker to the command buffer.</span></span> <span data-ttu-id="70209-367">Suponga que esto tarda aproximadamente 200 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-367">Assume this takes about 200 cycles.</span></span>
5.  <span data-ttu-id="70209-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) hace que el búfer de comandos se vacíe, lo que fuerza la transición del modo kernel.</span><span class="sxs-lookup"><span data-stu-id="70209-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) causes the command buffer to be emptied which forces the kernel-mode transition.</span></span> <span data-ttu-id="70209-369">Suponga que esto tarda aproximadamente 5000 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-369">Assume this takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="70209-370">A continuación, el controlador procesa el trabajo asociado a las cuatro llamadas.</span><span class="sxs-lookup"><span data-stu-id="70209-370">The driver then processes the work associated with all four calls.</span></span> <span data-ttu-id="70209-371">Supongamos que el tiempo del controlador para procesar [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) es aproximadamente 2964 ciclos, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) es de aproximadamente 3600 ciclos, el [**problema**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) es de aproximadamente 200 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-371">Assume that the driver time to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2964 cycles, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is about 3600 cycles, [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) is about 200 cycles.</span></span> <span data-ttu-id="70209-372">Por lo tanto, el tiempo total del controlador para los cuatro comandos es aproximadamente 6450 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-372">So the total driver time for all four commands is about 6450 cycles.</span></span>
    > [!Note]  
    > <span data-ttu-id="70209-373">El controlador también tarda un poco en ver cuál es el estado de la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-373">The driver also takes a little time to see what the status of the GPU is.</span></span> <span data-ttu-id="70209-374">Dado que el trabajo de la GPU es trivial, la GPU ya debe realizarse.</span><span class="sxs-lookup"><span data-stu-id="70209-374">Because the GPU work is trivial, the GPU should be done already.</span></span> <span data-ttu-id="70209-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) devolverá \_ los valores correctos en función de la probabilidad de que la GPU finalice.</span><span class="sxs-lookup"><span data-stu-id="70209-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) will return S\_OK based on the likelihood that the GPU is finished.</span></span>

     

7.  <span data-ttu-id="70209-376">Cuando el controlador finaliza su trabajo, la transición de modo de usuario devuelve el control al tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="70209-376">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="70209-377">El búfer de comandos está ahora vacío.</span><span class="sxs-lookup"><span data-stu-id="70209-377">The command buffer is now empty.</span></span> <span data-ttu-id="70209-378">Suponga que esto tarda aproximadamente 5000 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-378">Assume this takes about 5000 cycles.</span></span>

<span data-ttu-id="70209-379">Los números de [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) incluyen:</span><span class="sxs-lookup"><span data-stu-id="70209-379">The numbers for [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) include:</span></span>


```
GetData = kernel-transition + driver work + user-transition
GetData = 5000              + 6450        + 5000           
GetData = 16,450  

driver work = SetTexture + DrawPrimitive + Issue = 
driver work = 2964       + 3600          + 200   = 6450 cycles 
```



<span data-ttu-id="70209-380">El mecanismo de consulta utilizado en combinación con QueryPerformanceCounter mide todo el trabajo de la CPU.</span><span class="sxs-lookup"><span data-stu-id="70209-380">The query mechanism used in combination with QueryPerformanceCounter measures all of the CPU work.</span></span> <span data-ttu-id="70209-381">Esto se hace con una combinación de marcadores de consulta y comparaciones de estado de consulta.</span><span class="sxs-lookup"><span data-stu-id="70209-381">This is done with a combination of query markers, and query status comparisons.</span></span> <span data-ttu-id="70209-382">Los marcadores de consulta de inicio y detención agregados al búfer de comandos se utilizan para controlar la cantidad de trabajo que hay en el búfer.</span><span class="sxs-lookup"><span data-stu-id="70209-382">Start and stop query markers added to the command buffer are used to control how much work is in the buffer.</span></span> <span data-ttu-id="70209-383">Si espera hasta que se devuelve el código de retorno correcto, la medida de inicio se realiza justo antes de que se inicie una secuencia de representación limpia y la medida de detención se realiza justo después de que el controlador haya finalizado el trabajo asociado con el contenido del búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-383">By waiting until the right return code is returned, the start measurement is made just before a clean render sequence starts, and the stop measurement is made just after the driver has finished the work associated with the command buffer contents.</span></span> <span data-ttu-id="70209-384">Esto captura eficazmente el trabajo de CPU realizado por el motor en tiempo de ejecución, así como el controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-384">This effectively captures the CPU work done by the runtime as well as the driver.</span></span>

<span data-ttu-id="70209-385">Ahora que conoce el búfer de comandos y el efecto que puede tener en la generación de perfiles, debe saber que hay algunas otras condiciones que pueden hacer que el tiempo de ejecución vacíe el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-385">Now that you know about the command buffer and the effect it can have on profiling, you should know that there are a few other conditions that can cause the runtime to empty the command buffer.</span></span> <span data-ttu-id="70209-386">Debe verlos en las secuencias de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-386">You need to watch out for these in your render sequences.</span></span> <span data-ttu-id="70209-387">Algunas de estas condiciones son respuesta a las llamadas a la API, mientras que otras están en respuesta a los cambios de los recursos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="70209-387">Some of these conditions are in response to API calls, others are in response to resource changes in the runtime.</span></span> <span data-ttu-id="70209-388">Cualquiera de las siguientes condiciones producirá una transición de modo:</span><span class="sxs-lookup"><span data-stu-id="70209-388">Any of the following conditions will cause a mode transition:</span></span>

-   <span data-ttu-id="70209-389">Cuando se llama a uno de los métodos de bloqueo ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) en un búfer de vértices, un búfer de índice o una textura (bajo ciertas condiciones con ciertas marcas).</span><span class="sxs-lookup"><span data-stu-id="70209-389">When one of the lock methods ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) is called on a vertex buffer, index buffer, or texture (under certain conditions with certain flags).</span></span>
-   <span data-ttu-id="70209-390">Cuando se crea un dispositivo o un búfer de vértices, un búfer de índice o una textura.</span><span class="sxs-lookup"><span data-stu-id="70209-390">When a device or vertex buffer, index buffer, or texture is created.</span></span>
-   <span data-ttu-id="70209-391">Cuando la última versión destruye un dispositivo o un búfer de vértices, un búfer de índice o una textura.</span><span class="sxs-lookup"><span data-stu-id="70209-391">When a device or vertex buffer, index buffer, or texture is destroyed by the last release.</span></span>
-   <span data-ttu-id="70209-392">Cuando se llama a [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) .</span><span class="sxs-lookup"><span data-stu-id="70209-392">When [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) is called.</span></span>
-   <span data-ttu-id="70209-393">Cuando está [**presente**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) , se llama a.</span><span class="sxs-lookup"><span data-stu-id="70209-393">When [**Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) is called.</span></span>
-   <span data-ttu-id="70209-394">Cuando se llena el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="70209-394">When the command buffer fills up.</span></span>
-   <span data-ttu-id="70209-395">Cuando se llama a [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) con el \_ vaciado de D3DGETDATA.</span><span class="sxs-lookup"><span data-stu-id="70209-395">When [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) is called with D3DGETDATA\_FLUSH.</span></span>

<span data-ttu-id="70209-396">Tenga cuidado de ver estas condiciones en las secuencias de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-396">Be careful to watch for these conditions in your render sequences.</span></span> <span data-ttu-id="70209-397">Cada vez que se agrega una transición de modo, se agregarán 10.000 ciclos de trabajo de controlador a las medidas de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-397">Every time a mode transition is added, 10,000 cycles of driver work will be added to your profiling measurements.</span></span> <span data-ttu-id="70209-398">Además, el búfer de comandos no tiene un tamaño estático.</span><span class="sxs-lookup"><span data-stu-id="70209-398">In addition, the command buffer is not statically sized.</span></span> <span data-ttu-id="70209-399">El tiempo de ejecución puede cambiar el tamaño del búfer en respuesta a la cantidad de trabajo que está generando la aplicación.</span><span class="sxs-lookup"><span data-stu-id="70209-399">The runtime may change the buffer's size in response to the amount of work that is being generated by the application.</span></span> <span data-ttu-id="70209-400">Esta es otra optimización que depende de una secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-400">This is yet another optimization that is dependent on a render sequence.</span></span>

<span data-ttu-id="70209-401">Por tanto, tenga cuidado para controlar las transiciones de modo durante la generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-401">So be careful to control mode transitions during profiling.</span></span> <span data-ttu-id="70209-402">El mecanismo de consulta ofrece un método sólido para vaciar el búfer de comandos, de modo que pueda controlar la temporización de la transición de modo, así como la cantidad de trabajo que contiene el búfer.</span><span class="sxs-lookup"><span data-stu-id="70209-402">The query mechanism offers a robust method for emptying the command buffer so that you can control the timing of the mode transition as well as the amount of work the buffer contains.</span></span> <span data-ttu-id="70209-403">Sin embargo, incluso esta técnica se puede mejorar reduciendo el tiempo de transición de modo para que sea insignificante con respecto al resultado medido.</span><span class="sxs-lookup"><span data-stu-id="70209-403">However, even this technique can be improved by reducing the mode transition time to make it insignificant with respect to the measured result.</span></span>

### <a name="make-the-render-sequence-large-compared-to-the-mode-transition"></a><span data-ttu-id="70209-404">Hacer que la secuencia de representación sea grande en comparación con la transición de modo</span><span class="sxs-lookup"><span data-stu-id="70209-404">Make the Render Sequence Large Compared to the Mode Transition</span></span>

<span data-ttu-id="70209-405">En el ejemplo anterior, el modificador de modo kernel y el modificador de modo de usuario consumen aproximadamente 10.000 ciclos que no tienen nada que hacer con el tiempo de ejecución y el funcionamiento del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-405">In the previous example, the kernel-mode switch and the user-mode switch consume about 10,000 cycles that have nothing to do with runtime and driver work.</span></span> <span data-ttu-id="70209-406">Dado que la transición de modo se integra en el sistema operativo, no se puede reducir a cero.</span><span class="sxs-lookup"><span data-stu-id="70209-406">Since the mode transition is built into the operating system, it cannot be reduced to zero.</span></span> <span data-ttu-id="70209-407">Para hacer que la transición de modo sea insignificante, la secuencia de representación debe ajustarse para que el trabajo de controlador y tiempo de ejecución sea un orden de magnitud mayor que los modificadores de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-407">To make the mode transition insignificant, the render sequence needs to adjusted so that the driver and runtime work are an order of magnitude larger than the mode switches.</span></span> <span data-ttu-id="70209-408">Podría intentar realizar una resta para quitar las transiciones, pero amortizar el costo en un costo de secuencia de representación mucho mayor es más confiable.</span><span class="sxs-lookup"><span data-stu-id="70209-408">You could try to do a subtraction to remove the transitions, but amortizing the cost over a much larger render sequence cost is more reliable.</span></span>

<span data-ttu-id="70209-409">La estrategia para reducir la transición de modo hasta que se vuelve insignificante es agregar un bucle a la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-409">The strategy for reducing the mode transition until it becomes insignificant is to add a loop to the render sequence.</span></span> <span data-ttu-id="70209-410">Por ejemplo, echemos un vistazo a los resultados de generación de perfiles si se agrega un bucle que repetirá la secuencia de presentación 1500 veces:</span><span class="sxs-lookup"><span data-stu-id="70209-410">For example, let look at the profiling results if a loop is added that will repeat the render sequence 1500 times:</span></span>


```
// Initialize the array with two textures, same size, same format
IDirect3DTexture* texArray[2];

CreateQuery(D3DQUERYTYPE_EVENT, pEvent);
pEvent->Issue(D3DISSUE_END);
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

LARGE_INTEGER start, stop;
// Now start counting because the video card is ready
QueryPerformanceCounter(&start);

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  SetTexture(taxArray[i%2]);
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

pEvent->Issue(D3DISSUE_END);

while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="70209-411">Ejemplo 4: agregar un bucle a la secuencia de representación</span><span class="sxs-lookup"><span data-stu-id="70209-411">Example 4: Add a Loop to the Render Sequence</span></span>

<span data-ttu-id="70209-412">Estos son los resultados que se miden con QueryPerformanceCounter y QueryPerformanceFrequency:</span><span class="sxs-lookup"><span data-stu-id="70209-412">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="70209-413">Variable local</span><span class="sxs-lookup"><span data-stu-id="70209-413">Local Variable</span></span> | <span data-ttu-id="70209-414">Número de las marcas</span><span class="sxs-lookup"><span data-stu-id="70209-414">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="70209-415">start</span><span class="sxs-lookup"><span data-stu-id="70209-415">start</span></span>          | <span data-ttu-id="70209-416">1792998845000</span><span class="sxs-lookup"><span data-stu-id="70209-416">1792998845000</span></span>  |
| <span data-ttu-id="70209-417">stop</span><span class="sxs-lookup"><span data-stu-id="70209-417">stop</span></span>           | <span data-ttu-id="70209-418">1792998847084</span><span class="sxs-lookup"><span data-stu-id="70209-418">1792998847084</span></span>  |
| <span data-ttu-id="70209-419">Freq</span><span class="sxs-lookup"><span data-stu-id="70209-419">freq</span></span>           | <span data-ttu-id="70209-420">3579545</span><span class="sxs-lookup"><span data-stu-id="70209-420">3579545</span></span>        |



 

<span data-ttu-id="70209-421">El uso de QueryPerformanceCounter mide 2.840 TICs ahora.</span><span class="sxs-lookup"><span data-stu-id="70209-421">Using QueryPerformanceCounter measures 2,840 ticks now.</span></span> <span data-ttu-id="70209-422">La conversión de TICs en ciclos es la misma que ya se ha mostrado:</span><span class="sxs-lookup"><span data-stu-id="70209-422">Converting ticks to cycles is the same as we have already shown:</span></span>


```
# ticks  = (stop - start) = 1792998847084 - 1792998845000 = 2840 ticks
# cycles    = machine speed * number of ticks / QPF
# 6,900,000 = 2 GHz          * 2840           / 3,579,545
```



<span data-ttu-id="70209-423">En otras palabras, se tarda aproximadamente 6,9 millones ciclos en esta máquina de 2 GHz en procesar las llamadas 1500 en el bucle de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-423">In other words, it takes about 6.9 million cycles on this 2 GHz machine to process the 1500 calls in the render loop.</span></span> <span data-ttu-id="70209-424">De los ciclos 6,9 millones, la cantidad de tiempo en el modo de transición es aproximadamente de 10 000, por lo que ahora los resultados del perfil son casi totalmente medidas de trabajo asociadas a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) y [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="70209-424">Of the 6.9 million cycles, the amount of time in the mode transitions is approximately 10k, so now the profile results are almost entirely measuring work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>

<span data-ttu-id="70209-425">Observe que el ejemplo de código requiere una matriz de dos texturas.</span><span class="sxs-lookup"><span data-stu-id="70209-425">Notice that the code sample requires an array of two textures.</span></span> <span data-ttu-id="70209-426">Para evitar una optimización en tiempo de ejecución que quitaría [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) si establece el mismo puntero de textura cada vez que se llama, simplemente use una matriz de dos texturas.</span><span class="sxs-lookup"><span data-stu-id="70209-426">To avoid a runtime optimization that would remove [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) if it sets the same texture pointer every time it is called, simply use an array of two textures.</span></span> <span data-ttu-id="70209-427">De este modo, cada vez a través del bucle, cambia el puntero de textura y se realiza el trabajo completo asociado a **SetTexture** .</span><span class="sxs-lookup"><span data-stu-id="70209-427">That way, each time through the loop, the texture pointer changes, and the full work associated with **SetTexture** is performed.</span></span> <span data-ttu-id="70209-428">Asegúrese de que ambas texturas tengan el mismo tamaño y formato, de modo que ningún otro estado cambie cuando la textura sí lo sea.</span><span class="sxs-lookup"><span data-stu-id="70209-428">Be sure that both textures are the same size and format, so that no other state will change when the texture does.</span></span>

<span data-ttu-id="70209-429">Y ahora tiene una técnica para la generación de perfiles de Direct3D.</span><span class="sxs-lookup"><span data-stu-id="70209-429">And now you have a technique for profiling Direct3D.</span></span> <span data-ttu-id="70209-430">Se basa en el contador de alto rendimiento (QueryPerformanceCounter) para registrar el número de pasos que tarda la CPU en procesar el trabajo.</span><span class="sxs-lookup"><span data-stu-id="70209-430">It relies on the high performance counter (QueryPerformanceCounter) to record the number of ticks it takes the CPU to process work.</span></span> <span data-ttu-id="70209-431">El trabajo se controla cuidadosamente para ser el tiempo de ejecución y el trabajo del controlador asociados a las llamadas de API mediante el mecanismo de consulta.</span><span class="sxs-lookup"><span data-stu-id="70209-431">The work is carefully controlled to be the runtime and driver work associated with API calls using the query mechanism.</span></span> <span data-ttu-id="70209-432">Una consulta proporciona dos formas de control: primero para vaciar el búfer de comandos antes de que se inicie la secuencia de representación y, en segundo lugar, devolver cuando finalice el trabajo de la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-432">A query provides two means of control: first to empty the command buffer before the render sequence starts, and secondly to return when the GPU work is finished.</span></span>

<span data-ttu-id="70209-433">Hasta ahora, en este documento se ha mostrado cómo generar perfiles de una secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-433">So far, this paper has shown how to profile a render sequence.</span></span> <span data-ttu-id="70209-434">Cada secuencia de representación ha sido bastante simple, lo que contiene una única llamada a [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) y una llamada a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) .</span><span class="sxs-lookup"><span data-stu-id="70209-434">Each render sequence has been fairly simple, containing a single [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call and a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) call.</span></span> <span data-ttu-id="70209-435">Esto se hizo para centrarse en el búfer de comandos y el uso del mecanismo de consulta para controlarlo.</span><span class="sxs-lookup"><span data-stu-id="70209-435">This was done to focus on the command buffer and the use of the query mechanism to control it.</span></span> <span data-ttu-id="70209-436">A continuación se muestra un breve resumen de cómo generar perfiles de una secuencia de representación arbitraria:</span><span class="sxs-lookup"><span data-stu-id="70209-436">Here is a brief summary of how to profile an arbitrary render sequence:</span></span>

-   <span data-ttu-id="70209-437">Use un contador de alto rendimiento como QueryPerformanceCounter para medir el tiempo que se tarda en procesar cada llamada de API.</span><span class="sxs-lookup"><span data-stu-id="70209-437">Use a high performance counter like QueryPerformanceCounter to measure the time it takes to process each API call.</span></span> <span data-ttu-id="70209-438">Use QueryPerformanceFrequency y la tasa de reloj de la CPU para convertir esto en el número de ciclos de CPU por llamada API.</span><span class="sxs-lookup"><span data-stu-id="70209-438">Use QueryPerformanceFrequency and the CPU clock rate to convert this to the number of CPU cycles per API call.</span></span>
-   <span data-ttu-id="70209-439">Minimice la cantidad de trabajo de GPU mediante la representación de listas de triángulo, donde cada triángulo contiene un píxel.</span><span class="sxs-lookup"><span data-stu-id="70209-439">Minimize the amount of GPU work by rendering triangle lists, where each triangle contains one pixel.</span></span>
-   <span data-ttu-id="70209-440">Use el mecanismo de consulta para vaciar el búfer de comandos antes de la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-440">Use the query mechanism to empty the command buffer before the render sequence.</span></span> <span data-ttu-id="70209-441">Esto garantiza que la generación de perfiles capturará la cantidad correcta de tiempo de ejecución y de controlador asociado a la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-441">This guarantees that profiling will capturing the correct amount of runtime and driver work associated with the render sequence.</span></span>
-   <span data-ttu-id="70209-442">Controlar la cantidad de trabajo que se agrega al búfer de comandos con marcadores de eventos de consulta.</span><span class="sxs-lookup"><span data-stu-id="70209-442">Control the amount of work added to the command buffer with query event markers.</span></span> <span data-ttu-id="70209-443">Esta misma consulta detecta cuándo finaliza la GPU su trabajo.</span><span class="sxs-lookup"><span data-stu-id="70209-443">This same query detects when the GPU finishes its work.</span></span> <span data-ttu-id="70209-444">Dado que el trabajo de la GPU es trivial, es prácticamente equivalente a medir Cuándo se completa el trabajo del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-444">Since the GPU work is trivial, this is virtually equivalent to measuring when the driver work is completed.</span></span>

<span data-ttu-id="70209-445">Todas estas técnicas se usan para generar perfiles de cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-445">All of these techniques are used to profile state changes.</span></span> <span data-ttu-id="70209-446">Suponiendo que ha leído y comprendido cómo controlar el búfer de comandos y ha completado correctamente las medidas de línea base en [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), está listo para agregar cambios de estado a las secuencias de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-446">Assuming that you have read and understood how to control the command buffer, and have successfully completed baseline measurements on [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), you are ready to add state changes to your render sequences.</span></span> <span data-ttu-id="70209-447">Hay algunos desafíos de generación de perfiles adicionales al agregar cambios de estado a una secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-447">There are a few additional profiling challenges when adding state changes to a render sequence.</span></span> <span data-ttu-id="70209-448">Si desea agregar cambios de estado a las secuencias de representación, asegúrese de continuar en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="70209-448">If you intend to add state changes to your render sequences, be sure to continue into the next section.</span></span>

## <a name="profiling-direct3d-state-changes"></a><span data-ttu-id="70209-449">Generar perfiles de cambios de estado de Direct3D</span><span class="sxs-lookup"><span data-stu-id="70209-449">Profiling Direct3D State Changes</span></span>

<span data-ttu-id="70209-450">Direct3D usa muchos Estados de representación para controlar casi todos los aspectos de la canalización.</span><span class="sxs-lookup"><span data-stu-id="70209-450">Direct3D uses many render states to control almost every aspect of the pipeline.</span></span> <span data-ttu-id="70209-451">Las API que causan cambios de estado incluyen cualquier función o método que no sea las \* llamadas primitivas Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-451">The APIs that cause state changes include any function or method other than the Draw\*Primitive calls.</span></span>

<span data-ttu-id="70209-452">Los cambios de estado son complicados porque es posible que no pueda ver el costo de un cambio de estado sin representación.</span><span class="sxs-lookup"><span data-stu-id="70209-452">State changes are tricky because you may not be able to see the cost of a state change without rendering.</span></span> <span data-ttu-id="70209-453">Este es el resultado del algoritmo diferido que usan el controlador y la GPU para diferir el trabajo hasta que sea absolutamente necesario.</span><span class="sxs-lookup"><span data-stu-id="70209-453">This is a result of the lazy algorithm that the driver and the GPU use to defer work until it absolutely has to be done.</span></span> <span data-ttu-id="70209-454">En general, debe seguir estos pasos para medir un único cambio de estado:</span><span class="sxs-lookup"><span data-stu-id="70209-454">In general, you should follow these steps to measure a single state change:</span></span>

1.  <span data-ttu-id="70209-455">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) primero el perfil.</span><span class="sxs-lookup"><span data-stu-id="70209-455">Profile [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) first.</span></span>
2.  <span data-ttu-id="70209-456">Agregue un cambio de estado a la secuencia de representación y Perfile la nueva secuencia.</span><span class="sxs-lookup"><span data-stu-id="70209-456">Add one state change to the render sequence and profile the new sequence.</span></span>
3.  <span data-ttu-id="70209-457">Reste la diferencia entre las dos secuencias para obtener el costo del cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-457">Subtract the difference between the two sequences to get the cost of the state change.</span></span>

<span data-ttu-id="70209-458">Naturalmente, todo lo que ha aprendido sobre el uso del mecanismo de consulta y la colocación de la secuencia de representación en un bucle para negar el costo de la transición de modo se sigue aplicando.</span><span class="sxs-lookup"><span data-stu-id="70209-458">Naturally, everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

### <a name="profiling-a-simple-state-change"></a><span data-ttu-id="70209-459">Generar perfiles de un cambio de estado simple</span><span class="sxs-lookup"><span data-stu-id="70209-459">Profiling a Simple State Change</span></span>

<span data-ttu-id="70209-460">A partir de una secuencia de representación que contiene [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), esta es la secuencia de código para medir el costo de agregar [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span><span class="sxs-lookup"><span data-stu-id="70209-460">Starting with a render sequence that contains [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), here is the code sequence for measuring the cost of adding [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span></span>


```
// Get the start counter value as shown in Example 4 

// Initialize a texture array as shown in Example 4
IDirect3DTexture* texArray[2];

// Render sequence loop 
for(int i = 0; i < 1500; i++)
{
  SetTexture(0, texArray[i%2];
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="70209-461">Ejemplo 5: medir una llamada API de cambio de estado</span><span class="sxs-lookup"><span data-stu-id="70209-461">Example 5: Measuring One State Change API Call</span></span>

<span data-ttu-id="70209-462">Observe que el bucle contiene dos llamadas, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) y [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="70209-462">Notice that the loop contains two calls, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="70209-463">La secuencia de representación recorre el bucle 1500 veces y genera resultados similares a los siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-463">The render sequence loops 1500 times and generates results similar to these:</span></span>



| <span data-ttu-id="70209-464">Variable local</span><span class="sxs-lookup"><span data-stu-id="70209-464">Local Variable</span></span> | <span data-ttu-id="70209-465">Número de las marcas</span><span class="sxs-lookup"><span data-stu-id="70209-465">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="70209-466">start</span><span class="sxs-lookup"><span data-stu-id="70209-466">start</span></span>          | <span data-ttu-id="70209-467">1792998860000</span><span class="sxs-lookup"><span data-stu-id="70209-467">1792998860000</span></span>  |
| <span data-ttu-id="70209-468">stop</span><span class="sxs-lookup"><span data-stu-id="70209-468">stop</span></span>           | <span data-ttu-id="70209-469">1792998870260</span><span class="sxs-lookup"><span data-stu-id="70209-469">1792998870260</span></span>  |
| <span data-ttu-id="70209-470">Freq</span><span class="sxs-lookup"><span data-stu-id="70209-470">freq</span></span>           | <span data-ttu-id="70209-471">3579545</span><span class="sxs-lookup"><span data-stu-id="70209-471">3579545</span></span>        |



 

<span data-ttu-id="70209-472">La conversión de pasos a ciclos vuelve a producirse:</span><span class="sxs-lookup"><span data-stu-id="70209-472">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998870260 - 1792998860000 = 10,260 ticks
# cycles    = machine speed * number of ticks / QPF
5,775,000   = 2 GHz          * 10,260         / 3,579,545
```



<span data-ttu-id="70209-473">La división por el número de iteraciones en el bucle produce:</span><span class="sxs-lookup"><span data-stu-id="70209-473">Dividing by the number of iterations in the loop yields:</span></span>


```
5,775,000 cycles / 1500 iterations = 3850 cycles for one iteration
```



<span data-ttu-id="70209-474">Cada iteración del bucle contiene un cambio de estado y una llamada a Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-474">Each iteration of the loop contains a state change and a draw call.</span></span> <span data-ttu-id="70209-475">Restar el resultado de la secuencia de representación [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) :</span><span class="sxs-lookup"><span data-stu-id="70209-475">Subtracting out the result of the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence leaves:</span></span>


```
3850 - 1100 = 2750 cycles for SetTexture
```



<span data-ttu-id="70209-476">Es el número medio de ciclos para agregar [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) a esta secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-476">This is the average number of cycles to add [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to this render sequence.</span></span> <span data-ttu-id="70209-477">Esta misma técnica se puede aplicar a otros cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-477">This same technique can be applied to other state changes.</span></span>

<span data-ttu-id="70209-478">¿Por qué [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) se llama un cambio de estado simple?</span><span class="sxs-lookup"><span data-stu-id="70209-478">Why is [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) called a simple state change?</span></span> <span data-ttu-id="70209-479">Dado que el estado que se está configurando está restringido para que la canalización tenga la misma cantidad de trabajo cada vez que se cambia el estado.</span><span class="sxs-lookup"><span data-stu-id="70209-479">Because the state that is being set is constrained so that the pipeline does the same amount of work each time the state is changed.</span></span> <span data-ttu-id="70209-480">La restricción de ambas texturas al mismo tamaño y formato garantiza la misma cantidad de trabajo para cada llamada a **SetTexture** .</span><span class="sxs-lookup"><span data-stu-id="70209-480">Constraining both textures to the same size and format assures the same amount of work for each **SetTexture** call.</span></span>

### <a name="profiling-a-state-change-that-needs-to-be-toggled"></a><span data-ttu-id="70209-481">Generar perfiles de un cambio de estado que se debe alternar</span><span class="sxs-lookup"><span data-stu-id="70209-481">Profiling a State Change that Needs to Be Toggled</span></span>

<span data-ttu-id="70209-482">Hay otros cambios de estado que hacen que la cantidad de trabajo realizado por la canalización de gráficos cambie para cada iteración del bucle de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-482">There are other state changes that cause the amount of work performed by the graphics pipeline to change for every iteration of the render loop.</span></span> <span data-ttu-id="70209-483">Por ejemplo, si está habilitada la prueba z, cada color de píxel actualiza un destino de representación solo después de que el valor z del nuevo píxel se prueba con el valor z del píxel existente.</span><span class="sxs-lookup"><span data-stu-id="70209-483">For example, if z-testing is enabled, each pixel color updates a render target only after the new pixel's z value is tested against the z-value for the existing pixel.</span></span> <span data-ttu-id="70209-484">Si la prueba de z está deshabilitada, esta prueba por píxel no se realiza y la salida se escribe mucho más rápido.</span><span class="sxs-lookup"><span data-stu-id="70209-484">If z-testing is disabled, this per-pixel test is not done and the output is written much faster.</span></span> <span data-ttu-id="70209-485">Al habilitar o deshabilitar el estado de la prueba z, se cambia drásticamente la cantidad de trabajo realizado (por la CPU y la GPU) durante la representación.</span><span class="sxs-lookup"><span data-stu-id="70209-485">Enabling or disabling the z-test state dramatically changes the amount of work done (by the CPU as well as the GPU) during rendering.</span></span>

<span data-ttu-id="70209-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) requiere un estado de representación determinado y un valor de estado para habilitar o deshabilitar las pruebas z.</span><span class="sxs-lookup"><span data-stu-id="70209-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) requires a particular render state and a state value to enable or disable z-testing.</span></span> <span data-ttu-id="70209-487">El valor de estado concreto se evalúa en tiempo de ejecución para determinar cuánto trabajo es necesario.</span><span class="sxs-lookup"><span data-stu-id="70209-487">The particular state value is evaluated at runtime to determine how much work is necessary.</span></span> <span data-ttu-id="70209-488">Es difícil medir este cambio de estado en un bucle de representación y seguir condicionando el estado de la canalización para que se cambie.</span><span class="sxs-lookup"><span data-stu-id="70209-488">It is difficult to measure this state change in a render loop and still precondition the pipeline state so that it switches.</span></span> <span data-ttu-id="70209-489">La única solución es alternar el cambio de estado durante la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-489">The only solution is to toggle the state change during the render sequence.</span></span>

<span data-ttu-id="70209-490">Por ejemplo, la técnica de generación de perfiles debe repetirse dos veces como se indica a continuación:</span><span class="sxs-lookup"><span data-stu-id="70209-490">For example, the profiling technique needs to be repeated twice as follows:</span></span>

1.  <span data-ttu-id="70209-491">Empiece por generar perfiles de la secuencia de representación de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .</span><span class="sxs-lookup"><span data-stu-id="70209-491">Start by profiling the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence.</span></span> <span data-ttu-id="70209-492">Llame a esta línea de base.</span><span class="sxs-lookup"><span data-stu-id="70209-492">Call this the baseline.</span></span>
2.  <span data-ttu-id="70209-493">Generar perfiles de una segunda secuencia de representación que alterna el cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-493">Profile a second render sequence that toggles the state change.</span></span> <span data-ttu-id="70209-494">El bucle de la secuencia de representación contiene:</span><span class="sxs-lookup"><span data-stu-id="70209-494">The render sequence loop contains:</span></span>
    -   <span data-ttu-id="70209-495">Un cambio de estado para establecer el estado en una condición "false".</span><span class="sxs-lookup"><span data-stu-id="70209-495">A state change to set the state into a "false" condition.</span></span>
    -   <span data-ttu-id="70209-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) igual que la secuencia original.</span><span class="sxs-lookup"><span data-stu-id="70209-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) just like the original sequence.</span></span>
    -   <span data-ttu-id="70209-497">Un cambio de estado para establecer el estado en una condición "true".</span><span class="sxs-lookup"><span data-stu-id="70209-497">A state change to set the state into a "true" condition.</span></span>
    -   <span data-ttu-id="70209-498">Un segundo [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) para forzar el segundo cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-498">A second [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to force the second state change to be realized.</span></span>
3.  <span data-ttu-id="70209-499">Busque la diferencia entre las dos secuencias de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-499">Find the difference between the two render sequences.</span></span> <span data-ttu-id="70209-500">Para hacer esto:</span><span class="sxs-lookup"><span data-stu-id="70209-500">This is done by:</span></span>
    -   <span data-ttu-id="70209-501">Multiplica la secuencia [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) de línea de base por 2 porque hay dos llamadas **DrawPrimitive** en la nueva secuencia.</span><span class="sxs-lookup"><span data-stu-id="70209-501">Multiply the baseline [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sequence by 2 because there are two **DrawPrimitive** calls in the new sequence.</span></span>
    -   <span data-ttu-id="70209-502">Resta el resultado de la nueva secuencia de la secuencia original.</span><span class="sxs-lookup"><span data-stu-id="70209-502">Subtract the result of the new sequence from the original sequence.</span></span>
    -   <span data-ttu-id="70209-503">Divida el resultado en 2 para obtener el costo medio de los cambios de estado "false" y "true".</span><span class="sxs-lookup"><span data-stu-id="70209-503">Divide the result by 2 to get the average cost of both the "false" and the "true" state change.</span></span>

<span data-ttu-id="70209-504">Con la técnica de bucle utilizada en la secuencia de representación, el costo de cambiar el estado de canalización debe medirse alternando el estado de "true" a una condición "false" y viceversa, para cada iteración de la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-504">With the looping technique used in the render sequence, the cost of changing pipeline state needs to be measured by toggling the state from a "true" to a "false" condition and vice versa, for each iteration in the render sequence.</span></span> <span data-ttu-id="70209-505">El significado de "true" y "false" aquí no son literales, esto significa simplemente que el estado debe establecerse en condiciones opuestas.</span><span class="sxs-lookup"><span data-stu-id="70209-505">The meaning of "true" and "false" here are not literal, this simply means that the state needs to be set into opposing conditions.</span></span> <span data-ttu-id="70209-506">Esto hace que ambos cambios de estado se midan durante la generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-506">This causes both state changes to be measured during profiling.</span></span> <span data-ttu-id="70209-507">Por supuesto todo lo que ha aprendido sobre el uso del mecanismo de consulta y la colocación de la secuencia de representación en un bucle para negar el costo de la transición de modo se sigue aplicando.</span><span class="sxs-lookup"><span data-stu-id="70209-507">Of course everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

<span data-ttu-id="70209-508">Por ejemplo, esta es la secuencia de código para medir el costo de activar o desactivar las pruebas de z:</span><span class="sxs-lookup"><span data-stu-id="70209-508">For example, here is the code sequence for measuring the cost of toggling z-testing on or off:</span></span>


```
// Get the start counter value as shown in Example 4 

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the "false" condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Set the pipeline state to the "true" condition
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="70209-509">Ejemplo 5: medir un cambio de estado de alternancia</span><span class="sxs-lookup"><span data-stu-id="70209-509">Example 5: Measuring a Toggling State Change</span></span>

<span data-ttu-id="70209-510">El bucle alterna el estado mediante la ejecución de dos llamadas a [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) .</span><span class="sxs-lookup"><span data-stu-id="70209-510">The loop toggles the state by executing two [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) calls.</span></span> <span data-ttu-id="70209-511">La primera llamada a **SetRenderState** deshabilita las pruebas z y el segundo **SetRenderState** habilita las pruebas z.</span><span class="sxs-lookup"><span data-stu-id="70209-511">The first **SetRenderState** call disables z-testing and the second **SetRenderState** enables z-testing.</span></span> <span data-ttu-id="70209-512">Cada **SetRenderState** va seguido de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) para que el trabajo asociado con el cambio de estado lo procese el controlador en lugar de establecer solo un bit sucio en el controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-512">Each **SetRenderState** is followed by [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) so that the work associated with the state change is processed by the driver instead of only setting a dirty bit in the driver.</span></span>

<span data-ttu-id="70209-513">Estos números son razonables para esta secuencia de representación:</span><span class="sxs-lookup"><span data-stu-id="70209-513">These numbers are reasonable for this render sequence:</span></span>



| <span data-ttu-id="70209-514">Variable local</span><span class="sxs-lookup"><span data-stu-id="70209-514">Local Variable</span></span> | <span data-ttu-id="70209-515">Número de TICs</span><span class="sxs-lookup"><span data-stu-id="70209-515">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="70209-516">start</span><span class="sxs-lookup"><span data-stu-id="70209-516">start</span></span>          | <span data-ttu-id="70209-517">1792998845000</span><span class="sxs-lookup"><span data-stu-id="70209-517">1792998845000</span></span>   |
| <span data-ttu-id="70209-518">stop</span><span class="sxs-lookup"><span data-stu-id="70209-518">stop</span></span>           | <span data-ttu-id="70209-519">1792998861740</span><span class="sxs-lookup"><span data-stu-id="70209-519">1792998861740</span></span>   |
| <span data-ttu-id="70209-520">Freq</span><span class="sxs-lookup"><span data-stu-id="70209-520">freq</span></span>           | <span data-ttu-id="70209-521">3579545</span><span class="sxs-lookup"><span data-stu-id="70209-521">3579545</span></span>         |



 

<span data-ttu-id="70209-522">La conversión de pasos a ciclos vuelve a producirse:</span><span class="sxs-lookup"><span data-stu-id="70209-522">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998861740 - 1792998845000 = 15,120 ticks
# cycles    = machine speed * number of ticks / QPF
 9,300,000  = 2 GHz          * 16,740         / 3,579,545
```



<span data-ttu-id="70209-523">La división por el número de iteraciones en el bucle produce:</span><span class="sxs-lookup"><span data-stu-id="70209-523">Dividing by the number of iterations in the loop yields:</span></span>


```
9,300,000 cycles / 1500 iterations = 6200 cycles for one iteration
```



<span data-ttu-id="70209-524">Cada iteración del bucle contiene dos cambios de estado y dos llamadas a Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-524">Each iteration of the loop contains two state changes and two draw calls.</span></span> <span data-ttu-id="70209-525">Restar las llamadas a Draw (suponiendo 1100 ciclos) deja:</span><span class="sxs-lookup"><span data-stu-id="70209-525">Subtracting out the draw calls (assuming 1100 cycles) leaves:</span></span>


```
6200 - 1100 - 1100 = 4000 cycles for both state changes
```



<span data-ttu-id="70209-526">Es el número medio de ciclos para ambos cambios de estado, por lo que el tiempo medio para cada cambio de estado es:</span><span class="sxs-lookup"><span data-stu-id="70209-526">This is the average number of cycles for both state changes so the average time for each state change is:</span></span>


```
4000 / 2  = 2000 cycles for each state change
```



<span data-ttu-id="70209-527">Por lo tanto, el número medio de ciclos para habilitar o deshabilitar las pruebas z es de 2000 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-527">Therefore, the average number of cycles to enable or disable z-testing is 2000 cycles.</span></span> <span data-ttu-id="70209-528">Merece la pena mencionar que QueryPerformanceCounter mide la mitad del tiempo y la mitad del tiempo deshabilitada para z.</span><span class="sxs-lookup"><span data-stu-id="70209-528">It is worth noting that QueryPerformanceCounter is measuring z-enable half the time and z-disable half of the time.</span></span> <span data-ttu-id="70209-529">Esta técnica mide realmente el promedio de ambos cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-529">This technique actually measures the average of both state changes.</span></span> <span data-ttu-id="70209-530">En otras palabras, está midiendo el tiempo para alternar un estado.</span><span class="sxs-lookup"><span data-stu-id="70209-530">In other words, you are measuring the time to toggle a state.</span></span> <span data-ttu-id="70209-531">Con esta técnica, no tiene ninguna manera de saber si los tiempos de habilitación y deshabilitación son equivalentes, ya que ha medido el promedio de ambos.</span><span class="sxs-lookup"><span data-stu-id="70209-531">Using this technique, you have no way of knowing if the enable and disable times are equivalent since you have measured the average of both of them.</span></span> <span data-ttu-id="70209-532">No obstante, se trata de un número razonable que se usa al presupuestar un estado de alternancia como una aplicación que hace que este cambio de estado solo pueda hacerlo alternando este estado.</span><span class="sxs-lookup"><span data-stu-id="70209-532">Nevertheless, this is a reasonable number to use when budgeting a toggling state as an application that causes this state change can only do so by toggling this state.</span></span>

<span data-ttu-id="70209-533">Por lo tanto, ahora puede aplicar estas técnicas y generar perfiles de todos los cambios de estado que desee, ¿es correcto?</span><span class="sxs-lookup"><span data-stu-id="70209-533">So now you can apply these techniques and profile all the state changes you want, right?</span></span> <span data-ttu-id="70209-534">No del todo.</span><span class="sxs-lookup"><span data-stu-id="70209-534">Not quite.</span></span> <span data-ttu-id="70209-535">Todavía tiene que tener cuidado con las optimizaciones que están diseñadas para reducir la cantidad de trabajo que debe realizarse.</span><span class="sxs-lookup"><span data-stu-id="70209-535">You still need to be careful about optimizations that are designed to reduce the amount of work that needs to be done.</span></span> <span data-ttu-id="70209-536">Hay dos tipos de optimizaciones que se deben tener en cuenta al diseñar las secuencias de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-536">There are two types of optimizations that you should be aware of when designing your render sequences.</span></span>

### <a name="watch-out-for-state-change-optimizations"></a><span data-ttu-id="70209-537">Ver las optimizaciones de cambio de estado</span><span class="sxs-lookup"><span data-stu-id="70209-537">Watch Out for State Change Optimizations</span></span>

<span data-ttu-id="70209-538">En la sección anterior se muestra cómo generar perfiles de ambos tipos de cambios de estado: un cambio de estado simple que está restringido para generar la misma cantidad de trabajo para cada iteración y un cambio de estado de alternancia que cambia drásticamente la cantidad de trabajo realizada.</span><span class="sxs-lookup"><span data-stu-id="70209-538">The previous section show how to profile both kinds of state changes: a simple state change that is constrained to generate the same amount of work for each iteration, and a toggling state change that dramatically changes the amount of work done.</span></span> <span data-ttu-id="70209-539">¿Qué ocurre si toma la secuencia de representación anterior y agrega otro cambio de estado a ella?</span><span class="sxs-lookup"><span data-stu-id="70209-539">What happens if you take the previous render sequence and add another state change to it?</span></span> <span data-ttu-id="70209-540">Por ejemplo, en este ejemplo se toma la secuencia de representación z>-enable y se le agrega una comparación entre z-FUNC:</span><span class="sxs-lookup"><span data-stu-id="70209-540">For instance, this example takes the z>-enable render sequence and adds a z-func comparison to it:</span></span>


```
// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZFUNC, D3DCMP_NEVER);

  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}
```



<span data-ttu-id="70209-541">El estado z-FUNC establece el nivel de comparación al escribir en el búfer z (entre el valor z de un píxel actual con el valor z de un píxel en el búfer de profundidad).</span><span class="sxs-lookup"><span data-stu-id="70209-541">The z-func state sets the comparison level when writing to the z-buffer (between the z-value of a current pixel with the z-value of a pixel in the depth buffer).</span></span> <span data-ttu-id="70209-542">D3DCMP \_ nunca desactiva la comparación de pruebas z mientras que D3DCMP \_ siempre establece la comparación para que suceda cada vez que se realiza la prueba z.</span><span class="sxs-lookup"><span data-stu-id="70209-542">D3DCMP\_NEVER turns off the z-testing comparison while D3DCMP\_ALWAYS sets the comparison to happen every time z-testing is done.</span></span>

<span data-ttu-id="70209-543">La generación de perfiles de uno de estos cambios de estado en una secuencia de representación con [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) genera resultados similares a los siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-543">Profiling either one of these state changes in a render sequence with [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) generates results similar to these:</span></span>



| <span data-ttu-id="70209-544">Cambio de estado único</span><span class="sxs-lookup"><span data-stu-id="70209-544">Single State Change</span></span> | <span data-ttu-id="70209-545">Número promedio de ciclos</span><span class="sxs-lookup"><span data-stu-id="70209-545">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="70209-546">\_Solo D3DRS ZENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-546">D3DRS\_ZENABLE only</span></span> | <span data-ttu-id="70209-547">2000</span><span class="sxs-lookup"><span data-stu-id="70209-547">2000</span></span>                     |



 

<span data-ttu-id="70209-548">or</span><span class="sxs-lookup"><span data-stu-id="70209-548">or</span></span>



| <span data-ttu-id="70209-549">Cambio de estado único</span><span class="sxs-lookup"><span data-stu-id="70209-549">Single State Change</span></span> | <span data-ttu-id="70209-550">Número promedio de ciclos</span><span class="sxs-lookup"><span data-stu-id="70209-550">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="70209-551">\_Solo D3DRS ZFUNC</span><span class="sxs-lookup"><span data-stu-id="70209-551">D3DRS\_ZFUNC only</span></span>   | <span data-ttu-id="70209-552">600</span><span class="sxs-lookup"><span data-stu-id="70209-552">600</span></span>                      |



 

<span data-ttu-id="70209-553">Sin embargo, si \_ genera el perfil de D3DRS ZENABLE y D3DRS \_ ZFUNC en la misma secuencia de representación, podría ver resultados como los siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-553">But, if you profile both D3DRS\_ZENABLE and D3DRS\_ZFUNC in the same render sequence you could see results like these:</span></span>



| <span data-ttu-id="70209-554">Ambos cambios de estado</span><span class="sxs-lookup"><span data-stu-id="70209-554">Both State Changes</span></span>            | <span data-ttu-id="70209-555">Número promedio de ciclos</span><span class="sxs-lookup"><span data-stu-id="70209-555">Average Number of Cycles</span></span> |
|-------------------------------|--------------------------|
| <span data-ttu-id="70209-556">D3DRS \_ ZENABLE + D3DRS \_ ZFUNC</span><span class="sxs-lookup"><span data-stu-id="70209-556">D3DRS\_ZENABLE + D3DRS\_ZFUNC</span></span> | <span data-ttu-id="70209-557">2000</span><span class="sxs-lookup"><span data-stu-id="70209-557">2000</span></span>                     |



 

<span data-ttu-id="70209-558">Podría esperar que el resultado sea la suma de los ciclos 2000 y 600 (o 2600) porque el controlador está realizando todo el trabajo asociado a la configuración de ambos Estados de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-558">You could expect the result to be to be the sum of 2000 and 600 (or 2600) cycles because the driver is doing all the work associated with setting both render states.</span></span> <span data-ttu-id="70209-559">En su lugar, el promedio es 2000 ciclos.</span><span class="sxs-lookup"><span data-stu-id="70209-559">Instead, the average is 2000 cycles.</span></span>

<span data-ttu-id="70209-560">Este resultado refleja una optimización de cambio de estado implementada en el tiempo de ejecución, el controlador o la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-560">This result reflects a state change optimization implemented in the runtime, the driver, or the GPU.</span></span> <span data-ttu-id="70209-561">En este caso, el controlador podría ver la primera [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) y establecer un estado sucio que pospuso el trabajo hasta más tarde.</span><span class="sxs-lookup"><span data-stu-id="70209-561">In this case, the driver could see the first [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) and set a dirty state which would postpone the work until later.</span></span> <span data-ttu-id="70209-562">Cuando el controlador Ve el segundo **SetRenderState**, el mismo estado modificado podría estar establecido de redundancia y el mismo trabajo se pospuso una vez más.</span><span class="sxs-lookup"><span data-stu-id="70209-562">When the driver sees the second **SetRenderState**, the same dirty state could be redundantly set and the same work would be postponed once again.</span></span> <span data-ttu-id="70209-563">Cuando se llama a [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , el trabajo asociado con el estado Dirty se procesa finalmente.</span><span class="sxs-lookup"><span data-stu-id="70209-563">When [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is called, the work associated with the dirty state is finally processed.</span></span> <span data-ttu-id="70209-564">El controlador ejecuta el trabajo una vez, lo que significa que el controlador consolida en efecto los dos primeros cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-564">The driver executes the work one time, which means that the first two state changes are effectively consolidated by the driver.</span></span> <span data-ttu-id="70209-565">De forma similar, el controlador consolida el tercer y cuarto cambio de estado de forma eficaz en un solo cambio de estado cuando se llama al segundo **DrawPrimitive** .</span><span class="sxs-lookup"><span data-stu-id="70209-565">Similarly, the third and fourth state changes are effectively consolidated by the driver into a single state change when the second **DrawPrimitive** is called.</span></span> <span data-ttu-id="70209-566">El resultado neto es que el controlador y la GPU procesan un solo cambio de estado para cada llamada a Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-566">The net result is that the driver and the GPU process a single state change for each draw call.</span></span>

<span data-ttu-id="70209-567">Este es un buen ejemplo de optimización de un controlador dependiente de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="70209-567">This is a good example of a sequence-dependent driver optimization.</span></span> <span data-ttu-id="70209-568">El controlador pospuso el trabajo dos veces estableciendo un estado modificado y, a continuación, realizó el trabajo una vez para borrar el estado sucio.</span><span class="sxs-lookup"><span data-stu-id="70209-568">The driver postponed work twice by setting a dirty state, and then performed the work once to clear the dirty state.</span></span> <span data-ttu-id="70209-569">Este es un buen ejemplo del tipo de mejora de la eficacia que puede tener lugar cuando se aplaza el trabajo hasta que sea absolutamente necesario.</span><span class="sxs-lookup"><span data-stu-id="70209-569">This is a good example of the kind of efficiency improvement that can take place when work is deferred until absolutely necessary.</span></span>

<span data-ttu-id="70209-570">¿Cómo se sabe qué cambios de estado establecen un estado modificado internamente y, por tanto, se pospone el trabajo hasta más tarde?</span><span class="sxs-lookup"><span data-stu-id="70209-570">How do you know which state changes set a dirty state internally and therefore postpone work until later?</span></span> <span data-ttu-id="70209-571">Solo mediante la prueba de secuencias de representación (o la comunicación con los escritores de controladores).</span><span class="sxs-lookup"><span data-stu-id="70209-571">Only by testing render sequences (or talking to driver writers).</span></span> <span data-ttu-id="70209-572">Los controladores se actualizan y mejoran periódicamente para que la lista de optimizaciones no sea estática.</span><span class="sxs-lookup"><span data-stu-id="70209-572">Drivers are updated and improved periodically so the list of optimizations is not static.</span></span> <span data-ttu-id="70209-573">Solo hay una manera de saber absolutamente cuál es el costo de un cambio de estado en una secuencia de representación determinada, en un conjunto de hardware determinado. y eso es medirlo.</span><span class="sxs-lookup"><span data-stu-id="70209-573">There is only one way to absolutely know what a state change costs in a given render sequence, on a particular set of hardware; and that is to measure it.</span></span>

### <a name="watch-out-for-drawprimitive-optimizations"></a><span data-ttu-id="70209-574">Ver las optimizaciones de DrawPrimitive</span><span class="sxs-lookup"><span data-stu-id="70209-574">Watch Out for DrawPrimitive Optimizations</span></span>

<span data-ttu-id="70209-575">Además de las optimizaciones de cambio de estado, el tiempo de ejecución intentará optimizar el número de llamadas a Draw que el controlador tiene que procesar.</span><span class="sxs-lookup"><span data-stu-id="70209-575">In addition to state change optimizations, the runtime will attempt to optimize the number of draw calls that the driver has to process.</span></span> <span data-ttu-id="70209-576">Por ejemplo, tenga en cuenta estas llamadas de vuelta a Draw:</span><span class="sxs-lookup"><span data-stu-id="70209-576">For example, consider these back to back draw calls:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 3); // Draw 3 primitives, vertices 0 - 8
DrawPrimitive(D3DPT_TRIANGLELIST, 9, 4); // Draw 4 primitives, vertices 9 - 20
```



<span data-ttu-id="70209-577">Ejemplo 5A: dos llamadas a Draw</span><span class="sxs-lookup"><span data-stu-id="70209-577">Example 5a: Two Draw Calls</span></span>

<span data-ttu-id="70209-578">Esta secuencia contiene dos llamadas a Draw, que el Runtime consolidará en una única llamada equivalente a:</span><span class="sxs-lookup"><span data-stu-id="70209-578">This sequence contains two draw calls, which the runtime will consolidate into a single call equivalent to:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 7); // Draw 7 primitives, vertices 0 - 20
```



<span data-ttu-id="70209-579">Ejemplo 5B: una única llamada a Draw concatenada</span><span class="sxs-lookup"><span data-stu-id="70209-579">Example 5b: A Single Concatenated Draw Call</span></span>

<span data-ttu-id="70209-580">El tiempo de ejecución concatenará ambas llamadas a Draw en una sola llamada, lo que reduce el trabajo del controlador en un 50 por ciento, ya que el controlador ahora solo necesitará procesar una llamada a Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-580">The runtime will concatenate both of these particular draw calls into a single call, which reduces the driver work by 50 percent because the driver will now only need to process one draw call.</span></span>

<span data-ttu-id="70209-581">En general, el motor en tiempo de ejecución concatenará dos o más llamadas [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) de vuelta a la inversa cuando:</span><span class="sxs-lookup"><span data-stu-id="70209-581">In general, the runtime will concatenate two or more back-to-back [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls when:</span></span>

1.  <span data-ttu-id="70209-582">El tipo primitivo es una lista de triángulos (D3DPT \_ TRIANGLELIST).</span><span class="sxs-lookup"><span data-stu-id="70209-582">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="70209-583">Cada llamada [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sucesiva debe hacer referencia a vértices consecutivos en el búfer de vértices.</span><span class="sxs-lookup"><span data-stu-id="70209-583">Each successive [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call must reference consecutive vertices within the vertex buffer.</span></span>

<span data-ttu-id="70209-584">Del mismo modo, las condiciones adecuadas para concatenar dos o más llamadas de [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) de retroceso son:</span><span class="sxs-lookup"><span data-stu-id="70209-584">Similarly, the right conditions for concatenating two or more back-to-back [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) calls are:</span></span>

1.  <span data-ttu-id="70209-585">El tipo primitivo es una lista de triángulos (D3DPT \_ TRIANGLELIST).</span><span class="sxs-lookup"><span data-stu-id="70209-585">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="70209-586">Cada llamada [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) sucesiva debe hacer referencia secuencial de índices consecutivos en el búfer de índice.</span><span class="sxs-lookup"><span data-stu-id="70209-586">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must sequential reference consecutive indices within the index buffer.</span></span>
3.  <span data-ttu-id="70209-587">Cada llamada [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) sucesiva debe usar el mismo valor para BaseVertexIndex.</span><span class="sxs-lookup"><span data-stu-id="70209-587">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must use the same value for BaseVertexIndex.</span></span>

<span data-ttu-id="70209-588">Para evitar la concatenación durante la generación de perfiles, modifique la secuencia de representación de modo que el tipo primitivo no sea una lista de triángulos o modifique la secuencia de representación para que no haya ninguna llamada de dibujo de vuelta atrás que use vértices consecutivos (o índices).</span><span class="sxs-lookup"><span data-stu-id="70209-588">To prevent concatenation during profiling, modify the render sequence so that the primitive type is not a triangle list, or modify the render sequence so that there are no back-to-back draw calls that use consecutive vertices (or indices).</span></span> <span data-ttu-id="70209-589">Más concretamente, el tiempo de ejecución también concatenará las llamadas a Draw que cumplan las dos condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="70209-589">More specifically, the runtime will also concatenate draw calls that meet both of the following conditions:</span></span>

-   <span data-ttu-id="70209-590">Cuando la llamada anterior es [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), si la siguiente llamada a Draw:</span><span class="sxs-lookup"><span data-stu-id="70209-590">When the previous call is [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="70209-591">usa una lista de triángulos y</span><span class="sxs-lookup"><span data-stu-id="70209-591">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="70209-592">especifica StartVertex = anterior StartVertex + PrimitiveCount anterior \* 3</span><span class="sxs-lookup"><span data-stu-id="70209-592">specifies the StartVertex = previous StartVertex + previous PrimitiveCount \* 3</span></span>
-   <span data-ttu-id="70209-593">Cuando se usa [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), si la siguiente llamada a Draw:</span><span class="sxs-lookup"><span data-stu-id="70209-593">When using [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="70209-594">usa una lista de triángulos y</span><span class="sxs-lookup"><span data-stu-id="70209-594">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="70209-595">especifica StartIndex = anterior StartIndex + PrimitiveCount anterior \* 3 y</span><span class="sxs-lookup"><span data-stu-id="70209-595">specifies the StartIndex = previous StartIndex + previous PrimitiveCount \* 3, AND</span></span>
    -   <span data-ttu-id="70209-596">especifica BaseVertexIndex = BaseVertexIndex anterior</span><span class="sxs-lookup"><span data-stu-id="70209-596">specifies the BaseVertexIndex = previous BaseVertexIndex</span></span>

<span data-ttu-id="70209-597">Este es un ejemplo más sutil de concatenación de llamadas a Draw que es fácil de pasar por alto cuando se generan perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-597">Here is a more subtle example of draw call concatenation that is easy to overlook when you are profiling.</span></span> <span data-ttu-id="70209-598">Supongamos que la secuencia de representación tiene el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="70209-598">Assume the render sequence looks like this:</span></span>


```
  for(int i = 0; i < 1500; i++)
  {
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="70209-599">Ejemplo 5C: un cambio de estado y una llamada a Draw</span><span class="sxs-lookup"><span data-stu-id="70209-599">Example 5c: One State Change and One Draw Call</span></span>

<span data-ttu-id="70209-600">El bucle recorre en iteración hasta 1500 triángulos, estableciendo una textura y dibujando cada triángulo.</span><span class="sxs-lookup"><span data-stu-id="70209-600">The loop iterates through 1500 triangles, setting a texture and drawing each triangle.</span></span> <span data-ttu-id="70209-601">Este bucle de representación tarda aproximadamente 2750 ciclos en los ciclos [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) y 1100 de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) como se muestra en las secciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="70209-601">This render loop takes approximately 2750 cycles for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and 1100 cycles for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) as shown in previous sections.</span></span> <span data-ttu-id="70209-602">Podría esperar de forma intuitiva que mover **SetTexture** fuera del bucle de representación debe reducir la cantidad de trabajo realizado por el controlador en 1500 \* 2750 ciclos, que es la cantidad de trabajo asociada a la llamada a **SetTexture** 1500 veces.</span><span class="sxs-lookup"><span data-stu-id="70209-602">You might intuitively expect that moving **SetTexture** outside the render loop should reduce the amount of work done by the driver by 1500 \* 2750 cycles, which is the amount of work associated with calling **SetTexture** 1500 times.</span></span> <span data-ttu-id="70209-603">El fragmento de código tendría el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="70209-603">The code snippet would look like this:</span></span>


```
  SetTexture(...); // Set the state outside the loop
  for(int i = 0; i < 1500; i++)
  {
//    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="70209-604">Ejemplo 5D: ejemplo 5C con el cambio de estado fuera del bucle</span><span class="sxs-lookup"><span data-stu-id="70209-604">Example 5d: Example 5c with the State Change Outside the Loop</span></span>

<span data-ttu-id="70209-605">Mover [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) fuera del bucle de representación reduce la cantidad de trabajo asociado a **SetTexture** , ya que se llama una vez en lugar de 1500 veces.</span><span class="sxs-lookup"><span data-stu-id="70209-605">Moving [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) outside the render loop does reduce the amount of work associated with **SetTexture** since it is called once instead of 1500 times.</span></span> <span data-ttu-id="70209-606">Un efecto secundario menos obvio es que el trabajo de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) también se reduce de 1500 llamadas a 1 llamada porque se cumplen todas las condiciones para concatenar llamadas a Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-606">A less obvious secondary effect is that the work for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is also reduced from 1500 calls to 1 call because all of the conditions for concatenating draw calls are satisfied.</span></span> <span data-ttu-id="70209-607">Cuando se procesa la secuencia de representación, el tiempo de ejecución procesará las llamadas 1500 en una única llamada de controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-607">When the render sequence is processed, the runtime will process 1500 calls into a single driver call.</span></span> <span data-ttu-id="70209-608">Al mover esta línea de código, la cantidad de trabajo del controlador se ha reducido drásticamente:</span><span class="sxs-lookup"><span data-stu-id="70209-608">By moving this one line of code, the amount of driver work has been reduced dramatically:</span></span>


```
total work done = runtime + driver work

Example 5c: with SetTexture in the loop:
runtime work = 1500 SetTextures + 1500 DrawPrimitives 
driver  work = 1500 SetTextures + 1500 DrawPrimitives 

Example 5d: with SetTexture outside of the loop:
runtime work = 1 SetTexture + 1 DrawPrimitive + 1499 Concatenated DrawPrimitives 
driver  work = 1 SetTexture + 1 DrawPrimitive 
```



<span data-ttu-id="70209-609">Estos resultados son completamente correctos, pero son muy engañosos en el contexto de la pregunta original.</span><span class="sxs-lookup"><span data-stu-id="70209-609">These results are entirely correct, but are very misleading in the context of the original question.</span></span> <span data-ttu-id="70209-610">La optimización de llamadas de Draw ha provocado que la cantidad de trabajo de controlador se reduzca drásticamente.</span><span class="sxs-lookup"><span data-stu-id="70209-610">The draw call optimization has caused the amount of driver work to be dramatically reduced.</span></span> <span data-ttu-id="70209-611">Se trata de un problema común al realizar la generación de perfiles personalizada.</span><span class="sxs-lookup"><span data-stu-id="70209-611">This is a common problem when doing custom profiling.</span></span> <span data-ttu-id="70209-612">Al eliminar llamadas de una secuencia de representación, tenga cuidado de evitar la concatenación de llamadas a Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-612">When eliminating calls from a render sequence, be careful to avoid draw call concatenation.</span></span> <span data-ttu-id="70209-613">De hecho, este escenario es un eficaz ejemplo de la cantidad de mejoras en el rendimiento del controlador posible gracias a esta optimización en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="70209-613">In fact, this scenario is a powerful example of the amount of improvement in driver performance possible by this runtime optimization.</span></span>

<span data-ttu-id="70209-614">Ahora ya sabe cómo medir los cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-614">So now you know how to measure state changes.</span></span> <span data-ttu-id="70209-615">Empiece por generar perfiles de [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="70209-615">Start by profiling [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="70209-616">A continuación, agregue cada cambio de estado adicional a la secuencia (en algunos casos, agregando una llamada y en otros casos agregando dos llamadas) y mide la diferencia entre las dos secuencias.</span><span class="sxs-lookup"><span data-stu-id="70209-616">Then add each additional state change to the sequence (in some cases adding one call and in other cases adding two calls) and measure the difference between the two sequences.</span></span> <span data-ttu-id="70209-617">Puede convertir los resultados en pasos o ciclos u hora.</span><span class="sxs-lookup"><span data-stu-id="70209-617">You can convert the results to ticks or cycles or time.</span></span> <span data-ttu-id="70209-618">Al igual que la medición de secuencias de representación con QueryPerformanceCounter, la medida de los cambios de estado individuales se basa en el mecanismo de consulta para controlar el búfer de comandos y en un bucle para minimizar el impacto de las transiciones de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-618">Just like measuring render sequences with QueryPerformanceCounter, measuring individual state changes relies on the query mechanism to control the command buffer, and putting the state changes in a loop to minimize the impact of the mode transitions.</span></span> <span data-ttu-id="70209-619">Esta técnica mide el costo de alternar un estado, ya que el generador de perfiles devuelve el promedio de habilitar y deshabilitar el estado.</span><span class="sxs-lookup"><span data-stu-id="70209-619">This technique measures the cost of toggling a state, since the profiler returns the average of enabling and disabling the state.</span></span>

<span data-ttu-id="70209-620">Con esta capacidad, puede empezar a generar secuencias de representación arbitrarias y a medir con precisión el tiempo de ejecución y el trabajo del controlador asociados.</span><span class="sxs-lookup"><span data-stu-id="70209-620">With this capability, you can start generating arbitrary rendering sequences and accurately measuring the associated runtime and driver work.</span></span> <span data-ttu-id="70209-621">A continuación, se pueden usar los números para responder a las preguntas de la cotización, como "el número de llamadas más que se pueden realizar" en la secuencia de representación, a la vez que se mantiene una velocidad de fotogramas razonable, suponiendo escenarios limitados por la CPU.</span><span class="sxs-lookup"><span data-stu-id="70209-621">The numbers can then be used to answer budgeting questions like "how many more of these calls" can be made in the render sequence while still maintaining a reasonable frame rate, assuming CPU-limited scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="70209-622">Resumen</span><span class="sxs-lookup"><span data-stu-id="70209-622">Summary</span></span>

<span data-ttu-id="70209-623">En este documento se muestra cómo controlar el búfer de comandos para que se puedan crear perfiles de forma precisa de las llamadas individuales.</span><span class="sxs-lookup"><span data-stu-id="70209-623">This paper demonstrates how to control the command buffer so that individual calls can be accurately profiled.</span></span> <span data-ttu-id="70209-624">Los números de generación de perfiles se pueden generar en pasos, ciclos o en tiempo absoluto.</span><span class="sxs-lookup"><span data-stu-id="70209-624">The profiling numbers can be generated in ticks, cycles, or absolute time.</span></span> <span data-ttu-id="70209-625">Representan la cantidad de trabajo de controlador y tiempo de ejecución asociado a cada llamada de API.</span><span class="sxs-lookup"><span data-stu-id="70209-625">They represent the amount of runtime and driver work associated with each API call.</span></span>

<span data-ttu-id="70209-626">Empiece por generar perfiles de una \* llamada primitiva Draw en una secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-626">Start by profiling a Draw\*Primitive call in a render sequence.</span></span> <span data-ttu-id="70209-627">Recuerde:</span><span class="sxs-lookup"><span data-stu-id="70209-627">Remember to:</span></span>

1.  <span data-ttu-id="70209-628">Use QueryPerformanceCounter para medir el número de TICs por llamada API.</span><span class="sxs-lookup"><span data-stu-id="70209-628">Use QueryPerformanceCounter to measure the number of ticks per API call.</span></span> <span data-ttu-id="70209-629">Use QueryPerformanceFrequency para convertir los resultados en ciclos u hora si lo desea.</span><span class="sxs-lookup"><span data-stu-id="70209-629">Use QueryPerformanceFrequency to convert the results to cycles or time if you like.</span></span>
2.  <span data-ttu-id="70209-630">Use el mecanismo de consulta para vaciar el búfer de comandos antes de iniciarse.</span><span class="sxs-lookup"><span data-stu-id="70209-630">Use the query mechanism to empty the command buffer before starting.</span></span>
3.  <span data-ttu-id="70209-631">Incluya la secuencia de representación en un bucle para minimizar el impacto de la transición de modo.</span><span class="sxs-lookup"><span data-stu-id="70209-631">Include the render sequence in a loop to minimize the impact of the mode transition.</span></span>
4.  <span data-ttu-id="70209-632">Use el mecanismo de consulta para medir el momento en que la GPU ha completado su trabajo.</span><span class="sxs-lookup"><span data-stu-id="70209-632">Use the query mechanism to measure when the GPU has completed its work.</span></span>
5.  <span data-ttu-id="70209-633">Vea la concatenación en tiempo de ejecución que tendrá un impacto importante en la cantidad de trabajo realizado.</span><span class="sxs-lookup"><span data-stu-id="70209-633">Watch out for runtime concatenation that will have a major impact on the amount of work done.</span></span>

<span data-ttu-id="70209-634">Esto le proporciona un rendimiento básico para [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) que se puede usar para compilar desde.</span><span class="sxs-lookup"><span data-stu-id="70209-634">This gives you a baseline performance for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) that can be used to build from.</span></span> <span data-ttu-id="70209-635">Para generar perfiles de un cambio de estado, siga estas sugerencias adicionales:</span><span class="sxs-lookup"><span data-stu-id="70209-635">To profile one state change, follow these additional tips:</span></span>

1.  <span data-ttu-id="70209-636">Agregue el cambio de estado a una secuencia de representación conocida Perfil de la nueva secuencia.</span><span class="sxs-lookup"><span data-stu-id="70209-636">Add the state change to a known render sequence profile the new sequence.</span></span> <span data-ttu-id="70209-637">Dado que las pruebas se realizan en un bucle, esto requiere establecer el estado dos veces en valores opuestos (como habilitar y deshabilitar por ejemplo).</span><span class="sxs-lookup"><span data-stu-id="70209-637">Since the testing is done in a loop, this requires setting the state twice into opposite values (like enable and disable for instance).</span></span>
2.  <span data-ttu-id="70209-638">Compare la diferencia en los tiempos de ciclo entre las dos secuencias.</span><span class="sxs-lookup"><span data-stu-id="70209-638">Compare the difference in cycle times between the two sequences.</span></span>
3.  <span data-ttu-id="70209-639">En el caso de los cambios de estado que cambian significativamente la canalización (como [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), reste la diferencia entre las dos secuencias para obtener la hora de cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-639">For state changes that significantly change the pipeline (like [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), subtract the difference between the two sequences to get the time for state change.</span></span>
4.  <span data-ttu-id="70209-640">En el caso de los cambios de estado que cambian significativamente la canalización (y, por consiguiente, requieren Estados de alternancia como [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), reste la diferencia entre las secuencias de representación y divida por 2.</span><span class="sxs-lookup"><span data-stu-id="70209-640">For state changes that significantly change the pipeline (and therefore require toggling states like [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), subtract the difference between the render sequences and divide by 2.</span></span> <span data-ttu-id="70209-641">Esto generará el promedio de ciclos para cada cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-641">This will generate the average number of cycles for each state change.</span></span>

<span data-ttu-id="70209-642">Pero tenga cuidado con las optimizaciones que causan resultados inesperados durante la generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="70209-642">But be careful of optimizations that cause unexpected results when profiling.</span></span> <span data-ttu-id="70209-643">Las optimizaciones de cambio de estado pueden establecer Estados modificados que provocan que se difiera el trabajo.</span><span class="sxs-lookup"><span data-stu-id="70209-643">State change optimizations may set dirty states which causes work to be deferred.</span></span> <span data-ttu-id="70209-644">Esto puede producir resultados de perfil que no son tan intuitivos como se espera.</span><span class="sxs-lookup"><span data-stu-id="70209-644">This can cause profile results which are not as intuitive as expected.</span></span> <span data-ttu-id="70209-645">Las llamadas a Draw que se concatenan reducirán drásticamente el trabajo del controlador, lo que puede dar lugar a conclusiones engañosas.</span><span class="sxs-lookup"><span data-stu-id="70209-645">Draw calls that are concatenated will dramatically reduce driver work which can lead to misleading conclusions.</span></span> <span data-ttu-id="70209-646">Las secuencias de representación planeadas cuidadosamente se usan para impedir que se produzcan los cambios de estado y las concatenaciones de llamadas a Draw.</span><span class="sxs-lookup"><span data-stu-id="70209-646">Carefully planned render sequences are used to prevent state change and draw call concatenations from occurring.</span></span> <span data-ttu-id="70209-647">El truco es evitar que las optimizaciones se produzcan durante la generación de perfiles, de modo que los números que genere sean números de presupuesto razonables.</span><span class="sxs-lookup"><span data-stu-id="70209-647">The trick is to prevent the optimizations from happening during profiling so that the numbers you generate are reasonable budgeting numbers.</span></span>

> [!Note]  
> <span data-ttu-id="70209-648">La duplicación de esta estrategia de generación de perfiles en una aplicación sin el mecanismo de consulta es más difícil.</span><span class="sxs-lookup"><span data-stu-id="70209-648">Duplicating this profiling strategy in an application without the query mechanism is more difficult.</span></span> <span data-ttu-id="70209-649">Antes de Direct3D 9, la única manera predecible de vaciar el búfer de comandos es bloquear una superficie activa (como un destino de representación) para esperar hasta que la GPU esté inactiva.</span><span class="sxs-lookup"><span data-stu-id="70209-649">Prior to Direct3D 9 the only predictable way to empty the command buffer is to lock an active surface (such as a render target) to wait until the GPU is idle.</span></span> <span data-ttu-id="70209-650">Esto se debe a que el bloqueo de una superficie obliga al tiempo de ejecución a vaciar el búfer de comandos en caso de que haya algún comando de representación en el búfer que deba actualizar la superficie antes de que se bloquee, además de esperar a que la GPU finalice.</span><span class="sxs-lookup"><span data-stu-id="70209-650">This is because locking a surface forces the runtime to empty the command buffer in case there are any rendering commands in the buffer that should update the surface before it gets locked, in addition to waiting for the GPU to finish.</span></span> <span data-ttu-id="70209-651">Esta técnica es funcional, aunque es más molesta que usar el mecanismo de consulta incluido en Direct3D 9.</span><span class="sxs-lookup"><span data-stu-id="70209-651">This technique is functional, although it is more obtrusive that using the query mechanism introduced in Direct3D 9.</span></span>

 

## <a name="appendix"></a><span data-ttu-id="70209-652">Apéndice</span><span class="sxs-lookup"><span data-stu-id="70209-652">Appendix</span></span>

<span data-ttu-id="70209-653">Los números de esta tabla son una serie de aproximaciones para la cantidad de trabajo de controlador y en tiempo de ejecución asociado a cada uno de estos cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="70209-653">The numbers in this table are a range of approximations for the amount of runtime and driver work associated with each of these state changes.</span></span> <span data-ttu-id="70209-654">Las aproximaciones se basan en las medidas reales realizadas en los controladores mediante las técnicas que se muestran en el documento.</span><span class="sxs-lookup"><span data-stu-id="70209-654">The approximations are based on actual measurements made on drivers using the techniques shown in the paper.</span></span> <span data-ttu-id="70209-655">Estos números se generaron mediante el tiempo de ejecución de Direct3D 9 y dependen del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-655">These numbers were generated using the Direct3D 9 runtime and are driver-dependent.</span></span>

<span data-ttu-id="70209-656">Las técnicas de este documento están diseñadas para medir el funcionamiento del tiempo de ejecución y del controlador.</span><span class="sxs-lookup"><span data-stu-id="70209-656">The techniques in this paper are designed to measure runtime and driver work.</span></span> <span data-ttu-id="70209-657">En general, no es práctico proporcionar resultados que coincidan con el rendimiento de la CPU y la GPU en todas las aplicaciones, ya que esto requeriría una matriz exhaustiva de secuencias de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-657">In general, it is impractical to provide results that match the performance of the CPU and the GPU in every application as this would require an exhaustive array of render sequences.</span></span> <span data-ttu-id="70209-658">Además, es especialmente difícil el rendimiento de las pruebas comparativas de la GPU, ya que depende en gran medida de la configuración de estado de la canalización antes de la secuencia de representación.</span><span class="sxs-lookup"><span data-stu-id="70209-658">In addition, it is particularly difficult to benchmark performance of the GPU because it is highly dependent on the state setup in the pipeline before the render sequence.</span></span> <span data-ttu-id="70209-659">Por ejemplo, la habilitación de la combinación alfa no afecta a la cantidad de trabajo necesario para la CPU, pero puede tener un gran impacto en la cantidad de trabajo realizado por la GPU.</span><span class="sxs-lookup"><span data-stu-id="70209-659">For instance, enabling alpha blending does little to affect the amount of CPU work necessary, but can have a big impact on the amount of work done by the GPU.</span></span> <span data-ttu-id="70209-660">Por lo tanto, las técnicas de este documento restringen el trabajo de la GPU a la cantidad mínima posible limitando la cantidad de datos que se deben representar.</span><span class="sxs-lookup"><span data-stu-id="70209-660">Therefore, the techniques in this paper constrain the GPU work to the minimum amount possible by limiting the amount of data that needs to be rendered.</span></span> <span data-ttu-id="70209-661">Esto significa que los números de la tabla coincidirán más estrechamente con los resultados obtenidos de las aplicaciones limitadas por la CPU (en lugar de a una aplicación limitada por la GPU).</span><span class="sxs-lookup"><span data-stu-id="70209-661">This means that the numbers in the table will most closely match the results attained from applications that are CPU limited (as opposed to an application that is limited by the GPU).</span></span>

<span data-ttu-id="70209-662">Se recomienda usar las técnicas que se presentan para cubrir los escenarios y configuraciones más importantes para usted.</span><span class="sxs-lookup"><span data-stu-id="70209-662">You are encouraged to use the techniques presented to cover the scenarios and configurations most important to you.</span></span> <span data-ttu-id="70209-663">Los valores de la tabla se pueden utilizar para comparar con los números que genera.</span><span class="sxs-lookup"><span data-stu-id="70209-663">The values in the table can be used to compare with the numbers you generate.</span></span> <span data-ttu-id="70209-664">Puesto que cada controlador varía, la única manera de generar los números reales que verá es generar resultados de generación de perfiles con los escenarios.</span><span class="sxs-lookup"><span data-stu-id="70209-664">Since each driver varies, the only way to generate the actual numbers you will see is to generate profiling results using your scenarios.</span></span>



| <span data-ttu-id="70209-665">Llamada a la API</span><span class="sxs-lookup"><span data-stu-id="70209-665">API Call</span></span>                             | <span data-ttu-id="70209-666">Número promedio de ciclos</span><span class="sxs-lookup"><span data-stu-id="70209-666">Average number of Cycles</span></span> |
|--------------------------------------|--------------------------|
| <span data-ttu-id="70209-667">SetVertexDeclaration</span><span class="sxs-lookup"><span data-stu-id="70209-667">SetVertexDeclaration</span></span>                 | <span data-ttu-id="70209-668">6500-11250</span><span class="sxs-lookup"><span data-stu-id="70209-668">6500 - 11250</span></span>             |
| <span data-ttu-id="70209-669">SetFVF</span><span class="sxs-lookup"><span data-stu-id="70209-669">SetFVF</span></span>                               | <span data-ttu-id="70209-670">6400-11200</span><span class="sxs-lookup"><span data-stu-id="70209-670">6400 - 11200</span></span>             |
| <span data-ttu-id="70209-671">SetVertexShader</span><span class="sxs-lookup"><span data-stu-id="70209-671">SetVertexShader</span></span>                      | <span data-ttu-id="70209-672">3000-12100</span><span class="sxs-lookup"><span data-stu-id="70209-672">3000 - 12100</span></span>             |
| <span data-ttu-id="70209-673">SetPixelShader</span><span class="sxs-lookup"><span data-stu-id="70209-673">SetPixelShader</span></span>                       | <span data-ttu-id="70209-674">6300-7000</span><span class="sxs-lookup"><span data-stu-id="70209-674">6300 - 7000</span></span>              |
| <span data-ttu-id="70209-675">SPECULARENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-675">SPECULARENABLE</span></span>                       | <span data-ttu-id="70209-676">1900-11200</span><span class="sxs-lookup"><span data-stu-id="70209-676">1900 - 11200</span></span>             |
| <span data-ttu-id="70209-677">SetRenderTarget</span><span class="sxs-lookup"><span data-stu-id="70209-677">SetRenderTarget</span></span>                      | <span data-ttu-id="70209-678">6000-6250</span><span class="sxs-lookup"><span data-stu-id="70209-678">6000 - 6250</span></span>              |
| <span data-ttu-id="70209-679">SetPixelShaderConstant (1 constante)</span><span class="sxs-lookup"><span data-stu-id="70209-679">SetPixelShaderConstant (1 Constant)</span></span>  | <span data-ttu-id="70209-680">1500-9000</span><span class="sxs-lookup"><span data-stu-id="70209-680">1500 - 9000</span></span>              |
| <span data-ttu-id="70209-681">NORMALIZENORMALS</span><span class="sxs-lookup"><span data-stu-id="70209-681">NORMALIZENORMALS</span></span>                     | <span data-ttu-id="70209-682">2200-8100</span><span class="sxs-lookup"><span data-stu-id="70209-682">2200 - 8100</span></span>              |
| <span data-ttu-id="70209-683">LightEnable</span><span class="sxs-lookup"><span data-stu-id="70209-683">LightEnable</span></span>                          | <span data-ttu-id="70209-684">1300-9000</span><span class="sxs-lookup"><span data-stu-id="70209-684">1300 - 9000</span></span>              |
| <span data-ttu-id="70209-685">SetStreamSource</span><span class="sxs-lookup"><span data-stu-id="70209-685">SetStreamSource</span></span>                      | <span data-ttu-id="70209-686">3700-5800</span><span class="sxs-lookup"><span data-stu-id="70209-686">3700 - 5800</span></span>              |
| <span data-ttu-id="70209-687">ILUMINACIÓN</span><span class="sxs-lookup"><span data-stu-id="70209-687">LIGHTING</span></span>                             | <span data-ttu-id="70209-688">1700-7500</span><span class="sxs-lookup"><span data-stu-id="70209-688">1700 - 7500</span></span>              |
| <span data-ttu-id="70209-689">DIFFUSEMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="70209-689">DIFFUSEMATERIALSOURCE</span></span>                | <span data-ttu-id="70209-690">900-8300</span><span class="sxs-lookup"><span data-stu-id="70209-690">900 - 8300</span></span>               |
| <span data-ttu-id="70209-691">AMBIENTMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="70209-691">AMBIENTMATERIALSOURCE</span></span>                | <span data-ttu-id="70209-692">900-8200</span><span class="sxs-lookup"><span data-stu-id="70209-692">900 - 8200</span></span>               |
| <span data-ttu-id="70209-693">COLORVERTEX</span><span class="sxs-lookup"><span data-stu-id="70209-693">COLORVERTEX</span></span>                          | <span data-ttu-id="70209-694">800-7800</span><span class="sxs-lookup"><span data-stu-id="70209-694">800 - 7800</span></span>               |
| <span data-ttu-id="70209-695">SetLight</span><span class="sxs-lookup"><span data-stu-id="70209-695">SetLight</span></span>                             | <span data-ttu-id="70209-696">2200-5100</span><span class="sxs-lookup"><span data-stu-id="70209-696">2200 - 5100</span></span>              |
| <span data-ttu-id="70209-697">SetTransform</span><span class="sxs-lookup"><span data-stu-id="70209-697">SetTransform</span></span>                         | <span data-ttu-id="70209-698">3200-3750</span><span class="sxs-lookup"><span data-stu-id="70209-698">3200 - 3750</span></span>              |
| <span data-ttu-id="70209-699">SetIndices</span><span class="sxs-lookup"><span data-stu-id="70209-699">SetIndices</span></span>                           | <span data-ttu-id="70209-700">900-5600</span><span class="sxs-lookup"><span data-stu-id="70209-700">900 - 5600</span></span>               |
| <span data-ttu-id="70209-701">AMBIENTES</span><span class="sxs-lookup"><span data-stu-id="70209-701">AMBIENT</span></span>                              | <span data-ttu-id="70209-702">1150-4800</span><span class="sxs-lookup"><span data-stu-id="70209-702">1150 - 4800</span></span>              |
| <span data-ttu-id="70209-703">SetTexture</span><span class="sxs-lookup"><span data-stu-id="70209-703">SetTexture</span></span>                           | <span data-ttu-id="70209-704">2500-3100</span><span class="sxs-lookup"><span data-stu-id="70209-704">2500 - 3100</span></span>              |
| <span data-ttu-id="70209-705">SPECULARMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="70209-705">SPECULARMATERIALSOURCE</span></span>               | <span data-ttu-id="70209-706">900-4600</span><span class="sxs-lookup"><span data-stu-id="70209-706">900 - 4600</span></span>               |
| <span data-ttu-id="70209-707">EMISSIVEMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="70209-707">EMISSIVEMATERIALSOURCE</span></span>               | <span data-ttu-id="70209-708">900-4500</span><span class="sxs-lookup"><span data-stu-id="70209-708">900 - 4500</span></span>               |
| <span data-ttu-id="70209-709">SetMaterial</span><span class="sxs-lookup"><span data-stu-id="70209-709">SetMaterial</span></span>                          | <span data-ttu-id="70209-710">1000-3700</span><span class="sxs-lookup"><span data-stu-id="70209-710">1000 - 3700</span></span>              |
| <span data-ttu-id="70209-711">ZENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-711">ZENABLE</span></span>                              | <span data-ttu-id="70209-712">700-3900</span><span class="sxs-lookup"><span data-stu-id="70209-712">700 - 3900</span></span>               |
| <span data-ttu-id="70209-713">WRAP0</span><span class="sxs-lookup"><span data-stu-id="70209-713">WRAP0</span></span>                                | <span data-ttu-id="70209-714">1600-2700</span><span class="sxs-lookup"><span data-stu-id="70209-714">1600 - 2700</span></span>              |
| <span data-ttu-id="70209-715">MINFILTER</span><span class="sxs-lookup"><span data-stu-id="70209-715">MINFILTER</span></span>                            | <span data-ttu-id="70209-716">1700-2500</span><span class="sxs-lookup"><span data-stu-id="70209-716">1700 - 2500</span></span>              |
| <span data-ttu-id="70209-717">MAGFILTER</span><span class="sxs-lookup"><span data-stu-id="70209-717">MAGFILTER</span></span>                            | <span data-ttu-id="70209-718">1700-2400</span><span class="sxs-lookup"><span data-stu-id="70209-718">1700 - 2400</span></span>              |
| <span data-ttu-id="70209-719">SetVertexShaderConstant (1 constante)</span><span class="sxs-lookup"><span data-stu-id="70209-719">SetVertexShaderConstant (1 Constant)</span></span> | <span data-ttu-id="70209-720">1000-2700</span><span class="sxs-lookup"><span data-stu-id="70209-720">1000 - 2700</span></span>              |
| <span data-ttu-id="70209-721">COLOROP</span><span class="sxs-lookup"><span data-stu-id="70209-721">COLOROP</span></span>                              | <span data-ttu-id="70209-722">1500-2100</span><span class="sxs-lookup"><span data-stu-id="70209-722">1500 - 2100</span></span>              |
| <span data-ttu-id="70209-723">COLORARG2</span><span class="sxs-lookup"><span data-stu-id="70209-723">COLORARG2</span></span>                            | <span data-ttu-id="70209-724">1300-2000</span><span class="sxs-lookup"><span data-stu-id="70209-724">1300 - 2000</span></span>              |
| <span data-ttu-id="70209-725">COLORARG1</span><span class="sxs-lookup"><span data-stu-id="70209-725">COLORARG1</span></span>                            | <span data-ttu-id="70209-726">1300-1980</span><span class="sxs-lookup"><span data-stu-id="70209-726">1300 - 1980</span></span>              |
| <span data-ttu-id="70209-727">CULLMODE</span><span class="sxs-lookup"><span data-stu-id="70209-727">CULLMODE</span></span>                             | <span data-ttu-id="70209-728">500-2570</span><span class="sxs-lookup"><span data-stu-id="70209-728">500 - 2570</span></span>               |
| <span data-ttu-id="70209-729">SALTE</span><span class="sxs-lookup"><span data-stu-id="70209-729">CLIPPING</span></span>                             | <span data-ttu-id="70209-730">500-2550</span><span class="sxs-lookup"><span data-stu-id="70209-730">500 - 2550</span></span>               |
| <span data-ttu-id="70209-731">DrawIndexedPrimitive</span><span class="sxs-lookup"><span data-stu-id="70209-731">DrawIndexedPrimitive</span></span>                 | <span data-ttu-id="70209-732">1200-1400</span><span class="sxs-lookup"><span data-stu-id="70209-732">1200 - 1400</span></span>              |
| <span data-ttu-id="70209-733">ADDRESSV</span><span class="sxs-lookup"><span data-stu-id="70209-733">ADDRESSV</span></span>                             | <span data-ttu-id="70209-734">1090-1500</span><span class="sxs-lookup"><span data-stu-id="70209-734">1090 - 1500</span></span>              |
| <span data-ttu-id="70209-735">ADDRESSU</span><span class="sxs-lookup"><span data-stu-id="70209-735">ADDRESSU</span></span>                             | <span data-ttu-id="70209-736">1070-1500</span><span class="sxs-lookup"><span data-stu-id="70209-736">1070 - 1500</span></span>              |
| <span data-ttu-id="70209-737">DrawPrimitive</span><span class="sxs-lookup"><span data-stu-id="70209-737">DrawPrimitive</span></span>                        | <span data-ttu-id="70209-738">1050-1150</span><span class="sxs-lookup"><span data-stu-id="70209-738">1050 - 1150</span></span>              |
| <span data-ttu-id="70209-739">SRGBTEXTURE</span><span class="sxs-lookup"><span data-stu-id="70209-739">SRGBTEXTURE</span></span>                          | <span data-ttu-id="70209-740">150-1500</span><span class="sxs-lookup"><span data-stu-id="70209-740">150 - 1500</span></span>               |
| <span data-ttu-id="70209-741">STENCILMASK</span><span class="sxs-lookup"><span data-stu-id="70209-741">STENCILMASK</span></span>                          | <span data-ttu-id="70209-742">570-700</span><span class="sxs-lookup"><span data-stu-id="70209-742">570 - 700</span></span>                |
| <span data-ttu-id="70209-743">STENCILZFAIL</span><span class="sxs-lookup"><span data-stu-id="70209-743">STENCILZFAIL</span></span>                         | <span data-ttu-id="70209-744">500-800</span><span class="sxs-lookup"><span data-stu-id="70209-744">500 - 800</span></span>                |
| <span data-ttu-id="70209-745">STENCILREF</span><span class="sxs-lookup"><span data-stu-id="70209-745">STENCILREF</span></span>                           | <span data-ttu-id="70209-746">550-700</span><span class="sxs-lookup"><span data-stu-id="70209-746">550 - 700</span></span>                |
| <span data-ttu-id="70209-747">ALPHABLENDENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-747">ALPHABLENDENABLE</span></span>                     | <span data-ttu-id="70209-748">550-700</span><span class="sxs-lookup"><span data-stu-id="70209-748">550 - 700</span></span>                |
| <span data-ttu-id="70209-749">STENCILFUNC</span><span class="sxs-lookup"><span data-stu-id="70209-749">STENCILFUNC</span></span>                          | <span data-ttu-id="70209-750">560-680</span><span class="sxs-lookup"><span data-stu-id="70209-750">560 - 680</span></span>                |
| <span data-ttu-id="70209-751">STENCILWRITEMASK</span><span class="sxs-lookup"><span data-stu-id="70209-751">STENCILWRITEMASK</span></span>                     | <span data-ttu-id="70209-752">520-700</span><span class="sxs-lookup"><span data-stu-id="70209-752">520 - 700</span></span>                |
| <span data-ttu-id="70209-753">STENCILFAIL</span><span class="sxs-lookup"><span data-stu-id="70209-753">STENCILFAIL</span></span>                          | <span data-ttu-id="70209-754">500-750</span><span class="sxs-lookup"><span data-stu-id="70209-754">500 - 750</span></span>                |
| <span data-ttu-id="70209-755">ZFUNC</span><span class="sxs-lookup"><span data-stu-id="70209-755">ZFUNC</span></span>                                | <span data-ttu-id="70209-756">510-700</span><span class="sxs-lookup"><span data-stu-id="70209-756">510 - 700</span></span>                |
| <span data-ttu-id="70209-757">ZWRITEENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-757">ZWRITEENABLE</span></span>                         | <span data-ttu-id="70209-758">520-680</span><span class="sxs-lookup"><span data-stu-id="70209-758">520 - 680</span></span>                |
| <span data-ttu-id="70209-759">STENCILENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-759">STENCILENABLE</span></span>                        | <span data-ttu-id="70209-760">540-650</span><span class="sxs-lookup"><span data-stu-id="70209-760">540 - 650</span></span>                |
| <span data-ttu-id="70209-761">STENCILPASS</span><span class="sxs-lookup"><span data-stu-id="70209-761">STENCILPASS</span></span>                          | <span data-ttu-id="70209-762">560-630</span><span class="sxs-lookup"><span data-stu-id="70209-762">560 - 630</span></span>                |
| <span data-ttu-id="70209-763">SRCBLEND</span><span class="sxs-lookup"><span data-stu-id="70209-763">SRCBLEND</span></span>                             | <span data-ttu-id="70209-764">500-685</span><span class="sxs-lookup"><span data-stu-id="70209-764">500 - 685</span></span>                |
| <span data-ttu-id="70209-765">Dos \_ \_ StencilMODE</span><span class="sxs-lookup"><span data-stu-id="70209-765">Two\_Sided\_StencilMODE</span></span>              | <span data-ttu-id="70209-766">450-590</span><span class="sxs-lookup"><span data-stu-id="70209-766">450 - 590</span></span>                |
| <span data-ttu-id="70209-767">ALPHATESTENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-767">ALPHATESTENABLE</span></span>                      | <span data-ttu-id="70209-768">470-525</span><span class="sxs-lookup"><span data-stu-id="70209-768">470 - 525</span></span>                |
| <span data-ttu-id="70209-769">ALPHAREF</span><span class="sxs-lookup"><span data-stu-id="70209-769">ALPHAREF</span></span>                             | <span data-ttu-id="70209-770">460-530</span><span class="sxs-lookup"><span data-stu-id="70209-770">460 - 530</span></span>                |
| <span data-ttu-id="70209-771">ALPHAFUNC</span><span class="sxs-lookup"><span data-stu-id="70209-771">ALPHAFUNC</span></span>                            | <span data-ttu-id="70209-772">450-540</span><span class="sxs-lookup"><span data-stu-id="70209-772">450 - 540</span></span>                |
| <span data-ttu-id="70209-773">DESTBLEND</span><span class="sxs-lookup"><span data-stu-id="70209-773">DESTBLEND</span></span>                            | <span data-ttu-id="70209-774">475-510</span><span class="sxs-lookup"><span data-stu-id="70209-774">475 - 510</span></span>                |
| <span data-ttu-id="70209-775">COLORWRITEENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-775">COLORWRITEENABLE</span></span>                     | <span data-ttu-id="70209-776">465-515</span><span class="sxs-lookup"><span data-stu-id="70209-776">465 - 515</span></span>                |
| <span data-ttu-id="70209-777">CCW \_ STENCILFAIL</span><span class="sxs-lookup"><span data-stu-id="70209-777">CCW\_STENCILFAIL</span></span>                     | <span data-ttu-id="70209-778">340-560</span><span class="sxs-lookup"><span data-stu-id="70209-778">340 - 560</span></span>                |
| <span data-ttu-id="70209-779">CCW \_ STENCILPASS</span><span class="sxs-lookup"><span data-stu-id="70209-779">CCW\_STENCILPASS</span></span>                     | <span data-ttu-id="70209-780">340-545</span><span class="sxs-lookup"><span data-stu-id="70209-780">340 - 545</span></span>                |
| <span data-ttu-id="70209-781">CCW \_ STENCILZFAIL</span><span class="sxs-lookup"><span data-stu-id="70209-781">CCW\_STENCILZFAIL</span></span>                    | <span data-ttu-id="70209-782">330-495</span><span class="sxs-lookup"><span data-stu-id="70209-782">330 - 495</span></span>                |
| <span data-ttu-id="70209-783">SCISSORTESTENABLE</span><span class="sxs-lookup"><span data-stu-id="70209-783">SCISSORTESTENABLE</span></span>                    | <span data-ttu-id="70209-784">375-440</span><span class="sxs-lookup"><span data-stu-id="70209-784">375 - 440</span></span>                |
| <span data-ttu-id="70209-785">CCW \_ STENCILFUNC</span><span class="sxs-lookup"><span data-stu-id="70209-785">CCW\_STENCILFUNC</span></span>                     | <span data-ttu-id="70209-786">250-480</span><span class="sxs-lookup"><span data-stu-id="70209-786">250 - 480</span></span>                |
| <span data-ttu-id="70209-787">SetScissorRect</span><span class="sxs-lookup"><span data-stu-id="70209-787">SetScissorRect</span></span>                       | <span data-ttu-id="70209-788">150-340</span><span class="sxs-lookup"><span data-stu-id="70209-788">150 - 340</span></span>                |



 

## <a name="related-topics"></a><span data-ttu-id="70209-789">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="70209-789">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="70209-790">Temas avanzados</span><span class="sxs-lookup"><span data-stu-id="70209-790">Advanced Topics</span></span>](advanced-topics.md)
</dt> </dl>

 

 
