---
title: Aplicaciones auxiliares de implementación de servidor fuera de proceso
description: Aplicaciones auxiliares de implementación de servidor fuera de proceso
ms.assetid: 18641a84-56f8-4d27-9ddb-fa64011ac8ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 264d3f26b179b3ecb659ef93785c8c223b6c524e
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/21/2020
ms.locfileid: "104421469"
---
# <a name="out-of-process-server-implementation-helpers"></a><span data-ttu-id="28463-103">Aplicaciones auxiliares de implementación de servidor fuera de proceso</span><span class="sxs-lookup"><span data-stu-id="28463-103">Out-of-Process Server Implementation Helpers</span></span>

<span data-ttu-id="28463-104">Hay cuatro funciones auxiliares a las que pueden llamar los servidores fuera de proceso para simplificar el trabajo de escritura de código de servidor.</span><span class="sxs-lookup"><span data-stu-id="28463-104">Four helper functions that can be called by out-of-process servers are available to simplify the job of writing server code.</span></span> <span data-ttu-id="28463-105">Los clientes COM y los servidores en proceso COM normalmente no los llamarán.</span><span class="sxs-lookup"><span data-stu-id="28463-105">COM clients and COM in-process servers typically would not call them.</span></span> <span data-ttu-id="28463-106">Estas funciones están diseñadas para ayudar a evitar condiciones de carrera en la activación del servidor cuando los servidores tienen varios apartamentos o varios objetos de clase.</span><span class="sxs-lookup"><span data-stu-id="28463-106">These functions are designed to help prevent race conditions in server activation when the servers have multiple apartments or multiple class objects.</span></span> <span data-ttu-id="28463-107">Sin embargo, también se pueden usar con facilidad para servidores de objetos de un solo subproceso y de una sola clase.</span><span class="sxs-lookup"><span data-stu-id="28463-107">They can also, however, as easily be used for single-threaded and single class object servers.</span></span> <span data-ttu-id="28463-108">Las funciones son las siguientes:</span><span class="sxs-lookup"><span data-stu-id="28463-108">The functions are as follows:</span></span>

-   [<span data-ttu-id="28463-109">**CoAddRefServerProcess**</span><span class="sxs-lookup"><span data-stu-id="28463-109">**CoAddRefServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess)
-   [<span data-ttu-id="28463-110">**CoReleaseServerProcess**</span><span class="sxs-lookup"><span data-stu-id="28463-110">**CoReleaseServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)
-   [<span data-ttu-id="28463-111">**CoSuspendClassObjects**</span><span class="sxs-lookup"><span data-stu-id="28463-111">**CoSuspendClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)
-   [<span data-ttu-id="28463-112">**CoResumeClassObjects**</span><span class="sxs-lookup"><span data-stu-id="28463-112">**CoResumeClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)

<span data-ttu-id="28463-113">Para cerrar correctamente, un servidor COM debe realizar un seguimiento del número de instancias de objeto de las que se ha creado una instancia y el número de veces que se ha llamado al método [**IClassFactory:: lockserver (**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) .</span><span class="sxs-lookup"><span data-stu-id="28463-113">To shut down properly, a COM server must keep track of how many object instances it has instantiated and how many times its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method has been called.</span></span> <span data-ttu-id="28463-114">Solo cuando ambos recuentos llegan a cero, se puede apagar un servidor.</span><span class="sxs-lookup"><span data-stu-id="28463-114">Only when both of these counts reach zero can a server shut down.</span></span> <span data-ttu-id="28463-115">En los servidores COM de un solo subproceso, la decisión de apagarse se coordinaba con las solicitudes de activación entrantes, que se serializaron en la cola de mensajes.</span><span class="sxs-lookup"><span data-stu-id="28463-115">In single-threaded COM servers, the decision to shut down was coordinated with incoming activation requests, which were serialized by the message queue.</span></span> <span data-ttu-id="28463-116">El servidor, al recibir una versión en su instancia de objeto final y decidir cerrarse, revocaría sus objetos de clase antes de que se envíen más solicitudes de activación.</span><span class="sxs-lookup"><span data-stu-id="28463-116">The server, upon receiving a release on its final object instance and deciding to shut down, would revoke its class objects before any more activation requests were dispatched.</span></span> <span data-ttu-id="28463-117">Si una solicitud de activación se realizó después de este punto, COM reconocía que los objetos de clase se revocaron y devolvería un error al administrador de control de servicios (SCM), lo que provocaría la ejecución de una nueva instancia del proceso del servidor local.</span><span class="sxs-lookup"><span data-stu-id="28463-117">If an activation request did come in after this point, COM would recognize that the class objects were revoked and would return an error to the Service Control Manager (SCM), which would then cause a new instance of the local server process to be run.</span></span>

<span data-ttu-id="28463-118">Sin embargo, en un servidor de modelo de apartamento, en el que los distintos objetos de clase se registran en distintos apartamentos y en todos los servidores de subprocesos libres, esta decisión de apagarse debe coordinarse con solicitudes de activación entre varios subprocesos, de modo que un subproceso del servidor no decida cerrarse mientras otro subproceso del servidor esté ocupado entregando objetos de clase u</span><span class="sxs-lookup"><span data-stu-id="28463-118">However, in an apartment model server, in which different class objects are registered on different apartments, and in all free-threaded servers, this decision to shut down must be coordinated with activation requests across multiple threads so that one thread of the server does not decide to shut down while another thread of the server is busy handing out class objects or object instances.</span></span> <span data-ttu-id="28463-119">Un enfoque clásico pero engorroso para solucionar este error consiste en tener el servidor, una vez que haya revocado sus objetos de clase, debe volver a comprobar su recuento de instancias y permanecer activo hasta que se liberen todas las instancias.</span><span class="sxs-lookup"><span data-stu-id="28463-119">One classical but cumbersome approach to solving this is to have the server, after it has revoked its class objects, recheck its instance count and stay alive until all instances have been released.</span></span>

<span data-ttu-id="28463-120">Para facilitar a los escritores de servidor la administración de estos tipos de condiciones de carrera, COM proporciona dos funciones de recuento de referencias:</span><span class="sxs-lookup"><span data-stu-id="28463-120">To make it easier for server writers to handle these types of race conditions, COM provides two reference counting functions:</span></span>

-   <span data-ttu-id="28463-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) incrementa un recuento de referencias por proceso global.</span><span class="sxs-lookup"><span data-stu-id="28463-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) increments a global per-process reference count.</span></span>
-   <span data-ttu-id="28463-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) disminuye el recuento de referencias por proceso global.</span><span class="sxs-lookup"><span data-stu-id="28463-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrements the global per-process reference count.</span></span>

<span data-ttu-id="28463-123">Cuando el recuento de referencias por proceso globales llega a cero, COM llama automáticamente a [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), lo que impide que se produzcan nuevas solicitudes de activación.</span><span class="sxs-lookup"><span data-stu-id="28463-123">When the global per-process reference count reaches zero, COM automatically calls [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), which prevents any new activation requests from coming in.</span></span> <span data-ttu-id="28463-124">Después, el servidor puede anular el registro de los distintos objetos de clase de sus distintos subprocesos en tiempo de ocio sin preocuparse de que se pueda entrar en otra solicitud de activación.</span><span class="sxs-lookup"><span data-stu-id="28463-124">The server can then deregister its various class objects from its various threads at leisure without worry that another activation request may come in.</span></span> <span data-ttu-id="28463-125">El SCM administra todas las nuevas solicitudes de activación iniciando una nueva instancia del proceso del servidor local.</span><span class="sxs-lookup"><span data-stu-id="28463-125">All new activation requests are henceforth handled by the SCM launching a new instance of the local server process.</span></span>

<span data-ttu-id="28463-126">La manera más sencilla de que una aplicación de servidor local haga uso de estas funciones es llamar a [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) en el constructor para cada uno de sus objetos de instancia y en cada uno de sus métodos [**IClassFactory:: lockserver (**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) cuando el parámetro de *rebaño* sea **true**.</span><span class="sxs-lookup"><span data-stu-id="28463-126">The simplest way for a local server application to make use of these functions is to call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) in the constructor for each of its instance objects and in each of its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) methods when the *fLock* parameter is **TRUE**.</span></span> <span data-ttu-id="28463-127">La aplicación de servidor también debe llamar a [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) en el destructor de cada uno de sus objetos de instancia y en cada uno de sus métodos IClassFactory::**lockserver (** cuando el parámetro de *rebaño* es **false**.</span><span class="sxs-lookup"><span data-stu-id="28463-127">The server application should also call [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) in the destructor of each of its instance objects and in each of its IClassFactory::**LockServer** methods when the *fLock* parameter is **FALSE**.</span></span>

<span data-ttu-id="28463-128">Por último, la aplicación de servidor debe prestar atención al código de retorno de [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)y, si devuelve 0, la aplicación de servidor debe iniciar su limpieza, que, para un servidor con varios subprocesos, normalmente significa que debe señalar sus distintos subprocesos para salir de los bucles de mensajes y llamar a [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) y [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span><span class="sxs-lookup"><span data-stu-id="28463-128">Finally, the server application should pay attention to the return code from [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) and [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span></span> <span data-ttu-id="28463-129">Si se usan las funciones de administración de la duración del proceso del servidor, se deben usar tanto en las instancias de objeto como en el método [**lockserver (**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) . de lo contrario, la aplicación de servidor se puede cerrar prematuramente.</span><span class="sxs-lookup"><span data-stu-id="28463-129">If the server process lifetime management functions are used, they must be used in both the object instances and the [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method; otherwise, the server application may be shut down prematurely.</span></span>

<span data-ttu-id="28463-130">Cuando se realiza una solicitud [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) , com se pone en contacto con el servidor, calcula las referencias de la interfaz [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) del objeto de clase, vuelve al proceso del cliente, anula la serialización de la interfaz **IClassFactory** y lo devuelve al cliente.</span><span class="sxs-lookup"><span data-stu-id="28463-130">When a [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) request is made, COM contacts the server, marshals the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface of the class object, returns to the client process, unmarshals the **IClassFactory** interface, and returns this to the client.</span></span> <span data-ttu-id="28463-131">En este momento, los clientes suelen llamar a [**lockserver (**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) con **true** para evitar que el proceso del servidor se cierre.</span><span class="sxs-lookup"><span data-stu-id="28463-131">At this point, clients typically call [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) with **TRUE** to prevent the server process from shutting down.</span></span> <span data-ttu-id="28463-132">Sin embargo, hay una ventana de tiempo entre el momento en el que se calculan las referencias del objeto de clase y el momento en el que el cliente llama a **lockserver (** en el que otro cliente podría conectarse al mismo servidor, obtener una instancia de y liberar esa instancia, lo que provoca que el servidor se apague y deje el primer cliente alto y seco con un puntero **IClassFactory** desconectado.</span><span class="sxs-lookup"><span data-stu-id="28463-132">However, there is a window of time between when the class object is marshaled and when the client calls **LockServer** in which another client could connect to the same server, get an instance, and release that instance, thus causing the server to shut down and leaving the first client high and dry with a disconnected **IClassFactory** pointer.</span></span> <span data-ttu-id="28463-133">Para evitar esta condición de carrera, COM agrega una llamada implícita a **lockserver (** con **true** al objeto de clase cuando calcula las referencias de la interfaz **IClassFactory** y una llamada implícita a **lockserver (** con **false** cuando el cliente libera la interfaz **IClassFactory** .</span><span class="sxs-lookup"><span data-stu-id="28463-133">To prevent this race condition, COM adds an implicit call to **LockServer** with **TRUE** to the class object when it marshals the **IClassFactory** interface and an implicit call to **LockServer** with **FALSE** when the client releases the **IClassFactory** interface.</span></span> <span data-ttu-id="28463-134">Por lo tanto, no es necesario volver a **lockserver (** las llamadas remotas al servidor, y el proxy de **Lockserver (** simplemente devuelve S \_ OK sin realmente la comunicación remota de la llamada.</span><span class="sxs-lookup"><span data-stu-id="28463-134">Therefore, it is not necessary to remote **LockServer** calls back to the server, and the proxy for **LockServer** simply returns S\_OK without actually remoting the call.</span></span>

<span data-ttu-id="28463-135">Hay otra condición de carrera relacionada con la activación durante la inicialización de un proceso de servidor fuera de proceso.</span><span class="sxs-lookup"><span data-stu-id="28463-135">There is another activation-related race condition during initialization of an out-of-process server process.</span></span> <span data-ttu-id="28463-136">Un servidor COM que registra varias clases normalmente llama a [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) con el \_ servidor local REGCLS \_ para cada CLSID que admite.</span><span class="sxs-lookup"><span data-stu-id="28463-136">A COM server that registers multiple classes typically calls [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER for each CLSID it supports.</span></span> <span data-ttu-id="28463-137">Una vez hecho esto para todas las clases, el servidor entra en su bucle de mensajes.</span><span class="sxs-lookup"><span data-stu-id="28463-137">After it has done this for all classes, the server enters its message loop.</span></span> <span data-ttu-id="28463-138">Para un servidor COM de un solo subproceso, todas las solicitudes de activación se bloquean hasta que el servidor entra en el bucle de mensajes.</span><span class="sxs-lookup"><span data-stu-id="28463-138">For a single-threaded COM server, all activation requests are blocked until the server enters the message loop.</span></span> <span data-ttu-id="28463-139">Sin embargo, para un servidor de modelo de apartamento que registra diferentes objetos de clase en distintos apartamentos y para todos los servidores de subprocesamiento libre, las solicitudes de activación pueden llegar antes que esta.</span><span class="sxs-lookup"><span data-stu-id="28463-139">However, for an apartment model server that registers different class objects in different apartments and for all free-threaded servers, activation requests can arrive earlier than this.</span></span> <span data-ttu-id="28463-140">En el caso de los servidores de modelo de apartamento, las solicitudes de activación podrían llegar en cuanto cualquier subproceso haya entrado en su bucle de mensajes.</span><span class="sxs-lookup"><span data-stu-id="28463-140">In the case of apartment model servers, activation requests could arrive as soon as any one thread has entered its message loop.</span></span> <span data-ttu-id="28463-141">En el caso de los servidores de subprocesamiento libre, una solicitud de activación podría llegar en cuanto se registre el primer objeto de clase.</span><span class="sxs-lookup"><span data-stu-id="28463-141">In the case of free-threaded servers, an activation request could arrive as soon as the first class object is registered.</span></span> <span data-ttu-id="28463-142">Dado que una activación puede producirse esta vez, también es posible que se produzca la versión final (y, por tanto, que el servidor comience a cerrarse) antes de que el resto del servidor haya tenido la oportunidad de finalizar la inicialización.</span><span class="sxs-lookup"><span data-stu-id="28463-142">Since an activation can happen this early, it is also possible for the final release to occur (and therefore cause the server to begin shutting down) before the rest of the server has had a chance to finish initializing.</span></span>

<span data-ttu-id="28463-143">Para eliminar estas condiciones de carrera y simplificar el trabajo del escritor de servidor, cualquier servidor que desee registrar varios objetos de clase con COM debe llamar a [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) con el \_ servidor local REGCLS \_ \| REGCLS \_ suspendido para cada CLSID diferente que el servidor admita.</span><span class="sxs-lookup"><span data-stu-id="28463-143">To eliminate these race conditions and simplify the job of the server writer, any server that wants to register multiple class objects with COM should call [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER \| REGCLS\_SUSPENDED for each different CLSID the server supports.</span></span> <span data-ttu-id="28463-144">Una vez que todas las clases se han registrado y el proceso del servidor está listo para aceptar solicitudes de activación entrantes, el servidor debe realizar una llamada a [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span><span class="sxs-lookup"><span data-stu-id="28463-144">After all classes have been registered and the server process is ready to accept incoming activation requests, the server should make one call to [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span></span> <span data-ttu-id="28463-145">Esta función indica a COM que informe al SCM acerca de todas las clases registradas y comienza a permitir las solicitudes de activación en el proceso del servidor.</span><span class="sxs-lookup"><span data-stu-id="28463-145">This function tells COM to inform the SCM about all the registered classes, and it begins letting activation requests into the server process.</span></span> <span data-ttu-id="28463-146">El uso de estas funciones proporciona las siguientes ventajas:</span><span class="sxs-lookup"><span data-stu-id="28463-146">Using these functions provides the following advantages:</span></span>

-   <span data-ttu-id="28463-147">Solo se realiza una llamada al SCM, independientemente de cuántos CLSID estén registrados, lo que reduce el tiempo de registro global (y, por tanto, el tiempo de inicio de la aplicación de servidor).</span><span class="sxs-lookup"><span data-stu-id="28463-147">Only one call is made to the SCM, regardless of how many CLSIDs are registered, thus reducing the overall registration time (and hence startup time of the server application).</span></span>
-   <span data-ttu-id="28463-148">Si el servidor tiene varios apartamentos y los distintos CLSID se registran en distintos apartamentos, o si el servidor es un servidor de subprocesamiento libre, no habrá ninguna solicitud de activación hasta que el servidor llame a [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), lo que proporciona al servidor una oportunidad de registrar todos sus CLSID y establecerla correctamente antes de tener que tratar con las solicitudes de activación y las posibles solicitudes de cierre.</span><span class="sxs-lookup"><span data-stu-id="28463-148">If the server has multiple apartments and different CLSIDs are registered in different apartments, or if the server is a free-threaded server, no activation requests will come in until the server calls [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), giving the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests and possible shut down requests.</span></span>

## <a name="related-topics"></a><span data-ttu-id="28463-149">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="28463-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="28463-150">Responsabilidades del servidor COM</span><span class="sxs-lookup"><span data-stu-id="28463-150">COM Server Responsibilities</span></span>](com-server-responsibilities.md)
</dt> </dl>

 

 