---
description: Una operación de clonación de bloques indica al sistema de archivos que copie un intervalo de bytes de archivo en nombre de una aplicación.
ms.assetid: E18E8D79-3985-40B8-A4C5-A73A21E5C527
title: Clonación de bloques
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b33aa1c1eee693b6ed4b502aedc6da6176ece3e9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "104546702"
---
# <a name="block-cloning"></a><span data-ttu-id="8c16b-103">Clonación de bloques</span><span class="sxs-lookup"><span data-stu-id="8c16b-103">Block Cloning</span></span>

<span data-ttu-id="8c16b-104">Una operación de *clonación de bloques* indica al sistema de archivos que copie un intervalo de bytes de archivo en nombre de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="8c16b-104">A *block clone* operation instructs the file system to copy a range of file bytes on behalf of an application.</span></span> <span data-ttu-id="8c16b-105">El archivo de destino puede ser el mismo que el archivo de origen, o distinto de él.</span><span class="sxs-lookup"><span data-stu-id="8c16b-105">The destination file may be the same as, or different from, the source file.</span></span>

<span data-ttu-id="8c16b-106">Un sistema de archivos administra las asignaciones de [clústeres y extensiones](clusters-and-extents.md), y puede ser capaz de realizar la copia modificando el número de clúster virtual (VCN) en las asignaciones de número de clúster lógico (LCN) como una operación de metadatos de bajo costo, en lugar de leer y escribir los datos de archivo subyacentes.</span><span class="sxs-lookup"><span data-stu-id="8c16b-106">A file system manages the mappings of [Clusters and Extents](clusters-and-extents.md), and may be able to perform the copy by altering the virtual cluster number (VCN) to logical cluster number (LCN) mappings as a low-cost metadata operation, rather than reading and writing the underlying file data.</span></span> <span data-ttu-id="8c16b-107">Esto permite que la copia se complete más rápido y genera menos e/s en el almacenamiento subyacente.</span><span class="sxs-lookup"><span data-stu-id="8c16b-107">This allows the copy to complete faster and generates less I/O to the underlying storage.</span></span> <span data-ttu-id="8c16b-108">Además, es posible que varios archivos compartan ahora clústeres lógicos después del clon de bloque, lo que ahorra capacidad al no almacenar clústeres idénticos varias veces en el disco.</span><span class="sxs-lookup"><span data-stu-id="8c16b-108">Moreover, multiple files may now share logical clusters after the block clone, saving capacity by not storing identical clusters multiple times on disk.</span></span>

<span data-ttu-id="8c16b-109">Una operación de clonación de bloques no interrumpe el aislamiento proporcionado entre los archivos.</span><span class="sxs-lookup"><span data-stu-id="8c16b-109">A block clone operation does not break the isolation provided between files.</span></span> <span data-ttu-id="8c16b-110">Una vez que se completa un clon de bloque, las operaciones de escritura en el archivo de código fuente no aparecen en el destino, o viceversa.</span><span class="sxs-lookup"><span data-stu-id="8c16b-110">After a block clone completes, writes to the source file do not appear in the destination, or vice versa.</span></span>

<span data-ttu-id="8c16b-111">La clonación de bloques solo está disponible en el tipo de [sistema de archivos ReFS](/windows/desktop/w8cookbook/resilient-file-system--refs-) a partir de Windows Server 2016.</span><span class="sxs-lookup"><span data-stu-id="8c16b-111">Block cloning is available only on the [ReFS file system](/windows/desktop/w8cookbook/resilient-file-system--refs-) type beginning with Windows Server 2016.</span></span>

## <a name="block-cloning-on-refs"></a><span data-ttu-id="8c16b-112">Bloquear la clonación en ReFS</span><span class="sxs-lookup"><span data-stu-id="8c16b-112">Block Cloning on ReFS</span></span>

<span data-ttu-id="8c16b-113">ReFS en Windows Server 2016 implementa la clonación de bloques mediante la reasignación de los clústeres lógicos (es decir, las ubicaciones físicas en un volumen) de la región de origen a la región de destino.</span><span class="sxs-lookup"><span data-stu-id="8c16b-113">ReFS on Windows Server 2016 implements block cloning by remapping logical clusters (that is, physical locations on a volume) from the source region to the destination region.</span></span> <span data-ttu-id="8c16b-114">A continuación, usa un mecanismo de asignación de escritura para garantizar el aislamiento entre esas regiones.</span><span class="sxs-lookup"><span data-stu-id="8c16b-114">It then uses an allocate-on-write mechanism to ensure isolation between those regions.</span></span> <span data-ttu-id="8c16b-115">Las regiones de origen y de destino pueden estar en el mismo archivo o en archivos distintos.</span><span class="sxs-lookup"><span data-stu-id="8c16b-115">The source and destination regions may be in the same, or different, files.</span></span>

<span data-ttu-id="8c16b-116">Esta implementación requiere que los desplazamientos de archivo inicial y final se alineen con los límites del clúster.</span><span class="sxs-lookup"><span data-stu-id="8c16b-116">This implementation requires that the starting and ending file offsets be aligned to cluster boundaries.</span></span> <span data-ttu-id="8c16b-117">En ReFS en Windows Server 2016, los clústeres tienen un tamaño de 4 KB de forma predeterminada, pero se pueden establecer opcionalmente en 64 KB.</span><span class="sxs-lookup"><span data-stu-id="8c16b-117">In ReFS on Windows Server 2016, clusters are 4KB in size by default, but can optionally be set to 64KB.</span></span> <span data-ttu-id="8c16b-118">El tamaño del clúster es un conjunto de parámetros en todo el volumen en el momento del formato.</span><span class="sxs-lookup"><span data-stu-id="8c16b-118">The cluster size is a volume-wide parameter set at format time.</span></span>

## <a name="restrictions-and-remarks"></a><span data-ttu-id="8c16b-119">Restricciones y comentarios</span><span class="sxs-lookup"><span data-stu-id="8c16b-119">Restrictions and Remarks</span></span>

-   <span data-ttu-id="8c16b-120">Las regiones de origen y de destino deben comenzar y finalizar en un límite de clúster.</span><span class="sxs-lookup"><span data-stu-id="8c16b-120">The source and destination regions must begin and end at a cluster boundary.</span></span>
-   <span data-ttu-id="8c16b-121">La región clonada debe ser inferior a 4 GB de longitud.</span><span class="sxs-lookup"><span data-stu-id="8c16b-121">The cloned region must be less than 4GB in length.</span></span>
-   <span data-ttu-id="8c16b-122">La región de destino no debe extenderse más allá del final del archivo.</span><span class="sxs-lookup"><span data-stu-id="8c16b-122">The destination region must not extend past the end of file.</span></span> <span data-ttu-id="8c16b-123">Si la aplicación desea extender el destino con datos clonados, primero debe llamar a [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span><span class="sxs-lookup"><span data-stu-id="8c16b-123">If the application wishes to extend the destination with cloned data, it must first call [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span></span>
-   <span data-ttu-id="8c16b-124">Si las regiones de origen y destino están en el mismo archivo, no deben superponerse.</span><span class="sxs-lookup"><span data-stu-id="8c16b-124">If the source and destination regions are in the same file, they must not overlap.</span></span> <span data-ttu-id="8c16b-125">(Es posible que la aplicación pueda continuar dividiendo la operación de clonación de bloques en varios clones de bloques que ya no se superpongan).</span><span class="sxs-lookup"><span data-stu-id="8c16b-125">(The application may able to proceed by splitting up the block clone operation into multiple block clones that no longer overlap.)</span></span>
-   <span data-ttu-id="8c16b-126">Los archivos de origen y de destino deben tener el mismo volumen ReFS.</span><span class="sxs-lookup"><span data-stu-id="8c16b-126">The source and destination files must be on the same ReFS volume.</span></span>
-   <span data-ttu-id="8c16b-127">Los archivos de origen y de destino deben tener la misma configuración de [**flujos de integridad**](file-attribute-constants.md) (es decir, los flujos de integridad deben estar habilitados en ambos archivos o deshabilitados en ambos archivos).</span><span class="sxs-lookup"><span data-stu-id="8c16b-127">The source and destination files must have the same [**Integrity Streams**](file-attribute-constants.md) setting (that is, Integrity Streams must be enabled in both files, or disabled in both files).</span></span>
-   <span data-ttu-id="8c16b-128">Si el archivo de origen es disperso, el archivo de destino también debe serlo.</span><span class="sxs-lookup"><span data-stu-id="8c16b-128">If the source file is sparse, the destination file must also be sparse.</span></span>
-   <span data-ttu-id="8c16b-129">La operación de clonación de bloques interrumpirá los bloqueos oportunistas compartidos (también conocidos como [bloqueos oportunistas de nivel 2](types-of-opportunistic-locks.md)).</span><span class="sxs-lookup"><span data-stu-id="8c16b-129">The block clone operation will break Shared Opportunistic Locks (also known as [Level 2 Opportunistic Locks](types-of-opportunistic-locks.md)).</span></span>
-   <span data-ttu-id="8c16b-130">El volumen ReFS debe tener el formato Windows Server 2016 y, si el clúster de conmutación por error de Windows está en uso, el nivel funcional de la agrupación en clústeres debe ser Windows Server 2016 o posterior en el momento del formato.</span><span class="sxs-lookup"><span data-stu-id="8c16b-130">The ReFS volume must have been formatted with Windows Server 2016, and if Windows Failover Clustering is in use, the Clustering Functional Level must have been Windows Server 2016 or later at format time.</span></span>

## <a name="example"></a><span data-ttu-id="8c16b-131">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="8c16b-131">Example</span></span>

<span data-ttu-id="8c16b-132">Supongamos que tenemos dos archivos, X e y, donde cada archivo se compone de tres regiones distintas.</span><span class="sxs-lookup"><span data-stu-id="8c16b-132">Suppose we have two files, X and Y, where each file is composed of 3 distinct regions.</span></span> <span data-ttu-id="8c16b-133">Cada región de archivo se almacena en una región distinta del volumen.</span><span class="sxs-lookup"><span data-stu-id="8c16b-133">Each file region is stored on a distinct region of the volume.</span></span> <span data-ttu-id="8c16b-134">El sistema de archivos almacena la información a la que se hace referencia en una región de archivo a cada una de esas regiones de volumen:</span><span class="sxs-lookup"><span data-stu-id="8c16b-134">The file system stores the knowledge that each of those volume regions is referenced in one file region:</span></span>

![antes del clon](images/before-clone.png)

<span data-ttu-id="8c16b-136">Ahora Supongamos que una aplicación emite una operación de clonación de bloques desde el archivo X, a través de las regiones del archivo a y B, al archivo Y en el desplazamiento donde E actualmente es.</span><span class="sxs-lookup"><span data-stu-id="8c16b-136">Now suppose an application issues a block clone operation from File X, over file regions A and B, to File Y at the offset where E currently is.</span></span> <span data-ttu-id="8c16b-137">El siguiente estado del sistema de archivos daría como resultado:</span><span class="sxs-lookup"><span data-stu-id="8c16b-137">The following file system state would result:</span></span>

![después del clon](images/after-clone.png)

<span data-ttu-id="8c16b-139">Los datos de las regiones A y B se duplicaban de forma eficaz desde el archivo X al archivo Y modificando las asignaciones VCN a LCN en el volumen ReFS.</span><span class="sxs-lookup"><span data-stu-id="8c16b-139">The data in regions A and B were effectively duplicated from File X to File Y by altering the VCN to LCN mappings within the ReFS volume.</span></span> <span data-ttu-id="8c16b-140">No se leyeron las regiones de respaldo de las regiones A y B, ni las extensiones de disco que respaldan las regiones antiguas E y F sobrescribieron durante la operación.</span><span class="sxs-lookup"><span data-stu-id="8c16b-140">The disk extents backing regions A and B were not read, nor were the disk extents backing the old regions E and F overwritten during the operation.</span></span>

<span data-ttu-id="8c16b-141">Los archivos X e Y ahora comparten clústeres lógicos en el disco.</span><span class="sxs-lookup"><span data-stu-id="8c16b-141">Files X and Y now share logical clusters on disk.</span></span> <span data-ttu-id="8c16b-142">Esto se refleja en los recuentos de referencias que se muestran en la tabla.</span><span class="sxs-lookup"><span data-stu-id="8c16b-142">This is reflected in the reference counts shown in the table.</span></span> <span data-ttu-id="8c16b-143">El uso compartido da como resultado un consumo de menor capacidad de volumen que si las regiones A y B estuvieran duplicadas en el volumen subyacente.</span><span class="sxs-lookup"><span data-stu-id="8c16b-143">The sharing results in lower volume capacity consumption than if regions A and B were duplicated on the underlying volume.</span></span>

<span data-ttu-id="8c16b-144">Ahora, supongamos que la aplicación sobrescribe la región A en el archivo X. ReFS realiza una copia duplicada de un, que ahora llamaremos a G. ReFS y luego asigna G al archivo X y aplica la modificación.</span><span class="sxs-lookup"><span data-stu-id="8c16b-144">Now, suppose the application overwrites region A in File X. ReFS makes a duplicate copy of A, which we’ll now call G. ReFS then maps G into File X, and applies the modification.</span></span> <span data-ttu-id="8c16b-145">Esto asegura que el aislamiento entre los archivos se conserve.</span><span class="sxs-lookup"><span data-stu-id="8c16b-145">This ensures that isolation between the files is preserved.</span></span> <span data-ttu-id="8c16b-146">Los recuentos de referencias se actualizan correctamente:</span><span class="sxs-lookup"><span data-stu-id="8c16b-146">Reference counts are updated appropriately:</span></span>

![después de modificar la escritura](images/after-modifying-write.png)

<span data-ttu-id="8c16b-148">Después de modificar la escritura, la región B todavía se comparte en el disco.</span><span class="sxs-lookup"><span data-stu-id="8c16b-148">After the modifying write, region B is still shared on disk.</span></span> <span data-ttu-id="8c16b-149">Ten en cuenta que si la región A fuera mayor que un clúster, solo el clúster modificado se habría duplicado y el resto seguiría siendo compartido.</span><span class="sxs-lookup"><span data-stu-id="8c16b-149">Note that if region A were larger than a cluster, only the modified cluster would have been duplicated, and the remaining portion would have remained shared.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8c16b-150">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="8c16b-150">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8c16b-151">**datos de extensiones DUPLICAdas \_ \_**</span><span class="sxs-lookup"><span data-stu-id="8c16b-151">**DUPLICATE\_EXTENTS\_DATA**</span></span>](/windows/desktop/api/WinIoCtl/ns-winioctl-duplicate_extents_data)
</dt> <dt>

[<span data-ttu-id="8c16b-152">**\_elementos duplicados \_ \_ de extensiones de FSCTL en el \_ archivo**</span><span class="sxs-lookup"><span data-stu-id="8c16b-152">**FSCTL\_DUPLICATE\_EXTENTS\_TO\_FILE**</span></span>](/windows/win32/api/winioctl/ni-winioctl-fsctl_duplicate_extents_to_file)
</dt> </dl>

 

 
