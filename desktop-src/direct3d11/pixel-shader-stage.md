---
title: Fase del sombreador de píxeles
description: La fase del sombreador de píxeles (PS) permite técnicas de sombreado enriquecidas, como la iluminación por píxel y el procesamiento posterior.
ms.assetid: 09831B10-4FD1-41E7-8D81-5AA63DC90020
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 57142e9c32919a6959a7fac14bf544cca1dacd79
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/20/2020
ms.locfileid: "104149495"
---
# <a name="pixel-shader-stage"></a><span data-ttu-id="32c7e-103">Fase del sombreador de píxeles</span><span class="sxs-lookup"><span data-stu-id="32c7e-103">Pixel Shader Stage</span></span>

<span data-ttu-id="32c7e-104">La fase del sombreador de píxeles (PS) permite técnicas de sombreado enriquecidas, como la iluminación por píxel y el procesamiento posterior.</span><span class="sxs-lookup"><span data-stu-id="32c7e-104">The pixel-shader stage (PS) enables rich shading techniques such as per-pixel lighting and post-processing.</span></span> <span data-ttu-id="32c7e-105">Un sombreador de píxeles es un programa que combina variables constantes, datos de textura, valores interpolados por vértice y otros datos para generar salidas por píxel.</span><span class="sxs-lookup"><span data-stu-id="32c7e-105">A pixel shader is a program that combines constant variables, texture data, interpolated per-vertex values, and other data to produce per-pixel outputs.</span></span> <span data-ttu-id="32c7e-106">La fase de rasterizador invoca un sombreador de píxeles una vez para cada píxel incluido en una primitiva; sin embargo, es posible especificar un sombreador **nulo** para evitar la ejecución de un sombreador.</span><span class="sxs-lookup"><span data-stu-id="32c7e-106">The rasterizer stage invokes a pixel shader once for each pixel covered by a primitive, however, it is possible to specify a **NULL** shader to avoid running a shader.</span></span>

## <a name="the-pixel-shader"></a><span data-ttu-id="32c7e-107">Sombreador de píxeles</span><span class="sxs-lookup"><span data-stu-id="32c7e-107">The Pixel Shader</span></span>

<span data-ttu-id="32c7e-108">Cuando se realiza un muestreo múltiple de una textura, se invoca un sombreador de píxeles una vez por cada uno de ellos, mientras que una prueba de profundidad/estarcido se produce para cada Multimuestra.</span><span class="sxs-lookup"><span data-stu-id="32c7e-108">When multisampling a texture, a pixel shader is invoked once per-covered pixel while a depth/stencil test occurs for each covered multisample.</span></span> <span data-ttu-id="32c7e-109">Los ejemplos que superan la prueba de profundidad/estarcido se actualizan con el color de salida del sombreador de píxeles.</span><span class="sxs-lookup"><span data-stu-id="32c7e-109">Samples that pass the depth/stencil test are updated with the pixel shader output color.</span></span>

<span data-ttu-id="32c7e-110">Las funciones intrínsecas del sombreador de píxeles producen o utilizan derivados de cantidades con respecto al espacio de pantalla x e y.</span><span class="sxs-lookup"><span data-stu-id="32c7e-110">The pixel shader intrinsic functions produce or use derivatives of quantities with respect to screen space x and y.</span></span> <span data-ttu-id="32c7e-111">El uso más común de los derivados es calcular los cálculos de nivel de detalle para el muestreo de textura y, en el caso del filtrado anisotrópico, seleccionar muestras a lo largo del eje de anisotropía.</span><span class="sxs-lookup"><span data-stu-id="32c7e-111">The most common use for derivatives is to compute level-of-detail calculations for texture sampling and in the case of anisotropic filtering, selecting samples along the axis of anisotropy.</span></span> <span data-ttu-id="32c7e-112">Normalmente, una implementación de hardware ejecuta un sombreador de píxeles en varios píxeles (por ejemplo, una cuadrícula de 2x2) simultáneamente, de modo que los derivados de cantidades calculadas en el sombreador de píxeles se pueden aproximar razonablemente como deltas de los valores en el mismo punto de ejecución en píxeles adyacentes.</span><span class="sxs-lookup"><span data-stu-id="32c7e-112">Typically, a hardware implementation runs a pixel shader on multiple pixels (for example a 2x2 grid) simultaneously, so that derivatives of quantities computed in the pixel shader can be reasonably approximated as deltas of the values at the same point of execution in adjacent pixels.</span></span>

### <a name="inputs"></a><span data-ttu-id="32c7e-113">Entradas</span><span class="sxs-lookup"><span data-stu-id="32c7e-113">Inputs</span></span>

<span data-ttu-id="32c7e-114">Cuando la canalización se configura sin un sombreador de geometría, un sombreador de píxeles se limita a 16, 32 bits, 4-entradas de componentes.</span><span class="sxs-lookup"><span data-stu-id="32c7e-114">When the pipeline is configured without a geometry shader, a pixel shader is limited to 16, 32-bit, 4-component inputs.</span></span> <span data-ttu-id="32c7e-115">De lo contrario, un sombreador de píxeles puede tardar hasta 32, 32 bits, 4-entradas de componente.</span><span class="sxs-lookup"><span data-stu-id="32c7e-115">Otherwise, a pixel shader can take up to 32, 32-bit, 4-component inputs.</span></span>

<span data-ttu-id="32c7e-116">Los datos de entrada del sombreador de píxeles incluyen atributos de vértices (que se pueden interpolar con o sin corrección de perspectiva) o se pueden tratar como constantes por primitiva.</span><span class="sxs-lookup"><span data-stu-id="32c7e-116">Pixel shader input data includes vertex attributes (that can be interpolated with or without perspective correction) or can be treated as per-primitive constants.</span></span> <span data-ttu-id="32c7e-117">Las entradas del sombreador de píxeles se interpolan a partir de los atributos de vértice de la primitiva que se está rasterizando, según el modo de interpolación declarado.</span><span class="sxs-lookup"><span data-stu-id="32c7e-117">Pixel shader inputs are interpolated from the vertex attributes of the primitive being rasterized, based on the interpolation mode declared.</span></span> <span data-ttu-id="32c7e-118">Si una primitiva se recorta antes de la rasterización, también se respeta el modo de interpolación durante el proceso de recorte.</span><span class="sxs-lookup"><span data-stu-id="32c7e-118">If a primitive gets clipped before rasterization, the interpolation mode is honored during the clipping process as well.</span></span>

<span data-ttu-id="32c7e-119">Los atributos de vértice se interpolan (o evalúan) en las ubicaciones del centro de sombreador de píxeles.</span><span class="sxs-lookup"><span data-stu-id="32c7e-119">Vertex attributes are interpolated (or evaluated) at pixel shader center locations.</span></span> <span data-ttu-id="32c7e-120">Los modos de interpolación de atributo del sombreador de píxeles se declaran en una declaración de registro de entrada, por elemento, en un [argumento](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) o en una [estructura de entrada](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span><span class="sxs-lookup"><span data-stu-id="32c7e-120">Pixel shader attribute interpolation modes are declared in an input register declaration, on a per-element basis in either an [argument](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) or an [input structure](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span></span> <span data-ttu-id="32c7e-121">Los atributos se pueden interpolar linealmente o con el [muestreo centroide](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="32c7e-121">Attributes can be interpolated linearly, or with [centroid sampling](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx).</span></span> <span data-ttu-id="32c7e-122">La evaluación de centroide solo es relevante durante el muestreo múltiple para cubrir los casos en los que un píxel está cubierto por un primitivo, pero un centro de píxeles puede no ser; la evaluación de centroide se produce lo más cerca posible del centro de píxeles (no incluido).</span><span class="sxs-lookup"><span data-stu-id="32c7e-122">Centroid evaluation is relevant only during multisampling to cover cases where a pixel is covered by a primitive but a pixel center may not be; centroid evaluation occurs as close as possible to the (non-covered) pixel center.</span></span>

<span data-ttu-id="32c7e-123">Las entradas también se pueden declarar con una [semántica de valor del sistema](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), que marca un parámetro consumido por otras fases de canalización.</span><span class="sxs-lookup"><span data-stu-id="32c7e-123">Inputs may also be declared with a [system-value semantic](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), which marks a parameter that is consumed by other pipeline stages.</span></span> <span data-ttu-id="32c7e-124">Por ejemplo, una posición en píxeles se debe marcar con la \_ semántica de la posición VP.</span><span class="sxs-lookup"><span data-stu-id="32c7e-124">For instance, a pixel position should be marked with the SV\_Position semantic.</span></span> <span data-ttu-id="32c7e-125">La fase IA puede producir un escalar para un sombreador de píxeles (mediante \_ la VP PrimitiveID); la fase de rasterizador también puede generar un escalar para un sombreador de píxeles (con la VP \_ IsFrontFace).</span><span class="sxs-lookup"><span data-stu-id="32c7e-125">The IA stage can produce one scalar for a pixel shader (using SV\_PrimitiveID); the rasterizer stage can also generate one scalar for a pixel shader (using SV\_IsFrontFace).</span></span>

### <a name="outputs"></a><span data-ttu-id="32c7e-126">Salidas</span><span class="sxs-lookup"><span data-stu-id="32c7e-126">Outputs</span></span>

<span data-ttu-id="32c7e-127">Un sombreador de píxeles puede generar un resultado de hasta 8, 32 bits, colores de cuatro componentes o ningún color si se descarta el píxel.</span><span class="sxs-lookup"><span data-stu-id="32c7e-127">A pixel shader can output up to 8, 32-bit, 4-component colors, or no color if the pixel is discarded.</span></span> <span data-ttu-id="32c7e-128">Los componentes del registro de salida del sombreador de píxeles se deben declarar antes de poder usarlos. cada registro tiene permitida una máscara de salida-escritura distinta.</span><span class="sxs-lookup"><span data-stu-id="32c7e-128">Pixel shader output register components must be declared before they can be used; each register is allowed a distinct output-write mask.</span></span>

<span data-ttu-id="32c7e-129">Use el estado de Depth-Write-Enable (en la fase de combinación de salida) para controlar si los datos de profundidad se escriben en un búfer de profundidad (o use la instrucción discard para descartar los datos de ese píxel).</span><span class="sxs-lookup"><span data-stu-id="32c7e-129">Use the depth-write-enable state (in the output-merger stage) to control whether depth data gets written to a depth buffer (or use the discard instruction to discard data for that pixel).</span></span> <span data-ttu-id="32c7e-130">Un sombreador de píxeles también puede generar un valor de profundidad de punto flotante y de un componente de 32 bits opcional para las pruebas de profundidad (con la semántica de profundidad de la VP \_ ).</span><span class="sxs-lookup"><span data-stu-id="32c7e-130">A pixel shader can also output an optional 32-bit, 1-component, floating-point, depth value for depth testing (using the SV\_Depth semantic).</span></span> <span data-ttu-id="32c7e-131">El valor de profundidad se genera en el registro oDepth y reemplaza el valor de profundidad interpolada para las pruebas de profundidad (suponiendo que la prueba de profundidad está habilitada).</span><span class="sxs-lookup"><span data-stu-id="32c7e-131">The depth value is output in the oDepth register, and replaces the interpolated depth value for depth testing (assuming depth testing is enabled).</span></span> <span data-ttu-id="32c7e-132">No hay ninguna manera de cambiar de forma dinámica entre el uso de la profundidad de funciones fijas o del sombreador oDepth.</span><span class="sxs-lookup"><span data-stu-id="32c7e-132">There is no way to dynamically change between using fixed-function depth or shader oDepth.</span></span>

<span data-ttu-id="32c7e-133">Un sombreador de píxeles no puede generar un valor de estarcido.</span><span class="sxs-lookup"><span data-stu-id="32c7e-133">A pixel shader cannot output a stencil value.</span></span>

## <a name="related-topics"></a><span data-ttu-id="32c7e-134">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="32c7e-134">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="32c7e-135">Canalización de gráficos</span><span class="sxs-lookup"><span data-stu-id="32c7e-135">Graphics Pipeline</span></span>](overviews-direct3d-11-graphics-pipeline.md)
</dt> <dt>

[<span data-ttu-id="32c7e-136">Fases de canalización (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="32c7e-136">Pipeline Stages (Direct3D 10)</span></span>](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-pipeline-stages)
</dt> </dl>

 

 