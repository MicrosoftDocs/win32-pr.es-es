---
description: Puede realizar operaciones de e/s sincrónicas o asincrónicas (también denominadas superpuestas) en archivos, canalizaciones con nombre y dispositivos de comunicaciones serie.
ms.assetid: db44990e-5a0f-4153-8ff6-79dd7cda48af
title: Sincronización y entrada y salida superpuestas
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e263bb39badc7cbfadd67d80eb169dc1fe6d6c35
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105668449"
---
# <a name="synchronization-and-overlapped-input-and-output"></a>Sincronización y entrada y salida superpuestas

Puede realizar operaciones de e/s sincrónicas o asincrónicas (también denominadas superpuestas) en archivos, canalizaciones con nombre y dispositivos de comunicaciones serie. Las funciones [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**readfile**](/windows/win32/api/fileapi/nf-fileapi-readfile), [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol), [**WaitCommEvent**](/windows/win32/api/winbase/nf-winbase-waitcommevent), [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)y [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) se pueden realizar de forma sincrónica o asincrónica. Las funciones [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex) y [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) solo se pueden realizar de forma asincrónica.

Cuando una función se ejecuta sincrónicamente, no devuelve ningún resultado hasta que se haya completado la operación. Esto significa que la ejecución del subproceso que realiza la llamada puede bloquearse durante un período indefinido mientras espera a que finalice una operación que consume mucho tiempo. Las funciones a las que se llama para la operación superpuesta pueden volver inmediatamente, aunque no se haya completado la operación. Esto permite que una operación de e/s que tarda mucho tiempo se ejecute en segundo plano, mientras que el subproceso que realiza la llamada puede realizar otras tareas. Por ejemplo, un único subproceso puede realizar operaciones de e/s simultáneas en diferentes identificadores, o incluso en operaciones de lectura y escritura simultáneas en el mismo identificador.

Para sincronizar su ejecución con la realización de la operación superpuesta, el subproceso que realiza la llamada utiliza la función [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , la función [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) o una de las [funciones de espera](wait-functions.md) para determinar cuándo se ha completado la operación superpuesta. También puede usar la macro [**HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) para sondear la finalización.

Para cancelar todas las operaciones de e/s asincrónicas pendientes, utilice la función [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) y proporcione una estructura [**superpuesta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) que especifique la solicitud que se va a cancelar. Use la función [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) para cancelar las operaciones de e/s asincrónicas pendientes emitidas por el subproceso que realiza la llamada para el identificador de archivo especificado.

Las operaciones superpuestas requieren un archivo, una canalización con nombre o un dispositivo de comunicaciones creado con la marca de superposición de **\_ \_ marca de archivo** . Cuando un subproceso llama a una función (como la función [**readfile**](/windows/win32/api/fileapi/nf-fileapi-readfile) ) para realizar una operación superpuesta, el subproceso que realiza la llamada debe especificar un puntero a una estructura [**superpuesta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) . (Si este puntero es **null**, el valor devuelto de la función puede indicar incorrectamente que la operación se completó). Todos los miembros de la estructura **superpuesta** se deben inicializar en cero, a menos que se use un evento para indicar la finalización de una operación de e/s. Si se utiliza un evento, el miembro **hEvent** de la estructura **OVERLAPPED** especifica un identificador para el objeto de evento asignado. El sistema establece el estado del objeto de evento en no señalado cuando una llamada a la función de e/s se devuelve antes de que se haya completado la operación. El sistema establece el estado del objeto de evento en señalado cuando se ha completado la operación. Un evento solo es necesario si hay más de una operación de e/s pendiente al mismo tiempo. Si no se utiliza un evento, cada operación de e/s completada señalará el archivo, la canalización con nombre o el dispositivo de comunicaciones.

Cuando se llama a una función para realizar una operación superpuesta, es posible que la operación se complete antes de que se devuelva la función. Cuando esto ocurre, los resultados se controlan como si la operación se hubiera realizado sincrónicamente. Sin embargo, si la operación no se completó, el valor devuelto de la función es **false** y la función [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) devuelve el **error de \_ e/s \_ pendiente**.

Un subproceso puede administrar las operaciones superpuestas por uno de estos dos métodos:

-   Utilice la función [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) o [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) para esperar a que se complete la operación superpuesta. Si se usa **GetOverlappedResultEx** , el subproceso que realiza la llamada puede especificar un tiempo de espera para la operación superpuesta o realizar una espera de alerta.
-   Especifique un identificador para el objeto de evento de restablecimiento manual de la estructura [**superpuesta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) en una de las [funciones de espera](wait-functions.md) y, después, después de que se devuelva la función wait, llame a [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) o [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex). La función devuelve los resultados de la operación superpuesta completada y, en el caso de las funciones en las que la información es adecuada, informa del número real de bytes transferidos.

Al realizar varias operaciones simultáneas superpuestas en un único subproceso, el subproceso que realiza la llamada debe especificar una estructura [**superpuesta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) para cada operación. Cada estructura **superpuesta** debe especificar un identificador para un objeto de evento de restablecimiento manual diferente. Para esperar a que se complete una de las operaciones superpuestas, el subproceso especifica todos los identificadores de eventos de restablecimiento manual como criterios de espera en una de las [funciones de espera](wait-functions.md)de varios objetos. El valor devuelto de la función de varios objetos wait indica qué objeto de evento de restablecimiento manual se ha señalado, por lo que el subproceso puede determinar qué operación superpuesta ha provocado la finalización de la operación de espera.

Es más seguro utilizar un objeto de evento independiente para cada operación superpuesta, en lugar de no especificar ningún objeto de evento ni volver a usar el mismo objeto de evento para varias operaciones. Si no se especifica ningún objeto de evento en la estructura [**superpuesta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) , el sistema indica el estado del archivo, la canalización con nombre o el dispositivo de comunicaciones cuando se ha completado la operación superpuesta. Por lo tanto, puede especificar estos identificadores como objetos de sincronización en una función de espera, aunque su uso para este propósito puede ser difícil de administrar porque, al realizar operaciones superpuestas simultáneamente en el mismo archivo, canalización con nombre o dispositivo de comunicaciones, no hay ninguna manera de saber qué operación provocó la señal del estado del objeto.

Un subproceso no debe reutilizar un evento con la suposición de que el evento solo será señalizado por la operación superpuesta del subproceso. Un evento se señaliza en el mismo subproceso que la operación superpuesta que se está completando. El uso del mismo evento en varios subprocesos puede conducir a una condición de carrera en la que el evento se señaliza correctamente para el subproceso cuya operación se completa primero y prematuramente para otros subprocesos que usan ese evento. A continuación, cuando se completa la siguiente operación superpuesta, el evento se vuelve a señalizar para todos los subprocesos que usan ese evento, y así sucesivamente hasta que se completan todas las operaciones superpuestas.

Para obtener ejemplos que ilustran el uso de operaciones superpuestas, rutinas de finalización y la función [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , vea [usar canalizaciones](../ipc/using-pipes.md).

* * Windows Vista, Windows Server 2003 y Windows XP: * *

Tenga cuidado al reutilizar estructuras [**SUPERpuestas**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) . Si se reutilizan las estructuras **SUPERpuestas** en varios subprocesos y se llama a [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) con el parámetro *bWait* establecido en **true**, el subproceso de llamada debe asegurarse de que el evento asociado se señaliza antes de volver a utilizar la estructura. Esto puede realizarse mediante la función [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) después de llamar a **GetOverlappedResult** para obligar a que el subproceso espere hasta que se complete la operación. Tenga en cuenta que el objeto de evento debe ser un objeto de evento de restablecimiento manual. Si se utiliza un objeto de evento AutoReset, la llamada a **GetOverlappedResult** con el parámetro *BWait* establecido en **true** hace que la función se bloquee indefinidamente. Este comportamiento ha cambiado a partir de Windows 7 y Windows Server 2008 R2 para las aplicaciones que especifican Windows 7 como sistema operativo compatible en el manifiesto de aplicación. Para obtener más información, consulte [manifiestos de aplicación](/previous-versions/windows/desktop/adrms_sdk/application-manifests).

## <a name="related-topics"></a>Temas relacionados

<dl> <dt>

[Conceptos de e/s](../fileio/i-o-concepts.md)
</dt> </dl>

 

 
