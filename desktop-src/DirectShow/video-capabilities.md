---
description: Capacidades de vídeo
ms.assetid: 305bd009-f58e-4dcc-9b70-252de87dc86d
title: Capacidades de vídeo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6287839b75bd5044644480c3abcc8248cc46dc0a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "104570952"
---
# <a name="video-capabilities"></a><span data-ttu-id="62993-103">Capacidades de vídeo</span><span class="sxs-lookup"><span data-stu-id="62993-103">Video Capabilities</span></span>

<span data-ttu-id="62993-104">El método [**IAMStreamConfig:: GetStreamCaps**](/windows/desktop/api/Strmif/nf-strmif-iamstreamconfig-getstreamcaps) presenta funcionalidades de vídeo en una matriz de pares de estructuras de [**\_ \_ tipo de medio am**](/windows/win32/api/strmif/ns-strmif-am_media_type) y de [**\_ \_ \_ Cap de configuración de flujo de vídeo**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) .</span><span class="sxs-lookup"><span data-stu-id="62993-104">The [**IAMStreamConfig::GetStreamCaps**](/windows/desktop/api/Strmif/nf-strmif-iamstreamconfig-getstreamcaps) method presents video capabilities in an array of pairs of [**AM\_MEDIA\_TYPE**](/windows/win32/api/strmif/ns-strmif-am_media_type) and [**VIDEO\_STREAM\_CONFIG\_CAPS**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) structures.</span></span> <span data-ttu-id="62993-105">Puede utilizar esto para exponer todos los formatos y las resoluciones admitidos en un PIN, tal y como se describe a continuación.</span><span class="sxs-lookup"><span data-stu-id="62993-105">You can use this to expose all the formats and resolutions supported on a pin as discussed below.</span></span>

<span data-ttu-id="62993-106">Para ver ejemplos relacionados con el audio de **GetStreamCaps**, consulte [capacidades de audio](audio-capabilities.md).</span><span class="sxs-lookup"><span data-stu-id="62993-106">For audio-related examples of **GetStreamCaps**, see [Audio Capabilities](audio-capabilities.md).</span></span>

<span data-ttu-id="62993-107">Supongamos que la tarjeta de captura admite el formato JPEG en todas las resoluciones entre 160 x 120 píxeles y 320 x 240 píxeles, ambos incluidos.</span><span class="sxs-lookup"><span data-stu-id="62993-107">Suppose your capture card supports JPEG format at all resolutions between 160 x 120 pixels and 320 x 240 pixels, inclusive.</span></span> <span data-ttu-id="62993-108">La diferencia entre las resoluciones admitidas es una en este caso porque agrega o resta un píxel de cada resolución admitida para obtener la siguiente resolución admitida.</span><span class="sxs-lookup"><span data-stu-id="62993-108">The difference between supported resolutions is one in this case because you add or subtract one pixel from each supported resolution to get the next supported resolution.</span></span> <span data-ttu-id="62993-109">Esta diferencia en las resoluciones admitidas se denomina granularidad.</span><span class="sxs-lookup"><span data-stu-id="62993-109">This difference in supported resolutions is called granularity.</span></span>

<span data-ttu-id="62993-110">Supongamos que la tarjeta también admite el tamaño 640 x 480.</span><span class="sxs-lookup"><span data-stu-id="62993-110">Suppose your card also supports the size 640 x 480.</span></span> <span data-ttu-id="62993-111">A continuación se muestra esta resolución única y el intervalo de resoluciones anterior (todos los tamaños entre 160 x 120 píxeles y 320 x 240 píxeles).</span><span class="sxs-lookup"><span data-stu-id="62993-111">The following illustrates this single resolution and the above range of resolutions (all sizes between 160 x 120 pixels and 320 x 240 pixels).</span></span>

![resolución de 160 x 120 a 320 x 240 píxeles, más 640 x 480](images/strmcap1.png)

<span data-ttu-id="62993-113">Además, supongamos que admite el formato RGB de color de 24 bits en resoluciones entre 160 x 120 y 320 x 240, pero con una granularidad de 8.</span><span class="sxs-lookup"><span data-stu-id="62993-113">Also, suppose it supports 24-bit color RGB format at resolutions between 160 x 120 and 320 x 240, but with a granularity of 8.</span></span> <span data-ttu-id="62993-114">En la ilustración siguiente se muestran algunos de los tamaños válidos en este caso.</span><span class="sxs-lookup"><span data-stu-id="62993-114">The following illustration shows some of the valid sizes in this case.</span></span>

![resolución de 160 x 120 a 320 a 240, con granularidad = 8](images/strmcap3.png)

<span data-ttu-id="62993-116">Para colocarlo de otra manera y mostrar más soluciones, a continuación se muestran todos los elementos de la lista de resoluciones válidas.</span><span class="sxs-lookup"><span data-stu-id="62993-116">To put it another way, and listing more resolutions, the following are all among the list of valid resolutions.</span></span>

-   <span data-ttu-id="62993-117">160 x 120</span><span class="sxs-lookup"><span data-stu-id="62993-117">160 x 120</span></span>
-   <span data-ttu-id="62993-118">168 x 120</span><span class="sxs-lookup"><span data-stu-id="62993-118">168 x 120</span></span>
-   <span data-ttu-id="62993-119">168 x 128</span><span class="sxs-lookup"><span data-stu-id="62993-119">168 x 128</span></span>
-   <span data-ttu-id="62993-120">176 x 128</span><span class="sxs-lookup"><span data-stu-id="62993-120">176 x 128</span></span>
-   <span data-ttu-id="62993-121">176 x 136</span><span class="sxs-lookup"><span data-stu-id="62993-121">176 x 136</span></span>
-   <span data-ttu-id="62993-122">... resoluciones adicionales...</span><span class="sxs-lookup"><span data-stu-id="62993-122">... additional resolutions ...</span></span>
-   <span data-ttu-id="62993-123">312 x 232</span><span class="sxs-lookup"><span data-stu-id="62993-123">312 x 232</span></span>
-   <span data-ttu-id="62993-124">320 x 240</span><span class="sxs-lookup"><span data-stu-id="62993-124">320 x 240</span></span>

<span data-ttu-id="62993-125">Use **GetStreamCaps** para exponer estas capacidades de formato de color y de dimensión mediante el uso de un tipo de medio de 320 x 240 JPEG (si es su tamaño predeterminado o preferido) acoplado a las capacidades mínimas de 160 x 120, capacidad máxima de 320 x 240 y una granularidad de 1.</span><span class="sxs-lookup"><span data-stu-id="62993-125">Use **GetStreamCaps** to expose these color format and dimension capabilities by offering a media type of 320 x 240 JPEG (if that is your default or preferred size) coupled with minimum capabilities of 160 x 120, maximum capabilities of 320 x 240, and a granularity of 1.</span></span> <span data-ttu-id="62993-126">El siguiente par que exponga mediante **GetStreamCaps** es un tipo de medio de 640 x 480 JPEG junto con un mínimo de 640 x 480 y un máximo de 640 x 480 y una granularidad de 0.</span><span class="sxs-lookup"><span data-stu-id="62993-126">The next pair you expose by using **GetStreamCaps** is a media type of 640 x 480 JPEG coupled with a minimum of 640 x 480 and a maximum of 640 x 480 and a granularity of 0.</span></span> <span data-ttu-id="62993-127">El tercer par incluye un tipo de medio de 320 x 240, RGB de 24 bits con capacidades mínimas de 160 x 120, capacidad máxima de 320 x 240 y una granularidad de 8.</span><span class="sxs-lookup"><span data-stu-id="62993-127">The third pair includes a media type of 320 x 240, 24-bit RGB with minimum capabilities of 160 x 120, maximum capabilities of 320 x 240, and a granularity of 8.</span></span> <span data-ttu-id="62993-128">De esta manera, puede publicar casi todos los formatos y la funcionalidad que puede admitir la tarjeta.</span><span class="sxs-lookup"><span data-stu-id="62993-128">In this way you can publish almost every format and capability your card might support.</span></span> <span data-ttu-id="62993-129">Una aplicación que debe saber qué formatos de compresión proporciona puede obtener todos los pares y hacer una lista de todos los subtipos únicos de los tipos de medios.</span><span class="sxs-lookup"><span data-stu-id="62993-129">An application that must know what compression formats you provide can get all the pairs and make a list of all the unique subtypes of the media types.</span></span>

<span data-ttu-id="62993-130">Un filtro obtiene sus rectángulos de origen y de destino de tipo de medio de los miembros **rcSource** y **rcTarget** de la estructura [**VIDEOINFOHEADER**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader) , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="62993-130">A filter obtains its media type source and target rectangles from the [**VIDEOINFOHEADER**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader) structure's **rcSource** and **rcTarget** members, respectively.</span></span> <span data-ttu-id="62993-131">No es necesario que los filtros admitan los rectángulos de origen y de destino.</span><span class="sxs-lookup"><span data-stu-id="62993-131">Filters do not have to support source and target rectangles.</span></span>

<span data-ttu-id="62993-132">El rectángulo de recorte descrito en la documentación de [**IAMStreamConfig**](/windows/desktop/api/Strmif/nn-strmif-iamstreamconfig) es el mismo que el rectángulo **rcSource** de la estructura **VIDEOINFOHEADER** para el PIN de salida.</span><span class="sxs-lookup"><span data-stu-id="62993-132">The cropping rectangle described throughout the [**IAMStreamConfig**](/windows/desktop/api/Strmif/nn-strmif-iamstreamconfig) documentation is the same as the **VIDEOINFOHEADER** structure's **rcSource** rectangle for the output pin.</span></span>

<span data-ttu-id="62993-133">El rectángulo de salida descrito en la documentación de **IAMStreamConfig** es el mismo que el de los miembros **biwidth** y **biheight** de la estructura **BITMAPINFOHEADER** del PIN de salida (consulte [datos de DV en el formato de archivo AVI](dv-data-in-the-avi-file-format.md)).</span><span class="sxs-lookup"><span data-stu-id="62993-133">The output rectangle described throughout the **IAMStreamConfig** documentation is the same as the **biWidth** and **biHeight** members of the output pin's **BITMAPINFOHEADER** structure (see [DV Data in the AVI File Format](dv-data-in-the-avi-file-format.md).).</span></span>

<span data-ttu-id="62993-134">Si el PIN de salida de un filtro se conecta a un tipo de medio con rectángulos de origen y de destino no vacíos, se requiere el filtro para ajustar el subrectángulo de origen del formato de entrada al subrectángulo de destino del formato de salida.</span><span class="sxs-lookup"><span data-stu-id="62993-134">If a filter's output pin is connected to a media type with nonempty source and target rectangles, then your filter is required to stretch the input format's source subrectangle into the output format's target subrectangle.</span></span> <span data-ttu-id="62993-135">El subrectángulo de origen se almacena en el miembro **Inlocate** de la estructura de vídeo de configuración de la [**secuencia de vídeo \_ \_ \_**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) .</span><span class="sxs-lookup"><span data-stu-id="62993-135">The source subrectangle is stored in the [**VIDEO\_STREAM\_CONFIG\_CAPS**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) structure's **InputSize** member.</span></span>

<span data-ttu-id="62993-136">Por ejemplo, considere el siguiente escenario de compresor de vídeo: la imagen de entrada está en formato RGB y tiene un tamaño de 160 x 120 píxeles.</span><span class="sxs-lookup"><span data-stu-id="62993-136">For example, consider the following video compressor scenario: The input image is in RGB format and has a size of 160 x 120 pixels.</span></span> <span data-ttu-id="62993-137">La esquina superior izquierda del rectángulo de origen está en la coordenada (20, 20) y la esquina inferior derecha está en (30, 30).</span><span class="sxs-lookup"><span data-stu-id="62993-137">The source rectangle's upper-left corner is at coordinate (20,20), and its lower-right corner is at (30,30).</span></span> <span data-ttu-id="62993-138">La imagen de salida está en formato MPEG con un tamaño de 320 x 240.</span><span class="sxs-lookup"><span data-stu-id="62993-138">The output image is in MPEG format with a size of 320 x 240.</span></span> <span data-ttu-id="62993-139">La esquina superior izquierda del rectángulo de destino está en (0,0) y la esquina inferior derecha está en (100.100).</span><span class="sxs-lookup"><span data-stu-id="62993-139">The target rectangle's upper-left corner is at (0,0) and its lower-right corner is at (100,100).</span></span> <span data-ttu-id="62993-140">En este caso, el filtro debe tomar una pieza de 10 x 10 del mapa de bits de origen RGB 160 x 120 y hacer que rellene el área de 100 x 100 superior de un mapa de bits de 320 x 240, lo que deja el resto del mapa de bits 320 x 240 sin tocar.</span><span class="sxs-lookup"><span data-stu-id="62993-140">In this case, the filter should take a 10 x 10 piece of the 160 x 120 RGB source bitmap, and make it fill the top 100 x 100 area of a 320 x 240 bitmap, leaving the rest of the 320 x 240 bitmap untouched.</span></span> <span data-ttu-id="62993-141">En la ilustración siguiente se muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="62993-141">The following illustration shows this scenario.</span></span>

![expansión de subrectángulos](images/strmcap4.png)

<span data-ttu-id="62993-143">Es posible que un filtro no sea compatible con este y que pueda no conectarse con un tipo de medio en el que **rcSource** y **rcTarget** no estén vacíos.</span><span class="sxs-lookup"><span data-stu-id="62993-143">A filter might not support this and can fail to connect with a media type where **rcSource** and **rcTarget** are not empty.</span></span>

<span data-ttu-id="62993-144">La estructura **VIDEOINFOHEADER** expone información sobre las capacidades de velocidad de datos de un filtro.</span><span class="sxs-lookup"><span data-stu-id="62993-144">The **VIDEOINFOHEADER** structure exposes information about a filter's data rate capabilities.</span></span> <span data-ttu-id="62993-145">Por ejemplo, supongamos que ha conectado el PIN de salida al siguiente filtro con un tipo de medio determinado (ya sea directamente o mediante el tipo de medio pasado por la función [**CMediaType:: SetFormat**](cmediatype-setformat.md) ).</span><span class="sxs-lookup"><span data-stu-id="62993-145">For example, suppose you connected your output pin to the next filter with a certain media type (either directly or by using the media type passed by the [**CMediaType::SetFormat**](cmediatype-setformat.md) function).</span></span> <span data-ttu-id="62993-146">Fíjese en el miembro **dwBitRate** de la estructura de formato **VIDEOINFOHEADER** de ese tipo de medio para ver qué velocidad de datos debe comprimir el vídeo.</span><span class="sxs-lookup"><span data-stu-id="62993-146">Look at the **dwBitRate** member of that media type's **VIDEOINFOHEADER** format structure to see what data rate you should compress the video to.</span></span> <span data-ttu-id="62993-147">Si multiplica el número de unidades de tiempo por fotograma en el miembro **AvgTimePerFrame** de la estructura **VIDEOINFOHEADER** por la velocidad de datos del miembro **dwBitRate** y divide por 10 millones (el número de unidades por segundo), puede averiguar cuántos bytes deben ser cada fotograma.</span><span class="sxs-lookup"><span data-stu-id="62993-147">If you multiply the number of units of time per frame in the **VIDEOINFOHEADER** structure's **AvgTimePerFrame** member by the data rate in the **dwBitRate** member and divide by 10,000,000 (the number of units per second), you can figure out how many bytes each frame should be.</span></span> <span data-ttu-id="62993-148">Puede generar un marco con un tamaño menor, pero nunca más grande.</span><span class="sxs-lookup"><span data-stu-id="62993-148">You can produce a smaller sized frame, but never a larger one.</span></span> <span data-ttu-id="62993-149">Para determinar la velocidad de fotogramas de un compresor de vídeo o de un filtro de captura, use **AvgTimePerFrame** en el tipo de medio del PIN de salida.</span><span class="sxs-lookup"><span data-stu-id="62993-149">To determine the frame rate for a video compressor or for a capture filter, use **AvgTimePerFrame** from your output pin's media type.</span></span>

 

 



