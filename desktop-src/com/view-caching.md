---
title: Ver almacenamiento en caché
description: Ver almacenamiento en caché
ms.assetid: d19c111c-1367-43a2-97a9-35dc0ff5dcc8
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 592c5bc2555e907cdc4e600465b807387c3a5548
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/21/2020
ms.locfileid: "104421445"
---
# <a name="view-caching"></a><span data-ttu-id="5f1ba-103">Ver almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="5f1ba-103">View Caching</span></span>

<span data-ttu-id="5f1ba-104">Una aplicación contenedora debe ser capaz de obtener una presentación de un objeto con el fin de mostrarla o imprimirla para los usuarios cuando el documento está abierto, pero la aplicación de servidor del objeto no se está ejecutando o no está instalada en el equipo del usuario.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-104">A container application must be able to obtain a presentation of an object for the purpose of displaying or printing it for users when the document is open but the object's server application is not running or is not installed on the user's machine.</span></span> <span data-ttu-id="5f1ba-105">No obstante, supongamos que los servidores de todos los objetos que se pueden encontrar en un documento se instalan en el equipo de cada usuario y que siempre se pueden ejecutar a petición es poco realista.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-105">To assume, however, that the servers for all the objects that might conceivably be found in a document are installed on every user's machine and can always run on demand is unrealistic.</span></span> <span data-ttu-id="5f1ba-106">El controlador de objetos predeterminado, que está disponible en todo momento, resuelve este dilema mediante el almacenamiento en caché de las presentaciones del objeto en el almacenamiento del documento y la manipulación de estas presentaciones en cualquier plataforma, independientemente de la disponibilidad del servidor de objetos en una instalación determinada del contenedor.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-106">The default object handler, which is available at all times, solves this dilemma by caching object presentations in the document's storage and manipulating these presentations on any platform regardless of the availablility of the object server on any particular installation of the container.</span></span>

<span data-ttu-id="5f1ba-107">Los contenedores pueden mantener las presentaciones de dibujo de uno o más dispositivos de destino específicos, además de la necesaria para mantener el objeto en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-107">Containers can maintain drawing presentations for one or more specific target devices in addition to the one required to maintain the object on screen.</span></span> <span data-ttu-id="5f1ba-108">Además, si traslada el objeto de una plataforma a otra, OLE convierte automáticamente los formatos de datos del objeto en los que se admiten en la nueva plataforma.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-108">Moreover, if you port the object from one platform to another, OLE automatically converts the object's data formats to ones supported on the new platform.</span></span> <span data-ttu-id="5f1ba-109">Por ejemplo, si mueve un objeto de Windows a Macintosh, OLE convertirá sus presentaciones de metarchivo en formatos PICT.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-109">For example, if you move an object from Windows to the Macintosh, OLE will convert its metafile presentations to PICT formats.</span></span>

<span data-ttu-id="5f1ba-110">Para presentar una representación exacta de un objeto incrustado al usuario, la aplicación contenedora del objeto inicia un cuadro de diálogo con el controlador de objetos, solicitando datos e instrucciones de dibujo.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-110">In order to present an accurate representation of an embedded object to the user, the object's container application initiates a dialog with the object handler, requesting data and drawing instructions.</span></span> <span data-ttu-id="5f1ba-111">Para poder satisfacer las solicitudes del contenedor, el controlador debe implementar las interfaces [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject), [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)y [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) .</span><span class="sxs-lookup"><span data-stu-id="5f1ba-111">To be able to fulfill the container's requests, the handler must implement the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject), [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2), and [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) interfaces.</span></span>

<span data-ttu-id="5f1ba-112">[**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) permite a una aplicación contenedora OLE obtener y enviar datos a los objetos incrustados o vinculados.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-112">[**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) enables an OLE container application to get data from and send data to its embedded or linked objects.</span></span> <span data-ttu-id="5f1ba-113">Cuando los datos cambian en un objeto, esta interfaz proporciona una manera para que el objeto haga que sus nuevos datos estén disponibles para su contenedor y proporciona al contenedor una manera de actualizar los datos en su copia del objeto.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-113">When data changes in an object, this interface provides a way for the object to make its new data available to its container and provides the container with a way to update the data in its copy of the object.</span></span> <span data-ttu-id="5f1ba-114">(Para obtener una explicación de la transferencia de datos en general, vea el capítulo 4, Transferencia de datos).</span><span class="sxs-lookup"><span data-stu-id="5f1ba-114">(For a discussion of data transfer in general, see Chapter 4, Data Transfer.)</span></span>

<span data-ttu-id="5f1ba-115">La interfaz [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) es muy similar a la interfaz [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) , salvo que pide a un objeto que se dibuje en un contexto de dispositivo, como una pantalla, una impresora o un metarchivo, en lugar de moverse o copiar sus datos en la memoria o en algún otro medio de transferencia.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-115">The [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) interface is very much like the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface except that it asks an object to draw itself on a device context, such as a screen, printer, or metafile, rather than move or copy its data to memory or some other transfer medium.</span></span> <span data-ttu-id="5f1ba-116">El propósito de la interfaz es permitir a un contenedor OLE obtener representaciones de gráficos alternativas de sus objetos incrustados, cuyos datos ya tiene, evitando así la sobrecarga de tener que transferir instancias completamente nuevas de los mismos objetos de datos simplemente para obtener nuevas instrucciones de dibujo.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-116">The purpose of the interface is to enable an OLE container to obtain alternative pictorial representations of its embedded objects, whose data it already has, thereby avoiding the overhead of having to transfer entirely new instances of the same data objects simply to obtain new drawing instructions.</span></span> <span data-ttu-id="5f1ba-117">En su lugar, la interfaz **IViewObject2** permite al contenedor pedir a un objeto que proporcione una representación gráfica de sí mismo dibujando en un contexto de dispositivo especificado por el contenedor.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-117">Instead, the **IViewObject2** interface enables the container to ask an object to provide a pictorial representation of itself by drawing on a device context specified by the container.</span></span>

<span data-ttu-id="5f1ba-118">Al llamar a la interfaz [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) , una aplicación contenedora también puede especificar que el objeto se dibuje en un dispositivo de destino distinto del que realmente se representará.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-118">When calling the [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) interface, a container application can also specify that the object draw itself on a target device different than the one on which it will actually be rendered.</span></span> <span data-ttu-id="5f1ba-119">Esto habilita el contenedor, según sea necesario, para generar representaciones diferentes a partir de un único objeto.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-119">This enables the container, as needed, to generate different renderings from a single object.</span></span> <span data-ttu-id="5f1ba-120">Por ejemplo, el autor de la llamada podría solicitar al objeto que se componga para una impresora aunque el dibujo resultante se represente en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-120">For example, the caller could ask the object to compose itself for a printer even though the resulting drawing will be rendered on screen.</span></span> <span data-ttu-id="5f1ba-121">El resultado, por supuesto, sería una vista previa de impresión del objeto.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-121">The result, of course, would be a print-preview of the object.</span></span>

<span data-ttu-id="5f1ba-122">La interfaz [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)también proporciona métodos que permiten a los contenedores registrarse para las notificaciones de cambio de vista.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-122">The [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)interface also provides methods that enable containers to register for view-change notifications.</span></span> <span data-ttu-id="5f1ba-123">Al igual que con los datos y los avisos OLE, una conexión de consulta de vistas permite a un contenedor actualizar sus representaciones de un objeto por su propia comodidad en lugar de responder a una llamada del objeto.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-123">As with data and OLE advisories, a view advisory connection enables a container to update its renderings of an object at its own convenience rather than in response to a call from the object.</span></span> <span data-ttu-id="5f1ba-124">Por ejemplo, si una nueva versión de la aplicación de servidor de un objeto proporcionara vistas adicionales de los mismos datos, el controlador predeterminado del objeto llamaría a la implementación del contenedor de [**IAdviseSink:: OnViewChange**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onviewchange) para que sepan que las nuevas presentaciones estaban disponibles.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-124">For example, if a new version of an object's server application were to offer additional views of the same data, the object's default handler would call each container's implementation of [**IAdviseSink::OnViewChange**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onviewchange) to let them know that the new presentations were available.</span></span> <span data-ttu-id="5f1ba-125">El contenedor recuperaría esta información del receptor de notificaciones solo cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-125">The container would retrieve this information from the advise sink only when needed.</span></span>

<span data-ttu-id="5f1ba-126">Dado que los contextos de dispositivos Windows solo tienen significado dentro de un único proceso, no se pueden pasar punteros de [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) a través de los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-126">Because Windows device contexts have meaning only within a single process, you cannot pass [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) pointers across process boundaries.</span></span> <span data-ttu-id="5f1ba-127">Como resultado, no es necesario que los servidores locales y remotos de OLE implementen la interfaz, lo que no funcionaría correctamente aunque lo hicieran.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-127">As a result, OLE local and remote servers have no need whatsoever to implement the interface, which wouldn't work properly even if they did.</span></span> <span data-ttu-id="5f1ba-128">Solo los controladores de objetos y los servidores en proceso implementan la interfaz **IViewObject2**.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-128">Only object handlers and in-process servers implement the **IViewObject2** interface.</span></span> <span data-ttu-id="5f1ba-129">OLE proporciona una implementación predeterminada, que puede usar en sus propios servidores OLE en proceso y controladores de objetos simplemente agregando el controlador predeterminado de OLE.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-129">OLE provides a default implementation, which you can use in your own OLE in-process servers and object handlers simply by aggregating the OLE default handler.</span></span> <span data-ttu-id="5f1ba-130">También puede escribir su propia implementación de **IViewObject2**.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-130">Or you can write your own implementation of **IViewObject2**.</span></span>

<span data-ttu-id="5f1ba-131">Un objeto implementa la interfaz [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) para permitir que el controlador sepa qué funcionalidades debe almacenar en caché.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-131">An object implements the [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) interface in order to let the handler know what capabilities it should cache.</span></span> <span data-ttu-id="5f1ba-132">El controlador de objetos también posee la memoria caché y garantiza que se mantiene actualizada.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-132">The object handler also owns the cache and ensures it is kept up to date.</span></span> <span data-ttu-id="5f1ba-133">Cuando el objeto incrustado entra en el estado de ejecución, el controlador establece las conexiones de consulta apropiadas en el objeto de servidor, que actúa como receptor.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-133">As the embedded object enters the running state, the handler sets up appropriate advisory connections on the server object, with itself acting as the sink.</span></span> <span data-ttu-id="5f1ba-134">Las implementaciones de la interfaz [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) y [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)operan fuera de los datos almacenados en caché en el lado cliente.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-134">The [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) and [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)interface implementations operate out of data cached on the client side.</span></span> <span data-ttu-id="5f1ba-135">La implementación del controlador de **IViewObject2** es responsable de determinar qué formatos de datos se almacenan en memoria caché para satisfacer las solicitudes de dibujo del cliente.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-135">The handler's implementation of **IViewObject2** is responsible for determining what data formats to cache in order to satisfy client draw requests.</span></span> <span data-ttu-id="5f1ba-136">La implementación del controlador de **IDataObject** es responsable de obtener datos en varios formatos, etc., entre la memoria y la instancia de [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) subyacente del objeto incrustado.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-136">The handler's implementation of **IDataObject** is responsible for getting data in various formats, etc., between memory and the underlying [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) instance of the embedded object.</span></span> <span data-ttu-id="5f1ba-137">Los controladores personalizados pueden utilizar estas implementaciones agregando en el controlador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-137">Custom handlers can use these implementations by aggregating on the default handler.</span></span>

> [!Note]  
> <span data-ttu-id="5f1ba-138">La interfaz [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) es una extensión funcional simple de [**IViewObject**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject) y debe implementarse en lugar de la última interfaz, que ahora está obsoleta.</span><span class="sxs-lookup"><span data-stu-id="5f1ba-138">The [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) interface is a simple functional extension of [**IViewObject**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject) and should be implemented instead of the latter interface, which is now obsolete.</span></span> <span data-ttu-id="5f1ba-139">Además de proporcionar los métodos **IViewObject** , la interfaz **IViewObject2** proporciona un solo miembro adicional, [**GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-iviewobject2-getextent), que permite a una aplicación contenedora obtener el tamaño de la presentación de un objeto de la memoria caché sin tener que trasladar primero el objeto al estado en ejecución con una llamada a [**IOleObject:: GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-ioleobject-getextent).</span><span class="sxs-lookup"><span data-stu-id="5f1ba-139">In addition to providing the **IViewObject** methods, the **IViewObject2** interface provides a single additional member, [**GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-iviewobject2-getextent), which enables a container application to get the size of an object's presentation from the cache without first having to move the object into the running state with a call to [**IOleObject::GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-ioleobject-getextent).</span></span>

 

## <a name="related-topics"></a><span data-ttu-id="5f1ba-140">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="5f1ba-140">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="5f1ba-141">Documentos compuestos</span><span class="sxs-lookup"><span data-stu-id="5f1ba-141">Compound Documents</span></span>](compound-documents.md)
</dt> </dl>

 

 