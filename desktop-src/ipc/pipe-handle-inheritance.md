---
description: El servidor de canalización controla si sus identificadores se pueden heredar de las siguientes maneras.
ms.assetid: 72302f8b-f3a2-4efc-aab1-e596b8323984
title: Herencia de controladores de canalización
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 21cf91d4393b43011a2df632806f96da1e713b96
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "103808402"
---
# <a name="pipe-handle-inheritance"></a><span data-ttu-id="49e10-103">Herencia de controladores de canalización</span><span class="sxs-lookup"><span data-stu-id="49e10-103">Pipe Handle Inheritance</span></span>

<span data-ttu-id="49e10-104">El servidor de canalización controla si sus identificadores se pueden heredar de las siguientes maneras:</span><span class="sxs-lookup"><span data-stu-id="49e10-104">The pipe server controls whether its handles can be inherited in the following ways:</span></span>

-   <span data-ttu-id="49e10-105">La función [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) recibe una estructura de [**\_ atributos de seguridad**](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) .</span><span class="sxs-lookup"><span data-stu-id="49e10-105">The [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) function receives a [**SECURITY\_ATTRIBUTES**](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) structure.</span></span> <span data-ttu-id="49e10-106">Si el servidor de canalización establece el miembro **bInheritHandle** de esta estructura en **true**, los identificadores creados por **CreatePipe** se pueden heredar.</span><span class="sxs-lookup"><span data-stu-id="49e10-106">If the pipe server sets the **bInheritHandle** member of this structure to **TRUE**, the handles created by **CreatePipe** can be inherited.</span></span>
-   <span data-ttu-id="49e10-107">El servidor de canalización puede utilizar la función [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) para cambiar la herencia de un identificador de canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-107">The pipe server can use the [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) function to change the inheritance of a pipe handle.</span></span> <span data-ttu-id="49e10-108">El servidor de canalización puede crear un duplicado no heredable de un identificador de canalización heredable o un duplicado heredable de un identificador de canalización que no se puede heredar.</span><span class="sxs-lookup"><span data-stu-id="49e10-108">The pipe server can create a noninheritable duplicate of an inheritable pipe handle or an inheritable duplicate of a noninheritable pipe handle.</span></span>
-   <span data-ttu-id="49e10-109">La función [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) permite que el servidor de canalización especifique si un proceso secundario hereda todos o ninguno de sus identificadores heredables.</span><span class="sxs-lookup"><span data-stu-id="49e10-109">The [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) function enables the pipe server to specify whether a child process inherits all or none of its inheritable handles.</span></span>

<span data-ttu-id="49e10-110">Cuando un proceso secundario hereda un identificador de canalización, el sistema permite que el proceso tenga acceso a la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-110">When a child process inherits a pipe handle, the system enables the process to access the pipe.</span></span> <span data-ttu-id="49e10-111">Sin embargo, el proceso primario debe comunicar el valor del identificador al proceso secundario.</span><span class="sxs-lookup"><span data-stu-id="49e10-111">However, the parent process must communicate the handle value to the child process.</span></span> <span data-ttu-id="49e10-112">Normalmente, el proceso primario hace esto redirigiendo el identificador de salida estándar al proceso secundario, tal y como se muestra en los pasos siguientes:</span><span class="sxs-lookup"><span data-stu-id="49e10-112">The parent process typically does this by redirecting the standard output handle to the child process, as shown in the following steps:</span></span>

1.  <span data-ttu-id="49e10-113">Llame a la función [**GetStdHandle**](/windows/console/getstdhandle) para obtener el identificador de salida estándar actual; Guarde este identificador para poder restaurar el identificador de salida estándar original después de que se haya creado el proceso secundario.</span><span class="sxs-lookup"><span data-stu-id="49e10-113">Call the [**GetStdHandle**](/windows/console/getstdhandle) function to get the current standard output handle; save this handle so you can restore the original standard output handle after the child process has been created.</span></span>
2.  <span data-ttu-id="49e10-114">Llame a la función [**SetStdHandle**](/windows/console/setstdhandle) para establecer el identificador de salida estándar en el identificador de escritura en la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-114">Call the [**SetStdHandle**](/windows/console/setstdhandle) function to set the standard output handle to the write handle to the pipe.</span></span> <span data-ttu-id="49e10-115">Ahora, el proceso primario puede crear el proceso secundario.</span><span class="sxs-lookup"><span data-stu-id="49e10-115">Now the parent process can create the child process.</span></span>
3.  <span data-ttu-id="49e10-116">Llame a la función [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) para cerrar el identificador de escritura en la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-116">Call the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function to close the write handle to the pipe.</span></span> <span data-ttu-id="49e10-117">Después de que el proceso secundario hereda el identificador de escritura, el proceso primario ya no necesita su copia.</span><span class="sxs-lookup"><span data-stu-id="49e10-117">After the child process inherits the write handle, the parent process no longer needs its copy.</span></span>
4.  <span data-ttu-id="49e10-118">Llame a [**SetStdHandle**](/windows/console/setstdhandle) para restaurar el identificador de salida estándar original.</span><span class="sxs-lookup"><span data-stu-id="49e10-118">Call [**SetStdHandle**](/windows/console/setstdhandle) to restore the original standard output handle.</span></span>

<span data-ttu-id="49e10-119">El proceso secundario utiliza la función [**GetStdHandle**](/windows/console/getstdhandle) para obtener su identificador de salida estándar, que ahora es un identificador del extremo de escritura de una canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-119">The child process uses the [**GetStdHandle**](/windows/console/getstdhandle) function to get its standard output handle, which is now a handle to the write end of a pipe.</span></span> <span data-ttu-id="49e10-120">A continuación, el proceso secundario utiliza la función [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) para enviar su salida a la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-120">The child process then uses the [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) function to send its output to the pipe.</span></span> <span data-ttu-id="49e10-121">Cuando el elemento secundario ha terminado con la canalización, debe cerrar el identificador de canalización llamando a [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) o finalizando, lo que cierra automáticamente el identificador.</span><span class="sxs-lookup"><span data-stu-id="49e10-121">When the child has finished with the pipe, it should close the pipe handle by calling [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) or by terminating, which automatically closes the handle.</span></span>

<span data-ttu-id="49e10-122">El proceso primario utiliza la función [**readfile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) para recibir la entrada de la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-122">The parent process uses the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) function to receive input from the pipe.</span></span> <span data-ttu-id="49e10-123">Los datos se escriben en una canalización anónima como un flujo de bytes.</span><span class="sxs-lookup"><span data-stu-id="49e10-123">Data is written to an anonymous pipe as a stream of bytes.</span></span> <span data-ttu-id="49e10-124">Esto significa que el proceso primario que lee de una canalización no puede distinguir entre los bytes escritos en operaciones de escritura independientes, a menos que los procesos primarios y secundarios usen un protocolo para indicar dónde finaliza la operación de escritura.</span><span class="sxs-lookup"><span data-stu-id="49e10-124">This means that the parent process reading from a pipe cannot distinguish between the bytes written in separate write operations, unless both the parent and child processes use a protocol to indicate where the write operation ends.</span></span> <span data-ttu-id="49e10-125">Cuando se cierran todos los identificadores de escritura de la canalización, la función **readfile** devuelve cero.</span><span class="sxs-lookup"><span data-stu-id="49e10-125">When all write handles to the pipe are closed, the **ReadFile** function returns zero.</span></span> <span data-ttu-id="49e10-126">Es importante que el proceso primario cierre su identificador hasta el final de escritura de la canalización antes de llamar a **readfile**.</span><span class="sxs-lookup"><span data-stu-id="49e10-126">It is important for the parent process to close its handle to the write end of the pipe before calling **ReadFile**.</span></span> <span data-ttu-id="49e10-127">Si no se hace esto, la operación **readfile** no puede devolver cero porque el proceso primario tiene un identificador abierto para el extremo de escritura de la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-127">If this is not done, the **ReadFile** operation cannot return zero because the parent process has an open handle to the write end of the pipe.</span></span>

<span data-ttu-id="49e10-128">El procedimiento para redirigir el identificador de entrada estándar es similar al de redirigir el identificador de salida estándar, salvo que el identificador de lectura de la canalización se usa como el identificador de entrada estándar del elemento secundario.</span><span class="sxs-lookup"><span data-stu-id="49e10-128">The procedure for redirecting the standard input handle is similar to that for redirecting the standard output handle, except that the pipe's read handle is used as the child's standard input handle.</span></span> <span data-ttu-id="49e10-129">En este caso, el proceso primario debe asegurarse de que el proceso secundario no hereda el identificador de escritura de la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-129">In this case, the parent process must ensure that the child process does not inherit the pipe's write handle.</span></span> <span data-ttu-id="49e10-130">Si no se hace esto, la operación [**readfile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) realizada por el proceso secundario no puede devolver cero porque el proceso secundario tiene un identificador abierto para el extremo de escritura de la canalización.</span><span class="sxs-lookup"><span data-stu-id="49e10-130">If this is not done, the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) operation performed by the child process cannot return zero because the child process has an open handle to the write end of the pipe.</span></span>

<span data-ttu-id="49e10-131">Para obtener un programa de ejemplo que usa canalizaciones anónimas para redirigir los identificadores estándar de un proceso secundario, vea [crear un proceso secundario con entrada y salida redirigidas](/windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output).</span><span class="sxs-lookup"><span data-stu-id="49e10-131">For an example program that uses anonymous pipes to redirect the standard handles of a child process, see [Creating a Child Process with Redirected Input and Output](/windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output).</span></span>

 

 
