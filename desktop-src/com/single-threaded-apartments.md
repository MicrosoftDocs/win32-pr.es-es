---
title: Single-Threaded apartamentos
description: Single-Threaded apartamentos
ms.assetid: 2f345ae2-8314-4067-a6d6-5a0275941ed4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0f0a8cb1422b6866d9e0d043fdd46c895e6d335b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/21/2020
ms.locfileid: "104421450"
---
# <a name="single-threaded-apartments"></a><span data-ttu-id="dc606-103">Single-Threaded apartamentos</span><span class="sxs-lookup"><span data-stu-id="dc606-103">Single-Threaded Apartments</span></span>

<span data-ttu-id="dc606-104">El uso de apartamentos de un solo subproceso (el proceso del modelo de apartamento) ofrece un paradigma basado en mensaje para tratar varios objetos que se ejecutan simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="dc606-104">Using single-threaded apartments (the apartment model process) offers a message-based paradigm for dealing with multiple objects running concurrently.</span></span> <span data-ttu-id="dc606-105">Permite escribir código más eficaz permitiendo que un subproceso, mientras espera que se complete una operación que consume mucho tiempo, para permitir la ejecución de otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-105">It enables you to write more efficient code by allowing a thread, while it waits for some time-consuming operation to complete, to allow another thread to be executed.</span></span>

<span data-ttu-id="dc606-106">Cada subproceso de un proceso que se inicializa como un proceso de modelo de apartamento, y que recupera y envía mensajes de ventana, es un subproceso de apartamento de un solo subproceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-106">Each thread in a process that is initialized as an apartment model process, and that retrieves and dispatches window messages, is a single-threaded apartment thread.</span></span> <span data-ttu-id="dc606-107">Cada subproceso reside en su propio apartamento.</span><span class="sxs-lookup"><span data-stu-id="dc606-107">Each thread lives within its own apartment.</span></span> <span data-ttu-id="dc606-108">Dentro de un contenedor, los punteros de interfaz se pueden pasar sin serialización y, por tanto, todos los objetos de un subproceso de apartamento de un solo subproceso se comunican directamente.</span><span class="sxs-lookup"><span data-stu-id="dc606-108">Within an apartment, interface pointers can be passed without marshaling, and therefore, all objects in one single-threaded apartment thread communicate directly.</span></span>

<span data-ttu-id="dc606-109">Una agrupación lógica de objetos relacionados que todos se ejecutan en el mismo subproceso y, por tanto, debe tener una ejecución sincrónica, puede residir en el mismo subproceso de apartamento de un solo subproceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-109">A logical grouping of related objects that all execute on the same thread, and therefore must have synchronous execution, could live on the same single-threaded apartment thread.</span></span> <span data-ttu-id="dc606-110">Sin embargo, un objeto de modelo de apartamento no puede residir en más de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-110">However, an apartment model object cannot reside on more than one thread.</span></span> <span data-ttu-id="dc606-111">Las llamadas a objetos de otros subprocesos deben realizarse en el contexto del subproceso propietario, por lo que los subprocesos COM distribuidos automáticamente cambian automáticamente cuando se llama a en un proxy.</span><span class="sxs-lookup"><span data-stu-id="dc606-111">Calls to objects in other threads must be made within the context of the owning thread, so distributed COM switches threads for you automatically when you call on a proxy.</span></span>

<span data-ttu-id="dc606-112">Los modelos de interproceso e interthread son similares.</span><span class="sxs-lookup"><span data-stu-id="dc606-112">The interprocess and interthread models are similar.</span></span> <span data-ttu-id="dc606-113">Cuando es necesario pasar un puntero de interfaz a un objeto de otro apartamento (en otro subproceso) dentro del mismo proceso, se usa el mismo modelo de serialización que los objetos de diferentes procesos utilizan para pasar punteros a través de los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-113">When it is necessary to pass an interface pointer to an object in another apartment (on another thread) within the same process, you use the same marshaling model that objects in different processes use to pass pointers across process boundaries.</span></span> <span data-ttu-id="dc606-114">Al obtener un puntero al objeto de serialización estándar, puede calcular las referencias de los punteros de interfaz a través de los límites de subprocesos (entre apartamentos) de la misma manera que lo hace entre los procesos.</span><span class="sxs-lookup"><span data-stu-id="dc606-114">By getting a pointer to the standard marshaling object, you can marshal interface pointers across thread boundaries (between apartments) in the same way you do between processes.</span></span> <span data-ttu-id="dc606-115">(Se deben calcular las referencias de los punteros de interfaz cuando se pasan entre apartamentos).</span><span class="sxs-lookup"><span data-stu-id="dc606-115">(Interface pointers must be marshaled when passed between apartments.)</span></span>

<span data-ttu-id="dc606-116">Las reglas para apartamentos de un solo subproceso son sencillas, pero es importante seguirlos con cuidado:</span><span class="sxs-lookup"><span data-stu-id="dc606-116">Rules for single-threaded apartments are simple, but it is important to follow them carefully:</span></span>

-   <span data-ttu-id="dc606-117">Cada objeto debe residir en un único subproceso (dentro de un contenedor uniproceso).</span><span class="sxs-lookup"><span data-stu-id="dc606-117">Every object should live on only one thread (within a single-threaded apartment).</span></span>
-   <span data-ttu-id="dc606-118">Inicialice la biblioteca COM para cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-118">Initialize the COM library for each thread.</span></span>
-   <span data-ttu-id="dc606-119">Calcular las referencias de todos los punteros a objetos al pasarlos entre apartamentos.</span><span class="sxs-lookup"><span data-stu-id="dc606-119">Marshal all pointers to objects when passing them between apartments.</span></span>
-   <span data-ttu-id="dc606-120">Cada apartamento de un solo subproceso debe tener un bucle de mensajes para controlar las llamadas de otros procesos y apartamentos dentro del mismo proceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-120">Each single-threaded apartment must have a message loop to handle calls from other processes and apartments within the same process.</span></span> <span data-ttu-id="dc606-121">Los apartamentos de un solo subproceso sin objetos (solo cliente) también necesitan un bucle de mensajes para enviar los mensajes de difusión que usan algunas aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="dc606-121">Single-threaded apartments without objects (client only) also need a message loop to dispatch the broadcast messages that some applications use.</span></span>
-   <span data-ttu-id="dc606-122">Los objetos basados en DLL o en proceso no llaman a las funciones de inicialización de COM; en su lugar, registran su modelo de subprocesos con el valor de **ThreadingModel** denominado-Value bajo la clave [InProcServer32](inprocserver32.md) en el registro.</span><span class="sxs-lookup"><span data-stu-id="dc606-122">DLL-based or in-process objects do not call the COM initialization functions; instead, they register their threading model with the **ThreadingModel** named-value under the [InprocServer32](inprocserver32.md) key in the registry.</span></span> <span data-ttu-id="dc606-123">Los objetos que reconocen el apartamento también deben escribir cuidadosamente puntos de entrada de DLL.</span><span class="sxs-lookup"><span data-stu-id="dc606-123">Apartment-aware objects must also write DLL entry points carefully.</span></span> <span data-ttu-id="dc606-124">Existen consideraciones especiales que se aplican a los subprocesos de los servidores en proceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-124">There are special considerations that apply to threading in-process servers.</span></span> <span data-ttu-id="dc606-125">Para obtener más información, vea [problemas de subprocesos de servidor en proceso](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="dc606-125">For more information, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="dc606-126">Mientras que varios objetos pueden residir en un único subproceso, ningún objeto de modelo de apartamento puede residir en más de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-126">While multiple objects can live on a single thread, no apartment model object can live on more than one thread.</span></span>

<span data-ttu-id="dc606-127">Cada subproceso de un proceso de cliente o servidor fuera de proceso debe llamar a [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), o llamar a [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) y especificar coinit \_ APARTMENTTHREADED para el parámetro *dwCoInit* .</span><span class="sxs-lookup"><span data-stu-id="dc606-127">Each thread of a client process or out-of-process server must call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), or call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) and specify COINIT\_APARTMENTTHREADED for the *dwCoInit* parameter.</span></span> <span data-ttu-id="dc606-128">El apartamento principal es el subproceso que llama a **CoInitializeEx** en primer lugar.</span><span class="sxs-lookup"><span data-stu-id="dc606-128">The main apartment is the thread that calls **CoInitializeEx** first.</span></span> <span data-ttu-id="dc606-129">Para obtener información sobre los servidores en proceso, vea [problemas de subprocesos de servidor en proceso](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="dc606-129">For information on in-process servers, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="dc606-130">Todas las llamadas a un objeto deben realizarse en su subproceso (dentro de su apartamento).</span><span class="sxs-lookup"><span data-stu-id="dc606-130">All calls to an object must be made on its thread (within its apartment).</span></span> <span data-ttu-id="dc606-131">Está prohibido llamar a un objeto directamente desde otro subproceso. el uso de objetos en este modo de subprocesamiento libre podría causar problemas en las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="dc606-131">It is forbidden to call an object directly from another thread; using objects in this free-threaded manner could cause problems for applications.</span></span> <span data-ttu-id="dc606-132">La implicación de esta regla es que se deben calcular las referencias de todos los punteros a objetos cuando se pasan entre apartamentos.</span><span class="sxs-lookup"><span data-stu-id="dc606-132">The implication of this rule is that all pointers to objects must be marshaled when passed between apartments.</span></span> <span data-ttu-id="dc606-133">COM proporciona las dos funciones siguientes para este propósito:</span><span class="sxs-lookup"><span data-stu-id="dc606-133">COM provides the following two functions for this purpose:</span></span>

-   <span data-ttu-id="dc606-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) calcula las referencias de una interfaz en un objeto de flujo que se devuelve al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="dc606-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) marshals an interface into a stream object that is returned to the caller.</span></span>
-   <span data-ttu-id="dc606-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) no calcula las referencias de un puntero de interfaz desde un objeto de flujo y lo libera.</span><span class="sxs-lookup"><span data-stu-id="dc606-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) unmarshals an interface pointer from a stream object and releases it.</span></span>

<span data-ttu-id="dc606-136">Estas funciones ajustan las llamadas a las funciones [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) y [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) , que requieren el uso de la \_ marca INPROC MSHCTX.</span><span class="sxs-lookup"><span data-stu-id="dc606-136">These functions wrap calls to [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) and [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) functions, which require the use of the MSHCTX\_INPROC flag.</span></span>

<span data-ttu-id="dc606-137">En general, COM realiza automáticamente el cálculo de referencias.</span><span class="sxs-lookup"><span data-stu-id="dc606-137">In general, the marshaling is accomplished automatically by COM.</span></span> <span data-ttu-id="dc606-138">Por ejemplo, cuando se pasa un puntero de interfaz como un parámetro en una llamada de método en un proxy a un objeto de otro apartamento, o cuando se llama a [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), com realiza el cálculo de referencias automáticamente.</span><span class="sxs-lookup"><span data-stu-id="dc606-138">For example, when passing an interface pointer as a parameter in a method call on a proxy to an object in another apartment, or when calling [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), COM does the marshaling automatically.</span></span> <span data-ttu-id="dc606-139">Sin embargo, en algunos casos especiales, en los que el escritor de la aplicación está pasando punteros de interfaz entre apartamentos sin usar los mecanismos COM normales, el escritor debe controlar manualmente el cálculo de referencias.</span><span class="sxs-lookup"><span data-stu-id="dc606-139">However, in some special cases, where the application writer is passing interface pointers between apartments without using the normal COM mechanisms, the writer must handle the marshaling manually.</span></span>

<span data-ttu-id="dc606-140">Si un contenedor (Apartamento 1) de un proceso tiene un puntero de interfaz y otro apartamento (Apartamento 2) requiere su uso, el apartamento 1 debe llamar a [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) para calcular las referencias de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="dc606-140">If one apartment (Apartment 1) in a process has an interface pointer and another apartment (Apartment 2) requires its use, Apartment 1 must call [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) to marshal the interface.</span></span> <span data-ttu-id="dc606-141">La secuencia que se crea mediante esta función es segura para subprocesos y debe almacenarse en una variable a la que pueda acceder el apartamento 2.</span><span class="sxs-lookup"><span data-stu-id="dc606-141">The stream that is created by this function is thread-safe and must be stored in a variable that is accessible by Apartment 2.</span></span> <span data-ttu-id="dc606-142">El Apartamento 2 debe pasar esta secuencia a [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) para anular la serialización de la interfaz y devolverá un puntero a un proxy a través del cual puede acceder a la interfaz.</span><span class="sxs-lookup"><span data-stu-id="dc606-142">Apartment 2 must pass this stream to [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) to unmarshal the interface and will get back a pointer to a proxy through which it can access the interface.</span></span> <span data-ttu-id="dc606-143">El apartamento principal debe permanecer activo hasta que el cliente haya completado todo el trabajo COM (porque algunos objetos en curso se cargan en el apartamento principal, como se describe en [problemas de subprocesos de servidor en proceso](in-process-server-threading-issues.md)).</span><span class="sxs-lookup"><span data-stu-id="dc606-143">The main apartment must remain alive until the client has completed all COM work (because some in-process objects are loaded in the main apartment, as described in [In-Process Server Threading Issues](in-process-server-threading-issues.md)).</span></span> <span data-ttu-id="dc606-144">Una vez que se ha pasado un objeto entre subprocesos de esta manera, es muy fácil pasar punteros de interfaz como parámetros.</span><span class="sxs-lookup"><span data-stu-id="dc606-144">After one object has been passed between threads in this manner, it is very easy to pass interface pointers as parameters.</span></span> <span data-ttu-id="dc606-145">De este modo, COM distribuido realiza las referencias y el cambio de subprocesos de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="dc606-145">That way, distributed COM does the marshaling and thread switching for the application.</span></span>

<span data-ttu-id="dc606-146">Para controlar las llamadas de otros procesos y apartamentos dentro del mismo proceso, cada apartamento de un solo subproceso debe tener un bucle de mensajes.</span><span class="sxs-lookup"><span data-stu-id="dc606-146">To handle calls from other processes and apartments within the same process, each single-threaded apartment must have a message loop.</span></span> <span data-ttu-id="dc606-147">Esto significa que la función de trabajo del subproceso debe tener un bucle GetMessage/DispatchMessage.</span><span class="sxs-lookup"><span data-stu-id="dc606-147">This means that the thread's work function must have a GetMessage/DispatchMessage loop.</span></span> <span data-ttu-id="dc606-148">Si se usan otras primitivas de sincronización para la comunicación entre subprocesos, la función [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) se puede usar para esperar tanto los mensajes como los eventos de sincronización de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="dc606-148">If other synchronization primitives are being used to communicate between threads, the [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) function can be used to wait both for messages and for thread synchronization events.</span></span> <span data-ttu-id="dc606-149">La documentación de esta función tiene un ejemplo de este tipo de bucle de combinación.</span><span class="sxs-lookup"><span data-stu-id="dc606-149">The documentation for this function has an example of this sort of combination loop.</span></span>

<span data-ttu-id="dc606-150">COM crea una ventana oculta mediante la clase de Windows "OleMainThreadWndClass" en cada apartamento de un solo subproceso.</span><span class="sxs-lookup"><span data-stu-id="dc606-150">COM creates a hidden window using the Windows class "OleMainThreadWndClass" in each single-threaded apartment.</span></span> <span data-ttu-id="dc606-151">Se recibe una llamada a un objeto como un mensaje de ventana en esta ventana oculta.</span><span class="sxs-lookup"><span data-stu-id="dc606-151">A call to an object is received as a window message to this hidden window.</span></span> <span data-ttu-id="dc606-152">Cuando el apartamento del objeto recupera y envía el mensaje, la ventana oculta lo recibirá.</span><span class="sxs-lookup"><span data-stu-id="dc606-152">When the object's apartment retrieves and dispatches the message, the hidden window will receive it.</span></span> <span data-ttu-id="dc606-153">A continuación, el procedimiento de ventana llamará al método de interfaz correspondiente del objeto.</span><span class="sxs-lookup"><span data-stu-id="dc606-153">The window procedure will then call the corresponding interface method of the object.</span></span>

<span data-ttu-id="dc606-154">Cuando varios clientes llaman a un objeto, las llamadas se ponen en cola en la cola de mensajes y el objeto recibirá una llamada cada vez que su apartamento recupere y envíe mensajes.</span><span class="sxs-lookup"><span data-stu-id="dc606-154">When multiple clients call an object, the calls are queued in the message queue and the object will receive a call each time its apartment retrieves and dispatches messages.</span></span> <span data-ttu-id="dc606-155">Dado que COM sincroniza las llamadas y las llamadas siempre se entregan mediante el subproceso que pertenece al apartamento del objeto, las implementaciones de interfaz del objeto no necesitan realizar la sincronización.</span><span class="sxs-lookup"><span data-stu-id="dc606-155">Because the calls are synchronized by COM and the calls are always delivered by the thread that belongs to the object's apartment, the object's interface implementations need not provide synchronization.</span></span> <span data-ttu-id="dc606-156">Los apartamentos de un solo subproceso pueden implementar [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) para permitirles cancelar llamadas o recibir mensajes de ventana cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="dc606-156">Single-threaded apartments can implement [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) to permit them to cancel calls or receive window messages when necessary.</span></span>

<span data-ttu-id="dc606-157">El objeto se puede volver a escribir si una de sus implementaciones de método de interfaz recupera y envía mensajes o realiza una llamada ORPC a otro subproceso, lo que provoca que se entregue otra llamada al objeto (por el mismo apartamento).</span><span class="sxs-lookup"><span data-stu-id="dc606-157">The object can be reentered if one of its interface method implementations retrieves and dispatches messages or makes an ORPC call to another thread, thereby causing another call to be delivered to the object (by the same apartment).</span></span> <span data-ttu-id="dc606-158">OLE no impide la reentrada en el mismo subproceso, pero puede ayudar a proporcionar seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="dc606-158">OLE does not prevent reentrancy on the same thread, but it can help provide thread safety.</span></span> <span data-ttu-id="dc606-159">Es idéntico a la forma en que se puede volver a escribir un procedimiento de ventana si recupera y envía mensajes mientras procesa un mensaje.</span><span class="sxs-lookup"><span data-stu-id="dc606-159">This is identical to the way in which a window procedure can be reentered if it retrieves and dispatches messages while processing a message.</span></span> <span data-ttu-id="dc606-160">Sin embargo, si se llama a un servidor de apartamento de un solo subproceso fuera de proceso que llama a otro servidor de apartamento de un solo subproceso, permitirá que se vuelva a escribir el primer servidor.</span><span class="sxs-lookup"><span data-stu-id="dc606-160">However, calling an out-of-process single-threaded apartment server that calls another single-threaded apartment server will allow the first server to be reentered.</span></span>

## <a name="related-topics"></a><span data-ttu-id="dc606-161">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="dc606-161">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="dc606-162">Acceso a interfaces entre apartamentos</span><span class="sxs-lookup"><span data-stu-id="dc606-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="dc606-163">Elegir el modelo de subprocesos</span><span class="sxs-lookup"><span data-stu-id="dc606-163">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="dc606-164">Apartamentos multiproceso</span><span class="sxs-lookup"><span data-stu-id="dc606-164">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="dc606-165">Problemas de subprocesos de servidor en proceso</span><span class="sxs-lookup"><span data-stu-id="dc606-165">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="dc606-166">Procesos, subprocesos y apartamentos</span><span class="sxs-lookup"><span data-stu-id="dc606-166">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="dc606-167">Comunicación multiproceso y de un solo subproceso</span><span class="sxs-lookup"><span data-stu-id="dc606-167">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> </dl>

 

 