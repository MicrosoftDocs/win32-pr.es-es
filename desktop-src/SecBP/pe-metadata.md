---
description: En este artículo se proporcionan detalles adicionales sobre los metadatos de protección de flujo de control en imágenes PE.
title: Metadatos de PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105669910"
---
# <a name="pe-metadata"></a>Metadatos de PE

En este artículo se proporcionan detalles adicionales sobre los metadatos de protección de flujo de control (CFG) en imágenes PE. Se supone que está familiarizado con la estructura de los metadatos de CFG en las imágenes PE. Consulte el tema [formato PE](../debug/pe-format.md) para obtener documentación de alto nivel sobre metadatos de cfg en imágenes PE.

- Las funciones que son destinos de llamadas indirectas válidas se enumeran en el **GuardCFFunctionTable** adjunto al directorio de configuración de carga, a veces se denomina la tabla **GFIDS** por motivos de brevedad. Se trata de una lista ordenada de direcciones virtuales relativas (RVA) que contienen información sobre los destinos de llamadas CFG válidos. En general, se trata de símbolos de función. Una imagen que desea que el cumplimiento de CFG Enumere todos los símbolos de función de dirección tomada en la tabla **GFIDS** . La lista RVA de la tabla **GFIDS** se debe ordenar correctamente o la imagen no se cargará. La tabla **GFIDS** es una matriz de 4 + *n* bytes, donde *n* viene dado por ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT). "GuardFlags" es el campo GuardFlags del directorio de configuración de carga. Esto permite adjuntar metadatos adicionales a destinos de llamada CFG en el futuro. Los únicos metadatos actualmente definidos son un campo opcional de marcas adicionales de 1 bytes ("GFIDS flags") que se adjunta a cada entrada **GFIDS** si algún destino de llamada tiene metadatos. Hay dos marcas **GFIDS** definidas:
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | El destino de la llamada se suprime explícitamente (no lo trate como válido para los fines de CFG) |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0X2 | El destino de la llamada es la exportación suprimida. Consulte [extinción de exportación](#export-suppression) para obtener más detalles |
  
  En el futuro, las herramientas no deben establecer marcas **GFIDS** que aún no se hayan definido y no deben incluir más bytes de metadatos **GFIDS** adicionales, más allá del valor de 1 byte definido actualmente, ya que los significados para otras marcas o metadatos adicionales todavía no se han asignado. Puede encontrar ejemplos de imágenes que incluyen bytes de metadatos adicionales mediante el volcado de la tabla de archivos binarios de **GFIDS** , como Ntdll.dll en una versión moderna de Windows 10 os.

  Las herramientas solo deben declarar símbolos de función como destinos de llamada válidos, lo que puede merecer una consideración adicional para el código del ensamblador en el que se pueden tratar las etiquetas. Por motivos históricos, el código de ensamblador puede basarse en etiquetas de código distintas de PROC o. no se convierte en destinos de llamada de CFG por el enlazador.

  Además, por motivos históricos, el código puede declarar deliberadamente el código como datos para evitar la inclusión en la tabla **GFIDS** . Por ejemplo, un archivo objeto puede implementar un símbolo como código, mientras que otro puede declararlo como datos para tomar la dirección del símbolo sin generar un registro de destino de CFG válido. Por motivos de compatibilidad, se recomienda que los conjuntos de herramientas admitan esta práctica.

- Las imágenes que admiten CFG y que desean o realizan comprobaciones de CFG deben establecer los bits IMAGE_GUARD_CF_INSTRUMENTED y IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags y deben establecer el bit de IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics en los encabezados de la imagen.

- El directorio de configuración de carga anuncia dos punteros de función: GuardCFCheckFunctionPointer y GuardCFDispatchFunctionPointer (el último solo se admite para determinadas arquitecturas, como AMD64). Estos punteros de función deben apuntar a la memoria de solo lectura para que la seguridad de CFG sea efectiva. el cargador de DLL del sistema operativo volverá a proteger la memoria transitoriamente durante la carga de imágenes para almacenar los punteros de función. El uso típico podría ser fusionar mediante combinación estos en la misma sección que contiene la tabla de direcciones de importación (IAT). GuardCFCheckFunctionPointer proporciona la dirección de un símbolo proporcionado por el cargador del sistema operativo al que se puede llamar con un puntero de función en el primer registro de argumento de tipo entero (ECX en x86) que devolverá si se ejecuta correctamente o anulará el proceso si el destino de la llamada no es un destino de CFG válido. El GuardCFDispatchFunctionPointer proporciona la dirección de un símbolo proporcionado por el cargador del sistema operativo que toma un destino de llamada en el registro RAX y realiza una llamada a la rama de la rama y la bifurcación de la rama de cola en el destino de la llamada (los registros R10/R11 se reservan para su uso por parte de los registros de los argumentos de la llamada Ultimate). La dirección predeterminada de los símbolos CFG en una imagen debe apuntar a una función que solo devuelve (GuardCFCheckFunctionPointer) o que devuelve un símbolo Guard-suprimido (o que se ha omitido por completo en el símbolo de tabla **GFIDS** ) que ejecuta una instrucción "JMP Rax". En el caso de GuardCFDispatchFunctionPointer AMD64, cuando se carga una imagen en un sistema operativo compatible con CFG y CFG está habilitado, el cargador de DLL de OS instalará los punteros de función adecuados, lo que proporciona compatibilidad con versiones anteriores. Una imagen puede proporcionar 0 para GuardCFDispatchFunctionPointer en la configuración de carga si no tiene intención de usar la instalación de distribución de CFG. Esto debe hacerse para las arquitecturas que no son AMD64 para una compatibilidad futura, en caso de que estas arquitecturas admitan finalmente el mecanismo de distribución de CFG de alguna forma. Tenga en cuenta que Windows 8.1 AMD64 no era compatible con el envío de CFG y dejaría el puntero de función predeterminado en su lugar para GuardCFDispatchFunctionPointer. CFG Dispatch solo se admite en sistemas operativos Windows 10 y versiones posteriores.

- El modo de usuario CFG solo se puede aplicar para las imágenes marcadas como compatibilidad con la selección aleatoria del diseño del espacio de direcciones (ASLR) (que se especifica mediante la opción/DYNAMICBASE con el vinculador de Microsoft). Esto se debe a la forma en que el sistema operativo controla internamente CFG, donde se conecta esencialmente con la infraestructura de ASLR. En general, los usuarios de CFG deben habilitar ASLR para sus imágenes como primer paso. Las herramientas no deben suponer que el sistema operativo siempre omitirá CFG sin el conjunto ASLR, pero generalmente debe establecer ambos al mismo tiempo.

## <a name="compiler-directives"></a>Directivas de compilador

- Los destinos de llamada se pueden marcar como suprimidos explícitamente con el modificador __declspec (Guard (suprimir)) o con la Directiva del enlazador/guardsym: symname, S (para código ASM, por ejemplo). Esto hace que el destino de la llamada se incluya en la tabla **GFIDS** pero está marcado de tal forma que el sistema operativo tratará el destino de la llamada como no válido. Algunos escenarios que no son de producción, como con determinada instrumentación de Comprobador de aplicación habilitada en algunos sistemas operativos anteriores, pueden permitir que los destinos de llamada suprimidos se traten como válidos, pero en general estos escenarios no se espera que sean escenarios de producción. Esta directiva es útil para anotar funciones "peligrosas" que no se deben considerar como destinos de llamada válidos, aunque la regla de CFG normal las incluiría.

- El código puede indicar comprobaciones de CFG no deseadas con el modificador __declspec (Guard (nocf)). Esto indica al compilador que no inserte ninguna comprobación de CFG para toda la función. El compilador debe tener cuidado de propagar esta directiva a cualquier código aportado por una función insertada que esté marcada como que no desea realizar comprobaciones de CFG. Este enfoque se suele usar con moderación en situaciones específicas en las que el programador ha insertado manualmente la protección "CFG-Equivalent". El programador sabe que están llamando a través de alguna tabla de funciones de solo lectura cuya dirección se obtiene a través de las referencias de memoria de solo lectura y cuyo índice se enmascara en el límite de la tabla de funciones. Este enfoque también se puede aplicar a las funciones de contenedor pequeñas que no están insertadas y que no hacen nada más que realizar una llamada a través de un puntero de función. Dado que el uso incorrecto de esta Directiva puede poner en peligro la seguridad de CFG, el programador debe ser muy cuidadoso mediante la Directiva. Normalmente, este uso está limitado a funciones muy pequeñas que solo llaman a una función.

## <a name="import-handling"></a>Administración de importación

- Las llamadas a través de la IAT no deben usar la protección de CFG. La IAT es de solo lectura en las imágenes modernas (suponiendo que la IAT esté declarada en los encabezados de PE en cuyo caso debe estar en sus propias páginas). La IAT se puede usar para llegar a las funciones que se han suprimido, por lo que se trata de un requisito de corrección. La protección de memoria de solo lectura a través de la IAT sustituye a la de CFG, ya que el enlace del destino de la llamada es inmutable una vez que se resuelven las instantáneas de importación de la imagen y la resolución de enlace es específica.

- Carga retrasada protegida: las llamadas a través de la IAT de carga retrasada no deben usar la protección de CFG, por las mismas razones que la IAT estándar. La IAT de carga retrasada debe estar en su propia sección y la imagen debe establecer el IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT bit GuardFlags. Esto indica que el cargador de DLL del sistema operativo debe cambiar las protecciones de la tabla IAT de carga retrasada durante la resolución de exportación si se usa la compatibilidad de carga retrasada del sistema operativo nativa con Windows 8 y los sistemas operativos posteriores. El cargador de DLL del sistema operativo administra la sincronización de este paso si se está usando la compatibilidad con la carga retrasada del sistema operativo nativo (por ejemplo, ResolveDelayLoadedAPI), por lo que ningún otro componente debe volver a proteger las páginas que abarquen la carga de retraso declarada. Para mantener la compatibilidad con versiones anteriores de los sistemas operativos anteriores a la versión de CFG, las herramientas pueden habilitar la opción de pasar la tabla IAT de carga retrasada a su propia sección (canónicamente ". Didat"), protegida como de lectura/escritura en los encabezados de la imagen y establecer además la marca IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION. Esta configuración hará que los cargadores de archivos DLL del sistema operativo compatible con CFG vuelvan a proteger toda la sección que contiene la tabla IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT para leer solo la memoria durante la carga de la imagen. Es posible que la opción para colocar la tabla de carga retrasada en su propia sección no sea necesaria si no le importa la ejecución de una imagen en los sistemas operativos compatibles con CFG, pero las herramientas deben tomar esa decisión según la compatibilidad mínima del sistema operativo que necesita una imagen.

  Si una imagen no utiliza la compatibilidad nativa de carga retrasada del sistema operativo, todavía puede establecer los bits de GuardFlags relacionados con la carga retrasada protegida. En esta configuración, el cargador del sistema operativo solo proporcionará compatibilidad para proteger la IAT de carga retrasada como de solo lectura en tiempo de ejecución si es compatible con la plataforma, y se convierte en la responsabilidad del código auxiliar de resolución de carga retrasada interna de la imagen para sincronizar y administrar la protección de la IAT de carga retrasada. Siempre que la tabla de configuración de carga esté almacenada en memoria de solo lectura (lo que se recomienda), la presencia o ausencia del bit de IAT de carga retrasada protegida en el campo GuardFlags de la imagen podría ser útil como una sugerencia interna para el código auxiliar de resolución de carga retrasada interna de la imagen para indicar si debe proteger o no la tabla IAT de carga retrasada.

  Se recomienda habilitar la carga retrasada protegida de forma predeterminada si CFG está habilitado. Las imágenes que se ejecutan en versiones anteriores del sistema operativo y que usan la compatibilidad con la carga de retraso nativa del sistema operativo, como se indica, pueden usar la operación de carga retrasada de IAT en su propia sección para la compatibilidad con versiones anteriores. Esto no es lo mismo que marcar la IAT de carga retrasada como de solo lectura y combinarla con otra sección, lo que se interrumpiría en los sistemas operativos más antiguos que no entienden las cargas de retraso protegidas y que proporcionan compatibilidad con la resolución de carga de retraso nativa. Todas las versiones de Windows 10 y la primera Windows 8.1/Windows Server 2012 R2 compilaciones que admiten CFG (es decir, la actualización de noviembre de 2014) incorporan compatibilidad con la carga de retraso protegida en el sistema operativo.

## <a name="function-alignment"></a>Alineación de funciones

- Las funciones que se tratan y que, por tanto, se incluyen en la tabla **GFIDS** , se deben alinear de 16 bytes, si es posible. Esto no siempre es posible. Por ejemplo, para las funciones que no sean de COMDAT y que formen parte de los archivos objeto agrupados como una unidad por parte de las herramientas que no reconocen CFG, que pueden producir algunos ensambladores, el usuario de la herramienta que generó los archivos debe establecer la alineación adecuadamente. Las herramientas pueden optar por emitir una advertencia de diagnóstico en esta situación para que el usuario pueda tomar las medidas correctivas adecuadas. La razón es que CFG marca los destinos de llamada como válidos o no válidos en límites de 16 bytes para mejorar la eficacia de las comprobaciones de CFG rápidas. Si una función no tiene una alineación de 16 bytes, toda la ranura de 16 bytes debe marcarse como válida, lo que no es tan seguro, ya que puede llamar a un código no alineado en el código que no está en el inicio de una función. Este escenario se admite para facilitar la interoperabilidad al traer primero el CFG para un proyecto. Las imágenes que no reconocen la CFG se marcan de forma similar como válidas para cualquier alineación de destino de llamada por compatibilidad. Como antes, tener destinos de llamada desalineados reduce las ventajas de seguridad de CFG, por lo que las herramientas deben alinearse automáticamente a un límite de 16 bytes para cualquier elemento de la tabla **GFIDS** cuando se desea usar cfg para una imagen. No es necesario que los símbolos que no están en la tabla **GFIDS** tengan alineaciones concretas para cfg.

## <a name="export-suppression"></a>Supresión de exportación

- La supresión de exportación de CFG (CFG es) es un modo opcional que permite a un proceso indicar que los destinos de llamada que solo eran válidos porque eran símbolos dllexport y que todavía no han sido resueltos dinámicamente por GetProcAddress, se considerarán como no válidos para los fines de CFG. Esto reduce el área expuesta de CFG de las exportaciones de DLL del sistema. La supresión de la exportación implica la comunicación de los destinos de llamada dllexport "Export suprimed" mediante su marcación con los IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED marcas **GFIDS** . Los símbolos dllexport y el punto de entrada de imagen de PE deben considerarse implícitamente una dirección tomada por las herramientas con el fin de generar la tabla **GFIDS** .  Si un símbolo de exportación tiene una alineación de 16 bytes y se trata de una dirección que no es una forma de dllexport, se puede marcar con la marca Export suprimed **GFIDS** en la tabla de la función. Los destinos de llamada que no tienen alineación de 16 bytes **no se deben** marcar con la marca IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** y no se pueden restringir para que solo se habiliten dinámicamente como destinos de llamada válidos en el tiempo de GetProcAddress.

  Una imagen que admite CFG ES incluye un GuardAddressTakenIatEntryTable cuyo recuento lo proporciona GuardAddressTakenIatEntryCount como parte de su directorio de configuración de carga. Esta tabla tiene el mismo formato que la tabla **GFIDS** . Usa el mismo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK de GuardFlags para codificar bytes de metadatos opcionales adicionales en la tabla de IAT de dirección tomada, aunque todos los bytes de metadatos deben ser cero para la tabla de IAT de dirección tomada y están reservadas. La tabla de IAT de dirección tomada indica una matriz ordenada de RVA de los códigos thunk de importación que tienen el importado como una dirección de símbolo tomada como destino de la llamada. Esta construcción admite símbolos de dirección que se encuentran en un módulo remoto y que son dllexports, con CFG ES en uso. Un ejemplo de este tipo de código sería:

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  Todos estos códigos thunk de importación se deben enumerar para que el cargador del sistema operativo pueda encontrarlos y hacer que los destinos de llamada adecuados sean válidos al cargar una imagen y ajustar sus importaciones. La tabla y el recuento pueden ser 0 si no hay ningún thunk de importación que se haya solucionado.

  Un módulo establece el IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT bit GuardFlags para indicar que ha enumerado todas las direcciones que se han tomado en la tabla IAT de su dirección y que todas las exportaciones que son válidas para CFG se marcan con la marca IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** . Tenga en cuenta que puede haber cero tales thunks y que también puede haber cero símbolos dllexport. Un error al mantener la tabla IAT tomada puede ser un problema de corrección, ya que es posible que algunos destinos de llamada no sean válidos cuando deberían estar en el momento de la carga del archivo DLL.

  Un módulo establece el IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION bit GuardFlags para indicar que desea habilitar CFG ES para el proceso. En la práctica, esto solo es significativo para los archivos exe de hoy en día. Un proceso que habilita CFG ES no debe cargar las dll no creadas con CFG ES o se pueden producir errores en tiempo de ejecución debido a que la dirección no designada tomó símbolos IAT. La compatibilidad con la habilitación de CFG ES una opción opcional independiente de la habilitación de CFG. Proporcionar metadatos de CFG es seguro y recomendado de forma predeterminada con CFG, aunque los conjuntos de herramientas deben tener cuidado para asegurarse de que generan los metadatos correctos. Si no es así, es posible que las imágenes generadas no se ejecuten correctamente en un proceso de CFG. Esta compatibilidad se debe probar exhaustivamente en un proceso de prueba que aplique CFG. Los archivos DLL del sistema integrados del sistema operativo admiten los metadatos de CFG ES para las versiones modernas del sistema operativo Windows 10 que comprenden CFG. Las versiones de sistema operativo anteriores a esta compatibilidad no comprenden CFG s y omitirán cualquier directiva de CFG ES relacionada con la imagen. Estas imágenes siguen siendo compatibles con las versiones anteriores del sistema operativo.

  La compatibilidad de CFG es opcional desde el punto de vista del conjunto de herramientas, pero se recomienda que los conjuntos de herramientas incluyan al menos compatibilidad para enumerar la información suficiente para que las imágenes se ejecuten en un proceso que quiere CFG. Como se mencionó, es fundamental que la compatibilidad con el conjunto de herramientas se pruebe minuciosamente para asegurarse de que es compatible con CFG ES, ya que la mayoría de los procesos aún no habilitan CFG.

## <a name="exception-handling-and-unwinding"></a>Control de excepciones y desenredo

- Los controladores específicos del lenguaje como __C_specific_handler, como se indica en la información del controlador de excepciones en un registro. pdata, no deben marcarse como destinos de llamada válidos en la tabla **GFIDS** . En su lugar, se buscan al atravesar la memoria de solo lectura. Del mismo modo, el controlador específico del lenguaje C de Microsoft usa búsquedas de memoria de solo lectura para buscar funclets para los controladores de excepciones y, por lo tanto, no declara su funclets como destinos de llamada válidos en la tabla **GFIDS** .

- Administración de saltos largos (para destinos que no son x86, como AMD64): los conjuntos de herramientas que se compilan con CFG y que admiten setjmp ()/longjmp () deben implementar el salto largo como "salto de larga seguridad" que interopera con el control de excepciones estructurado (SEH). Esto significa que el salto largo se implementa como una llamada a RtlUnwindEx con STATUS_LONGJUMP como el código de estado en el registro de la excepción proporcionada y un _JUMP_BUFFER estándar al que apunta ExceptionInformation [0]. El destino de desenredado de salto debe ser el TargetIp del desenredado. El búfer de salto representa el contexto de registro restaurado por el sistema operativo después de que se haya completado el salto largo. RtlUnwind (ex) cuando se llama con STATUS_LONGJUMP tiene una importancia especial exclusiva para CFG. Destino de salto largo (_JUMP_BUFFER. RIP o _JUMP_BUFFER. LR en ARM64) se busca en la lista de módulos cargados que mantiene el sistema operativo en la memoria de solo lectura. Si el módulo contenedor del destino de salto (el "módulo de destino") tiene la marca IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT establecida en el campo GuardFlags, el directorio de configuración de carga tiene una GuardLongJumpTargetTable whith un recuento de elementos especificado por el campo GuardLongJumpTargetCount de configuración de carga. Esta tabla tiene el mismo formato que la tabla **GFIDS** y usa el mismo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags para codificar bytes de metadatos adicionales opcionales en la tabla de saltos largos. Todos los bytes de metadatos deben ser cero para la tabla de saltos largos y están reservados.

  La tabla de saltos largos representa una matriz ordenada de RVA que son destinos de salto largo válidos. Si un módulo de destino de salto largo establece IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT en su campo GuardFlags, todos los destinos de salto largos deben enumerarse en el LongJumpTargetTable. Incluso si un módulo tiene destinos de saltos largos, debe establecer la marca de IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT si el conjunto de herramientas admite la protección de saltos larga para CFG. Esto significa explícitamente que la imagen no tiene destinos de saltos largos y no es una imagen antigua que el sistema operativo debe asumir que podría tener destinos de salto largo válidos en ubicaciones no marcadas para las que no se puede realizar la comprobación de destino prolongado.

  Se recomienda habilitar la protección de saltos larga de forma predeterminada si se admite CFG. Esta es la disposición de los compiladores de Microsoft. Los sistemas operativos que no entienden la protección de saltos largos (versiones anteriores a Windows 10 o versiones anteriores de Windows 10) no realizarán comprobaciones de protección prolongada y omitirán los metadatos de protección prolongada, por lo que la protección prolongada es compatible con las versiones anteriores del sistema operativo.

  En el caso de las imágenes de modo kernel, la tabla de destino de salto largo de protección no debe incluirse en una sección descartable. La tabla de destino de salto largo de protección debe almacenarse siempre en memoria de solo lectura para que sus propiedades de seguridad sean eficaces.

## <a name="coff-information"></a>Información COFF

- Hay marcas de archivo de objeto para declarar si un archivo objeto se ajusta a CFG o no. Un archivo objeto que se ajuste a CFG mostrará los destinos de llamada válidos que genera, explícitamente, así como cualquier dirección tomada metadatos de IAT. Un archivo objeto que no se ajusta a CFG debe tener destinos de llamada inferidos mediante el examen de las reubicaciones COFF del archivo OBJ para buscar las reubicaciones que apuntan al inicio de un símbolo de función. Esto puede sobreaproximar los destinos de llamada CFG válidos, por lo que es conveniente que las herramientas marquen los archivos obj que son compatibles con CFG e incluyen los metadatos del archivo OBJ de CFG si se compilan con CFG.

- Hay marcas de archivo de objeto para declarar destinos de saltos largos para el salto largo de CFG que se debe rellenar para el modo de compilación de CFG.
