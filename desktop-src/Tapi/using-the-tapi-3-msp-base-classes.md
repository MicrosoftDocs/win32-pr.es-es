---
description: En el procedimiento siguiente se describe cómo implementar un MSP mediante ATL versión 2.1 o ATL versión 3.0 y las clases base de MSP.
ms.assetid: 7485c34a-3c8a-412f-9cb9-8eb895084292
title: Uso de las clases base de MSP de TAPI 3
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6131d44b6746075c43fc61c9d35decbe0564773db4746bba6d72b0da4697cabd
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/11/2021
ms.locfileid: "119139718"
---
# <a name="using-the-tapi-3-msp-base-classes"></a>Uso de las clases base de MSP de TAPI 3

En el procedimiento siguiente se describe cómo implementar un MSP mediante ATL versión 2.1 o ATL versión 3.0 y las clases base de MSP. Para obtener más información y una lista de bibliotecas y encabezados, vea [CLASES base de MSP de TAPI 3.](tapi-3-msp-base-classes.md) El contenido contenido en este tema supone que el desarrollador tiene conocimientos de ATL y COM, y tiene experiencia en la implementación de archivos DLL COM mediante ATL.

**Para implementar y MSP mediante ATL 2.1 o ATL 3.0**

1.  Cree un archivo IDL para el MSP. Este archivo define un CLSID para el MSP. Declare la "coclase" del MSP como implementación de la interfaz [**ITMSPAddress**](/windows/desktop/api/msp/nn-msp-itmspaddress) y declare esta interfaz como la interfaz predeterminada en el objeto de clase. Para la definición de **ITMSPAddress,** importe el archivo "msp.idl". Incluya la "coclase" del MSP en una biblioteca de tipos para el MSP. Si el MSP admite interfaces privadas (personalizadas), defiénlas aquí e inscluyélas en la biblioteca de tipos. El ejemplo de código siguiente es un archivo IDL como se describió anteriormente, sin interfaces personalizadas.

    ``` syntax
    import "msp.idl";
    [
          uuid(4DDB6D35-3BC1-11d2-86F2-006008B0E5D2),
          version(2.0),
          helpstring("Wave MSP 2.0 Type Library")
    ]
    library WAVEMSPLib
    {
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(4DDB6D36-3BC1-11d2-86F2-006008B0E5D2),
    helpstring("Wave MSP Class")
    ]
    coclass WaveMSP
    {
    [default] interface ITMSPAddress;
    };
    };
    ```

2.  Modifique el TSP para anunciar el CLSID del MSP cuando Tapi3.dll lo solicite. Asegúrese de que (1) el TSP puede negociar TAPI VERSION3 0 o superior en la función \_ \_ [**TSPI \_ lineNegotiateTSPIVersion**](/windows/win32/api/tspi/nf-tspi-tspi_linenegotiatetspiversion), (2) la estructura [**LINEDEVCAPS**](/windows/win32/api/tapi/ns-tapi-linedevcaps) de TSP tiene la marca MSP LINEDEVCAPFLAGS establecida en el miembro \_ **dwDevCapFlags** y (3) el TSP devuelve el CLSID de MSP en la función [**TSPI \_ lineMSPIdentify**](/windows/win32/api/tspi/nf-tspi-tspi_linemspidentify). Debe ser el mismo CLSID especificado en el archivo IDL; por ejemplo, la segunda línea "uuid" del archivo IDL de ejemplo en el paso anterior.
3.  Compile la aplicación de ejemplo MSPBase, ubicada en platform software development kit (SDK), para crear la biblioteca MSPBaseSample.lib.
4.  Vincule el archivo DLL de MSP con la biblioteca MSPBaseSample.lib.
5.  Incluya Mspbase.h desde las definiciones de clase base del SDK para MSP.
6.  Implemente las exportaciones dll (por ejemplo, DllMain). Microsoft Visual C++ los generará automáticamente. En DllMain, en DLL PROCESS ATTACH y \_ \_ DLL PROCESS \_ \_ DETACH, respectivamente, use las macros **MSPLOGREGISTER** y **MSPLOGDEREGISTER** para habilitar las características de registro para el archivo DLL. Especifique el nombre del archivo DLL en la **llamada MSPLOGDEREGISTER.**
7.  Use la macro LOG, definida en Msplog.h, para generar mensajes de seguimiento de la misma manera que las clases base. Defina el símbolo de preprocesador MSPLOG para incluir el registro en el archivo DLL; déjelo sin definir para compilar un archivo DLL que no tenga registro.
8.  Derive una clase de CMSPAddress que implemente direcciones para el MSP. Declare un mapa de objetos ATL global que indique a ATL que cree una instancia de la clase de dirección cuando se le pida **cocreate** en el CLSID especificado en el archivo IDL. Además, derive la clase de dirección de la plantilla **CComCoClass** atl e incluya una declaración DECLARE \_ REGISTRY \_ RESOURCEID en la clase de dirección. Construya un script de recursos y un archivo de encabezado correspondientes, como para cualquier otro archivo DLL COM atl.
9.  Implemente las invalidaciones de CMSPAddress necesarias para la clase de dirección. Para [**MSPAddressAddRef**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressaddref) y [**MSPAddressRelease,**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressrelease)llame a las plantillas de función auxiliar proporcionadas. Para [**GetCallMediaTypes**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-getcallmediatypes), simplemente devuelva un mapa de bits **DWORD** con todos los TAPIMEDIAMODEs ORed admitidos por MSP juntos. Para [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) y [**ShutdownMSPCall,**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall)devuelva E NOTIMPL y compile y \_ vincule el MSP en este momento. Ahora, compruebe que puede registrar y crear instancias del MSP desde aplicaciones TAPI 3, pero no crear llamadas correctamente.
10. Derive una clase de CMSPCallMultiGraph para implementar los objetos de llamada MSP. Es posible que quiera derivar de [**CMSPCallBase en**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallbase) lugar de [**CMSPCallMultiGraph**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallmultigraph) si el modelo filter-graph-per-stream no se ajusta a sus requisitos; esto aumentará la complejidad de la tarea (a partir de este artículo, todos los MSP derivan objetos de llamada directamente desde **CMSPCallMultiGraph**). En el objeto de dirección, implemente [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) y [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall) para crear y apagar el tipo específico de objeto de llamada mediante las plantillas de función auxiliar proporcionadas. En el objeto de llamada, [**invalide CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) para devolver E \_ NOTIMPL. Invalide [**MSPCallAddRef**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcalladdref) y [**MSPCallRelease de**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcallrelease) una manera idéntica a los métodos de dirección correspondientes. De nuevo, debería poder compilar y vincular el MSP; ahora debería poder crear y apagar llamadas, pero las llamadas no realizarán ningún streaming útil.
11. Derive una clase de CMSPStream para implementar los objetos de flujo msp. En el objeto de llamada, implemente [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) para crear e inicializar el objeto de secuencia (normalmente llamando a ATL **CreateInstance** seguido de ATL **\_ InternalQueryInterface** para [**ITStream**](/windows/win32/api/tapi3if/nn-tapi3if-itstream) seguido de una llamada a **Init** en el objeto de secuencia). Para admitir un número fijo de secuencias (esto es habitual para los MSP que no admiten la modificación de configuraciones de secuencias por parte de otros puntos de conexión en la llamada), invalide **Init**, [**CreateStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-createstream)y [**RemoveStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-removestream) en el objeto de llamada. (La llamada **Init** crea inicialmente todas las secuencias y **CreateStream** y **RemoveStream** devuelven los códigos de error TAPI adecuados para evitar que la aplicación cree o quite secuencias). De lo contrario, invalide el método **Init** de la llamada para crear una configuración predeterminada inicial de secuencias mediante los tipos de medios solicitados para la llamada. Al crear objetos de flujo predeterminados en el método **Init** de la llamada, use el método auxiliar [**InternalCreateStream.**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-internalcreatestream)
12. Implemente el objeto de secuencia. La única invalidación necesaria es el [**método get \_ Name,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-get_name) que simplemente devuelve un nombre descriptivo para la secuencia. Además, deberá invalidar otros métodos. Exactamente qué métodos invalidar dependen de la implementación y cuándo decida realizar las distintas tareas implicadas en la construcción y deconstrucción del gráfico de filtros. Estas tareas incluyen la creación de los filtros de "transporte" adecuados, códecs, entre otros, y su inserción y eliminación de los gráficos de filtro en el momento adecuado. También tendrá que usar la interfaz [**ITTerminalControl**](/windows/desktop/api/Termmgr/nn-termmgr-itterminalcontrol) en objetos de terminal para conectar los terminales seleccionados a los flujos. Es posible que quiera invalidar [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal) y [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) en el objeto de secuencia para limitar las configuraciones de terminal que aceptarán las secuencias. Limitar cada secuencia a un solo terminal simplificará especialmente la construcción de los gráficos de filtro, pero sacrificará la funcionalidad de la aplicación, como la versión preliminar de vídeo. En función de la implementación, colocará el código de conexión de terminal, deconstrucción y construcción de grafos en los métodos [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**StopStream,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream) [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**Initialize**](/windows/desktop/api/msp/nf-msp-itmspaddress-initialize), [**Shutdown,**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdown) [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)y [**UnselectTerminal,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) o en sus propios métodos basados en la comunicación privada de TSP. Tenga en cuenta que una secuencia sin terminales seleccionados debe realizar un seguimiento del estado deseado del grafo; Una **llamada StartStream** seguida de una **llamada SelectTerminal** en este tipo de flujo debe dar lugar a un flujo de datos. Invalide la mayoría de estos métodos para asegurarse de que se produce la construcción, deconstrucción, conexión y desconexión correctas en cada caso en función del estado de la secuencia.
13. Implemente la comunicación de TSP. Invalide [**CMSPAddress::ReceiveTSPAddressData**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-receivetspaddressdata) o [**CMSPCallBase::ReceiveTSPCallData**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-receivetspcalldata)o llame a [**PostEvent**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-postevent) en el objeto de dirección o [**HandleStreamEvent**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-handlestreamevent) en el objeto de llamada (desde los objetos de llamada o de secuencia).
14. Use PostEvent en el objeto de dirección o HandleStreamEvent en el objeto de llamada (desde los objetos de llamada o de secuencia) para enviar eventos multimedia de llamada a la aplicación a través de Tapi3.dll. Normalmente lo hará en el objeto de secuencia, en métodos invalidados, incluidos los métodos [**ProcessGraphEvent**](/windows/desktop/api/Mspstrm/nf-mspstrm-cmspstream-processgraphevent), [**StopStream,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream) [**StartStream,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream) [**PauseStream,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream) [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)y [**UnselectTerminal,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) en función de cómo implemente las secuencias.
15. Implemente las interfaces privadas o substreams deseadas en los objetos existentes (dirección, llamada y secuencia). Normalmente no hay ninguno. Tenga en cuenta que al implementar las interfaces privadas, especifique el LIBID de la biblioteca de tipos desde el archivo IDL. Es decir, los programadores de aplicaciones deben usar la biblioteca de tipos msp al usar las interfaces personalizadas. Las interfaces MSP estándar, implementadas en las clases base de MSP, usan el Tapi3.dll LIBID y, por tanto, son accesibles para todas las aplicaciones TAPI 3.
16. Si implementa objetos de terminal estáticos o dinámicos específicos de MSP o reemplazos para los terminales estáticos predeterminados (no típicos), puede usar las clases base de terminal proporcionadas. Tendrá que invalidar varios métodos en el objeto de dirección para proporcionar métodos alternativos o adicionales para crear objetos terminales.
17. Implemente la interfaz IObjectSafety en los objetos Address, Call, Stream y Terminal. Para usar [el Asignador de distribución](dispatch-mapper.md) para consultar interfaces en los objetos MSP, marque los objetos como seguros para el scripting en estas interfaces. Para ello, implemente la **interfaz IObjectSafety** en el objeto . Derivar de **CMSPObjectSafetyImpl** (una clase auxiliar proporcionada en Msputils.h) y agregar **IObjectSafety** al MAPA COM atl de la clase hará que los objetos se creen scripts seguros en todas las interfaces que \_ exponen. Tenga en cuenta que el uso del Asignador de distribución en objetos MSP podría ser implícito. La dirección MSP y la llamada MSP se agregan mediante los objetos TAPI Address y TAPI Call. Si el Asignador de distribución se usa en los objetos TAPI para consultar las interfaces expuestas por los objetos MSP agregados, se consultarán los objetos MSP agregados para garantizar la seguridad de las interfaces solicitadas.

 

 
