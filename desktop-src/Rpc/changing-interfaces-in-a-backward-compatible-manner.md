---
title: Cambiar las interfaces de una manera compatible con versiones anteriores
description: Los métodos que se explican en la teoría de control de versiones de RPC y COM pueden ser inaceptables por muchas razones.
ms.assetid: 7dec4b67-3d50-453f-b0ef-290d091186fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 314daecc6b55aaf4a348411010eb578149f86921
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/20/2020
ms.locfileid: "103793503"
---
# <a name="changing-interfaces-in-a-backward-compatible-manner"></a><span data-ttu-id="d3cb1-103">Cambiar las interfaces de una manera compatible con versiones anteriores</span><span class="sxs-lookup"><span data-stu-id="d3cb1-103">Changing Interfaces in a Backward Compatible Manner</span></span>

<span data-ttu-id="d3cb1-104">Los métodos que se explican en [la teoría de control de versiones de RPC y com](the-versioning-theory-for-rpc-and-com.md) pueden ser inaceptables por muchas razones.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-104">The methods explained in [The Versioning Theory for RPC and COM](the-versioning-theory-for-rpc-and-com.md) may be unacceptable for many reasons.</span></span> <span data-ttu-id="d3cb1-105">El cambio de una versión de interfaz de acuerdo con las reglas requiere básicamente que los nuevos clientes no se comuniquen con los servidores antiguos.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-105">Changing an interface version according to the rules essentially requires that new clients not communicate with old servers.</span></span> <span data-ttu-id="d3cb1-106">Esto suele ser imposible con el software comercial implementado en el campo.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-106">This is frequently impossible with commercial software deployed in the field.</span></span> <span data-ttu-id="d3cb1-107">A veces, Windows ha introducido cambios en la interfaz ausentes de las versiones o los GUID modificados.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-107">Sometimes, Windows has introduced interface changes absent of changed GUIDs or versions.</span></span> <span data-ttu-id="d3cb1-108">Esto fue el resultado de la necesidad de que los nuevos clientes se comuniquen con los servidores heredados, y porque la solución que el cliente nuevo admitiría era no deseable.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-108">This was a result of new clients needing to communicate with legacy servers, and because the solution that a new client would support both the old and new interfaces was deemed undesirable.</span></span>

## <a name="best-practice"></a><span data-ttu-id="d3cb1-109">Procedimiento recomendado</span><span class="sxs-lookup"><span data-stu-id="d3cb1-109">Best practice</span></span>

<span data-ttu-id="d3cb1-110">Estos son los métodos razonables para solucionar el problema de incompatibilidad de la conexión cuando no se puede cambiar la versión y el GUID de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-110">These are the reasonable methods of working around the wire incompatibility issue when the interface GUID and version cannot be changed.</span></span>

1.  <span data-ttu-id="d3cb1-111">Haga que la aplicación tenga en cuenta las capacidades del otro lado.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-111">Have the application be aware of the other side's capabilities.</span></span>

    <span data-ttu-id="d3cb1-112">El cliente y el servidor tienen un protocolo que permite que cada (o al menos el cliente nuevo) establezca la identidad del socio.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-112">The client and server have a protocol that enables each (or at least the new client) to establish the identity of the partner.</span></span> <span data-ttu-id="d3cb1-113">Normalmente es suficiente para que el nuevo cliente tenga en cuenta las características compatibles con los servidores antiguos y nuevos.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-113">Typically it is sufficient to have the new client be aware of features supported by old and new servers.</span></span> <span data-ttu-id="d3cb1-114">Esto se puede hacer fácilmente cuando una aplicación se mantiene en un contexto de conexión y se admite a través de un tipo *XxxGetInfo* de llamada de función ejecutada por el cliente antes de realizar cualquier operación de RPC.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-114">This may easily be done when an application holds on to a connection context, and be supported through an *XxxGetInfo* type of function call executed by the client before performing any RPC operations.</span></span> <span data-ttu-id="d3cb1-115">Cuando una aplicación administra las características en una versión por servidor, nunca se puede realizar una llamada a una incompatibilidad con el servidor o cliente anterior, ya que la aplicación controla qué llamadas se emiten a cada servidor.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-115">When an application manages the features on a per-server release basis, a call with an incompatibility to the old server/client can never occur, since the application controls which calls are issued to which server.</span></span> <span data-ttu-id="d3cb1-116">La línea inferior es que la aplicación es proactiva para evitar que se produzca una falta de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-116">The bottom line is that the application is proactive in preventing a mismatch from happening.</span></span> <span data-ttu-id="d3cb1-117">Esto puede realizarse junto con la segunda práctica.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-117">This may be performed in conjunction with the second practice.</span></span>

2.  <span data-ttu-id="d3cb1-118">Introduzca una nueva API remota.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-118">Introduce a new remote API.</span></span>

    <span data-ttu-id="d3cb1-119">Un nuevo método remoto no entra en conflicto con los métodos existentes si se agrega al final de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-119">A new remote method does not collide with existing methods if it is added at the very end of the interface.</span></span> <span data-ttu-id="d3cb1-120">Los clientes antiguos pueden llamar a los nuevos servidores como siempre lo tienen.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-120">Old clients can call new servers as they always have.</span></span> <span data-ttu-id="d3cb1-121">El nuevo cliente puede llamar al nuevo método sin conocer la identidad del servidor, siempre que inspeccione los errores procedentes del servidor al que se está llamando.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-121">The new client can call the new method without knowing the server's identity, provided it watches for the errors coming from the server being called.</span></span> <span data-ttu-id="d3cb1-122">El tiempo de ejecución de RPC siempre comprueba el número de método de cada interfaz antes de un envío para asegurarse de que el método está dentro de una tabla v adecuada.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-122">The RPC run time always checks the method number for each interface before a dispatch to ensure the method is within an appropriate v-table.</span></span> <span data-ttu-id="d3cb1-123">En el caso de un método desconocido para un servidor, el tiempo de ejecución de RPC produce la excepción RPC \_ S \_ PROCNUM \_ fuera \_ del \_ intervalo.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-123">For a method that is unknown to a server, the RPC run time raises the exception RPC\_S\_PROCNUM\_OUT\_OF\_RANGE.</span></span> <span data-ttu-id="d3cb1-124">Esta excepción solo se desencadena en esta situación concreta.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-124">This exception is raised only in this particular situation.</span></span> <span data-ttu-id="d3cb1-125">Por lo tanto, un cliente nuevo puede ver la excepción como un signo de que la llamada pasó a un servidor anterior y puede modificar su comportamiento correctamente.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-125">Therefore, a new client can watch for the exception as a sign that the call went to an old server and can modify its behavior gracefully.</span></span>

3.  <span data-ttu-id="d3cb1-126">Introduzca nuevos parámetros o nuevos tipos de datos solo en los nuevos métodos.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-126">Introduce new parameters or new data types only in the new methods.</span></span>

    <span data-ttu-id="d3cb1-127">Una razón para introducir un nuevo método es evitar la incompatibilidad de los datos.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-127">One reason to introduce a new method is to avoid data incompatibility.</span></span> <span data-ttu-id="d3cb1-128">Si se introduce un nuevo tipo de datos o simplemente se modifica, en principio solo debe usarse en un nuevo método (o métodos).</span><span class="sxs-lookup"><span data-stu-id="d3cb1-128">If a new data type is introduced or simply modified, in principle it should be used only in a new method (or methods).</span></span> <span data-ttu-id="d3cb1-129">Vea [ejemplos de cambios incompatibles](examples-of-incompatible-changes.md) para ver ejemplos de cambios de tipos de datos incompatibles.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-129">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples of incompatible data type changes.</span></span> <span data-ttu-id="d3cb1-130">La única excepción importante a esta regla se describe en el elemento cuatro.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-130">The only notable exception to this rule is described in item four.</span></span>

4.  <span data-ttu-id="d3cb1-131">Asigne nuevos parámetros o nuevos tipos de datos a través de un contenedor.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-131">Map new parameters or new data types through a wrapper.</span></span>

    <span data-ttu-id="d3cb1-132">Esta solución se aplica cuando un nuevo parámetro o tipo de datos debe exponerse a un usuario, pero realmente no tiene que ser remoto de forma independiente o se puede asignar a los tipos de datos o parámetros antiguos.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-132">This solution applies when a new parameter or data type must be exposed to a user, but actually does not have to be remoted separately or can be mapped to the old data types or parameters.</span></span> <span data-ttu-id="d3cb1-133">Por ejemplo, muchas API del sistema se activan y ejecutan una llamada remota.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-133">For example, many system APIs turn around and execute a remote call.</span></span> <span data-ttu-id="d3cb1-134">Pueden o no realizar algún tipo de asignación de los tipos de datos conocidos del usuario a los tipos de datos que se usan realmente en la llamada RPC subyacente.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-134">They may or may not be doing some kind of mapping from the user known data types to the data types actually used in the underlying RPC call.</span></span> <span data-ttu-id="d3cb1-135">Por lo tanto, siempre merece la pena examinar si el cambio en la interfaz de usuario debe propagarse como un cambio en una interfaz remota.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-135">It is therefore always worth examining if the change in the user interface needs to propagate as a change to a remote interface.</span></span>

    <span data-ttu-id="d3cb1-136">Se puede producir una situación similar cuando el usuario llama directamente a una API remota, pero se puede introducir un contenedor para realizar una nueva asignación de tipos o algunas otras acciones adicionales que se han hecho necesarias.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-136">A similar situation may happen when the user calls a remote API directly, but a wrapper could be introduced to do a new type mapping or some other additional actions that have become necessary.</span></span> <span data-ttu-id="d3cb1-137">El lenguaje de definición de interfaz (IDL) tiene varias formas de facilitar la reasignación, \[ [**llamar a \_ como**](/windows/desktop/Midl/call-as) \] , \[ [**transmitir \_ como**](/windows/desktop/Midl/transmit-as) \] y \[ [**calcular las \_ referencias**](/windows/desktop/Midl/wire-marshal) \] .</span><span class="sxs-lookup"><span data-stu-id="d3cb1-137">Interface Definition Language (IDL) has several ways of facilitating such remapping, namely \[[**call\_as**](/windows/desktop/Midl/call-as)\], \[[**transmit\_as**](/windows/desktop/Midl/transmit-as)\], and \[[**wire\_marshal**](/windows/desktop/Midl/wire-marshal)\].</span></span> <span data-ttu-id="d3cb1-138">El \[ atributo **Call \_ as** \] introduce un contenedor de funciones en el cliente y en el servidor.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-138">The \[**call\_as**\] attribute introduces a function wrapper on the client and server.</span></span> <span data-ttu-id="d3cb1-139">Ambos se colocan entre el código de usuario y el serializador.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-139">Both are placed between the user code and the marshaler.</span></span> <span data-ttu-id="d3cb1-140">Los demás atributos tratan con la asignación de tipos directos.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-140">The other attributes deal with direct type mapping.</span></span> <span data-ttu-id="d3cb1-141">En el caso de los problemas de extensión, \[ **llamar a \_ como** \] es el que se usa con más frecuencia y es más fácil de entender y manipular sin problemas.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-141">For extension problems, \[**call\_as**\] is the most frequently used, and is easiest to understand and manipulate without pitfalls.</span></span>

5.  <span data-ttu-id="d3cb1-142">Modifique los tipos de datos a través de una uniónless predeterminada.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-142">Modify data types through a defaultless union.</span></span>

    <span data-ttu-id="d3cb1-143">Cambiar un tipo de atributo o de datos normalmente conduce a la incompatibilidad de la conexión.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-143">Changing an attribute or data type typically leads to wire incompatibility.</span></span> <span data-ttu-id="d3cb1-144">Vea [ejemplos de cambios incompatibles](examples-of-incompatible-changes.md) para obtener ejemplos.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-144">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples.</span></span> <span data-ttu-id="d3cb1-145">Sin embargo, en el caso de una Unión sin una cláusula default, la incompatibilidad se puede administrar de forma similar a como se indica en el caso de un procedimiento fuera del intervalo, tal y como se ha descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-145">However, in the case of a union without a default clause, the incompatibility may be managed in a way similar to the case of a procedure out of range, as described previously.</span></span> <span data-ttu-id="d3cb1-146">Este esquema es aplicable fácilmente a los tipos de *XxxINFO* populares que usan uniones.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-146">This scheme is readily applicable to the popular *XxxINFO* types that use unions.</span></span>

    <span data-ttu-id="d3cb1-147">Por ejemplo, una llamada como esta</span><span class="sxs-lookup"><span data-stu-id="d3cb1-147">For example, a call like this</span></span>

    ```C++
    XxxGetInfo( [in] level, [out] XxxINFO  * pInfo );
    ```

    

    <span data-ttu-id="d3cb1-148">podría devolver información en el nivel 1, 2 o 3, donde *XxxINFO* es una unión con tres ramas: 1, 2 y 3.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-148">could return information at level 1, 2 or 3, with *XxxINFO* being a union with three branches: 1, 2 and 3.</span></span>

6.  <span data-ttu-id="d3cb1-149">Use el \[ atributo de [**intervalo**](/windows/desktop/Midl/range) \] para especificar el intervalo.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-149">Use the \[[**range**](/windows/desktop/Midl/range)\] attribute to specify range.</span></span>

    <span data-ttu-id="d3cb1-150">Puede especificar el \[ [](/windows/desktop/Midl/range) \] atributo de intervalo en un tipo de escala simple sin interrumpir la compatibilidad con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-150">You can specify the \[[**range**](/windows/desktop/Midl/range)\] attribute on a simple scale type without breaking backward compatibility.</span></span> <span data-ttu-id="d3cb1-151">Este atributo no afecta al formato de conexión, pero durante la desserialización de RPC comprueba el valor de conexión para confirmar que se encuentra dentro del intervalo especificado en el archivo. idl.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-151">This attribute does not affect wire format, but during unmarshalling RPC checks the value on wire to confirm that it is within the range specified in the .idl file.</span></span> <span data-ttu-id="d3cb1-152">Si no es así, \_ \_ \_ se produce una excepción enlazada no válida de RPC X.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-152">If not, a RPC\_X\_INVALID\_BOUND exception is thrown.</span></span> <span data-ttu-id="d3cb1-153">Esto es especialmente útil si el servidor conoce el tamaño máximo de una matriz de tamaño.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-153">This is especially useful if the server knows the maximum size of a sized array.</span></span>

    <span data-ttu-id="d3cb1-154">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="d3cb1-154">For example:</span></span>

    ```C++
    HRESULT Method1( [in, range(0,100)] ULONG m, [size_is(m)] ULONG *plong); 
    ```

    

<span data-ttu-id="d3cb1-155">El comportamiento de RPC cuando el nivel indicado es 4 y falta el brazo, depende de la definición de la Unión.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-155">The RPC behavior when the indicated level is 4 and the arm is missing, depends on the definition of the union.</span></span> <span data-ttu-id="d3cb1-156">En el caso de una unión con la cláusula default definida, RPC transmite un tipo indicado en la cláusula default para cualquier elemento diferente de las etiquetas de ARM conocidas (en este caso, algo distinto de 1, 2 o 3).</span><span class="sxs-lookup"><span data-stu-id="d3cb1-156">For a union with the default clause defined, RPC transmits a type indicated in the default clause for anything different than the known arm labels (in this case, anything other than 1, 2 or 3).</span></span> <span data-ttu-id="d3cb1-157">En el caso de una Unión sin valor predeterminado, el cálculo de referencias genera una excepción porque, por definición, no hay ningún valor predeterminado para revertir a.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-157">For a defaultless union, the unmarshaler raises an exception because by definition there is no default to fall back to.</span></span> <span data-ttu-id="d3cb1-158">La excepción es una \_ \_ etiqueta no válida de RPC S \_ .</span><span class="sxs-lookup"><span data-stu-id="d3cb1-158">The exception is RPC\_S\_INVALID\_TAG.</span></span>

<span data-ttu-id="d3cb1-159">De nuevo, un nuevo cliente puede ajustar su comportamiento al detectar que llamó a un servidor antiguo.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-159">Again, a new client can adjust its behavior upon discovering that it called an old server.</span></span>

<span data-ttu-id="d3cb1-160">Lo que se muestra a continuación de estas prácticas recomendadas es que si se debe diseñar un tipo de datos remoto que se pueda extender en el futuro, use una Unión sin valor predeterminado en el archivo IDL.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-160">What follows from these recommended practices is that if a remotable data type must be designed that can be extended in future, use a defaultless union in the IDL file.</span></span> <span data-ttu-id="d3cb1-161">Dada una opción, una Unión encapsulada es ligeramente más limpia.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-161">Given a choice, an encapsulated union is slightly cleaner.</span></span>

<span data-ttu-id="d3cb1-162">Debido a las peculiaridades de la representación interna del Protocolo de conexión de NDR64, la recomendación para agregar los brazos que se han proporcionado anteriormente en esta sección debe calificarse de la siguiente manera: el nuevo ARM que se va a agregar no puede cambiar la alineación de la Unión y, en particular, la alineación más grande de los brazos no debe cambiar.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-162">Due to quirks of internal representation of the NDR64 wire protocol, the recommendation for adding arms provided earlier in this section needs to be qualified as follows: The new arm being added cannot change the alignment of the union, and in particular, the biggest alignment of the arms should not change.</span></span> <span data-ttu-id="d3cb1-163">Normalmente no es un problema, ya que un puntero en un ARM fuerza la alineación a 8.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-163">This is typically not an issue, as a pointer in an arm forces alignment to 8.</span></span> <span data-ttu-id="d3cb1-164">Un diseño en el que cada ARM es un puntero a un tipo ARM es un método limpio para satisfacer el requisito.</span><span class="sxs-lookup"><span data-stu-id="d3cb1-164">A design where each arm is a pointer to an arm type is one clean way of satisfying the requirement.</span></span>

 

 