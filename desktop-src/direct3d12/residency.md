---
title: Residencia
description: Un objeto se considera residente cuando es accesible para la GPU.
ms.assetid: 956F80D7-EEC8-4D88-B251-EE325614F31E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6b842ce5b3e89c3877f50036e747a90f14104bce
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/20/2020
ms.locfileid: "104549146"
---
# <a name="residency"></a><span data-ttu-id="3d61f-103">Residencia</span><span class="sxs-lookup"><span data-stu-id="3d61f-103">Residency</span></span>

<span data-ttu-id="3d61f-104">Un objeto se considera *residente* cuando es accesible para la GPU.</span><span class="sxs-lookup"><span data-stu-id="3d61f-104">An object is considered to be *resident* when it is accessible by the GPU.</span></span>

-   [<span data-ttu-id="3d61f-105">Presupuesto de residencia</span><span class="sxs-lookup"><span data-stu-id="3d61f-105">Residency budget</span></span>](#residency-budget)
-   [<span data-ttu-id="3d61f-106">Recursos del montón</span><span class="sxs-lookup"><span data-stu-id="3d61f-106">Heap resources</span></span>](#heap-resources)
-   [<span data-ttu-id="3d61f-107">Prioridades de residencia</span><span class="sxs-lookup"><span data-stu-id="3d61f-107">Residency priorities</span></span>](#residency-priorities)
    -   [<span data-ttu-id="3d61f-108">Algoritmo de prioridad predeterminado</span><span class="sxs-lookup"><span data-stu-id="3d61f-108">Default priority algorithm</span></span>](#default-priority-algorithm)
-   [<span data-ttu-id="3d61f-109">Administración de la residencia de programación</span><span class="sxs-lookup"><span data-stu-id="3d61f-109">Programming residency management</span></span>](#programming-residency-management)
-   [<span data-ttu-id="3d61f-110">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="3d61f-110">Related topics</span></span>](#related-topics)

## <a name="residency-budget"></a><span data-ttu-id="3d61f-111">Presupuesto de residencia</span><span class="sxs-lookup"><span data-stu-id="3d61f-111">Residency budget</span></span>

<span data-ttu-id="3d61f-112">Las GPU todavía no admiten errores de página, por lo que las aplicaciones deben confirmar los datos en la memoria física mientras la GPU podría acceder a ella.</span><span class="sxs-lookup"><span data-stu-id="3d61f-112">GPUs do not yet support page-faulting, so applications must commit data into physical memory while the GPU could access it.</span></span> <span data-ttu-id="3d61f-113">Este proceso se conoce como "crear un elemento residente" y debe realizarse tanto para la memoria física del sistema como para la memoria física de vídeo independiente.</span><span class="sxs-lookup"><span data-stu-id="3d61f-113">This process is known as “making something resident”, and must be done for both physical system memory and physical discrete video memory.</span></span> <span data-ttu-id="3d61f-114">En D3D12, la mayoría de los objetos de API encapsulan cierta cantidad de memoria accesible desde GPU.</span><span class="sxs-lookup"><span data-stu-id="3d61f-114">In D3D12, most API objects encapsulate some amount of GPU-accessible memory.</span></span> <span data-ttu-id="3d61f-115">Esa memoria accesible mediante GPU se hace residente durante la creación del objeto de API y se expulsa en la destrucción de objetos de la API.</span><span class="sxs-lookup"><span data-stu-id="3d61f-115">That GPU-accessible memory is made resident during the creation of the API object, and evicted on API object destruction.</span></span>

<span data-ttu-id="3d61f-116">La cantidad de memoria física disponible para el proceso se conoce como el presupuesto de memoria de vídeo.</span><span class="sxs-lookup"><span data-stu-id="3d61f-116">The amount of physical memory available for the process is known as the video memory budget.</span></span> <span data-ttu-id="3d61f-117">El presupuesto puede fluctuar notablemente a medida que los procesos en segundo plano se reactivan y suspenden. y fluctúan drásticamente cuando el usuario cambia a otra aplicación.</span><span class="sxs-lookup"><span data-stu-id="3d61f-117">The budget can fluctuate noticeably as background processes wake-up and sleep; and fluctuate dramatically when the user switches away to another application.</span></span> <span data-ttu-id="3d61f-118">Se puede notificar a la aplicación cuando el presupuesto cambie y sondee el presupuesto actual y la cantidad de memoria consumida actualmente.</span><span class="sxs-lookup"><span data-stu-id="3d61f-118">The application can be notified when the budget changes and poll both the current budget and the currently consumed amount of memory.</span></span> <span data-ttu-id="3d61f-119">Si una aplicación no se mantiene dentro de su presupuesto, el proceso se inmovilizará intermitentemente para permitir que se ejecuten otras aplicaciones y/o las API de creación devolverán un error.</span><span class="sxs-lookup"><span data-stu-id="3d61f-119">If an application doesn’t stay within its budget, the process will be intermittently frozen to allow other applications to run and/or the creation APIs will return failure.</span></span> <span data-ttu-id="3d61f-120">La interfaz [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) proporciona los métodos que pertenecen a esta funcionalidad, en particular [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) y [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span><span class="sxs-lookup"><span data-stu-id="3d61f-120">The [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) interface provides the methods pertaining to this functionality, in particular [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) and [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span></span>

<span data-ttu-id="3d61f-121">Se recomienda que las aplicaciones usen una reserva para denotar la cantidad de memoria a la que no pueden ir.</span><span class="sxs-lookup"><span data-stu-id="3d61f-121">Applications are encouraged to use a reservation to denote the amount of memory they cannot go without.</span></span> <span data-ttu-id="3d61f-122">Idealmente, la configuración de gráficos "Low" especificada por el usuario, o algo más baja, es el valor correcto para dicha reserva.</span><span class="sxs-lookup"><span data-stu-id="3d61f-122">Ideally, the user-specified “low” graphics settings, or something even lower, is the right value for such a reservation.</span></span> <span data-ttu-id="3d61f-123">La configuración de una reserva no proporcionará nunca a una aplicación un presupuesto superior al que normalmente recibiría.</span><span class="sxs-lookup"><span data-stu-id="3d61f-123">Setting a reservation won’t ever give an application a higher budget than it would normally receive.</span></span> <span data-ttu-id="3d61f-124">En su lugar, la información de reserva ayuda al kernel del sistema operativo a minimizar rápidamente el impacto de las situaciones de presión de memoria de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="3d61f-124">Instead, the reservation information helps the OS kernel quickly minimize the impact of large memory pressure situations.</span></span> <span data-ttu-id="3d61f-125">Incluso no se garantiza que la reserva esté disponible para la aplicación cuando la aplicación no es la aplicación en primer plano.</span><span class="sxs-lookup"><span data-stu-id="3d61f-125">Even the reservation is not guaranteed to be available to the application when the application isn’t the foreground application.</span></span>

## <a name="heap-resources"></a><span data-ttu-id="3d61f-126">Recursos del montón</span><span class="sxs-lookup"><span data-stu-id="3d61f-126">Heap resources</span></span>

<span data-ttu-id="3d61f-127">Aunque muchos objetos de API encapsulan algunas memoria accesible por GPU, se espera que los montones & recursos sean la forma más significativa de usar y administrar la memoria física.</span><span class="sxs-lookup"><span data-stu-id="3d61f-127">While many API objects encapsulate some GPU-accessible memory, heaps & resources are expected to be the most significant way applications consume and manage physical memory.</span></span> <span data-ttu-id="3d61f-128">Un montón es la unidad de nivel más bajo para administrar la memoria física, por lo que es conveniente estar familiarizado con sus propiedades de residencia.</span><span class="sxs-lookup"><span data-stu-id="3d61f-128">A heap is the lowest level unit to manage physical memory, so it’s good to have some familiarity with their residency properties.</span></span>

-   <span data-ttu-id="3d61f-129">Los montones no se pueden hacer residentes parcialmente, pero existen soluciones con recursos reservados.</span><span class="sxs-lookup"><span data-stu-id="3d61f-129">Heaps cannot be made partially resident, but workarounds exists with reserved resources.</span></span>
-   <span data-ttu-id="3d61f-130">Los montones deben presupuestarse como parte de un grupo determinado.</span><span class="sxs-lookup"><span data-stu-id="3d61f-130">Heaps should be budgeted as part of a particular pool.</span></span> <span data-ttu-id="3d61f-131">Los adaptadores de UMA tienen un grupo, mientras que los adaptadores discretos tienen dos grupos.</span><span class="sxs-lookup"><span data-stu-id="3d61f-131">UMA adapters have one pool, while discrete adapters have two pools.</span></span> <span data-ttu-id="3d61f-132">Aunque es cierto que el kernel puede desplazar algunos montones en adaptadores discretos de la memoria de vídeo a la memoria del sistema, solo lo hace como último recurso.</span><span class="sxs-lookup"><span data-stu-id="3d61f-132">While it is true that kernel can shift some heaps on discrete adapters from video memory to system memory, it does so only as an extreme last resort.</span></span> <span data-ttu-id="3d61f-133">Las aplicaciones no deben basarse en el comportamiento de exceso de presupuesto del kernel y deben centrarse en la buena administración del presupuesto.</span><span class="sxs-lookup"><span data-stu-id="3d61f-133">Applications should not rely on the over-budget behavior of the kernel, and should focus on good budget management instead.</span></span>
-   <span data-ttu-id="3d61f-134">Los montones se pueden desalojar de la residencia, lo que permite que el contenido se desproteja en el disco.</span><span class="sxs-lookup"><span data-stu-id="3d61f-134">Heaps can be evicted from residency, which allows their content to be paged out to disk.</span></span> <span data-ttu-id="3d61f-135">Sin embargo, la destrucción de montones es una técnica más confiable para liberar la residencia en todas las arquitecturas de adaptador.</span><span class="sxs-lookup"><span data-stu-id="3d61f-135">But, destruction of heaps is a more reliable technique to free up residency across all adapter architectures.</span></span> <span data-ttu-id="3d61f-136">En los adaptadores en los que el campo *theMaxGPUVirtualAddressBitsPerProcess* de la [**\_ \_ \_ \_ \_ \_ compatibilidad de dirección virtual de GPU de datos de características de D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) está cerca del tamaño de presupuesto, la [**expulsión**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) no reclamará de manera confiable la residencia.</span><span class="sxs-lookup"><span data-stu-id="3d61f-136">On adapters where *theMaxGPUVirtualAddressBitsPerProcess* field of [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) is near the budget size, [**Evict**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) won’t reliably reclaim residency.</span></span>
-   <span data-ttu-id="3d61f-137">La creación del montón puede ser lenta; pero está optimizado para el procesamiento de subprocesos en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="3d61f-137">Heap creation can be slow; but it is optimized for background thread processing.</span></span> <span data-ttu-id="3d61f-138">Se recomienda crear montones en subprocesos en segundo plano para evitar el problema del subproceso de representación.</span><span class="sxs-lookup"><span data-stu-id="3d61f-138">It’s recommended to create heaps on background threads to avoid glitching the render thread.</span></span> <span data-ttu-id="3d61f-139">En D3D12, varios subprocesos pueden llamar a las rutinas de creación de forma segura simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="3d61f-139">In D3D12, multiple threads may safely call create routines concurrently.</span></span>

<span data-ttu-id="3d61f-140">D3D12 introduce más flexibilidad y ortogonalidad en su modelo de recursos con el fin de habilitar más opciones para las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="3d61f-140">D3D12 introduces more flexibility and orthogonality into its resource model in order to enable more options for applications.</span></span> <span data-ttu-id="3d61f-141">Hay tres tipos de recursos de alto nivel en D3D12: confirmados, colocados y reservados.</span><span class="sxs-lookup"><span data-stu-id="3d61f-141">There are three high-level types of resources in D3D12: committed, placed, and reserved.</span></span>

-   <span data-ttu-id="3d61f-142">Los recursos confirmados crean un recurso y un montón al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="3d61f-142">Committed resources create both a resource and a heap at the same time.</span></span> <span data-ttu-id="3d61f-143">El montón es implícito y no se puede tener acceso a él directamente.</span><span class="sxs-lookup"><span data-stu-id="3d61f-143">The heap is implicit and cannot be accessed directly.</span></span> <span data-ttu-id="3d61f-144">El tamaño del montón es el adecuado para buscar el recurso completo en el montón.</span><span class="sxs-lookup"><span data-stu-id="3d61f-144">The heap is appropriately sized to locate the entire resource within the heap.</span></span>
-   <span data-ttu-id="3d61f-145">Los recursos colocados permiten la colocación de un recurso en un desplazamiento distinto de cero dentro de un montón.</span><span class="sxs-lookup"><span data-stu-id="3d61f-145">Placed resources allow the placement of a resource at a non-zero offset within a heap.</span></span> <span data-ttu-id="3d61f-146">Los desplazamientos se deben alinear normalmente a 64 KB; pero existen algunas excepciones en ambas direcciones.</span><span class="sxs-lookup"><span data-stu-id="3d61f-146">Offsets must typically be aligned to 64KB; but some exceptions exist in both directions.</span></span> <span data-ttu-id="3d61f-147">Los recursos de MSAA requieren una alineación de desplazamiento de 4 MB y la alineación de desplazamiento de 4 KB está disponible para las texturas pequeñas.</span><span class="sxs-lookup"><span data-stu-id="3d61f-147">MSAA resources require 4MB offset alignment, and 4KB offset alignment is available for small textures.</span></span> <span data-ttu-id="3d61f-148">Los recursos colocados no se pueden reubicar o volver a asignar a otro montón directamente; pero habilitan la reubicación simple de los datos de recursos entre montones.</span><span class="sxs-lookup"><span data-stu-id="3d61f-148">Placed resources cannot be relocated or remapped to another heap directly; but they enable simple relocation of the resource data between heaps.</span></span> <span data-ttu-id="3d61f-149">Después de crear un nuevo recurso colocado en otro montón y copiar los datos de recursos, se tendrán que usar nuevos descriptores de recursos para la nueva ubicación de datos de recursos.</span><span class="sxs-lookup"><span data-stu-id="3d61f-149">After creating a new placed resource in a different heap and copying the resource data, new resource descriptors will have to be used for the new resource data location.</span></span>
-   <span data-ttu-id="3d61f-150">Los recursos reservados solo están disponibles cuando el adaptador admite los recursos en mosaico nivel 1 o superior.</span><span class="sxs-lookup"><span data-stu-id="3d61f-150">Reserved resources are only available when the adapter supports tiled resources tier 1 or greater.</span></span> <span data-ttu-id="3d61f-151">Cuando está disponible, ofrecen las técnicas de administración de residencia más avanzadas disponibles; pero no todos los adaptadores los admiten actualmente.</span><span class="sxs-lookup"><span data-stu-id="3d61f-151">When available, they offer the most advanced residency management techniques available; but not all adapters currently support them.</span></span> <span data-ttu-id="3d61f-152">Permiten volver a asignar un recurso sin necesidad de la regeneración de descriptores de recursos, la residencia parcial del nivel de MIP y escenarios de textura dispersos, etc. No se admiten todos los tipos de recursos, aunque los recursos reservados estén disponibles, por lo que todavía no es posible un administrador de residencia totalmente basado en páginas.</span><span class="sxs-lookup"><span data-stu-id="3d61f-152">They enable remapping a resource without requiring regeneration of resource descriptors, partial mip level residency, and sparse texture scenarios, etc. Not all resources types are supported even when reserved resources are available, so a fully general page-based residency manager isn’t yet feasible.</span></span>

## <a name="residency-priorities"></a><span data-ttu-id="3d61f-153">Prioridades de residencia</span><span class="sxs-lookup"><span data-stu-id="3d61f-153">Residency priorities</span></span>

<span data-ttu-id="3d61f-154">Windows 10 Creators Update permite a los desarrolladores influir en qué montones y recursos serán preferibles para permanecer residentes cuando la presión de memoria requiere que algunos de sus recursos se degraden.</span><span class="sxs-lookup"><span data-stu-id="3d61f-154">The Windows 10 Creators Update enables developers to influence which heaps and resources will be prefered to stay resident when memory pressure requires that some of its resources be demoted.</span></span> <span data-ttu-id="3d61f-155">Esto ayuda a los desarrolladores a crear aplicaciones de mejor rendimiento al aprovechar el conocimiento que el runtime no puede deducir del uso de la API.</span><span class="sxs-lookup"><span data-stu-id="3d61f-155">This helps developers create better performing applications by leveraging knowlege that the runtime can't infer from API usage.</span></span> <span data-ttu-id="3d61f-156">Se espera que los desarrolladores sean más cómodos y puedan especificar prioridades a medida que pasan por el uso de recursos confirmados para reservada y los recursos en mosaico.</span><span class="sxs-lookup"><span data-stu-id="3d61f-156">Its expected that developers will become more comfortable and capable specifying priorities as they transition from using commited resources to resereved and tiled resources.</span></span>

<span data-ttu-id="3d61f-157">La aplicación de estas prioridades debe ser más fácil que la administración de dos presupuestos de memoria dinámica, la degradación manual y la promoción de recursos bettween, ya que las aplicaciones ya pueden hacerlo.</span><span class="sxs-lookup"><span data-stu-id="3d61f-157">Applying these priorities must be easier than manageing two dynamic memory budgets, manually demoting and promoting resources bettween them, since applications can already do that.</span></span> <span data-ttu-id="3d61f-158">Por lo tanto, el diseño de la API de prioridad de residencia es muy específico con prioridades razonables predeterminadas asignadas a cada montón o recurso como se creó.</span><span class="sxs-lookup"><span data-stu-id="3d61f-158">Therefore, the design of the residency priority API is coursely-grained with reasonable default priorities assigned to each heap or resource as its created.</span></span> <span data-ttu-id="3d61f-159">Para obtener más información, vea [**ID3D12Device1:: SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) y la enumeración de [**prioridad de \_ residencia \_ de D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) .</span><span class="sxs-lookup"><span data-stu-id="3d61f-159">For more information, see [**ID3D12Device1::SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) and the [**D3D12\_RESIDENCY\_PRIORITY**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) enumeration.</span></span>

<span data-ttu-id="3d61f-160">Con las prioridades, se espera que los desarrolladores:</span><span class="sxs-lookup"><span data-stu-id="3d61f-160">With priorities, developers are expected to either:</span></span>

-   <span data-ttu-id="3d61f-161">Aumente la prioridad de algunos montones excepcionales para mitigar mejor el impacto en el rendimiento experimentado de estos montones al disminuir de nivel antes o con mayor frecuencia que sus patrones de acceso natural.</span><span class="sxs-lookup"><span data-stu-id="3d61f-161">Raise the priority of a few exceptional heaps to better mitigate the experienced performance impact of these heaps being demoted sooner or more frequently than their natural access patterns would demand.</span></span> <span data-ttu-id="3d61f-162">Se espera que este enfoque sea aprovechado por aplicaciones que se portan desde API de gráficos como Direct3D 11 o OpenGL, cuyo modelo de administración de recursos es significativamente diferente del de Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="3d61f-162">This approach is expected to be leveraged by applications ported from graphics APIs such as Direct3D 11 or OpenGL, who's resource management model is significantly different than that of Direct3D 12.</span></span>
-   <span data-ttu-id="3d61f-163">Invalide casi todas las prioridades del montón con el esquema de depósito propio de la aplicación, ya sea fijo, según el conocimiento del programador de la frecuencia de acceso o dinámica. un esquema fijo es más fácil de administrar que uno dinámico, pero puede ser menos eficaz y requerir que los pendiente"Styles de programador cambien en el transcurso del desarrollo.</span><span class="sxs-lookup"><span data-stu-id="3d61f-163">Override nearly all heap priorities with the application's own bucketization scheme, either fixed, based on the programmer's knowlege of access frequency, or dynamic; a fixed scheme is simpler to manage than a dynamic one, but can be less effective and require programmer intevention as use patterns change over the course of development.</span></span> <span data-ttu-id="3d61f-164">Se espera que este enfoque sea aprovechado por aplicaciones compiladas con la administración de recursos de estilo de Direct3D 12 en mente, como las que usan la biblioteca de residencia (especialmente los esquemas dinámicos).</span><span class="sxs-lookup"><span data-stu-id="3d61f-164">This approach is expected to be leveraged by applications that are built with Direct3D 12-style resource management in mind, such as those that use the residency library (especially dynamic schemes).</span></span>

### <a name="default-priority-algorithm"></a><span data-ttu-id="3d61f-165">Algoritmo de prioridad predeterminado</span><span class="sxs-lookup"><span data-stu-id="3d61f-165">Default priority algorithm</span></span>

<span data-ttu-id="3d61f-166">Una aplicación no puede especificar prioridades útiles para cualquier montón que intente administrar sin deshacer primero el algoritmo de prioridad predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3d61f-166">An application can't specify useful priorities for any heap it attempts to manage without first understaning the default priority algorithm.</span></span> <span data-ttu-id="3d61f-167">Esto se debe a que el valor de asignar una prioridad determinada a un montón se deriva de su prioridad relativa a otros montones con prioridad que compiten por la misma memoria.</span><span class="sxs-lookup"><span data-stu-id="3d61f-167">This is because the value of assigning a particular priority to a heap is derived from its relative priority to other prioritized heaps that compete for the same memory.</span></span>

<span data-ttu-id="3d61f-168">La estrategia elegida para generar las prioridades predeterminadas es categorizar los montones en dos cubos, con lo que se favorece el uso de los montones (lo que da prioridad más) a los montones que no se suelen escribir con frecuencia en los montones.</span><span class="sxs-lookup"><span data-stu-id="3d61f-168">The strategy chosen for generating default priorities is to categorize heaps into two buckets, favoring (giving higher priority to) heaps that are assumed to be written frequently by the GPU over heaps that aren't.</span></span>

<span data-ttu-id="3d61f-169">El depósito de alta prioridad contiene montones y recursos creados con marcas que los identifican como destinos de representación, búferes de estarcido de profundidad o vistas de acceso desordenado (UAVs).</span><span class="sxs-lookup"><span data-stu-id="3d61f-169">The high-priority bucket contains heaps and resources that are created with flags that identify them as render targets, depth-stencil buffers, or Unordered Access Views (UAVs).</span></span> <span data-ttu-id="3d61f-170">A estos se les asignan los valores de prioridad en el intervalo que empieza en la **prioridad de residencia de D3D12 \_ \_ \_ alto**; para dar mayor prioridad entre estos montones y recursos, los 16 bits más bajos de la prioridad se establecen en el tamaño del montón o recurso dividido entre 10 MB (saturando a 0xFFFF para montones extremadamente grandes).</span><span class="sxs-lookup"><span data-stu-id="3d61f-170">These are assigned priority values in the range starting at **D3D12\_RESIDENCY\_PRIORITY\_HIGH**; to further prioritize among these heaps and resources, the lowest 16-bits of the priority are set to the size of the heap or resource divided by 10MB (saturating to 0xFFFF for extremely large heaps).</span></span> <span data-ttu-id="3d61f-171">Esta priorización adicional favorece montones y recursos más grandes.</span><span class="sxs-lookup"><span data-stu-id="3d61f-171">This additional prioritization favors larger heaps and resources.</span></span>

<span data-ttu-id="3d61f-172">El depósito de prioridad baja contiene el resto de montones y recursos, a los que se asigna un valor de prioridad de la **prioridad de residencia de D3D12 \_ \_ \_ normal**.</span><span class="sxs-lookup"><span data-stu-id="3d61f-172">The low-priority bucket contains all other heaps and resources, which are assigned a priority value of **D3D12\_RESIDENCY\_PRIORITY\_NORMAL**.</span></span> <span data-ttu-id="3d61f-173">No se intenta establecer una priorización adicional entre estos montones y recursos.</span><span class="sxs-lookup"><span data-stu-id="3d61f-173">No further prioritization among these heaps and resources is attempted.</span></span>

## <a name="programming-residency-management"></a><span data-ttu-id="3d61f-174">Administración de la residencia de programación</span><span class="sxs-lookup"><span data-stu-id="3d61f-174">Programming residency management</span></span>

<span data-ttu-id="3d61f-175">Las aplicaciones sencillas pueden obtener simplemente la creación de recursos confirmados hasta que se produzcan errores de memoria insuficiente.</span><span class="sxs-lookup"><span data-stu-id="3d61f-175">Simple applications may be able to get by merely creating committed resources until experiencing out-of-memory failures.</span></span> <span data-ttu-id="3d61f-176">En caso de error, la aplicación puede destruir otros recursos confirmados o objetos de API para permitir que se realicen más creaciones de recursos.</span><span class="sxs-lookup"><span data-stu-id="3d61f-176">Upon failure, the application can destroy other committed resources or API objects to enable further resource creations to succeed.</span></span> <span data-ttu-id="3d61f-177">Sin embargo, se recomienda encarecidamente que las aplicaciones simples inspeccionen los cambios de presupuesto negativos y destruyan los objetos de API no usados aproximadamente una vez al fotograma.</span><span class="sxs-lookup"><span data-stu-id="3d61f-177">But, even simple applications are strongly recommended to watch for negative budget changes and destroy unused API objects roughly once a frame.</span></span>

<span data-ttu-id="3d61f-178">La complejidad de un diseño de la administración de las residencias se producirá al intentar optimizar las arquitecturas del adaptador o incorporar prioridades de residencia.</span><span class="sxs-lookup"><span data-stu-id="3d61f-178">The complexity of a residency management design will go up when trying to optimize for adapter architectures or incorporating residency priorities.</span></span> <span data-ttu-id="3d61f-179">La presupuestación discreta y la administración de dos grupos de memoria discreta serán más complejas que la administración de una sola y la asignación de prioridades fijas en una escala amplia puede suponer una carga de mantenimiento si evolucionan los patrones de uso.</span><span class="sxs-lookup"><span data-stu-id="3d61f-179">Discretely budgeting and managing two pools of discrete memory will be more complex than managing only one, and assigning fixed priorities on a wide scale can become a maintainance burden if use patterns evolve.</span></span> <span data-ttu-id="3d61f-180">El desbordamiento de texturas en la memoria del sistema aumenta la complejidad, ya que el recurso equivocado en la memoria del sistema puede afectar gravemente a la velocidad de fotogramas.</span><span class="sxs-lookup"><span data-stu-id="3d61f-180">Overflowing textures into system memory adds more complexity, as the wrong resource in system-memory can severely impact frame rate.</span></span> <span data-ttu-id="3d61f-181">Además, no hay ninguna funcionalidad sencilla que ayude a identificar los recursos que pueden beneficiarse del ancho de banda de la GPU superior o tolerar un ancho de banda menor de la GPU.</span><span class="sxs-lookup"><span data-stu-id="3d61f-181">And, there is no simple functionality to help identify the resources that would either benefit from higher GPU bandwidth or tolerate lower GPU bandwidth.</span></span>

<span data-ttu-id="3d61f-182">Incluso en diseños más complicados, se consultan las características del adaptador actual.</span><span class="sxs-lookup"><span data-stu-id="3d61f-182">Even more complicated designs will query for the features of the current adapter.</span></span> <span data-ttu-id="3d61f-183">Esta información está disponible en [**D3D12 \_ características \_ compatibilidad de la \_ \_ \_ dirección \_ virtual de GPU**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**\_ \_ \_ arquitectura de datos de D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), D3D12 de [**\_ \_ recursos en mosaico \_**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier)y [**\_ \_ \_ nivel de montón de recursos de D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span><span class="sxs-lookup"><span data-stu-id="3d61f-183">This information is available in [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**D3D12\_FEATURE\_DATA\_ARCHITECTURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), [**D3D12\_TILED\_RESOURCES\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier), and [**D3D12\_RESOURCE\_HEAP\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span></span>

<span data-ttu-id="3d61f-184">Es probable que varias partes de una aplicación se desenreden con distintas técnicas.</span><span class="sxs-lookup"><span data-stu-id="3d61f-184">Multiple parts of an application will likely wind up using different techniques.</span></span> <span data-ttu-id="3d61f-185">Por ejemplo, algunas texturas de gran tamaño y rutas de acceso de código poco empleadas pueden usar recursos confirmados, mientras que muchas texturas se pueden designar con una propiedad de streaming y usar una técnica de recursos colocados general.</span><span class="sxs-lookup"><span data-stu-id="3d61f-185">For example, some large textures and rarely exercised code paths may use committed resources, while many textures may be designated with a streaming property and use a general placed-resource technique.</span></span>

## <a name="related-topics"></a><span data-ttu-id="3d61f-186">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="3d61f-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3d61f-187">**ID3D12Heap**</span><span class="sxs-lookup"><span data-stu-id="3d61f-187">**ID3D12Heap**</span></span>](/windows/desktop/api/d3d12/nn-d3d12-id3d12heap)
</dt> <dt>

[<span data-ttu-id="3d61f-188">Administración de memoria</span><span class="sxs-lookup"><span data-stu-id="3d61f-188">Memory Management</span></span>](memory-management.md)
</dt> </dl>

 

 