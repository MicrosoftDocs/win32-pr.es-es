---
description: Los subprocesos streaming y Application
ms.assetid: 954f7abd-fe06-430a-b6f7-d60852826bc9
title: Los subprocesos streaming y Application
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 432e613ff0322377c042e796d84ef7affdda99c2
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "104547019"
---
# <a name="the-streaming-and-application-threads"></a><span data-ttu-id="4312c-103">Los subprocesos streaming y Application</span><span class="sxs-lookup"><span data-stu-id="4312c-103">The Streaming and Application Threads</span></span>

<span data-ttu-id="4312c-104">Cualquier aplicación de DirectShow contiene al menos dos subprocesos importantes: el subproceso de la aplicación y uno o más subprocesos de streaming.</span><span class="sxs-lookup"><span data-stu-id="4312c-104">Any DirectShow application contains at least two important threads: the application thread, and one or more streaming threads.</span></span> <span data-ttu-id="4312c-105">Los ejemplos se entregan en los subprocesos de streaming y los cambios de estado se producen en el subproceso de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="4312c-105">Samples are delivered on the streaming threads, and state changes happen on the application thread.</span></span> <span data-ttu-id="4312c-106">Un filtro de origen o analizador crea el subproceso de streaming principal.</span><span class="sxs-lookup"><span data-stu-id="4312c-106">The main streaming thread is created by a source or parser filter.</span></span> <span data-ttu-id="4312c-107">Otros filtros pueden crear subprocesos de trabajo que proporcionan ejemplos, y también se consideran subprocesos de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="4312c-107">Other filters might create worker threads that deliver samples, and these are considered streaming threads as well.</span></span>

<span data-ttu-id="4312c-108">Algunos métodos se llaman en el subproceso de la aplicación, mientras que otros se llaman en un subproceso de streaming.</span><span class="sxs-lookup"><span data-stu-id="4312c-108">Some methods are called on the application thread, while others are called on a streaming thread.</span></span> <span data-ttu-id="4312c-109">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="4312c-109">For example:</span></span>

-   <span data-ttu-id="4312c-110">Subprocesos de streaming: [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin:: ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPin:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator:: getBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="4312c-110">Streaming thread(s): [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span>
-   <span data-ttu-id="4312c-111">Subproceso de aplicación: [**IMediaFilter::P ause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter:: Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter:: Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking:: SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPin:: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPin:: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="4312c-111">Application thread: [**IMediaFilter::Pause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter::Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter::Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking::SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span>
-   <span data-ttu-id="4312c-112">O bien: [**IPin:: NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span><span class="sxs-lookup"><span data-stu-id="4312c-112">Either: [**IPin::NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span></span>

<span data-ttu-id="4312c-113">Tener un subproceso de streaming independiente permite que los datos fluyan a través del gráfico mientras el subproceso de la aplicación espera la entrada del usuario.</span><span class="sxs-lookup"><span data-stu-id="4312c-113">Having a separate streaming thread allows data to flow through the graph while the application thread waits for user input.</span></span> <span data-ttu-id="4312c-114">Sin embargo, el peligro de varios subprocesos es que un filtro puede crear recursos cuando se pausa (en el subproceso de aplicación), utilizarlos dentro de un método de transmisión por secuencias y destruirlos cuando se detiene (también en el subproceso de la aplicación).</span><span class="sxs-lookup"><span data-stu-id="4312c-114">The danger of multiple threads, however, is that a filter may create resources when it pauses (on the application thread), use them inside a streaming method, and destroy them when it stops (also on the application thread).</span></span> <span data-ttu-id="4312c-115">Si no tiene cuidado, el subproceso de streaming podría intentar usar los recursos una vez destruidos.</span><span class="sxs-lookup"><span data-stu-id="4312c-115">If you are not careful, the streaming thread might try to use the resources after they are destroyed.</span></span> <span data-ttu-id="4312c-116">La solución consiste en proteger los recursos mediante secciones críticas y sincronizar los métodos de streaming con los cambios de estado.</span><span class="sxs-lookup"><span data-stu-id="4312c-116">The solution is to protect resources using critical sections, and synchronize streaming methods with state changes.</span></span>

<span data-ttu-id="4312c-117">Un filtro necesita una sección crítica para proteger el estado del filtro.</span><span class="sxs-lookup"><span data-stu-id="4312c-117">A filter needs one critical section to protect the filter state.</span></span> <span data-ttu-id="4312c-118">La clase [**CBaseFilter**](cbasefilter.md) tiene una variable miembro para esta sección crítica, [**CBaseFilter:: m \_ Plock**](cbasefilter-m-plock.md).</span><span class="sxs-lookup"><span data-stu-id="4312c-118">The [**CBaseFilter**](cbasefilter.md) class has a member variable for this critical section, [**CBaseFilter::m\_pLock**](cbasefilter-m-plock.md).</span></span> <span data-ttu-id="4312c-119">Esta sección crítica se denomina bloqueo de filtro.</span><span class="sxs-lookup"><span data-stu-id="4312c-119">This critical section is called the filter lock.</span></span> <span data-ttu-id="4312c-120">Además, cada pin de entrada necesita una sección crítica para proteger los recursos utilizados por el subproceso de streaming.</span><span class="sxs-lookup"><span data-stu-id="4312c-120">Also, each input pin needs a critical section to protect resources used by the streaming thread.</span></span> <span data-ttu-id="4312c-121">Estas secciones críticas se denominan bloqueos de streaming; debe declararlos en la clase de PIN derivada.</span><span class="sxs-lookup"><span data-stu-id="4312c-121">These critical sections are called streaming locks; you must declare them in your derived pin class.</span></span> <span data-ttu-id="4312c-122">Es más fácil usar la clase [**CCritSec**](ccritsec.md) , que ajusta un objeto de **\_ sección crítica** de Windows y se puede bloquear mediante la clase [**CAutoLock**](cautolock.md) .</span><span class="sxs-lookup"><span data-stu-id="4312c-122">It is easiest to use the [**CCritSec**](ccritsec.md) class, which wraps a Windows **CRITICAL\_SECTION** object and can be locked using the [**CAutoLock**](cautolock.md) class.</span></span> <span data-ttu-id="4312c-123">La clase **CCritSec** también proporciona algunas funciones de depuración útiles.</span><span class="sxs-lookup"><span data-stu-id="4312c-123">The **CCritSec** class also provides some useful debugging functions.</span></span> <span data-ttu-id="4312c-124">Para obtener más información, vea [funciones críticas de depuración de sección](critical-section-debugging-functions.md).</span><span class="sxs-lookup"><span data-stu-id="4312c-124">For more information, see [Critical Section Debugging Functions](critical-section-debugging-functions.md).</span></span>

<span data-ttu-id="4312c-125">Cuando un filtro se detiene o se vacía, debe sincronizar el subproceso de aplicación con el subproceso de streaming.</span><span class="sxs-lookup"><span data-stu-id="4312c-125">When a filter stops or flushes, it must synchronize the application thread with the streaming thread.</span></span> <span data-ttu-id="4312c-126">Para evitar el interbloqueo, primero debe desbloquear el subproceso de streaming, que podría estar bloqueado por varias razones:</span><span class="sxs-lookup"><span data-stu-id="4312c-126">To avoid deadlocking, it must first unblock the streaming thread, which might be blocked for several reasons:</span></span>

-   <span data-ttu-id="4312c-127">Está esperando obtener un ejemplo dentro del método [**IMemAllocator:: getBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , porque todos los ejemplos del asignador están en uso.</span><span class="sxs-lookup"><span data-stu-id="4312c-127">It is waiting to get a sample inside the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, because all of the allocator's samples are in use.</span></span>
-   <span data-ttu-id="4312c-128">Está esperando a que se devuelva otro filtro desde un método de transmisión por secuencias, como **Receive**.</span><span class="sxs-lookup"><span data-stu-id="4312c-128">It is waiting for another filter to return from a streaming method, such as **Receive**.</span></span>
-   <span data-ttu-id="4312c-129">Está esperando dentro de uno de sus propios métodos de streaming, para que algún recurso esté disponible.</span><span class="sxs-lookup"><span data-stu-id="4312c-129">It is waiting inside one of its own streaming methods, for some resource to become available.</span></span>
-   <span data-ttu-id="4312c-130">Es un filtro de representador que espera el tiempo de presentación del ejemplo siguiente</span><span class="sxs-lookup"><span data-stu-id="4312c-130">It is a renderer filter waiting for the presentation time of the next sample</span></span>
-   <span data-ttu-id="4312c-131">Se trata de un filtro de representador que espera dentro del método **Receive** mientras está en pausa.</span><span class="sxs-lookup"><span data-stu-id="4312c-131">It is a renderer filter waiting inside the **Receive** method while paused.</span></span>

<span data-ttu-id="4312c-132">Por lo tanto, cuando el filtro se detiene o se vacía, debe hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="4312c-132">Therefore, when the filter stops or flushes, it must do the following:</span></span>

-   <span data-ttu-id="4312c-133">Libere cualquier ejemplo que esté reteniendo por cualquier motivo.</span><span class="sxs-lookup"><span data-stu-id="4312c-133">Release any sample it is holding for any reason.</span></span> <span data-ttu-id="4312c-134">Al hacerlo, se desbloquea el método **getBuffer** .</span><span class="sxs-lookup"><span data-stu-id="4312c-134">Doing so unblocks the **GetBuffer** method.</span></span>
-   <span data-ttu-id="4312c-135">Vuelva de cualquier método de streaming lo más rápido posible.</span><span class="sxs-lookup"><span data-stu-id="4312c-135">Return from any streaming method as quickly as possible.</span></span> <span data-ttu-id="4312c-136">Si un método de transmisión por secuencias está esperando un recurso, debe dejar de esperar de inmediato.</span><span class="sxs-lookup"><span data-stu-id="4312c-136">If a streaming method is waiting for a resource, it must stop waiting immediately.</span></span>
-   <span data-ttu-id="4312c-137">Empieza a rechazar muestras en **recepción**, de modo que el subproceso de streaming no tiene acceso a más recursos.</span><span class="sxs-lookup"><span data-stu-id="4312c-137">Start rejecting samples in **Receive**, so that the streaming thread does not access any more resources.</span></span> <span data-ttu-id="4312c-138">(La clase [**CBaseInputPin**](cbaseinputpin.md) lo controla automáticamente).</span><span class="sxs-lookup"><span data-stu-id="4312c-138">(The [**CBaseInputPin**](cbaseinputpin.md) class handles this automatically.)</span></span>
-   <span data-ttu-id="4312c-139">El método **Stop** debe desasignar todos los asignadores del filtro.</span><span class="sxs-lookup"><span data-stu-id="4312c-139">The **Stop** method must decommit all of the filter's allocators.</span></span> <span data-ttu-id="4312c-140">(La clase **CBaseInputPin** lo controla automáticamente).</span><span class="sxs-lookup"><span data-stu-id="4312c-140">(The **CBaseInputPin** class handles this automatically.)</span></span>

<span data-ttu-id="4312c-141">El vaciado y la detención se producen en el subproceso de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="4312c-141">Flushing and stopping both happen on the application thread.</span></span> <span data-ttu-id="4312c-142">Un filtro se detiene en respuesta al método [**IMediaControl:: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) .</span><span class="sxs-lookup"><span data-stu-id="4312c-142">A filter stops in response to the [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) method.</span></span> <span data-ttu-id="4312c-143">Filter Graph Manager emite el comando STOP en orden ascendente, empezando por los representadores y trabajando hacia atrás hasta los filtros de origen.</span><span class="sxs-lookup"><span data-stu-id="4312c-143">The Filter Graph Manager issues the stop command in upstream order, starting from the renderers and working backward to the source filters.</span></span> <span data-ttu-id="4312c-144">El comando STOP se produce completamente dentro del método **CBaseFilter:: Stop** del filtro.</span><span class="sxs-lookup"><span data-stu-id="4312c-144">The stop command happens completely inside the filter's **CBaseFilter::Stop** method.</span></span> <span data-ttu-id="4312c-145">Cuando el método devuelve, el filtro debe estar en estado detenido.</span><span class="sxs-lookup"><span data-stu-id="4312c-145">When the method returns, the filter should be in a stopped state.</span></span>

<span data-ttu-id="4312c-146">Normalmente, el vaciado se produce debido a un comando Seek.</span><span class="sxs-lookup"><span data-stu-id="4312c-146">Flushing typically occurs because of a seek command.</span></span> <span data-ttu-id="4312c-147">Un comando de vaciado se inicia desde el filtro de origen o analizador y se desplaza hacia abajo.</span><span class="sxs-lookup"><span data-stu-id="4312c-147">A flush command starts from the source or parser filter, and travels downstream.</span></span> <span data-ttu-id="4312c-148">El vaciado se produce en dos fases: el método [**IPin:: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) informa a un filtro para descartar todos los datos pendientes y entrantes; el método [**IPin:: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) señala el filtro para aceptar los datos de nuevo.</span><span class="sxs-lookup"><span data-stu-id="4312c-148">Flushing happens in two stages: The [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) method informs a filter to discard all pending and incoming data; the [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) method signals the filter to accept data again.</span></span> <span data-ttu-id="4312c-149">El vaciado requiere dos fases porque la llamada **BeginFlush** se encuentra en el subproceso de la aplicación, durante el cual el subproceso de streaming sigue entregando datos.</span><span class="sxs-lookup"><span data-stu-id="4312c-149">Flushing requires two stages because the **BeginFlush** call is on the application thread, during which the streaming thread continues to deliver data.</span></span> <span data-ttu-id="4312c-150">Por lo tanto, algunos ejemplos pueden llegar después de la llamada a **BeginFlush** .</span><span class="sxs-lookup"><span data-stu-id="4312c-150">Therefore, some samples may arrive after the **BeginFlush** call.</span></span> <span data-ttu-id="4312c-151">El filtro debe descartarlos.</span><span class="sxs-lookup"><span data-stu-id="4312c-151">The filter should discard these.</span></span> <span data-ttu-id="4312c-152">Se garantiza que las muestras que llegan después de la llamada a **EndFlush** son nuevas y deben entregarse.</span><span class="sxs-lookup"><span data-stu-id="4312c-152">Any samples that arrive after the **EndFlush** call are guaranteed to be new, and should be delivered.</span></span>

<span data-ttu-id="4312c-153">Las secciones siguientes contienen ejemplos de código que muestran cómo implementar los métodos de filtro más importantes, como **pausar**, **recibir**, etc., de modo que se eviten los interbloqueos y las condiciones de carrera.</span><span class="sxs-lookup"><span data-stu-id="4312c-153">The sections that follow contain code samples showing how to implement the most important filter methods, such as **Pause**, **Receive**, and so forth, in ways that avoid deadlocks and race conditions.</span></span> <span data-ttu-id="4312c-154">Sin embargo, cada filtro tiene requisitos diferentes, por lo que tendrá que adaptar estos ejemplos a su filtro concreto.</span><span class="sxs-lookup"><span data-stu-id="4312c-154">Every filter has different requirements, however, so you will need to adapt these examples to your particular filter.</span></span>

> [!Note]  
> <span data-ttu-id="4312c-155">Las clases base [**CTransformFilter**](ctransformfilter.md) y [**CTransInPlaceFilter**](ctransinplacefilter.md) controlan muchos de los problemas que se describen en este artículo.</span><span class="sxs-lookup"><span data-stu-id="4312c-155">The [**CTransformFilter**](ctransformfilter.md) and [**CTransInPlaceFilter**](ctransinplacefilter.md) base classes handle many of the issues described in this article.</span></span> <span data-ttu-id="4312c-156">Si está escribiendo un filtro de transformación y el filtro no espera en los eventos dentro de un método de transmisión por secuencias, o si contiene muestras fuera de la **recepción**, estas clases base deben ser suficientes.</span><span class="sxs-lookup"><span data-stu-id="4312c-156">If you are writing a transform filter, and your filter does not wait on events inside a streaming method, or hold onto samples outside of **Receive**, then these base classes should be sufficient.</span></span>

 

 

 



