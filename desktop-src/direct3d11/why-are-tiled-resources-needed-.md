---
title: ¿Por qué son necesarios los recursos en mosaico?
description: Los recursos en mosaico son necesarios, por lo que no se podrá tener acceso a la memoria de la unidad de procesamiento de gráficos (GPU), y el hardware puede comprender cómo filtrar por los mosaicos adyacentes.
ms.assetid: E2179D65-56D3-481F-A5F3-B9C45A11A179
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d42ccccf66a73d224d8bab9a9d10c87cc330be43
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/20/2020
ms.locfileid: "104983987"
---
# <a name="why-are-tiled-resources-needed"></a><span data-ttu-id="46ecb-103">¿Por qué son necesarios los recursos en mosaico?</span><span class="sxs-lookup"><span data-stu-id="46ecb-103">Why are tiled resources needed?</span></span>

<span data-ttu-id="46ecb-104">Los recursos en mosaico son necesarios, por lo que no se podrá tener acceso a la memoria de la unidad de procesamiento de gráficos (GPU), y el hardware puede comprender cómo filtrar por los mosaicos adyacentes.</span><span class="sxs-lookup"><span data-stu-id="46ecb-104">Tiled resources are needed so less graphics processing unit (GPU) memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles.</span></span>

<span data-ttu-id="46ecb-105">En un sistema de gráficos (es decir, el sistema operativo, el controlador de pantalla y el hardware de gráficos) sin compatibilidad con recursos en mosaico, el sistema de gráficos administra todas las asignaciones de memoria de Direct3D en la granularidad de los recursos.</span><span class="sxs-lookup"><span data-stu-id="46ecb-105">In a graphics system (that is, the operating system, display driver, and graphics hardware) without tiled resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span> <span data-ttu-id="46ecb-106">En el caso de un [búfer](overviews-direct3d-11-resources-buffers.md), todo el búfer es el subrecurso.</span><span class="sxs-lookup"><span data-stu-id="46ecb-106">For a [Buffer](overviews-direct3d-11-resources-buffers.md), the entire Buffer is the subresource.</span></span> <span data-ttu-id="46ecb-107">En el caso de una [textura](overviews-direct3d-11-resources-textures.md) (por ejemplo, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), cada nivel de MIP es un subrecurso; en el caso de una matriz de textura (por ejemplo, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), cada nivel de MIP en un segmento de matriz determinado es un subrecurso.</span><span class="sxs-lookup"><span data-stu-id="46ecb-107">For a [Texture](overviews-direct3d-11-resources-textures.md) (for example, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), each mip level is a subresource; for a texture array (for example, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="46ecb-108">El sistema de gráficos solo expone la capacidad de administrar la asignación de asignaciones en esta granularidad de Subrecursos.</span><span class="sxs-lookup"><span data-stu-id="46ecb-108">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="46ecb-109">En el contexto de los recursos en mosaico, la "asignación" hace referencia a hacer que los datos sean visibles para la GPU.</span><span class="sxs-lookup"><span data-stu-id="46ecb-109">In the context of tiled resources, "mapping" refers to making data visible to the GPU.</span></span>

<span data-ttu-id="46ecb-110">Supongamos que una aplicación sabe que una operación de representación determinada solo necesita tener acceso a una pequeña parte de una cadena de mipmap de imagen (quizás no incluso al área completa de un mipmap determinado).</span><span class="sxs-lookup"><span data-stu-id="46ecb-110">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="46ecb-111">Idealmente, la aplicación podría informar al sistema de gráficos sobre esta necesidad.</span><span class="sxs-lookup"><span data-stu-id="46ecb-111">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="46ecb-112">El sistema de gráficos solo se molestaría para asegurarse de que la memoria necesaria está asignada en la GPU sin paginación en demasiada memoria.</span><span class="sxs-lookup"><span data-stu-id="46ecb-112">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span> <span data-ttu-id="46ecb-113">En realidad, sin compatibilidad con recursos en mosaico, solo se puede informar al sistema de gráficos sobre la memoria que debe asignarse a la GPU en la granularidad de los Subrecursos (por ejemplo, un intervalo de niveles de mipmap completo a los que se puede tener acceso).</span><span class="sxs-lookup"><span data-stu-id="46ecb-113">In reality, without tiled resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="46ecb-114">No hay ningún error de demanda en el sistema de gráficos, por lo que es posible que se use una gran cantidad de memoria de GPU para hacer que se asignen Subrecursos completos antes de que se ejecute un comando de representación que haga referencia a cualquier parte de la memoria.</span><span class="sxs-lookup"><span data-stu-id="46ecb-114">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="46ecb-115">Esto es solo un problema que dificulta el uso de grandes asignaciones de memoria en Direct3D sin compatibilidad con recursos en mosaico.</span><span class="sxs-lookup"><span data-stu-id="46ecb-115">This is just one issue that makes the use of large memory allocations difficult in Direct3D without tiled resource support.</span></span>

<span data-ttu-id="46ecb-116">Direct3D 11 admite superficies [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) con hasta 16384 píxeles en un lado determinado.</span><span class="sxs-lookup"><span data-stu-id="46ecb-116">Direct3D 11 supports [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="46ecb-117">Una imagen de 16384 de ancho a 16384 de alto y 4 bytes por píxel consumirá 1 GB de memoria de vídeo (y la adición de mapas de bits duplicaría esa cantidad).</span><span class="sxs-lookup"><span data-stu-id="46ecb-117">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="46ecb-118">En la práctica, no es necesario hacer referencia a todos los 1 GB en una sola operación de representación.</span><span class="sxs-lookup"><span data-stu-id="46ecb-118">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="46ecb-119">Algunos desarrolladores de juegos muestran superficies del terreno tan grandes como 128 KB.</span><span class="sxs-lookup"><span data-stu-id="46ecb-119">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="46ecb-120">La forma en que lo hacen para trabajar en GPU existentes es dividir la superficie en mosaicos que son lo suficientemente pequeños como para controlar el hardware.</span><span class="sxs-lookup"><span data-stu-id="46ecb-120">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="46ecb-121">La aplicación debe averiguar qué mosaicos podrían ser necesarios y cargarlos en una caché de texturas en el sistema de paginación de software GPU-a.</span><span class="sxs-lookup"><span data-stu-id="46ecb-121">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span> <span data-ttu-id="46ecb-122">Una desventaja importante de este enfoque es que el hardware no está informando sobre la paginación que se está llevando a cabo: cuando es necesario mostrar una parte de una imagen en la pantalla que ocupa los mosaicos, el hardware no sabe cómo realizar el filtrado de función fija (es decir, eficaz) en los mosaicos.</span><span class="sxs-lookup"><span data-stu-id="46ecb-122">A significant downside to this approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="46ecb-123">Esto significa que la aplicación que administra su propia segmentación de software debe recurrir al filtrado manual de texturas en el código del sombreador (lo que resulta muy caro si se desea un filtro anisotrópico de buena calidad) o desperdiciar los márgenes de la creación de memoria alrededor de los mosaicos que contienen datos de mosaicos contiguos, de modo que el filtrado de hardware de función fija pueda seguir proporcionando</span><span class="sxs-lookup"><span data-stu-id="46ecb-123">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

<span data-ttu-id="46ecb-124">Si una representación en mosaico de las asignaciones de superficie puede ser una característica de primera clase en el sistema de gráficos, la aplicación podría indicar al hardware qué mosaicos debe poner a disposición.</span><span class="sxs-lookup"><span data-stu-id="46ecb-124">If a tiled representation of surface allocations could be a first class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="46ecb-125">De esta manera, se desperdicia menos memoria de GPU al almacenar regiones de superficies que la aplicación sabe que no se tendrá acceso a ella, y el hardware puede entender cómo filtrar por los mosaicos adyacentes, lo que evitará que se detecten algunos de los problemas de los desarrolladores que realizan el mosaico de software por su cuenta.</span><span class="sxs-lookup"><span data-stu-id="46ecb-125">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="46ecb-126">Pero para proporcionar una solución completa, se debe hacer algo para tratar con el hecho de que, independientemente de si se admite la disposición en mosaico dentro de una superficie, la dimensión de superficie máxima es actualmente de 16384-no está cerca de las 128K + que las aplicaciones ya quieren.</span><span class="sxs-lookup"><span data-stu-id="46ecb-126">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="46ecb-127">Simplemente requerir el hardware para admitir tamaños de textura mayores es un enfoque, sin embargo, hay costos y/o contrapartidas significativos para pasar a esta ruta.</span><span class="sxs-lookup"><span data-stu-id="46ecb-127">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span> <span data-ttu-id="46ecb-128">La ruta de acceso de la representación y la ruta de acceso del filtro de textura de Direct3D 11 ya están saturadas en términos de precisión en la compatibilidad con texturas de 16K con los demás requisitos, como la compatibilidad de las extensiones de la ventanilla que caen fuera de la superficie durante la representación o la compatibilidad con el ajuste de textura del borde de la superficie durante el filtrado.</span><span class="sxs-lookup"><span data-stu-id="46ecb-128">Direct3D 11's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="46ecb-129">Una posibilidad es definir un equilibrio de forma que, a medida que el tamaño de la textura aumente más allá de 16 k, la funcionalidad/precisión se proporcione de alguna manera.</span><span class="sxs-lookup"><span data-stu-id="46ecb-129">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="46ecb-130">Sin embargo, incluso con esta concesión, es posible que se requieran costos de hardware adicionales en cuanto a la capacidad de direccionamiento en todo el sistema de hardware para ir a tamaños de textura más grandes.</span><span class="sxs-lookup"><span data-stu-id="46ecb-130">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

<span data-ttu-id="46ecb-131">Un problema que se reproduce como texturas es muy grande es que las coordenadas de textura de punto flotante de precisión sencilla (y los interpoladores asociados para admitir la rasterización) se agotan sin precisión para especificar las ubicaciones en la superficie de forma precisa.</span><span class="sxs-lookup"><span data-stu-id="46ecb-131">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="46ecb-132">El filtrado de textura de vibración surgiría.</span><span class="sxs-lookup"><span data-stu-id="46ecb-132">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="46ecb-133">Una opción costosa sería requerir compatibilidad con el interpolador de precisión doble, aunque esto podría ser exageración dada una alternativa razonable.</span><span class="sxs-lookup"><span data-stu-id="46ecb-133">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

<span data-ttu-id="46ecb-134">Un nombre alternativo para los recursos en mosaico es "Texture SParte".</span><span class="sxs-lookup"><span data-stu-id="46ecb-134">An alternate name for tiled resources is "sparse texture."</span></span> <span data-ttu-id="46ecb-135">"Disperso" transmite tanto la naturaleza en mosaico de los recursos como la principal razón para su disposición en mosaico, de modo que no se espera que se asignen todos ellos a la vez.</span><span class="sxs-lookup"><span data-stu-id="46ecb-135">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="46ecb-136">De hecho, una aplicación puede crear un recurso en mosaico en el que no se crean datos para todas las regiones y MIPS del recurso, de forma intencionada.</span><span class="sxs-lookup"><span data-stu-id="46ecb-136">In fact, an application could conceivably author a tiled resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="46ecb-137">Por lo tanto, el propio contenido podría ser disperso y la asignación del contenido de la memoria de GPU en un momento dado sería un subconjunto de eso (más disperso).</span><span class="sxs-lookup"><span data-stu-id="46ecb-137">So, the content itself could be sparse, and the mapping of the content in GPU memory at a given time would be a subset of that (even more sparse).</span></span>

<span data-ttu-id="46ecb-138">Otro escenario que podrían atender los recursos en mosaico es habilitar varios recursos de diferentes dimensiones y formatos para compartir la misma memoria.</span><span class="sxs-lookup"><span data-stu-id="46ecb-138">Another scenario that could be served by tiled resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="46ecb-139">A veces, las aplicaciones tienen conjuntos exclusivos de recursos que se sabe que no se usan al mismo tiempo, o recursos que se crean solo para un uso muy breve y, a continuación, se destruyen, seguido de la creación de otros recursos.</span><span class="sxs-lookup"><span data-stu-id="46ecb-139">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="46ecb-140">Una forma de generalización que puede salir de "recursos en mosaico" es que es posible permitir que el usuario señale a varios recursos distintos en la misma memoria (superpuestas).</span><span class="sxs-lookup"><span data-stu-id="46ecb-140">A form of generality that can fall out of "tiled resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="46ecb-141">En otras palabras, la creación y destrucción de "recursos" (que definen una dimensión o formato, etc.) se pueden desacoplar de la administración de la memoria subyacente a los recursos desde el punto de vista de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="46ecb-141">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="related-topics"></a><span data-ttu-id="46ecb-142">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="46ecb-142">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="46ecb-143">Recursos en mosaico</span><span class="sxs-lookup"><span data-stu-id="46ecb-143">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 