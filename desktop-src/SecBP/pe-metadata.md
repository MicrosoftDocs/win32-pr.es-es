---
description: En este artículo se proporcionan detalles adicionales sobre los metadatos de protección de flujo de control en imágenes PE.
title: Metadatos de PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "105669910"
---
# <a name="pe-metadata"></a><span data-ttu-id="b5e03-103">Metadatos de PE</span><span class="sxs-lookup"><span data-stu-id="b5e03-103">PE metadata</span></span>

<span data-ttu-id="b5e03-104">En este artículo se proporcionan detalles adicionales sobre los metadatos de protección de flujo de control (CFG) en imágenes PE.</span><span class="sxs-lookup"><span data-stu-id="b5e03-104">This article provides additional details for Control Flow Guard (CFG) metadata in PE images.</span></span> <span data-ttu-id="b5e03-105">Se supone que está familiarizado con la estructura de los metadatos de CFG en las imágenes PE.</span><span class="sxs-lookup"><span data-stu-id="b5e03-105">Familiarity with the structure for CFG metadata in PE images is assumed.</span></span> <span data-ttu-id="b5e03-106">Consulte el tema [formato PE](../debug/pe-format.md) para obtener documentación de alto nivel sobre metadatos de cfg en imágenes PE.</span><span class="sxs-lookup"><span data-stu-id="b5e03-106">See the [PE Format](../debug/pe-format.md) topic for high-level documentation for CFG metadata in PE images.</span></span>

- <span data-ttu-id="b5e03-107">Las funciones que son destinos de llamadas indirectas válidas se enumeran en el **GuardCFFunctionTable** adjunto al directorio de configuración de carga, a veces se denomina la tabla **GFIDS** por motivos de brevedad.</span><span class="sxs-lookup"><span data-stu-id="b5e03-107">Functions that are valid indirect call targets are listed in the **GuardCFFunctionTable** attached to the load configuration directory, sometimes termed the **GFIDS** table for brevity.</span></span> <span data-ttu-id="b5e03-108">Se trata de una lista ordenada de direcciones virtuales relativas (RVA) que contienen información sobre los destinos de llamadas CFG válidos.</span><span class="sxs-lookup"><span data-stu-id="b5e03-108">This is a sorted list of relative virtual addresses (RVA) that contain information about valid CFG call targets.</span></span> <span data-ttu-id="b5e03-109">En general, se trata de símbolos de función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-109">These are, generally speaking, address taken function symbols.</span></span> <span data-ttu-id="b5e03-110">Una imagen que desea que el cumplimiento de CFG Enumere todos los símbolos de función de dirección tomada en la tabla **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-110">An image that wants CFG enforcement must enumerate all address taken function symbols in its **GFIDS** table.</span></span> <span data-ttu-id="b5e03-111">La lista RVA de la tabla **GFIDS** se debe ordenar correctamente o la imagen no se cargará.</span><span class="sxs-lookup"><span data-stu-id="b5e03-111">The RVA list in the **GFIDS** table must be sorted properly or the image will not be loaded.</span></span> <span data-ttu-id="b5e03-112">La tabla **GFIDS** es una matriz de 4 + *n* bytes, donde *n* viene dado por ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span><span class="sxs-lookup"><span data-stu-id="b5e03-112">The **GFIDS** table is an array of 4 + *n* bytes, where *n* is given by ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span></span> <span data-ttu-id="b5e03-113">"GuardFlags" es el campo GuardFlags del directorio de configuración de carga.</span><span class="sxs-lookup"><span data-stu-id="b5e03-113">“GuardFlags” is the GuardFlags field of the load configuration directory.</span></span> <span data-ttu-id="b5e03-114">Esto permite adjuntar metadatos adicionales a destinos de llamada CFG en el futuro.</span><span class="sxs-lookup"><span data-stu-id="b5e03-114">This allows for extra metadata to be attached to CFG call targets in the future.</span></span> <span data-ttu-id="b5e03-115">Los únicos metadatos actualmente definidos son un campo opcional de marcas adicionales de 1 bytes ("GFIDS flags") que se adjunta a cada entrada **GFIDS** si algún destino de llamada tiene metadatos.</span><span class="sxs-lookup"><span data-stu-id="b5e03-115">The only currently defined metadata is an optional 1-byte extra flags field (“GFIDS flags”) that is attached to each **GFIDS** entry if any call targets have metadata.</span></span> <span data-ttu-id="b5e03-116">Hay dos marcas **GFIDS** definidas:</span><span class="sxs-lookup"><span data-stu-id="b5e03-116">There are two **GFIDS** flags defined:</span></span>
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | <span data-ttu-id="b5e03-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span><span class="sxs-lookup"><span data-stu-id="b5e03-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span></span> | <span data-ttu-id="b5e03-118">El destino de la llamada se suprime explícitamente (no lo trate como válido para los fines de CFG)</span><span class="sxs-lookup"><span data-stu-id="b5e03-118">Call target is explicitly suppressed (do not treat it as valid for purposes of CFG)</span></span> |
  | <span data-ttu-id="b5e03-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0X2</span><span class="sxs-lookup"><span data-stu-id="b5e03-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span></span> | <span data-ttu-id="b5e03-120">El destino de la llamada es la exportación suprimida.</span><span class="sxs-lookup"><span data-stu-id="b5e03-120">Call target is export suppressed.</span></span> <span data-ttu-id="b5e03-121">Consulte [extinción de exportación](#export-suppression) para obtener más detalles</span><span class="sxs-lookup"><span data-stu-id="b5e03-121">See [Export suppression](#export-suppression) for more details</span></span> |
  
  <span data-ttu-id="b5e03-122">En el futuro, las herramientas no deben establecer marcas **GFIDS** que aún no se hayan definido y no deben incluir más bytes de metadatos **GFIDS** adicionales, más allá del valor de 1 byte definido actualmente, ya que los significados para otras marcas o metadatos adicionales todavía no se han asignado.</span><span class="sxs-lookup"><span data-stu-id="b5e03-122">For future compatibility, tools should not set **GFIDS** flags that have not yet been defined and should not include additional **GFIDS** extra metadata bytes beyond the 1-byte currently defined since the meanings for other flags or additional metadata are not yet assigned.</span></span> <span data-ttu-id="b5e03-123">Puede encontrar ejemplos de imágenes que incluyen bytes de metadatos adicionales mediante el volcado de la tabla de archivos binarios de **GFIDS** , como Ntdll.dll en una versión moderna de Windows 10 os.</span><span class="sxs-lookup"><span data-stu-id="b5e03-123">You can find examples of images that include extra metadata bytes by dumping the **GFIDS** table of binaries such as Ntdll.dll on a modern Windows 10 OS version.</span></span>

  <span data-ttu-id="b5e03-124">Las herramientas solo deben declarar símbolos de función como destinos de llamada válidos, lo que puede merecer una consideración adicional para el código del ensamblador en el que se pueden tratar las etiquetas.</span><span class="sxs-lookup"><span data-stu-id="b5e03-124">Tools should only declare function symbols as valid call targets which may merit additional consideration for assembler code where labels might be address taken.</span></span> <span data-ttu-id="b5e03-125">Por motivos históricos, el código de ensamblador puede basarse en etiquetas de código distintas de PROC o. no se convierte en destinos de llamada de CFG por el enlazador.</span><span class="sxs-lookup"><span data-stu-id="b5e03-125">For historical reasons, assembler code may rely on code labels other than PROC or .altentry as not being converted into CFG call targets by the linker.</span></span>

  <span data-ttu-id="b5e03-126">Además, por motivos históricos, el código puede declarar deliberadamente el código como datos para evitar la inclusión en la tabla **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-126">Also for historical reasons, code may deliberately declare code as data to avoid inclusion in the **GFIDS** table.</span></span> <span data-ttu-id="b5e03-127">Por ejemplo, un archivo objeto puede implementar un símbolo como código, mientras que otro puede declararlo como datos para tomar la dirección del símbolo sin generar un registro de destino de CFG válido.</span><span class="sxs-lookup"><span data-stu-id="b5e03-127">For example, one object file may implement a symbol as code while another may declare it as data in order to take the address of the symbol without generating a valid CFG target record.</span></span> <span data-ttu-id="b5e03-128">Por motivos de compatibilidad, se recomienda que los conjuntos de herramientas admitan esta práctica.</span><span class="sxs-lookup"><span data-stu-id="b5e03-128">For compatibility, it is recommended that toolsets support this practice.</span></span>

- <span data-ttu-id="b5e03-129">Las imágenes que admiten CFG y que desean o realizan comprobaciones de CFG deben establecer los bits IMAGE_GUARD_CF_INSTRUMENTED y IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags y deben establecer el bit de IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics en los encabezados de la imagen.</span><span class="sxs-lookup"><span data-stu-id="b5e03-129">Images that support CFG and that want or perform CFG checks should set the IMAGE_GUARD_CF_INSTRUMENTED and IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags bits, and should set the IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics bit in the image headers.</span></span>

- <span data-ttu-id="b5e03-130">El directorio de configuración de carga anuncia dos punteros de función: GuardCFCheckFunctionPointer y GuardCFDispatchFunctionPointer (el último solo se admite para determinadas arquitecturas, como AMD64).</span><span class="sxs-lookup"><span data-stu-id="b5e03-130">The load configuration directory advertises two function pointers: GuardCFCheckFunctionPointer and GuardCFDispatchFunctionPointer (the latter is only supported for certain architectures such as AMD64).</span></span> <span data-ttu-id="b5e03-131">Estos punteros de función deben apuntar a la memoria de solo lectura para que la seguridad de CFG sea efectiva. el cargador de DLL del sistema operativo volverá a proteger la memoria transitoriamente durante la carga de imágenes para almacenar los punteros de función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-131">These function pointers should point to read only memory for CFG security to be effective; the operating system’s DLL loader will reprotect the memory transiently during image loading to store the function pointers.</span></span> <span data-ttu-id="b5e03-132">El uso típico podría ser fusionar mediante combinación estos en la misma sección que contiene la tabla de direcciones de importación (IAT).</span><span class="sxs-lookup"><span data-stu-id="b5e03-132">Typical usage might be to merge these into the same section that contains the Import Address Table (IAT).</span></span> <span data-ttu-id="b5e03-133">GuardCFCheckFunctionPointer proporciona la dirección de un símbolo proporcionado por el cargador del sistema operativo al que se puede llamar con un puntero de función en el primer registro de argumento de tipo entero (ECX en x86) que devolverá si se ejecuta correctamente o anulará el proceso si el destino de la llamada no es un destino de CFG válido.</span><span class="sxs-lookup"><span data-stu-id="b5e03-133">The GuardCFCheckFunctionPointer provides the address of an OS-loader provided symbol that can be called with a function pointer in the first integer argument register (ECX on x86) which will return on success or will abort the process if the call target is not a valid CFG target.</span></span> <span data-ttu-id="b5e03-134">El GuardCFDispatchFunctionPointer proporciona la dirección de un símbolo proporcionado por el cargador del sistema operativo que toma un destino de llamada en el registro RAX y realiza una llamada a la rama de la rama y la bifurcación de la rama de cola en el destino de la llamada (los registros R10/R11 se reservan para su uso por parte de los registros de los argumentos de la llamada Ultimate).</span><span class="sxs-lookup"><span data-stu-id="b5e03-134">The GuardCFDispatchFunctionPointer provides the address of an OS-loader provided symbol that takes a call target in register RAX and performs a combined CFG check and tail branch optimized call to the call target (registers R10/R11 are reserved for use by the GuardCFDispatchFunctionPointer and integer argument registers are reserved for use by the ultimate call target).</span></span> <span data-ttu-id="b5e03-135">La dirección predeterminada de los símbolos CFG en una imagen debe apuntar a una función que solo devuelve (GuardCFCheckFunctionPointer) o que devuelve un símbolo Guard-suprimido (o que se ha omitido por completo en el símbolo de tabla **GFIDS** ) que ejecuta una instrucción "JMP Rax".</span><span class="sxs-lookup"><span data-stu-id="b5e03-135">The default address of the CFG symbols in an image should point to a function that just returns (GuardCFCheckFunctionPointer) or that returns a guard-suppressed symbol (or is preferably entirely omitted from the **GFIDS** table symbol) that executes a “jmp rax” instruction.</span></span> <span data-ttu-id="b5e03-136">En el caso de GuardCFDispatchFunctionPointer AMD64, cuando se carga una imagen en un sistema operativo compatible con CFG y CFG está habilitado, el cargador de DLL de OS instalará los punteros de función adecuados, lo que proporciona compatibilidad con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="b5e03-136">For AMD64 GuardCFDispatchFunctionPointer, when an image is loaded on a CFG-aware operating system, and CFG is enabled, the OS DLL loader will install appropriate function pointers, which facilities backwards compatibility.</span></span> <span data-ttu-id="b5e03-137">Una imagen puede proporcionar 0 para GuardCFDispatchFunctionPointer en la configuración de carga si no tiene intención de usar la instalación de distribución de CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-137">An image can supply 0 for the GuardCFDispatchFunctionPointer in the load config if it does not intend to use the CFG dispatch facility.</span></span> <span data-ttu-id="b5e03-138">Esto debe hacerse para las arquitecturas que no son AMD64 para una compatibilidad futura, en caso de que estas arquitecturas admitan finalmente el mecanismo de distribución de CFG de alguna forma.</span><span class="sxs-lookup"><span data-stu-id="b5e03-138">This should be done for non-AMD64 architectures for future compatibility, in case these architectures eventually support the CFG dispatch mechanism in some form.</span></span> <span data-ttu-id="b5e03-139">Tenga en cuenta que Windows 8.1 AMD64 no era compatible con el envío de CFG y dejaría el puntero de función predeterminado en su lugar para GuardCFDispatchFunctionPointer.</span><span class="sxs-lookup"><span data-stu-id="b5e03-139">Note that Windows 8.1 AMD64 did not support CFG dispatch and would leave the default function pointer in place for GuardCFDispatchFunctionPointer.</span></span> <span data-ttu-id="b5e03-140">CFG Dispatch solo se admite en sistemas operativos Windows 10 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="b5e03-140">CFG dispatch is only supported on Windows 10 and later operating systems.</span></span>

- <span data-ttu-id="b5e03-141">El modo de usuario CFG solo se puede aplicar para las imágenes marcadas como compatibilidad con la selección aleatoria del diseño del espacio de direcciones (ASLR) (que se especifica mediante la opción/DYNAMICBASE con el vinculador de Microsoft).</span><span class="sxs-lookup"><span data-stu-id="b5e03-141">User mode CFG might only be enforced for images that are marked as address space layout randomization (ASLR) compatible (specified by the /DYNAMICBASE option with the Microsoft linker).</span></span> <span data-ttu-id="b5e03-142">Esto se debe a la forma en que el sistema operativo controla internamente CFG, donde se conecta esencialmente con la infraestructura de ASLR.</span><span class="sxs-lookup"><span data-stu-id="b5e03-142">This is due to how the OS internally handles CFG where it is essentially wired in to the ASLR infrastructure.</span></span> <span data-ttu-id="b5e03-143">En general, los usuarios de CFG deben habilitar ASLR para sus imágenes como primer paso.</span><span class="sxs-lookup"><span data-stu-id="b5e03-143">In general, users of CFG should enable ASLR for their images as a first step.</span></span> <span data-ttu-id="b5e03-144">Las herramientas no deben suponer que el sistema operativo siempre omitirá CFG sin el conjunto ASLR, pero generalmente debe establecer ambos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="b5e03-144">Tools should not assume that the OS will always ignore CFG without ASLR set but should generally set both at the same time.</span></span>

## <a name="compiler-directives"></a><span data-ttu-id="b5e03-145">Directivas de compilador</span><span class="sxs-lookup"><span data-stu-id="b5e03-145">Compiler directives</span></span>

- <span data-ttu-id="b5e03-146">Los destinos de llamada se pueden marcar como suprimidos explícitamente con el modificador __declspec (Guard (suprimir)) o con la Directiva del enlazador/guardsym: symname, S (para código ASM, por ejemplo).</span><span class="sxs-lookup"><span data-stu-id="b5e03-146">Call targets can be marked as explicitly suppressed with the __declspec(guard(suppress)) modifier, or with the /guardsym:symname,S linker directive (for asm code for example).</span></span> <span data-ttu-id="b5e03-147">Esto hace que el destino de la llamada se incluya en la tabla **GFIDS** pero está marcado de tal forma que el sistema operativo tratará el destino de la llamada como no válido.</span><span class="sxs-lookup"><span data-stu-id="b5e03-147">This causes the call target to be included in the **GFIDS** table but marked in such a way that the OS will treat the call target as not valid.</span></span> <span data-ttu-id="b5e03-148">Algunos escenarios que no son de producción, como con determinada instrumentación de Comprobador de aplicación habilitada en algunos sistemas operativos anteriores, pueden permitir que los destinos de llamada suprimidos se traten como válidos, pero en general estos escenarios no se espera que sean escenarios de producción.</span><span class="sxs-lookup"><span data-stu-id="b5e03-148">Some non-production scenarios, such as with certain application verifier instrumentation enabled on some older operating systems, may enable suppressed call targets to be treated as valid, but in general these scenarios are not expected to be production scenarios.</span></span> <span data-ttu-id="b5e03-149">Esta directiva es útil para anotar funciones "peligrosas" que no se deben considerar como destinos de llamada válidos, aunque la regla de CFG normal las incluiría.</span><span class="sxs-lookup"><span data-stu-id="b5e03-149">This directive is useful for annotating “dangerous” functions that should not be considered as valid call targets, even though the normal CFG rule would include them.</span></span>

- <span data-ttu-id="b5e03-150">El código puede indicar comprobaciones de CFG no deseadas con el modificador __declspec (Guard (nocf)).</span><span class="sxs-lookup"><span data-stu-id="b5e03-150">Code can indicate CFG checks are not wanted with the __declspec(guard(nocf)) modifier.</span></span> <span data-ttu-id="b5e03-151">Esto indica al compilador que no inserte ninguna comprobación de CFG para toda la función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-151">This directs the compiler to not insert any CFG checks for the entire function.</span></span> <span data-ttu-id="b5e03-152">El compilador debe tener cuidado de propagar esta directiva a cualquier código aportado por una función insertada que esté marcada como que no desea realizar comprobaciones de CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-152">The compiler should take care to propagate this directive to any code contributed by an inlined function that is marked as not wanting CFG checks.</span></span> <span data-ttu-id="b5e03-153">Este enfoque se suele usar con moderación en situaciones específicas en las que el programador ha insertado manualmente la protección "CFG-Equivalent".</span><span class="sxs-lookup"><span data-stu-id="b5e03-153">This approach is typically used only sparingly in specific situations where the programmer has manually inserted “CFG-equivalent” protection.</span></span> <span data-ttu-id="b5e03-154">El programador sabe que están llamando a través de alguna tabla de funciones de solo lectura cuya dirección se obtiene a través de las referencias de memoria de solo lectura y cuyo índice se enmascara en el límite de la tabla de funciones.</span><span class="sxs-lookup"><span data-stu-id="b5e03-154">The programmer knows that they are calling through some read only function table whose address is obtained through read only memory references and for which the index is masked to the function table limit.</span></span> <span data-ttu-id="b5e03-155">Este enfoque también se puede aplicar a las funciones de contenedor pequeñas que no están insertadas y que no hacen nada más que realizar una llamada a través de un puntero de función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-155">This approach may also be applied to small wrapper functions that are not inlined and that do nothing more than make a call through a function pointer.</span></span> <span data-ttu-id="b5e03-156">Dado que el uso incorrecto de esta Directiva puede poner en peligro la seguridad de CFG, el programador debe ser muy cuidadoso mediante la Directiva.</span><span class="sxs-lookup"><span data-stu-id="b5e03-156">Since incorrect usage of this directive can compromise the security of CFG, the programmer must be very careful using the directive.</span></span> <span data-ttu-id="b5e03-157">Normalmente, este uso está limitado a funciones muy pequeñas que solo llaman a una función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-157">Typically, this usage is limited to very small functions that only call one function.</span></span>

## <a name="import-handling"></a><span data-ttu-id="b5e03-158">Administración de importación</span><span class="sxs-lookup"><span data-stu-id="b5e03-158">Import handling</span></span>

- <span data-ttu-id="b5e03-159">Las llamadas a través de la IAT no deben usar la protección de CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-159">Calls through the IAT should not use CFG protection.</span></span> <span data-ttu-id="b5e03-160">La IAT es de solo lectura en las imágenes modernas (suponiendo que la IAT esté declarada en los encabezados de PE en cuyo caso debe estar en sus propias páginas).</span><span class="sxs-lookup"><span data-stu-id="b5e03-160">The IAT is read only in modern images (assuming that the IAT is declared in the PE headers in which case it must be on its own pages).</span></span> <span data-ttu-id="b5e03-161">La IAT se puede usar para llegar a las funciones que se han suprimido, por lo que se trata de un requisito de corrección.</span><span class="sxs-lookup"><span data-stu-id="b5e03-161">The IAT can be used to reach functions that are guard suppressed, so this is a correctness requirement.</span></span> <span data-ttu-id="b5e03-162">La protección de memoria de solo lectura a través de la IAT sustituye a la de CFG, ya que el enlace del destino de la llamada es inmutable una vez que se resuelven las instantáneas de importación de la imagen y la resolución de enlace es específica.</span><span class="sxs-lookup"><span data-stu-id="b5e03-162">Read only memory protection through the IAT supersedes that of CFG since the call target binding is immutable after the image import snaps are resolved, and the binding resolution is fine grained.</span></span>

- <span data-ttu-id="b5e03-163">Carga retrasada protegida: las llamadas a través de la IAT de carga retrasada no deben usar la protección de CFG, por las mismas razones que la IAT estándar.</span><span class="sxs-lookup"><span data-stu-id="b5e03-163">Protected delay load: Calls through the delay load IAT should not use CFG protection, for the same reasons as the standard IAT.</span></span> <span data-ttu-id="b5e03-164">La IAT de carga retrasada debe estar en su propia sección y la imagen debe establecer el IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT bit GuardFlags.</span><span class="sxs-lookup"><span data-stu-id="b5e03-164">The delay load IAT should be in its own section and the image should set the IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span></span> <span data-ttu-id="b5e03-165">Esto indica que el cargador de DLL del sistema operativo debe cambiar las protecciones de la tabla IAT de carga retrasada durante la resolución de exportación si se usa la compatibilidad de carga retrasada del sistema operativo nativa con Windows 8 y los sistemas operativos posteriores.</span><span class="sxs-lookup"><span data-stu-id="b5e03-165">This indicates that the operating system’s DLL loader should change protections for the delay load IAT during export resolution if using the operating system’s delay load support native to Windows 8 and later operating systems.</span></span> <span data-ttu-id="b5e03-166">El cargador de DLL del sistema operativo administra la sincronización de este paso si se está usando la compatibilidad con la carga retrasada del sistema operativo nativo (por ejemplo, ResolveDelayLoadedAPI), por lo que ningún otro componente debe volver a proteger las páginas que abarquen la carga de retraso declarada.</span><span class="sxs-lookup"><span data-stu-id="b5e03-166">The synchronization of this step is managed by the operating system DLL loader if native operating system delay load support is in use (e.g. ResolveDelayLoadedAPI) so no other component should reprotect the pages spanning the declared delay load IAT.</span></span> <span data-ttu-id="b5e03-167">Para mantener la compatibilidad con versiones anteriores de los sistemas operativos anteriores a la versión de CFG, las herramientas pueden habilitar la opción de pasar la tabla IAT de carga retrasada a su propia sección (canónicamente ". Didat"), protegida como de lectura/escritura en los encabezados de la imagen y establecer además la marca IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION.</span><span class="sxs-lookup"><span data-stu-id="b5e03-167">For backwards compatibility with older pre-CFG operating systems, tools may enable the option to move the delay load IAT into its own section (canonically “.didat”), protected as read/write in the image headers, and additionally set the IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION flag.</span></span> <span data-ttu-id="b5e03-168">Esta configuración hará que los cargadores de archivos DLL del sistema operativo compatible con CFG vuelvan a proteger toda la sección que contiene la tabla IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT para leer solo la memoria durante la carga de la imagen.</span><span class="sxs-lookup"><span data-stu-id="b5e03-168">This setting will cause CFG-aware operating system DLL loaders to reprotect the entire section containing the IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT table to read only memory during image loading.</span></span> <span data-ttu-id="b5e03-169">Es posible que la opción para colocar la tabla de carga retrasada en su propia sección no sea necesaria si no le importa la ejecución de una imagen en los sistemas operativos compatibles con CFG, pero las herramientas deben tomar esa decisión según la compatibilidad mínima del sistema operativo que necesita una imagen.</span><span class="sxs-lookup"><span data-stu-id="b5e03-169">The option to place the delay load IAT in its own section may not be required if you do not care about running an image on operating systems that predate CFG support, but tools should make that decision based on the minimum operating system support that an image needs.</span></span>

  <span data-ttu-id="b5e03-170">Si una imagen no utiliza la compatibilidad nativa de carga retrasada del sistema operativo, todavía puede establecer los bits de GuardFlags relacionados con la carga retrasada protegida.</span><span class="sxs-lookup"><span data-stu-id="b5e03-170">If an image does not use the operating system’s native delay load support, it can still set the protected delay load related GuardFlags bits.</span></span> <span data-ttu-id="b5e03-171">En esta configuración, el cargador del sistema operativo solo proporcionará compatibilidad para proteger la IAT de carga retrasada como de solo lectura en tiempo de ejecución si es compatible con la plataforma, y se convierte en la responsabilidad del código auxiliar de resolución de carga retrasada interna de la imagen para sincronizar y administrar la protección de la IAT de carga retrasada.</span><span class="sxs-lookup"><span data-stu-id="b5e03-171">In this configuration, the operating system loader will just provide support to protect the delay load IAT as read only at runtime if supported by the platform, and it becomes the responsibility of the image’s internal delay load resolution stubs to synchronize and manage protection of the delay load IAT.</span></span> <span data-ttu-id="b5e03-172">Siempre que la tabla de configuración de carga esté almacenada en memoria de solo lectura (lo que se recomienda), la presencia o ausencia del bit de IAT de carga retrasada protegida en el campo GuardFlags de la imagen podría ser útil como una sugerencia interna para el código auxiliar de resolución de carga retrasada interna de la imagen para indicar si debe proteger o no la tabla IAT de carga retrasada.</span><span class="sxs-lookup"><span data-stu-id="b5e03-172">Provided that the load configuration table is stored in read only memory (which is recommended), the presence or absence of the protected delay load IAT bit in the image’s GuardFlags field might be useful as an internal hint to the image’s internal delay load resolution stubs to indicate whether or not it should protect the delay load IAT.</span></span>

  <span data-ttu-id="b5e03-173">Se recomienda habilitar la carga retrasada protegida de forma predeterminada si CFG está habilitado.</span><span class="sxs-lookup"><span data-stu-id="b5e03-173">It is recommended that protected delay load be enabled by default if CFG is enabled.</span></span> <span data-ttu-id="b5e03-174">Las imágenes que se ejecutan en versiones anteriores del sistema operativo y que usan la compatibilidad con la carga de retraso nativa del sistema operativo, como se indica, pueden usar la operación de carga retrasada de IAT en su propia sección para la compatibilidad con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="b5e03-174">Images that run on older operating system versions and that use the operating system’s native delay load support, as noted, may use the delay load IAT in its own section support for backwards compatibility.</span></span> <span data-ttu-id="b5e03-175">Esto no es lo mismo que marcar la IAT de carga retrasada como de solo lectura y combinarla con otra sección, lo que se interrumpiría en los sistemas operativos más antiguos que no entienden las cargas de retraso protegidas y que proporcionan compatibilidad con la resolución de carga de retraso nativa.</span><span class="sxs-lookup"><span data-stu-id="b5e03-175">This is opposed to marking the delay load IAT as read only and merging it with another section, which would break on older operating system’s that do not understand protected delay loads and which provide native delay load resolution support.</span></span> <span data-ttu-id="b5e03-176">Todas las versiones de Windows 10 y la primera Windows 8.1/Windows Server 2012 R2 compilaciones que admiten CFG (es decir, la actualización de noviembre de 2014) incorporan compatibilidad con la carga de retraso protegida en el sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="b5e03-176">All Windows 10 releases and the first Windows 8.1/Windows Server 2012 R2 builds that supported CFG (meaning the November 2014 update) introduce support for protected delay load in the operating system.</span></span>

## <a name="function-alignment"></a><span data-ttu-id="b5e03-177">Alineación de funciones</span><span class="sxs-lookup"><span data-stu-id="b5e03-177">Function alignment</span></span>

- <span data-ttu-id="b5e03-178">Las funciones que se tratan y que, por tanto, se incluyen en la tabla **GFIDS** , se deben alinear de 16 bytes, si es posible.</span><span class="sxs-lookup"><span data-stu-id="b5e03-178">Functions that are address taken and are therefore included in the **GFIDS** table should be made 16-byte aligned, if possible.</span></span> <span data-ttu-id="b5e03-179">Esto no siempre es posible.</span><span class="sxs-lookup"><span data-stu-id="b5e03-179">This may not always be possible.</span></span> <span data-ttu-id="b5e03-180">Por ejemplo, para las funciones que no sean de COMDAT y que formen parte de los archivos objeto agrupados como una unidad por parte de las herramientas que no reconocen CFG, que pueden producir algunos ensambladores, el usuario de la herramienta que generó los archivos debe establecer la alineación adecuadamente.</span><span class="sxs-lookup"><span data-stu-id="b5e03-180">For example, for non-COMDAT functions that are a part of object files assembled together as one unit by non-CFG aware tools, which some assemblers may produce, the user of the tool that produced the files must appropriately set the alignment.</span></span> <span data-ttu-id="b5e03-181">Las herramientas pueden optar por emitir una advertencia de diagnóstico en esta situación para que el usuario pueda tomar las medidas correctivas adecuadas.</span><span class="sxs-lookup"><span data-stu-id="b5e03-181">Tools may elect to issue a diagnostic warning in this situation so that the user can take appropriate corrective action.</span></span> <span data-ttu-id="b5e03-182">La razón es que CFG marca los destinos de llamada como válidos o no válidos en límites de 16 bytes para mejorar la eficacia de las comprobaciones de CFG rápidas.</span><span class="sxs-lookup"><span data-stu-id="b5e03-182">The reason for this is that CFG marks call targets as valid or not valid on 16-byte boundaries for efficiency of fast CFG checks.</span></span> <span data-ttu-id="b5e03-183">Si una función no tiene una alineación de 16 bytes, toda la ranura de 16 bytes debe marcarse como válida, lo que no es tan seguro, ya que puede llamar a un código no alineado en el código que no está en el inicio de una función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-183">If a function is not 16-byte aligned, then the entire 16-byte slot must be marked as valid, which is not as secure since you can call misaligned into code that is not at the very start of a function.</span></span> <span data-ttu-id="b5e03-184">Este escenario se admite para facilitar la interoperabilidad al traer primero el CFG para un proyecto.</span><span class="sxs-lookup"><span data-stu-id="b5e03-184">This scenario is supported for ease of interoperability when first bringing CFG up for a project.</span></span> <span data-ttu-id="b5e03-185">Las imágenes que no reconocen la CFG se marcan de forma similar como válidas para cualquier alineación de destino de llamada por compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="b5e03-185">Non-CFG aware images are similarly marked as valid for any call target alignment for compatibility.</span></span> <span data-ttu-id="b5e03-186">Como antes, tener destinos de llamada desalineados reduce las ventajas de seguridad de CFG, por lo que las herramientas deben alinearse automáticamente a un límite de 16 bytes para cualquier elemento de la tabla **GFIDS** cuando se desea usar cfg para una imagen.</span><span class="sxs-lookup"><span data-stu-id="b5e03-186">As before, having misaligned call targets reduces the security benefits of CFG, so tools should automatically align to a 16-byte boundary for anything in the **GFIDS** table when CFG is desired for an image.</span></span> <span data-ttu-id="b5e03-187">No es necesario que los símbolos que no están en la tabla **GFIDS** tengan alineaciones concretas para cfg.</span><span class="sxs-lookup"><span data-stu-id="b5e03-187">Symbols that are not in the **GFIDS** table do not need to have particular alignments for CFG.</span></span>

## <a name="export-suppression"></a><span data-ttu-id="b5e03-188">Supresión de exportación</span><span class="sxs-lookup"><span data-stu-id="b5e03-188">Export suppression</span></span>

- <span data-ttu-id="b5e03-189">La supresión de exportación de CFG (CFG es) es un modo opcional que permite a un proceso indicar que los destinos de llamada que solo eran válidos porque eran símbolos dllexport y que todavía no han sido resueltos dinámicamente por GetProcAddress, se considerarán como no válidos para los fines de CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-189">CFG export suppression (CFG ES) is an optional mode that enables a process to indicate that call targets which were only valid because they were dllexport symbols, and which have not yet been dynamically resolved by GetProcAddress, will be considered as not valid for purposes of CFG.</span></span> <span data-ttu-id="b5e03-190">Esto reduce el área expuesta de CFG de las exportaciones de DLL del sistema.</span><span class="sxs-lookup"><span data-stu-id="b5e03-190">This reduces the surface area of CFG from system DLL exports.</span></span> <span data-ttu-id="b5e03-191">La supresión de la exportación implica la comunicación de los destinos de llamada dllexport "Export suprimed" mediante su marcación con los IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED marcas **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-191">Export suppression involves communicating eligible “export suppressed” dllexport call targets by marking them with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flags.</span></span> <span data-ttu-id="b5e03-192">Los símbolos dllexport y el punto de entrada de imagen de PE deben considerarse implícitamente una dirección tomada por las herramientas con el fin de generar la tabla **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-192">Dllexport symbols and the PE image entry point should be implicitly considered address taken by tools for purposes of generating the **GFIDS** table.</span></span>  <span data-ttu-id="b5e03-193">Si un símbolo de exportación tiene una alineación de 16 bytes y se trata de una dirección que no es una forma de dllexport, se puede marcar con la marca Export suprimed **GFIDS** en la tabla de la función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-193">If an export symbol is 16-byte aligned and it is address taken for no other reason than being a dllexport, then it can be marked with the export suppressed **GFIDS** flag in the function table.</span></span> <span data-ttu-id="b5e03-194">Los destinos de llamada que no tienen alineación de 16 bytes **no se deben** marcar con la marca IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** y no se pueden restringir para que solo se habiliten dinámicamente como destinos de llamada válidos en el tiempo de GetProcAddress.</span><span class="sxs-lookup"><span data-stu-id="b5e03-194">Call targets that are not 16-byte aligned **must not** be marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag and cannot be restricted to only being dynamically enabled as valid call targets at GetProcAddress time.</span></span>

  <span data-ttu-id="b5e03-195">Una imagen que admite CFG ES incluye un GuardAddressTakenIatEntryTable cuyo recuento lo proporciona GuardAddressTakenIatEntryCount como parte de su directorio de configuración de carga.</span><span class="sxs-lookup"><span data-stu-id="b5e03-195">An image that supports CFG ES includes a GuardAddressTakenIatEntryTable whose count is provided by the GuardAddressTakenIatEntryCount as part of its load configuration directory.</span></span> <span data-ttu-id="b5e03-196">Esta tabla tiene el mismo formato que la tabla **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-196">This table is structurally formatted the same as the **GFIDS** table.</span></span> <span data-ttu-id="b5e03-197">Usa el mismo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK de GuardFlags para codificar bytes de metadatos opcionales adicionales en la tabla de IAT de dirección tomada, aunque todos los bytes de metadatos deben ser cero para la tabla de IAT de dirección tomada y están reservadas.</span><span class="sxs-lookup"><span data-stu-id="b5e03-197">It uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode extra optional metadata bytes in the address taken IAT table, though all metadata bytes must be zero for the address taken IAT table and are reserved.</span></span> <span data-ttu-id="b5e03-198">La tabla de IAT de dirección tomada indica una matriz ordenada de RVA de los códigos thunk de importación que tienen el importado como una dirección de símbolo tomada como destino de la llamada.</span><span class="sxs-lookup"><span data-stu-id="b5e03-198">The address taken IAT table indicates a sorted array of RVAs of import thunks which have the imported as a symbol address taken call target.</span></span> <span data-ttu-id="b5e03-199">Esta construcción admite símbolos de dirección que se encuentran en un módulo remoto y que son dllexports, con CFG ES en uso.</span><span class="sxs-lookup"><span data-stu-id="b5e03-199">This construct supports address taken symbols that exist in a remote module, and which are dllexports, with CFG ES in use.</span></span> <span data-ttu-id="b5e03-200">Un ejemplo de este tipo de código sería:</span><span class="sxs-lookup"><span data-stu-id="b5e03-200">An example of such a code construct would be:</span></span>

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  <span data-ttu-id="b5e03-201">Todos estos códigos thunk de importación se deben enumerar para que el cargador del sistema operativo pueda encontrarlos y hacer que los destinos de llamada adecuados sean válidos al cargar una imagen y ajustar sus importaciones.</span><span class="sxs-lookup"><span data-stu-id="b5e03-201">All such address taken import thunks must be enumerated so that the operating system loader can find them and make the appropriate call targets valid when loading an image and snapping its imports.</span></span> <span data-ttu-id="b5e03-202">La tabla y el recuento pueden ser 0 si no hay ningún thunk de importación que se haya solucionado.</span><span class="sxs-lookup"><span data-stu-id="b5e03-202">The table and count can be 0 if there are no import thunks that were address taken.</span></span>

  <span data-ttu-id="b5e03-203">Un módulo establece el IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT bit GuardFlags para indicar que ha enumerado todas las direcciones que se han tomado en la tabla IAT de su dirección y que todas las exportaciones que son válidas para CFG se marcan con la marca IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-203">A module sets the IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags bit to indicate that it has enumerated all address taken thunks in its address taken IAT table and that all exports that are CFG ES eligible are marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag.</span></span> <span data-ttu-id="b5e03-204">Tenga en cuenta que puede haber cero tales thunks y que también puede haber cero símbolos dllexport.</span><span class="sxs-lookup"><span data-stu-id="b5e03-204">Note that there may be zero such thunks and that there may also be zero such dllexport symbols.</span></span> <span data-ttu-id="b5e03-205">Un error al mantener la tabla IAT tomada puede ser un problema de corrección, ya que es posible que algunos destinos de llamada no sean válidos cuando deberían estar en el momento de la carga del archivo DLL.</span><span class="sxs-lookup"><span data-stu-id="b5e03-205">Failure to maintain the address taken IAT table can be a correctness issue as some call targets might not be made valid when they should be at DLL load time.</span></span>

  <span data-ttu-id="b5e03-206">Un módulo establece el IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION bit GuardFlags para indicar que desea habilitar CFG ES para el proceso.</span><span class="sxs-lookup"><span data-stu-id="b5e03-206">A module sets the IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags bit to indicate that it wants to enable CFG ES for the process.</span></span> <span data-ttu-id="b5e03-207">En la práctica, esto solo es significativo para los archivos exe de hoy en día.</span><span class="sxs-lookup"><span data-stu-id="b5e03-207">In practice, this is only meaningful for EXEs today.</span></span> <span data-ttu-id="b5e03-208">Un proceso que habilita CFG ES no debe cargar las dll no creadas con CFG ES o se pueden producir errores en tiempo de ejecución debido a que la dirección no designada tomó símbolos IAT.</span><span class="sxs-lookup"><span data-stu-id="b5e03-208">A process enabling CFG ES should not load DLLs not built with CFG ES or runtime failures may occur because of undesignated address taken IAT symbols.</span></span> <span data-ttu-id="b5e03-209">La compatibilidad con la habilitación de CFG ES una opción opcional independiente de la habilitación de CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-209">Support for enabling CFG ES should be a separate opt-in option from enabling CFG.</span></span> <span data-ttu-id="b5e03-210">Proporcionar metadatos de CFG es seguro y recomendado de forma predeterminada con CFG, aunque los conjuntos de herramientas deben tener cuidado para asegurarse de que generan los metadatos correctos.</span><span class="sxs-lookup"><span data-stu-id="b5e03-210">Providing CFG ES metadata is safe and recommended by default with CFG, though toolsets must take care to ensure they produce correct metadata.</span></span> <span data-ttu-id="b5e03-211">Si no es así, es posible que las imágenes generadas no se ejecuten correctamente en un proceso de CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-211">If not, their generated images may not run properly in a CFG ES process.</span></span> <span data-ttu-id="b5e03-212">Esta compatibilidad se debe probar exhaustivamente en un proceso de prueba que aplique CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-212">Such support should be thoroughly tested in a test process that enforces CFG ES.</span></span> <span data-ttu-id="b5e03-213">Los archivos DLL del sistema integrados del sistema operativo admiten los metadatos de CFG ES para las versiones modernas del sistema operativo Windows 10 que comprenden CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-213">The operating system built-in system DLLs support CFG ES metadata for modern Windows 10 operating system versions that understand CFG ES.</span></span> <span data-ttu-id="b5e03-214">Las versiones de sistema operativo anteriores a esta compatibilidad no comprenden CFG s y omitirán cualquier directiva de CFG ES relacionada con la imagen.</span><span class="sxs-lookup"><span data-stu-id="b5e03-214">Operating system versions prior to this support do not understand CFG ES at all and will ignore any CFG ES related directives in the image.</span></span> <span data-ttu-id="b5e03-215">Estas imágenes siguen siendo compatibles con las versiones anteriores del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="b5e03-215">Such images are still backwards compatible to older operating system versions.</span></span>

  <span data-ttu-id="b5e03-216">La compatibilidad de CFG es opcional desde el punto de vista del conjunto de herramientas, pero se recomienda que los conjuntos de herramientas incluyan al menos compatibilidad para enumerar la información suficiente para que las imágenes se ejecuten en un proceso que quiere CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-216">CFG ES support is optional from a toolset perspective, but it is recommended that toolsets at least include support to enumerate enough information for images to run in a process that desires CFG ES.</span></span> <span data-ttu-id="b5e03-217">Como se mencionó, es fundamental que la compatibilidad con el conjunto de herramientas se pruebe minuciosamente para asegurarse de que es compatible con CFG ES, ya que la mayoría de los procesos aún no habilitan CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-217">As mentioned, it is critical that toolset support be thoroughly tested to ensure that it is compatible with CFG ES, as most processes don’t yet enable CFG ES.</span></span>

## <a name="exception-handling-and-unwinding"></a><span data-ttu-id="b5e03-218">Control de excepciones y desenredo</span><span class="sxs-lookup"><span data-stu-id="b5e03-218">Exception handling and unwinding</span></span>

- <span data-ttu-id="b5e03-219">Los controladores específicos del lenguaje como __C_specific_handler, como se indica en la información del controlador de excepciones en un registro. pdata, no deben marcarse como destinos de llamada válidos en la tabla **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-219">Language specific handlers like __C_specific_handler, as designated by the exception handler information in a .pdata registration, should not be marked as valid call targets in the **GFIDS** table.</span></span> <span data-ttu-id="b5e03-220">En su lugar, se buscan al atravesar la memoria de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="b5e03-220">They are instead looked up by traversing read only memory.</span></span> <span data-ttu-id="b5e03-221">Del mismo modo, el controlador específico del lenguaje C de Microsoft usa búsquedas de memoria de solo lectura para buscar funclets para los controladores de excepciones y, por lo tanto, no declara su funclets como destinos de llamada válidos en la tabla **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="b5e03-221">Similarly, the Microsoft C language specific handler uses read only memory searches to locate funclets for exception handlers and thus does not declare its funclets as valid call targets in the **GFIDS** table.</span></span>

- <span data-ttu-id="b5e03-222">Administración de saltos largos (para destinos que no son x86, como AMD64): los conjuntos de herramientas que se compilan con CFG y que admiten setjmp ()/longjmp () deben implementar el salto largo como "salto de larga seguridad" que interopera con el control de excepciones estructurado (SEH).</span><span class="sxs-lookup"><span data-stu-id="b5e03-222">Long jump handling (for non-x86 targets like AMD64):  Toolsets compiling with CFG and supporting setjmp()/longjmp() should implement long jump as “safe long jump” that interoperates with structured exception handling (SEH).</span></span> <span data-ttu-id="b5e03-223">Esto significa que el salto largo se implementa como una llamada a RtlUnwindEx con STATUS_LONGJUMP como el código de estado en el registro de la excepción proporcionada y un _JUMP_BUFFER estándar al que apunta ExceptionInformation [0].</span><span class="sxs-lookup"><span data-stu-id="b5e03-223">This means long jump is implemented as a call to RtlUnwindEx with STATUS_LONGJUMP as the status code in the supplied exception record and a standard _JUMP_BUFFER pointed to by ExceptionInformation[0].</span></span> <span data-ttu-id="b5e03-224">El destino de desenredado de salto debe ser el TargetIp del desenredado.</span><span class="sxs-lookup"><span data-stu-id="b5e03-224">The jump unwind target should be the TargetIp of the unwind.</span></span> <span data-ttu-id="b5e03-225">El búfer de salto representa el contexto de registro restaurado por el sistema operativo después de que se haya completado el salto largo.</span><span class="sxs-lookup"><span data-stu-id="b5e03-225">The jump buffer represents the register context that is restored by the operating system after the long jump has completed.</span></span> <span data-ttu-id="b5e03-226">RtlUnwind (ex) cuando se llama con STATUS_LONGJUMP tiene una importancia especial exclusiva para CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-226">RtlUnwind(Ex) when called with STATUS_LONGJUMP has special significance unique to CFG.</span></span> <span data-ttu-id="b5e03-227">Destino de salto largo (_JUMP_BUFFER. RIP o _JUMP_BUFFER. LR en ARM64) se busca en la lista de módulos cargados que mantiene el sistema operativo en la memoria de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="b5e03-227">The long jump target (_JUMP_BUFFER.Rip or _JUMP_BUFFER.Lr on ARM64) is looked up in the loaded module list maintained by the operating system in read only memory.</span></span> <span data-ttu-id="b5e03-228">Si el módulo contenedor del destino de salto (el "módulo de destino") tiene la marca IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT establecida en el campo GuardFlags, el directorio de configuración de carga tiene una GuardLongJumpTargetTable whith un recuento de elementos especificado por el campo GuardLongJumpTargetCount de configuración de carga.</span><span class="sxs-lookup"><span data-stu-id="b5e03-228">If the containing module for the jump target (the “target module”) has the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag set in its GuardFlags field, then the load configuration directory has a GuardLongJumpTargetTable whith an element count specified by the load configuration GuardLongJumpTargetCount field.</span></span> <span data-ttu-id="b5e03-229">Esta tabla tiene el mismo formato que la tabla **GFIDS** y usa el mismo mecanismo de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags para codificar bytes de metadatos adicionales opcionales en la tabla de saltos largos.</span><span class="sxs-lookup"><span data-stu-id="b5e03-229">This table is structurally formatted the same as the **GFIDS** table and uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode optional extra metadata bytes in the long jump table.</span></span> <span data-ttu-id="b5e03-230">Todos los bytes de metadatos deben ser cero para la tabla de saltos largos y están reservados.</span><span class="sxs-lookup"><span data-stu-id="b5e03-230">All metadata bytes must be zero for the long jump table and are reserved.</span></span>

  <span data-ttu-id="b5e03-231">La tabla de saltos largos representa una matriz ordenada de RVA que son destinos de salto largo válidos.</span><span class="sxs-lookup"><span data-stu-id="b5e03-231">The long jump table represents a sorted array of RVAs that are valid long jump targets.</span></span> <span data-ttu-id="b5e03-232">Si un módulo de destino de salto largo establece IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT en su campo GuardFlags, todos los destinos de salto largos deben enumerarse en el LongJumpTargetTable.</span><span class="sxs-lookup"><span data-stu-id="b5e03-232">If a long jump target module sets IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT in its GuardFlags field, then all long jump targets must be enumerated in the LongJumpTargetTable.</span></span> <span data-ttu-id="b5e03-233">Incluso si un módulo tiene destinos de saltos largos, debe establecer la marca de IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT si el conjunto de herramientas admite la protección de saltos larga para CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-233">Even if a module has zero long jump targets, it should still set the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag if the toolset supports long jump hardening for CFG.</span></span> <span data-ttu-id="b5e03-234">Esto significa explícitamente que la imagen no tiene destinos de saltos largos y no es una imagen antigua que el sistema operativo debe asumir que podría tener destinos de salto largo válidos en ubicaciones no marcadas para las que no se puede realizar la comprobación de destino prolongado.</span><span class="sxs-lookup"><span data-stu-id="b5e03-234">This explicitly means that the image has no long jump targets and is not an old image that the operating system must assume could have valid long jump targets at unmarked locations for which it cannot perform long jump target checking.</span></span>

  <span data-ttu-id="b5e03-235">Se recomienda habilitar la protección de saltos larga de forma predeterminada si se admite CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-235">Long jump hardening is recommended to be enabled by default if CFG is supported.</span></span> <span data-ttu-id="b5e03-236">Esta es la disposición de los compiladores de Microsoft.</span><span class="sxs-lookup"><span data-stu-id="b5e03-236">This is the disposition of Microsoft compilers.</span></span> <span data-ttu-id="b5e03-237">Los sistemas operativos que no entienden la protección de saltos largos (versiones anteriores a Windows 10 o versiones anteriores de Windows 10) no realizarán comprobaciones de protección prolongada y omitirán los metadatos de protección prolongada, por lo que la protección prolongada es compatible con las versiones anteriores del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="b5e03-237">Operating systems that do not understand long jump hardening (pre-Windows 10 or older Windows 10 versions) will not perform long jump hardening checks and ignore any long jump hardening metadata, so long jump hardening is backwards compatible with older operating system releases.</span></span>

  <span data-ttu-id="b5e03-238">En el caso de las imágenes de modo kernel, la tabla de destino de salto largo de protección no debe incluirse en una sección descartable.</span><span class="sxs-lookup"><span data-stu-id="b5e03-238">For kernel mode images, the guard long jump target table should not be included in a discardable section.</span></span> <span data-ttu-id="b5e03-239">La tabla de destino de salto largo de protección debe almacenarse siempre en memoria de solo lectura para que sus propiedades de seguridad sean eficaces.</span><span class="sxs-lookup"><span data-stu-id="b5e03-239">The guard long jump target table should always be stored in read only memory for its security properties to be effective.</span></span>

## <a name="coff-information"></a><span data-ttu-id="b5e03-240">Información COFF</span><span class="sxs-lookup"><span data-stu-id="b5e03-240">COFF information</span></span>

- <span data-ttu-id="b5e03-241">Hay marcas de archivo de objeto para declarar si un archivo objeto se ajusta a CFG o no.</span><span class="sxs-lookup"><span data-stu-id="b5e03-241">There are object file markings to declare whether an object file conforms to CFG or not.</span></span> <span data-ttu-id="b5e03-242">Un archivo objeto que se ajuste a CFG mostrará los destinos de llamada válidos que genera, explícitamente, así como cualquier dirección tomada metadatos de IAT.</span><span class="sxs-lookup"><span data-stu-id="b5e03-242">An object file that conforms to CFG will list the valid call targets that it produces, explicitly, as well as any address taken IAT metadata.</span></span> <span data-ttu-id="b5e03-243">Un archivo objeto que no se ajusta a CFG debe tener destinos de llamada inferidos mediante el examen de las reubicaciones COFF del archivo OBJ para buscar las reubicaciones que apuntan al inicio de un símbolo de función.</span><span class="sxs-lookup"><span data-stu-id="b5e03-243">An object file that does not conform to CFG must have call targets inferred by examining the COFF relocations of the obj file to find relocations that point to the start of a function symbol.</span></span> <span data-ttu-id="b5e03-244">Esto puede sobreaproximar los destinos de llamada CFG válidos, por lo que es conveniente que las herramientas marquen los archivos obj que son compatibles con CFG e incluyen los metadatos del archivo OBJ de CFG si se compilan con CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-244">This may overapproximate valid CFG call targets so it is desirable that tools mark their obj files that are CFG-aware and include the CFG obj file metadata if compiling with CFG.</span></span>

- <span data-ttu-id="b5e03-245">Hay marcas de archivo de objeto para declarar destinos de saltos largos para el salto largo de CFG que se debe rellenar para el modo de compilación de CFG.</span><span class="sxs-lookup"><span data-stu-id="b5e03-245">There are object file markings to declare long jump targets for CFG hardened long jump which should be populated for CFG compilation mode.</span></span>
