---
title: Latencia y rendimiento de la red
description: Latencia y rendimiento de red con llamada a procedimiento remoto (RPC).
ms.assetid: 8285fd73-eb54-4c06-b01a-1bffafb7e675
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c5c51c4db75b904ac5feae8c4a1cc5965fc2b06e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "104269262"
---
# <a name="network-latency-and-throughput"></a><span data-ttu-id="c00ed-103">Latencia y rendimiento de la red</span><span class="sxs-lookup"><span data-stu-id="c00ed-103">Network Latency and Throughput</span></span>

<span data-ttu-id="c00ed-104">Tres problemas principales se refieren al uso óptimo de la red:</span><span class="sxs-lookup"><span data-stu-id="c00ed-104">Three major issues relate to optimal use of the network:</span></span>

-   <span data-ttu-id="c00ed-105">Latencia de red</span><span class="sxs-lookup"><span data-stu-id="c00ed-105">Network latency</span></span>
-   <span data-ttu-id="c00ed-106">Saturación de red</span><span class="sxs-lookup"><span data-stu-id="c00ed-106">Network saturation</span></span>
-   <span data-ttu-id="c00ed-107">Implicaciones en el procesamiento de paquetes</span><span class="sxs-lookup"><span data-stu-id="c00ed-107">Packet processing implications</span></span>

<span data-ttu-id="c00ed-108">En esta sección se presenta una tarea de programación que requiere el uso de RPC y, a continuación, se diseñan dos soluciones: una mal escrita y una escrita correctamente.</span><span class="sxs-lookup"><span data-stu-id="c00ed-108">This section introduces a programming task requiring use of RPC, then designs two solutions: one poorly written and one well written.</span></span> <span data-ttu-id="c00ed-109">A continuación, se analizan ambas soluciones y se describe su efecto en el rendimiento de la red.</span><span class="sxs-lookup"><span data-stu-id="c00ed-109">Both solutions are then scrutinized, and their affect on network performance is discussed.</span></span>

<span data-ttu-id="c00ed-110">Antes de hablar de las dos soluciones, en las próximas secciones se describen y aclaran los problemas de rendimiento relacionados con la red.</span><span class="sxs-lookup"><span data-stu-id="c00ed-110">Before discussing the two solutions, the next few sections discuss and clarify network related performance issues.</span></span>

## <a name="network-latency"></a><span data-ttu-id="c00ed-111">Latencia de red</span><span class="sxs-lookup"><span data-stu-id="c00ed-111">Network Latency</span></span>

<span data-ttu-id="c00ed-112">El ancho de banda de red y la latencia de red son términos independientes.</span><span class="sxs-lookup"><span data-stu-id="c00ed-112">Network bandwidth and network latency are separate terms.</span></span> <span data-ttu-id="c00ed-113">Las redes con ancho de banda alto no garantizan una latencia baja.</span><span class="sxs-lookup"><span data-stu-id="c00ed-113">Networks with high bandwidth do not guarantee low latency.</span></span> <span data-ttu-id="c00ed-114">Por ejemplo, una ruta de acceso de red que atraviesa un vínculo satélite suele tener una latencia elevada, aunque el rendimiento sea muy alto.</span><span class="sxs-lookup"><span data-stu-id="c00ed-114">For example, a network path traversing a satellite link often has high latency, even though throughput is very high.</span></span> <span data-ttu-id="c00ed-115">No es raro que un recorrido de ida y vuelta de red que atraviesa un vínculo satélite tenga cinco o más segundos de latencia.</span><span class="sxs-lookup"><span data-stu-id="c00ed-115">It is not uncommon for a network round trip traversing a satellite link to have five or more seconds of latency.</span></span> <span data-ttu-id="c00ed-116">La implicación de este retraso es: una aplicación diseñada para enviar una solicitud, esperar una respuesta, enviar otra solicitud, esperar otra respuesta, etc., esperará al menos cinco segundos para cada intercambio de paquetes, independientemente de la velocidad del servidor.</span><span class="sxs-lookup"><span data-stu-id="c00ed-116">The implication of such a delay is this: an application designed to send a request, wait for a reply, send another request, wait for another reply, and so on, will wait at least five seconds for each packet exchange, regardless of how fast the server is.</span></span> <span data-ttu-id="c00ed-117">A pesar del aumento de la velocidad de los equipos, las transmisiones de satélite y los medios de red se basan en la velocidad de la luz, que normalmente permanece constante.</span><span class="sxs-lookup"><span data-stu-id="c00ed-117">Despite the increasing speed of computers, satellite transmissions and network media are based on the speed of light, which generally stays constant.</span></span> <span data-ttu-id="c00ed-118">Como tal, es poco probable que se produzcan mejoras en la latencia de las redes satélite existentes.</span><span class="sxs-lookup"><span data-stu-id="c00ed-118">As such, improvements in latency for existing satellite networks is unlikely to occur.</span></span>

## <a name="network-saturation"></a><span data-ttu-id="c00ed-119">Saturación de red</span><span class="sxs-lookup"><span data-stu-id="c00ed-119">Network Saturation</span></span>

<span data-ttu-id="c00ed-120">En muchas redes se produce alguna saturación.</span><span class="sxs-lookup"><span data-stu-id="c00ed-120">Some saturation occurs in many networks.</span></span> <span data-ttu-id="c00ed-121">Las redes más fáciles de saturar son vínculos de módem lentos, como los módems analógicos estándar 56K.</span><span class="sxs-lookup"><span data-stu-id="c00ed-121">The easiest networks to saturate are slow modem links, such as standard 56k analog modems.</span></span> <span data-ttu-id="c00ed-122">Sin embargo, también se pueden saturar los vínculos Ethernet con muchos equipos en un único segmento.</span><span class="sxs-lookup"><span data-stu-id="c00ed-122">However, Ethernet links with many computers on a single segment can also become saturated.</span></span> <span data-ttu-id="c00ed-123">Lo mismo se aplica a las redes de área extensa con un vínculo de bajo ancho de banda o sobrecargado, como un enrutador o conmutador que puede controlar una cantidad limitada de tráfico.</span><span class="sxs-lookup"><span data-stu-id="c00ed-123">The same is true about wide area networks with a low-bandwidth or otherwise overburdened link, such as a router or switch that can handle a limited amount of traffic.</span></span> <span data-ttu-id="c00ed-124">En estos casos, si la red envía más paquetes de los que puede controlar su vínculo más débil, quita los paquetes.</span><span class="sxs-lookup"><span data-stu-id="c00ed-124">In such these cases, if the network sends more packets than its weakest link can handle, it drops packets.</span></span> <span data-ttu-id="c00ed-125">Para evitar congestiones, la pila TCP de Windows se escala de nuevo cuando se detectan paquetes que pueden producir retrasos significativos.</span><span class="sxs-lookup"><span data-stu-id="c00ed-125">To avoid congestion the Windows TCP stack scales back when dropped packets are detected which can result in significant delays.</span></span>

## <a name="packet-processing-implications"></a><span data-ttu-id="c00ed-126">Implicaciones en el procesamiento de paquetes</span><span class="sxs-lookup"><span data-stu-id="c00ed-126">Packet Processing Implications</span></span>

<span data-ttu-id="c00ed-127">Cuando se desarrollan programas para entornos de nivel superior como RPC, COM e incluso Windows Sockets, los desarrolladores suelen olvidar la cantidad de trabajo que tiene lugar en segundo plano para cada paquete enviado o recibido.</span><span class="sxs-lookup"><span data-stu-id="c00ed-127">When programs are developed for higher level environments like RPC, COM, and even Windows Sockets, developers tend to forget how much work takes place behind the scenes for each sent or received packet.</span></span> <span data-ttu-id="c00ed-128">Cuando llega un paquete desde la red, el equipo presta una interrupción de la tarjeta de red.</span><span class="sxs-lookup"><span data-stu-id="c00ed-128">When a packet arrives from the network, an interrupt from the network card is serviced by the computer.</span></span> <span data-ttu-id="c00ed-129">Después, una llamada a procedimiento diferida (DPC) se pone en cola y debe hacerlo a través de los controladores.</span><span class="sxs-lookup"><span data-stu-id="c00ed-129">Then a Deferred Procedure Call (DPC) is queued, and must make its way through the drivers.</span></span> <span data-ttu-id="c00ed-130">Si se utiliza cualquier forma de seguridad, es posible que el paquete tenga que descifrarse o que se haya comprobado el hash criptográfico.</span><span class="sxs-lookup"><span data-stu-id="c00ed-130">If any form of security is used, the packet may have to be decrypted, or the cryptographic hash verified.</span></span> <span data-ttu-id="c00ed-131">También se debe realizar una serie de comprobaciones de validez en cada Estado.</span><span class="sxs-lookup"><span data-stu-id="c00ed-131">A number of validity checks must also be performed at each state.</span></span> <span data-ttu-id="c00ed-132">Solo entonces el paquete llega al destino final: el código del servidor.</span><span class="sxs-lookup"><span data-stu-id="c00ed-132">Only then does the packet arrive at the final destination: the server code.</span></span> <span data-ttu-id="c00ed-133">El envío de muchos fragmentos pequeños de datos produce una sobrecarga de procesamiento de paquetes para cada pequeño fragmento de datos.</span><span class="sxs-lookup"><span data-stu-id="c00ed-133">Sending many small chunks of data results in packet processing overhead for each small chunk of data.</span></span> <span data-ttu-id="c00ed-134">El envío de un gran fragmento de datos tiende a consumir un tiempo de CPU significativamente menor en todo el sistema, aunque el costo de ejecución de muchos fragmentos pequeños en comparación con un fragmento grande puede ser el mismo para la aplicación de servidor.</span><span class="sxs-lookup"><span data-stu-id="c00ed-134">Sending one big chunk of data tends to consume significantly less CPU time throughout the system, even though the cost of execution for many small chunks compared to one large chunk may be the same for the server application.</span></span>

## <a name="example-1-a-poorly-designed-rpc-server"></a><span data-ttu-id="c00ed-135">Ejemplo 1: un servidor RPC mal diseñado</span><span class="sxs-lookup"><span data-stu-id="c00ed-135">Example 1: A Poorly Designed RPC Server</span></span>

<span data-ttu-id="c00ed-136">Imagine una aplicación que debe tener acceso a archivos remotos y que la tarea a mano es diseñar una interfaz RPC para manipular el archivo remoto.</span><span class="sxs-lookup"><span data-stu-id="c00ed-136">Imagine an application that must access remote files, and the task at hand is to design an RPC interface for manipulating the remote file.</span></span> <span data-ttu-id="c00ed-137">La solución más sencilla consiste en reflejar las rutinas de archivo de Studio para archivos locales.</span><span class="sxs-lookup"><span data-stu-id="c00ed-137">The simplest solution is to mirror the studio file routines for local files.</span></span> <span data-ttu-id="c00ed-138">Si lo hace, puede producirse una interfaz limpia y familiar de forma engañosa.</span><span class="sxs-lookup"><span data-stu-id="c00ed-138">Doing so may result in a deceptively clean and familiar interface.</span></span> <span data-ttu-id="c00ed-139">Este es un archivo. idl abreviado:</span><span class="sxs-lookup"><span data-stu-id="c00ed-139">Here is an abbreviated .idl file:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
... .
interface remote_file
{
    remote_file remote_fopen(file_name);
    void remote_fclose(remote_file ...);
    size_t remote_fread(void *, size_t, size_t, remote_file ...);
    size_t remote_fwrite(const void *, size_t, size_t, remote_file ...);
    size_t remote_fseek(remote_file ..., long, int);
}
```

<span data-ttu-id="c00ed-140">Parece bastante elegante, pero en realidad, se trata de una receta respetada en el tiempo para el desastre en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="c00ed-140">This seems elegant enough, but actually, this is a time-honored recipe for performance disaster.</span></span> <span data-ttu-id="c00ed-141">Al contrario que la opinión popular, la llamada a procedimiento remoto no es simplemente una llamada a procedimiento local con una conexión entre el llamador y el destinatario.</span><span class="sxs-lookup"><span data-stu-id="c00ed-141">Contrary to popular opinion, remote procedure call is not simply a local procedure call with a wire between the caller and callee.</span></span>

<span data-ttu-id="c00ed-142">Para ver cómo se comporta el rendimiento de esta receta, considere la posibilidad de usar un archivo de 2 k, donde 20 bytes se leen desde el principio y, después, 20 bytes desde el final, y vea cómo funciona esto.</span><span class="sxs-lookup"><span data-stu-id="c00ed-142">To see how this recipe burns performance, consider a 2K file, where 20 bytes are read from the beginning, and then 20 bytes from the end, and see how this performs.</span></span> <span data-ttu-id="c00ed-143">En el lado del cliente, se realizan las siguientes llamadas (muchas rutas de acceso de código se omiten por motivos de brevedad):</span><span class="sxs-lookup"><span data-stu-id="c00ed-143">On the client side, the following calls are made (many code paths are omitted for brevity):</span></span>

``` syntax
rfp = remote_fopen("c:\\sample.txt");
remote_read(...);
remote_fseek(...);
remote_read(...);
remote_fclose(rfp);
```

<span data-ttu-id="c00ed-144">Ahora Imagine que el servidor está separado del cliente por un vínculo satélite con un tiempo de ida y vuelta de cinco segundos.</span><span class="sxs-lookup"><span data-stu-id="c00ed-144">Now imagine that the server is separated from the client by a satellite link with a five-second round-trip time.</span></span> <span data-ttu-id="c00ed-145">Cada una de esas llamadas debe esperar una respuesta para poder continuar, lo que significa un mínimo absoluto para ejecutar esta secuencia de 25 segundos.</span><span class="sxs-lookup"><span data-stu-id="c00ed-145">Each of those calls must wait for a response before it can proceed, which means an absolute minimum for executing this sequence of 25 seconds.</span></span> <span data-ttu-id="c00ed-146">Teniendo en cuenta que solo se están recuperando 40 bytes, se trata de un rendimiento outrageously lento.</span><span class="sxs-lookup"><span data-stu-id="c00ed-146">Considering we are retrieving only 40 bytes, this is outrageously slow performance.</span></span> <span data-ttu-id="c00ed-147">Los clientes de esta aplicación serían Furious.</span><span class="sxs-lookup"><span data-stu-id="c00ed-147">Customers of this application would be furious.</span></span>

<span data-ttu-id="c00ed-148">Ahora Imagine que la red está saturada, porque la capacidad de un enrutador en algún lugar de la ruta de acceso de red es sobrecargada.</span><span class="sxs-lookup"><span data-stu-id="c00ed-148">Now imagine the network is saturated, because a router's capacity somewhere in the network path is overburdened.</span></span> <span data-ttu-id="c00ed-149">Este diseño obliga al enrutador a administrar al menos 10 paquetes si no tenemos seguridad (una para cada solicitud y otra para cada respuesta).</span><span class="sxs-lookup"><span data-stu-id="c00ed-149">This design forces the router to handle at least 10 packets if we do not have security (one for each request, and one for each reply).</span></span> <span data-ttu-id="c00ed-150">Eso también no es bueno.</span><span class="sxs-lookup"><span data-stu-id="c00ed-150">That, too, is not good.</span></span>

<span data-ttu-id="c00ed-151">Este diseño también obliga al servidor a recibir cinco paquetes y enviar cinco paquetes.</span><span class="sxs-lookup"><span data-stu-id="c00ed-151">This design also forces the server to receive five packets and send five packets.</span></span> <span data-ttu-id="c00ed-152">De nuevo, no es una implementación muy buena.</span><span class="sxs-lookup"><span data-stu-id="c00ed-152">Again, not a very good implementation.</span></span>

## <a name="example-2-a-better-designed-rpc-server"></a><span data-ttu-id="c00ed-153">Ejemplo 2: un servidor RPC mejor diseñado</span><span class="sxs-lookup"><span data-stu-id="c00ed-153">Example 2: A Better Designed RPC Server</span></span>

<span data-ttu-id="c00ed-154">Vamos a rediseñar la interfaz descrita en el ejemplo 1 y ver si podemos mejorarla.</span><span class="sxs-lookup"><span data-stu-id="c00ed-154">Let's redesign the interface discussed in Example 1, and see whether we can make it better.</span></span> <span data-ttu-id="c00ed-155">Es importante tener en cuenta que el hecho de que este servidor sea realmente bueno requiere conocer el patrón de uso de los archivos especificados: este tipo de conocimiento no se presupone en este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="c00ed-155">It is important to note that making this server really good requires knowledge of the usage pattern for the given files: such knowledge is not assumed for this example.</span></span> <span data-ttu-id="c00ed-156">Por lo tanto, se trata de un servidor RPC mejor diseñado, pero no un servidor RPC diseñado de forma óptima.</span><span class="sxs-lookup"><span data-stu-id="c00ed-156">Therefore, this is a better designed RPC server, but not an optimally designed RPC server.</span></span>

<span data-ttu-id="c00ed-157">La idea de este ejemplo es contraer tantas operaciones remotas en una operación como sea posible.</span><span class="sxs-lookup"><span data-stu-id="c00ed-157">The idea in this example is to collapse as many remote operations into one operation as possible.</span></span> <span data-ttu-id="c00ed-158">El primer intento es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="c00ed-158">The first attempt is the following:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
typedef struct
{
    long position;
    int origin;
} remote_seek_instruction;
... .
interface remote_file
{
    remote_fread(file_name, void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
    size_t remote_fwrite(file_name, const void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
}
```

<span data-ttu-id="c00ed-159">En este ejemplo se contraen todas las operaciones de lectura y escritura, lo que permite abrir un opcional en la misma operación, así como un cierre y una búsqueda opcionales.</span><span class="sxs-lookup"><span data-stu-id="c00ed-159">This example collapses all operations to a read and write, which allows for an optional open on the same operation, as well as an optional close and seek.</span></span>

<span data-ttu-id="c00ed-160">Esta misma secuencia de operación, cuando se escribe de forma abreviada, tiene el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="c00ed-160">This same sequence of operation, when written in abbreviated form, looks like this:</span></span>

``` syntax
remote_read("c:\\sample.txt", ..., &rfp, FALSE, NULL);
remote_read(NULL, ..., &rfp, TRUE, seek_to_20_bytes_before_end);
```

<span data-ttu-id="c00ed-161">Al considerar el mejor servidor RPC diseñado, en la segunda llamada el servidor comprueba que el *\_ nombre de archivo* es **null** y usa el archivo abierto almacenado en RFP.</span><span class="sxs-lookup"><span data-stu-id="c00ed-161">When considering the better designed RPC server, on the second call the server checks that the *file\_name* is **NULL**, and uses the stored open file in rfp.</span></span> <span data-ttu-id="c00ed-162">Después, verá que hay instrucciones de búsqueda y colocará el puntero de archivo 20 bytes antes del final antes de que se lea.</span><span class="sxs-lookup"><span data-stu-id="c00ed-162">Then it sees there are seek instructions, and will position the file pointer 20 bytes before the end before it reads.</span></span> <span data-ttu-id="c00ed-163">Cuando haya terminado, reconocerá que la marca **CloseWhenDone** está establecida en **true** y cerrará el archivo y cerrará RFP.</span><span class="sxs-lookup"><span data-stu-id="c00ed-163">When done, it will recognize the **CloseWhenDone** flag is set to **TRUE**, and will close the file, and close rfp.</span></span>

<span data-ttu-id="c00ed-164">En la red de latencia alta, esta mejor versión tarda 10 segundos en completarse (2,5 veces más rápido) y requiere el procesamiento de solo cuatro paquetes. dos reciben del servidor y dos envían desde el servidor.</span><span class="sxs-lookup"><span data-stu-id="c00ed-164">On the high latency network, this better version takes 10 seconds to complete (2.5 times faster) and requires processing of only four packets; two receives from the server, and two sends from the server.</span></span> <span data-ttu-id="c00ed-165">El *IFS* adicional y la anulación del cálculo de referencias del servidor son insignificantes en comparación con todo lo demás.</span><span class="sxs-lookup"><span data-stu-id="c00ed-165">The extra *ifs* and unmarshaling the server performs are negligible compared to everything else.</span></span>

<span data-ttu-id="c00ed-166">Si la ordenación causal se especifica correctamente, la interfaz se puede hacer incluso asincrónica y las dos llamadas se pueden enviar en paralelo.</span><span class="sxs-lookup"><span data-stu-id="c00ed-166">If causal ordering is specified properly, the interface can even be made asynchronous, and the two calls can be sent in parallel.</span></span> <span data-ttu-id="c00ed-167">Cuando se utilizan las llamadas de ordenación causal, se siguen enviando en orden, lo que significa que en la red de alta latencia solo se aplica un retraso de cinco segundos, aunque el número de paquetes enviados y recibidos sea el mismo.</span><span class="sxs-lookup"><span data-stu-id="c00ed-167">When causal ordering is used calls are still dispatched in order, which means on the high latency network only a five-second delay is endured, even though the number of packets sent and received is the same.</span></span>

<span data-ttu-id="c00ed-168">Podemos contraer esto aún más mediante la creación de un método que toma una matriz de estructuras, cada miembro de la matriz que describe una operación de archivo determinada. una variación remota de e/s de dispersión y recopilación.</span><span class="sxs-lookup"><span data-stu-id="c00ed-168">We can collapse this even further by creating one method that takes an array of structures, each member of the array describing a particular file operation; a remote variation of scatter/gather I/O.</span></span> <span data-ttu-id="c00ed-169">El enfoque se paga siempre que el resultado de cada operación no requiera más procesamiento en el cliente. en otras palabras, la aplicación va a leer los 20 bytes al final, independientemente de lo que sean los primeros 20 bytes leídos.</span><span class="sxs-lookup"><span data-stu-id="c00ed-169">The approach pays off as long as the result of each operation does not require further processing on the client; in other words the application is going to read the 20 bytes at the end regardless of what the first 20 bytes read are.</span></span>

<span data-ttu-id="c00ed-170">Sin embargo, si se debe realizar algún procesamiento en los primeros 20 bytes después de leerlos para determinar la operación siguiente, el contracción de todo en una operación no funciona (al menos no en todos los casos).</span><span class="sxs-lookup"><span data-stu-id="c00ed-170">However, if some processing must be performed on the first 20 bytes after reading them to determine the next operation, collapsing everything into one operation does not work (at least not in all cases).</span></span> <span data-ttu-id="c00ed-171">La elegancia de RPC es que una aplicación puede tener ambos métodos en la interfaz y llamar a cualquier método en función de las necesidades.</span><span class="sxs-lookup"><span data-stu-id="c00ed-171">The elegance of RPC is that an application can have both methods in the interface, and call either method depending on need.</span></span>

<span data-ttu-id="c00ed-172">En general, cuando la red está implicada, es mejor combinar tantas llamadas en una sola llamada como sea posible.</span><span class="sxs-lookup"><span data-stu-id="c00ed-172">In general, when the network is involved it is best to combine as many calls onto a single call as possible.</span></span> <span data-ttu-id="c00ed-173">Si una aplicación tiene dos actividades independientes, use operaciones asincrónicas y permita que se ejecuten en paralelo.</span><span class="sxs-lookup"><span data-stu-id="c00ed-173">If an application has two independent activities, use asynchronous operations and let them run in parallel.</span></span> <span data-ttu-id="c00ed-174">En esencia, mantenga la canalización completa.</span><span class="sxs-lookup"><span data-stu-id="c00ed-174">Essentially, keep the pipeline full.</span></span>

 

 




