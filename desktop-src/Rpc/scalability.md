---
title: Escalabilidad
description: Escalabilidad
ms.assetid: 39327621-b536-4494-9319-9e9d4f534123
keywords:
- Escalabilidad
- Llamada a procedimiento remoto RPC, procedimientos recomendados, escalabilidad
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0728e35d9c9b27494014363c448be9965e39eea7
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "103903770"
---
# <a name="scalability"></a><span data-ttu-id="c9012-105">Escalabilidad</span><span class="sxs-lookup"><span data-stu-id="c9012-105">Scalability</span></span>

<span data-ttu-id="c9012-106">El término, la escalabilidad, se suele usar infrecuentemente.</span><span class="sxs-lookup"><span data-stu-id="c9012-106">The term, scalability, is often misused.</span></span> <span data-ttu-id="c9012-107">En esta sección, se proporciona una definición dual:</span><span class="sxs-lookup"><span data-stu-id="c9012-107">For this section, a dual definition is provided:</span></span>

-   <span data-ttu-id="c9012-108">La escalabilidad es la capacidad de aprovechar al máximo la potencia de procesamiento disponible en un sistema de varios procesadores (2, 4, 8, 32 o más procesadores).</span><span class="sxs-lookup"><span data-stu-id="c9012-108">Scalability is the ability to fully utilize available processing power on a multiprocessor system (2, 4, 8, 32, or more processors).</span></span>
-   <span data-ttu-id="c9012-109">La escalabilidad es la capacidad de atender un gran número de clientes.</span><span class="sxs-lookup"><span data-stu-id="c9012-109">Scalability is the ability to service a large number of clients.</span></span>

<span data-ttu-id="c9012-110">Estas dos definiciones relacionadas se conocen comúnmente como *escalado* vertical.</span><span class="sxs-lookup"><span data-stu-id="c9012-110">These two related definitions are commonly referred to as *scaling up*.</span></span> <span data-ttu-id="c9012-111">Al final de este tema se proporcionan sugerencias sobre el *escalado* horizontal.</span><span class="sxs-lookup"><span data-stu-id="c9012-111">The end of this topic provides tips about *scaling out*.</span></span>

<span data-ttu-id="c9012-112">Esta explicación se centra exclusivamente en la escritura de servidores escalables, no en clientes escalables, ya que los servidores escalables son requisitos más comunes.</span><span class="sxs-lookup"><span data-stu-id="c9012-112">This discussion focuses exclusively on writing scalable servers, not scalable clients, because scalable servers are more common requirements.</span></span> <span data-ttu-id="c9012-113">En esta sección también se trata la escalabilidad en el contexto de los servidores RPC y RPC únicamente.</span><span class="sxs-lookup"><span data-stu-id="c9012-113">This section also addresses scalability in the context of RPC and RPC servers only.</span></span> <span data-ttu-id="c9012-114">Aquí no se describen los procedimientos recomendados para la escalabilidad, como la reducción de la contención, la prevención de errores de caché frecuentes en ubicaciones de memoria globales o la prevención del uso compartido falso.</span><span class="sxs-lookup"><span data-stu-id="c9012-114">Best practices for scalability, such as reducing contention, avoiding frequent cache misses on global memory locations, or avoiding false sharing, are not discussed here.</span></span>

## <a name="rpc-threading-model"></a><span data-ttu-id="c9012-115">Modelo de subprocesos RPC</span><span class="sxs-lookup"><span data-stu-id="c9012-115">RPC Threading Model</span></span>

<span data-ttu-id="c9012-116">Cuando un servidor recibe una llamada RPC, se llama a la rutina de servidor (rutina Manager) en un subproceso proporcionado por RPC.</span><span class="sxs-lookup"><span data-stu-id="c9012-116">When an RPC call is received by a server, the server routine (manager routine) is called on a thread supplied by RPC.</span></span> <span data-ttu-id="c9012-117">RPC utiliza un grupo de subprocesos adaptable que aumenta y disminuye a medida que la carga de trabajo fluctúa.</span><span class="sxs-lookup"><span data-stu-id="c9012-117">RPC uses an adaptive thread pool that increases and decreases as workload fluctuates.</span></span> <span data-ttu-id="c9012-118">A partir de Windows 2000, el núcleo del grupo de subprocesos RPC es un puerto de finalización.</span><span class="sxs-lookup"><span data-stu-id="c9012-118">Starting with Windows 2000, the core of the RPC thread pool is a completion port.</span></span> <span data-ttu-id="c9012-119">El puerto de finalización y su uso por parte de RPC están optimizados para las rutinas de servidor de contención cero a bajo.</span><span class="sxs-lookup"><span data-stu-id="c9012-119">The completion port and its usage by RPC are tuned for zero to low contention server routines.</span></span> <span data-ttu-id="c9012-120">Esto significa que el grupo de subprocesos RPC aumenta de forma agresiva el número de subprocesos de servicio si algunos se bloquean.</span><span class="sxs-lookup"><span data-stu-id="c9012-120">This means that the RPC thread pool aggressively increases the number of servicing threads if some become blocked.</span></span> <span data-ttu-id="c9012-121">Funciona en la presunción de que el bloqueo es poco frecuente y, si se bloquea un subproceso, se trata de una condición temporal que se resuelve rápidamente.</span><span class="sxs-lookup"><span data-stu-id="c9012-121">It operates on the presumption that blocking is rare, and if a thread gets blocked, this is a temporary condition that is quickly resolved.</span></span> <span data-ttu-id="c9012-122">Este enfoque permite la eficacia de los pocos servidores de contención.</span><span class="sxs-lookup"><span data-stu-id="c9012-122">This approach enables efficiency for low contention servers.</span></span> <span data-ttu-id="c9012-123">Por ejemplo, un servidor RPC de llamada void que opere en un servidor 550MHz de ocho procesadores al que se tiene acceso a través de una red de área de sistema (SAN) de alta velocidad realiza más de 30.000 llamadas void por segundo desde más de 200 clientes remotos.</span><span class="sxs-lookup"><span data-stu-id="c9012-123">For example, a void call RPC server operating on an eight-processor 550MHz server accessed over a high speed system area network (SAN) serves over 30,000 void calls per second from over 200 remote clients.</span></span> <span data-ttu-id="c9012-124">Esto representa más de 108 millones llamadas por hora.</span><span class="sxs-lookup"><span data-stu-id="c9012-124">This represents more than 108 million calls per hour.</span></span>

<span data-ttu-id="c9012-125">El resultado es que el grupo de subprocesos agresivo realmente se obtiene en la forma en que la contención en el servidor es alta.</span><span class="sxs-lookup"><span data-stu-id="c9012-125">The result is that the aggressive thread pool actually gets in the way when contention on the server is high.</span></span> <span data-ttu-id="c9012-126">Para ilustrar, Imagine un servidor con un gran arancel que se usa para acceder a los archivos de forma remota.</span><span class="sxs-lookup"><span data-stu-id="c9012-126">To illustrate, imagine a heavy-duty server used to remotely access files.</span></span> <span data-ttu-id="c9012-127">Suponga que el servidor adopta el enfoque más directo: simplemente lee/escribe el archivo sincrónicamente en el subproceso en el que RPC invoca la rutina de servidor.</span><span class="sxs-lookup"><span data-stu-id="c9012-127">Assume the server adopts the most straightforward approach: it simply reads/writes the file synchronously on the thread on which that RPC invokes the server routine.</span></span> <span data-ttu-id="c9012-128">Además, supongamos que tenemos un servidor de cuatro procesadores que atiende a muchos clientes.</span><span class="sxs-lookup"><span data-stu-id="c9012-128">Also, assume we have a four-processor server serving many clients.</span></span>

<span data-ttu-id="c9012-129">El servidor se iniciará con cinco subprocesos (esto varía realmente, pero se usan cinco subprocesos por simplicidad).</span><span class="sxs-lookup"><span data-stu-id="c9012-129">The server will start with five threads (this actually varies, but five threads is used for simplicity).</span></span> <span data-ttu-id="c9012-130">Una vez que RPC recoge la primera llamada RPC, envía la llamada a la rutina de servidor y la rutina de servidor emite la e/s.</span><span class="sxs-lookup"><span data-stu-id="c9012-130">Once RPC picks up the first RPC call, it dispatches the call to the server routine, and the server routine issues the I/O.</span></span> <span data-ttu-id="c9012-131">Con poca frecuencia, se pierde la memoria caché de archivos y, a continuación, se bloquea la espera del resultado.</span><span class="sxs-lookup"><span data-stu-id="c9012-131">Infrequently, it misses the file cache and then blocks waiting for the result.</span></span> <span data-ttu-id="c9012-132">En cuanto se bloquea, el quinto subproceso se libera para recoger una solicitud y se crea un sexto subproceso como un estado de espera activa.</span><span class="sxs-lookup"><span data-stu-id="c9012-132">As soon as it blocks, the fifth thread is released to pick up a request, and a sixth thread is created as a hot standby.</span></span> <span data-ttu-id="c9012-133">Suponiendo que cada décima operación de e/s pierda la memoria caché y se bloqueará durante 100 milisegundos (un valor de tiempo arbitrario), y suponiendo que el servidor de cuatro procesadores atiende las 20.000 llamadas por segundo (5.000 llamadas por procesador), un modelado simplista predecirá que cada procesador generará aproximadamente los subprocesos de 50.</span><span class="sxs-lookup"><span data-stu-id="c9012-133">Assuming each tenth I/O operation misses the cache and will block for 100 milliseconds (an arbitrary time value), and assuming the four-processor server serves about 20,000 calls per second (5,000 calls per processor), a simplistic modeling would predict that each processor will spawn approximately 50 threads.</span></span> <span data-ttu-id="c9012-134">Se supone que se trata de una llamada que bloqueará cada 2 milisegundos y, después de 100 milisegundos, el primer subproceso se libera de nuevo para que el grupo se estabilice en unos 200 subprocesos (50 por procesador).</span><span class="sxs-lookup"><span data-stu-id="c9012-134">This assumes a call that will block comes every 2 milliseconds, and after 100 milliseconds the first thread is freed again so the pool will stabilize at about 200 threads (50 per processor).</span></span>

<span data-ttu-id="c9012-135">El comportamiento real es más complicado, ya que el número alto de subprocesos producirá cambios de contexto adicionales que ralentizan el servidor y también ralentizan la velocidad de creación de nuevos subprocesos, pero la idea básica está clara.</span><span class="sxs-lookup"><span data-stu-id="c9012-135">The actual behavior is more complicated, as the high number of threads will cause extra context switches which slow the server, and also slow the rate of creation of new threads, but the basic idea is clear.</span></span> <span data-ttu-id="c9012-136">El número de subprocesos aumenta rápidamente a medida que los subprocesos del servidor inician el bloqueo y esperan algo (es decir, una e/s o el acceso a un recurso).</span><span class="sxs-lookup"><span data-stu-id="c9012-136">The number of threads goes up quickly as threads on the server start blocking and waiting for something (be it an I/O, or access to a resource).</span></span>

<span data-ttu-id="c9012-137">RPC y el puerto de finalización que las solicitudes entrantes intentarán mantener el número de subprocesos RPC que se pueden usar en el servidor para que sea igual al número de procesadores de la máquina.</span><span class="sxs-lookup"><span data-stu-id="c9012-137">RPC and the completion port that gates incoming requests will try to maintain the number of usable RPC threads in the server to be equal to the number of processors on the machine.</span></span> <span data-ttu-id="c9012-138">Esto significa que en un servidor de cuatro procesadores, una vez que un subproceso vuelve a RPC, si hay cuatro o más subprocesos RPC que se pueden usar, el quinto subproceso no tiene permiso para recopilar una nueva solicitud y, en su lugar, se quedará en estado de espera activa en caso de que uno de los subprocesos que se puedan usar actualmente sea.</span><span class="sxs-lookup"><span data-stu-id="c9012-138">This means that on a four-processor server, once a thread returns to RPC, if there are four or more usable RPC threads, the fifth thread is not allowed to pick up a new request, and instead will sit in a hot standby state in case one of the currently usable threads blocks.</span></span> <span data-ttu-id="c9012-139">Si el quinto subproceso espera el tiempo suficiente como un estado de espera activa sin el número de subprocesos RPC que se pueden usar y se quita por debajo del número de procesadores, se liberará, es decir, el grupo de subprocesos disminuirá.</span><span class="sxs-lookup"><span data-stu-id="c9012-139">If the fifth thread waits long enough as a hot standby without the number of usable RPC threads dropping below the number of processors, it will be released, that is, the thread pool will decrease.</span></span>

<span data-ttu-id="c9012-140">Imagine un servidor con muchos subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c9012-140">Imagine a server with many threads.</span></span> <span data-ttu-id="c9012-141">Como se explicó anteriormente, un servidor RPC termina con muchos subprocesos, pero solo si los subprocesos se bloquean a menudo.</span><span class="sxs-lookup"><span data-stu-id="c9012-141">As previously explained, an RPC server ends up with many threads, but only if the threads block often.</span></span> <span data-ttu-id="c9012-142">En un servidor en el que los subprocesos se bloquean a menudo, un subproceso que vuelve a RPC se saca pronto de la lista de espera activa, porque todos los subprocesos que se pueden usar actualmente se bloquean y se le proporciona una solicitud para procesar.</span><span class="sxs-lookup"><span data-stu-id="c9012-142">On a server where threads often block, a thread that returns to RPC is soon taken out of the hot standby list, because all currently usable threads block, and is given a request to process.</span></span> <span data-ttu-id="c9012-143">Cuando un subproceso se bloquea, el distribuidor de subprocesos en el kernel cambia el contexto a otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="c9012-143">When a thread blocks, the thread dispatcher in the kernel switches context to another thread.</span></span> <span data-ttu-id="c9012-144">Este cambio de contexto solo consume ciclos de CPU.</span><span class="sxs-lookup"><span data-stu-id="c9012-144">This context switch by itself consumes CPU cycles.</span></span> <span data-ttu-id="c9012-145">El subproceso siguiente ejecutará código diferente, tendrá acceso a estructuras de datos diferentes y tendrá una pila diferente, lo que significa que la tasa de aciertos de la memoria caché (las cachés L1 y L2) será mucho menor, lo que dará lugar a una ejecución más lenta.</span><span class="sxs-lookup"><span data-stu-id="c9012-145">The next thread will be executing different code, accessing different data structures, and will have a different stack, which means the memory cache hit rate (the L1 and L2 caches) will be much lower, resulting in slower execution.</span></span> <span data-ttu-id="c9012-146">Los numerosos subprocesos que se ejecutan simultáneamente aumentan la contención de los recursos existentes, como el montón, las secciones críticas en el código del servidor, etc.</span><span class="sxs-lookup"><span data-stu-id="c9012-146">The numerous threads executing simultaneously increases contention for existing resources, such as heap, critical sections in the server code, and so on.</span></span> <span data-ttu-id="c9012-147">Esto aumenta aún más la contención en el formulario de recursos.</span><span class="sxs-lookup"><span data-stu-id="c9012-147">This further increases contention as convoys on resources form.</span></span> <span data-ttu-id="c9012-148">Si la memoria es baja, la presión de memoria ejercida por el número grande y creciente de subprocesos producirá errores de página, que aumentarán aún más la velocidad a la que se bloquean los subprocesos y provocarán que se creen incluso más subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c9012-148">If memory is low, the memory pressure exerted by the large and growing number of threads will cause page faults, which further increase the rate at which the threads block, and cause even more threads to be created.</span></span> <span data-ttu-id="c9012-149">En función de la frecuencia con que se bloquee y de la cantidad de memoria física disponible, el servidor puede estabilizarse con un nivel de rendimiento inferior con una tasa de cambio de contexto alta o puede deteriorarse hasta el punto en el que solo se accede repetidamente al disco duro y al cambio de contexto sin realizar ningún trabajo real.</span><span class="sxs-lookup"><span data-stu-id="c9012-149">Depending on how often it blocks and how much physical memory is available, the server may either stabilize at some lower level of performance with a high context switch rate, or it may deteriorate to the point where it is only repeatedly accessing the hard disk and context switching without performing any actual work.</span></span> <span data-ttu-id="c9012-150">Esta situación no se mostrará en la carga de trabajo ligera, por supuesto, pero una carga de trabajo pesada pone el problema rápidamente en la superficie.</span><span class="sxs-lookup"><span data-stu-id="c9012-150">This situation will not show under light workload, of course, but a heavy workload quickly brings the problem to the surface.</span></span>

<span data-ttu-id="c9012-151">¿Cómo se puede evitar esto?</span><span class="sxs-lookup"><span data-stu-id="c9012-151">How can this be prevented?</span></span> <span data-ttu-id="c9012-152">Si se espera que los subprocesos se bloqueen, declare llamadas como asincrónicas y, una vez que la solicitud entre en la rutina del servidor, colóquelo en un grupo de subprocesos de trabajo que usen las capacidades asincrónicas del sistema de e/s y/o RPC.</span><span class="sxs-lookup"><span data-stu-id="c9012-152">If threads are expected to block, declare calls as asynchronous, and once the request enters the server routine, queue it to a pool of worker threads that use the asynchronous capabilities of the I/O system and/or RPC.</span></span> <span data-ttu-id="c9012-153">Si el servidor, a su vez, hace que las llamadas RPC realicen esos asíncronos y asegúrese de que la cola no crezca demasiado.</span><span class="sxs-lookup"><span data-stu-id="c9012-153">If the server is in turn making RPC calls make those asynchronous, and make sure the queue does not grow too large.</span></span> <span data-ttu-id="c9012-154">Si la rutina de servidor está realizando la e/s de archivos, use la e/s asincrónica de archivos para poner en cola varias solicitudes en el sistema de e/s y tener solo unos pocos subprocesos en cola y recoger los resultados.</span><span class="sxs-lookup"><span data-stu-id="c9012-154">If the server routine is performing file I/O, use asynchronous file I/O to queue multiple requests to the I/O system and have only a few threads queue them and pick up the results.</span></span> <span data-ttu-id="c9012-155">Si la rutina de servidor está realizando una e/s de red, utilice de nuevo las capacidades asincrónicas del sistema para emitir las solicitudes y recoger las respuestas de forma asincrónica y usar el menor número posible de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c9012-155">If the server routine is doing network I/O, again, use the asynchronous capabilities of the system to issue the requests and pick up the replies asynchronously, and use as few threads as possible.</span></span> <span data-ttu-id="c9012-156">Cuando se realiza la e/s, o cuando se completa la llamada RPC realizada por el servidor, complete la llamada RPC asincrónica que entregó la solicitud.</span><span class="sxs-lookup"><span data-stu-id="c9012-156">When the I/O is done, or the RPC call the server made is complete, complete the asynchronous RPC call that delivered the request.</span></span> <span data-ttu-id="c9012-157">Esto permitirá que el servidor se ejecute con el menor número posible de subprocesos, lo que aumenta el rendimiento y el número de clientes que puede atender un servidor.</span><span class="sxs-lookup"><span data-stu-id="c9012-157">This will enable the server to run with as few threads as possible, which increases the performance and the number of clients a server can service.</span></span>

## <a name="scale-out"></a><span data-ttu-id="c9012-158">Escalabilidad horizontal</span><span class="sxs-lookup"><span data-stu-id="c9012-158">Scale Out</span></span>

<span data-ttu-id="c9012-159">RPC puede configurarse para que funcione con equilibrio de carga de red (NLB) si se configura NLB de modo que todas las solicitudes de una dirección de cliente determinada vayan al mismo servidor.</span><span class="sxs-lookup"><span data-stu-id="c9012-159">RPC can be configured to work with Network Load Balancing (NLB) if NLB is configured such that all requests from a given client address go to the same server.</span></span> <span data-ttu-id="c9012-160">Dado que cada cliente RPC abre un grupo de conexiones (para obtener más información, consulte [RPC y la red](rpc-and-the-network.md)), es fundamental que todas las conexiones desde el grupo del cliente determinado terminen en el mismo equipo servidor.</span><span class="sxs-lookup"><span data-stu-id="c9012-160">Because each RPC client opens a connection pool (for more information, see [RPC and the Network](rpc-and-the-network.md)), it is essential that all connections from the pool of the given client end up on the same server computer.</span></span> <span data-ttu-id="c9012-161">Siempre que se cumpla esta condición, se puede configurar un clúster NLB para que funcione como un servidor RPC de gran tamaño con una escalabilidad potencialmente excelente.</span><span class="sxs-lookup"><span data-stu-id="c9012-161">As long as this condition is met, an NLB cluster can be configured to function as one large RPC server with potentially excellent scalability.</span></span>

 

 




