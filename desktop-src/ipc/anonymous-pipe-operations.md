---
description: Operaciones de canalización anónimas, incluida la creación de canalizaciones, escritura en una canalización, identificadores de canalización.
ms.assetid: df81471c-1072-4456-a877-304e76ade4bd
title: Operaciones de canalización anónimas
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 963d7127c51859b05e570d00291470a49be5ba66
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "105687384"
---
# <a name="anonymous-pipe-operations"></a><span data-ttu-id="abda7-103">Operaciones de canalización anónimas</span><span class="sxs-lookup"><span data-stu-id="abda7-103">Anonymous Pipe Operations</span></span>

<span data-ttu-id="abda7-104">La función [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) crea una canalización anónima y devuelve dos identificadores: un identificador de lectura para la canalización y un identificador de escritura para la canalización.</span><span class="sxs-lookup"><span data-stu-id="abda7-104">The [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) function creates an anonymous pipe and returns two handles: a read handle to the pipe and a write handle to the pipe.</span></span> <span data-ttu-id="abda7-105">El identificador de lectura tiene acceso de solo lectura a la canalización, y el identificador de escritura tiene acceso de solo escritura a la canalización.</span><span class="sxs-lookup"><span data-stu-id="abda7-105">The read handle has read-only access to the pipe, and the write handle has write-only access to the pipe.</span></span> <span data-ttu-id="abda7-106">Para comunicarse mediante la canalización, el servidor de canalización debe pasar un identificador de canalización a otro proceso.</span><span class="sxs-lookup"><span data-stu-id="abda7-106">To communicate using the pipe, the pipe server must pass a pipe handle to another process.</span></span> <span data-ttu-id="abda7-107">Normalmente, esto se hace a través de la herencia; es decir, el proceso permite que un proceso secundario herede el identificador.</span><span class="sxs-lookup"><span data-stu-id="abda7-107">Usually, this is done through inheritance; that is, the process allows the handle to be inherited by a child process.</span></span> <span data-ttu-id="abda7-108">El proceso también puede duplicar un identificador de canalización mediante la función [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) y enviarlo a un proceso no relacionado mediante algún tipo de comunicación entre procesos, como DDE o la memoria compartida.</span><span class="sxs-lookup"><span data-stu-id="abda7-108">The process can also duplicate a pipe handle using the [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) function and send it to an unrelated process using some form of interprocess communication, such as DDE or shared memory.</span></span>

<span data-ttu-id="abda7-109">Un servidor de canalización puede enviar el identificador de lectura o el identificador de escritura al cliente de canalización, dependiendo de si el cliente debe usar la canalización anónima para enviar información o recibir información.</span><span class="sxs-lookup"><span data-stu-id="abda7-109">A pipe server can send either the read handle or the write handle to the pipe client, depending on whether the client should use the anonymous pipe to send information or receive information.</span></span> <span data-ttu-id="abda7-110">Para leer de la canalización, use el identificador de lectura de la canalización en una llamada a la función [**readfile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) .</span><span class="sxs-lookup"><span data-stu-id="abda7-110">To read from the pipe, use the pipe's read handle in a call to the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) function.</span></span> <span data-ttu-id="abda7-111">La llamada **readfile** devuelve cuando otro proceso ha escrito en la canalización.</span><span class="sxs-lookup"><span data-stu-id="abda7-111">The **ReadFile** call returns when another process has written to the pipe.</span></span> <span data-ttu-id="abda7-112">La llamada **readfile** también puede devolver si se han cerrado todos los identificadores de escritura de la canalización o si se produce un error antes de que se haya completado la operación de lectura.</span><span class="sxs-lookup"><span data-stu-id="abda7-112">The **ReadFile** call can also return if all write handles to the pipe have been closed or if an error occurs before the read operation has been completed.</span></span>

<span data-ttu-id="abda7-113">Para escribir en la canalización, use el identificador de escritura de la canalización en una llamada a la función [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) .</span><span class="sxs-lookup"><span data-stu-id="abda7-113">To write to the pipe, use the pipe's write handle in a call to the [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) function.</span></span> <span data-ttu-id="abda7-114">La llamada **WriteFile** no vuelve hasta que ha escrito el número especificado de bytes en la canalización o se produce un error.</span><span class="sxs-lookup"><span data-stu-id="abda7-114">The **WriteFile** call does not return until it has written the specified number of bytes to the pipe or an error occurs.</span></span> <span data-ttu-id="abda7-115">Si el búfer de canalización está lleno y hay más bytes que se van a escribir, **WriteFile** no devuelve ningún resultado hasta que otro proceso Lee de la canalización, lo que hace que haya más espacio en búfer disponible.</span><span class="sxs-lookup"><span data-stu-id="abda7-115">If the pipe buffer is full and there are more bytes to be written, **WriteFile** does not return until another process reads from the pipe, making more buffer space available.</span></span> <span data-ttu-id="abda7-116">El servidor de canalización especifica el tamaño del búfer de la canalización cuando llama a [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe).</span><span class="sxs-lookup"><span data-stu-id="abda7-116">The pipe server specifies the buffer size for the pipe when it calls [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe).</span></span>

<span data-ttu-id="abda7-117">Las canalizaciones anónimas no admiten las operaciones de lectura y escritura asincrónicas (superpuestas).</span><span class="sxs-lookup"><span data-stu-id="abda7-117">Asynchronous (overlapped) read and write operations are not supported by anonymous pipes.</span></span> <span data-ttu-id="abda7-118">Esto significa que no puede usar las funciones [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) y [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) con canalizaciones anónimas.</span><span class="sxs-lookup"><span data-stu-id="abda7-118">This means that you cannot use the [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) functions with anonymous pipes.</span></span> <span data-ttu-id="abda7-119">Además, el parámetro *lpOverlapped* de [**readfile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) y [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) se omite cuando estas funciones se usan con canalizaciones anónimas.</span><span class="sxs-lookup"><span data-stu-id="abda7-119">In addition, the *lpOverlapped* parameter of [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) is ignored when these functions are used with anonymous pipes.</span></span>

<span data-ttu-id="abda7-120">Existe una canalización anónima hasta que se hayan cerrado todos los identificadores de canalización, tanto de lectura como de escritura.</span><span class="sxs-lookup"><span data-stu-id="abda7-120">An anonymous pipe exists until all pipe handles, both read and write, have been closed.</span></span> <span data-ttu-id="abda7-121">Un proceso puede cerrar los identificadores de canalización mediante la función [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) .</span><span class="sxs-lookup"><span data-stu-id="abda7-121">A process can close its pipe handles by using the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span> <span data-ttu-id="abda7-122">También se cierran todos los identificadores de canalización cuando finaliza el proceso.</span><span class="sxs-lookup"><span data-stu-id="abda7-122">All pipe handles are also closed when the process terminates.</span></span>

<span data-ttu-id="abda7-123">Las canalizaciones anónimas se implementan mediante una canalización con nombre con un nombre único.</span><span class="sxs-lookup"><span data-stu-id="abda7-123">Anonymous pipes are implemented using a named pipe with a unique name.</span></span> <span data-ttu-id="abda7-124">Por lo tanto, a menudo puede pasar un identificador a una canalización anónima a una función que requiera un identificador a una canalización con nombre.</span><span class="sxs-lookup"><span data-stu-id="abda7-124">Therefore, you can often pass a handle to an anonymous pipe to a function that requires a handle to a named pipe.</span></span>

 

 
