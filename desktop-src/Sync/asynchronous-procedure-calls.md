---
description: Una llamada a procedimiento asincrónico (APC) es una función que se ejecuta de forma asincrónica en el contexto de un subproceso determinado.
ms.assetid: 0197d78e-a4dc-414b-88ba-c5ec5f2ed614
title: Llamadas a procedimientos asincrónicos
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dd95e9afd663e2a462335b3c47bfe99462b449e7
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "104002461"
---
# <a name="asynchronous-procedure-calls"></a><span data-ttu-id="03c9d-103">Llamadas a procedimientos asincrónicos</span><span class="sxs-lookup"><span data-stu-id="03c9d-103">Asynchronous Procedure Calls</span></span>

<span data-ttu-id="03c9d-104">Una *llamada a procedimiento asincrónico* (APC) es una función que se ejecuta de forma asincrónica en el contexto de un subproceso determinado.</span><span class="sxs-lookup"><span data-stu-id="03c9d-104">An *asynchronous procedure call* (APC) is a function that executes asynchronously in the context of a particular thread.</span></span> <span data-ttu-id="03c9d-105">Cuando un APC se pone en cola en un subproceso, el sistema emite una interrupción de software.</span><span class="sxs-lookup"><span data-stu-id="03c9d-105">When an APC is queued to a thread, the system issues a software interrupt.</span></span> <span data-ttu-id="03c9d-106">La próxima vez que se programe el subproceso, se ejecutará la función APC.</span><span class="sxs-lookup"><span data-stu-id="03c9d-106">The next time the thread is scheduled, it will run the APC function.</span></span> <span data-ttu-id="03c9d-107">Una APC generada por el sistema se denomina *APC en modo kernel*.</span><span class="sxs-lookup"><span data-stu-id="03c9d-107">An APC generated by the system is called a *kernel-mode APC*.</span></span> <span data-ttu-id="03c9d-108">Una APC generada por una aplicación se denomina *APC de modo usuario*.</span><span class="sxs-lookup"><span data-stu-id="03c9d-108">An APC generated by an application is called a *user-mode APC*.</span></span> <span data-ttu-id="03c9d-109">Un subproceso debe estar en un estado de alerta para ejecutar un APC en modo de usuario.</span><span class="sxs-lookup"><span data-stu-id="03c9d-109">A thread must be in an alertable state to run a user-mode APC.</span></span>

<span data-ttu-id="03c9d-110">Cada subproceso tiene su propia cola APC.</span><span class="sxs-lookup"><span data-stu-id="03c9d-110">Each thread has its own APC queue.</span></span> <span data-ttu-id="03c9d-111">Una aplicación pone en cola un APC en un subproceso llamando a la función [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) .</span><span class="sxs-lookup"><span data-stu-id="03c9d-111">An application queues an APC to a thread by calling the [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) function.</span></span> <span data-ttu-id="03c9d-112">El subproceso que realiza la llamada especifica la dirección de una función APC en la llamada a **QueueUserAPC**.</span><span class="sxs-lookup"><span data-stu-id="03c9d-112">The calling thread specifies the address of an APC function in the call to **QueueUserAPC**.</span></span> <span data-ttu-id="03c9d-113">La puesta en cola de una APC es una solicitud para que el subproceso llame a la función APC.</span><span class="sxs-lookup"><span data-stu-id="03c9d-113">The queuing of an APC is a request for the thread to call the APC function.</span></span>

<span data-ttu-id="03c9d-114">Cuando se pone en cola un APC en modo de usuario, el subproceso al que se pone en cola no se dirige para llamar a la función APC a menos que esté en un estado de alerta.</span><span class="sxs-lookup"><span data-stu-id="03c9d-114">When a user-mode APC is queued, the thread to which it is queued is not directed to call the APC function unless it is in an alertable state.</span></span> <span data-ttu-id="03c9d-115">Un subproceso entra en un estado de alerta cuando llama a la función [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex)o [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) .</span><span class="sxs-lookup"><span data-stu-id="03c9d-115">A thread enters an alertable state when it calls the [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex), or [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) function.</span></span> <span data-ttu-id="03c9d-116">Si se cumple la espera antes de que se haya puesto en cola el APC, el subproceso ya no se encuentra en un estado de espera de alerta, por lo que la función APC no se ejecutará.</span><span class="sxs-lookup"><span data-stu-id="03c9d-116">If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed.</span></span> <span data-ttu-id="03c9d-117">Sin embargo, el APC todavía se pone en la cola, por lo que la función APC se ejecutará cuando el subproceso llame a otra función de espera de alerta.</span><span class="sxs-lookup"><span data-stu-id="03c9d-117">However, the APC is still queued, so the APC function will be executed when the thread calls another alertable wait function.</span></span>

<span data-ttu-id="03c9d-118">Las funciones [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex)y [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) se implementan mediante una APC como el mecanismo de devolución de llamada de notificación de finalización.</span><span class="sxs-lookup"><span data-stu-id="03c9d-118">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions are implemented using an APC as the completion notification callback mechanism.</span></span>

<span data-ttu-id="03c9d-119">Si usa un grupo de [subprocesos](../procthread/thread-pools.md), tenga en cuenta que APC no funcionan así como otros mecanismos de señalización porque el sistema controla la duración de los subprocesos del grupo de subprocesos, por lo que es posible que un subproceso finalice antes de que se entregue la notificación.</span><span class="sxs-lookup"><span data-stu-id="03c9d-119">If you are using a [thread pool](../procthread/thread-pools.md), note that APCs do not work as well as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span> <span data-ttu-id="03c9d-120">En lugar de usar un mecanismo de señalización basado en APC como el parámetro *pfnCompletionRoutine* de [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) o [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use un objeto que se debe esperar, como un temporizador creado con [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span><span class="sxs-lookup"><span data-stu-id="03c9d-120">Instead of using an APC-based signaling mechanism such as the *pfnCompletionRoutine* parameter of [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) or [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use a waitable object such as a timer created with [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span></span> <span data-ttu-id="03c9d-121">En e/s, use un objeto de finalización de e/s creado con [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) o una estructura [**superpuesta**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) basada en *hEvent* en la que se pueda pasar el evento a la función [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) .</span><span class="sxs-lookup"><span data-stu-id="03c9d-121">For I/O, use an I/O completion object created with [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) or an *hEvent*-based [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure where the event can be passed to the [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) function.</span></span>

## <a name="synchronization-internals"></a><span data-ttu-id="03c9d-122">Mecanismos internos de sincronización</span><span class="sxs-lookup"><span data-stu-id="03c9d-122">Synchronization Internals</span></span>

<span data-ttu-id="03c9d-123">Cuando se emite una solicitud de e/s, se asigna una estructura para representar la solicitud.</span><span class="sxs-lookup"><span data-stu-id="03c9d-123">When an I/O request is issued, a structure is allocated to represent the request.</span></span> <span data-ttu-id="03c9d-124">Esta estructura se denomina paquete de solicitud de e/s (IRP).</span><span class="sxs-lookup"><span data-stu-id="03c9d-124">This structure is called an I/O request packet (IRP).</span></span> <span data-ttu-id="03c9d-125">Con la e/s sincrónica, el subproceso compila el IRP, lo envía a la pila del dispositivo y espera en el kernel para que se complete el IRP.</span><span class="sxs-lookup"><span data-stu-id="03c9d-125">With synchronous I/O, the thread builds the IRP, sends it to the device stack, and waits in the kernel for the IRP to complete.</span></span> <span data-ttu-id="03c9d-126">Con la e/s asincrónica, el subproceso compila el IRP y lo envía a la pila del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="03c9d-126">With asynchronous I/O, the thread builds the IRP and sends it to the device stack.</span></span> <span data-ttu-id="03c9d-127">La pila podría completar el IRP inmediatamente o podría devolver un estado pendiente que indica que la solicitud está en curso.</span><span class="sxs-lookup"><span data-stu-id="03c9d-127">The stack might complete the IRP immediately, or it might return a pending status indicating that the request is in progress.</span></span> <span data-ttu-id="03c9d-128">Cuando esto sucede, el IRP todavía está asociado al subproceso, por lo que se cancelará si el subproceso finaliza o llama a una función como [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span><span class="sxs-lookup"><span data-stu-id="03c9d-128">When this happens, the IRP is still associated with the thread, so it will be canceled if the thread terminates or calls a function such as [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span></span> <span data-ttu-id="03c9d-129">Mientras tanto, el subproceso puede continuar realizando otras tareas mientras la pila de dispositivos continúa procesando el IRP.</span><span class="sxs-lookup"><span data-stu-id="03c9d-129">In the meantime, the thread can continue to perform other tasks while the device stack continues to process the IRP.</span></span>

<span data-ttu-id="03c9d-130">Hay varias maneras en las que el sistema puede indicar que se ha completado el IRP:</span><span class="sxs-lookup"><span data-stu-id="03c9d-130">There are several ways that the system can indicate that the IRP has completed:</span></span>

-   <span data-ttu-id="03c9d-131">Actualice la estructura superpuesta con el resultado de la operación para que el subproceso pueda realizar un sondeo para determinar si la operación se ha completado.</span><span class="sxs-lookup"><span data-stu-id="03c9d-131">Update the overlapped structure with the result of the operation so the thread can poll to determine whether the operation has completed.</span></span>
-   <span data-ttu-id="03c9d-132">Señale el evento en la estructura superpuesta para que un subproceso pueda sincronizarse en el evento y ser reactivarán cuando se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="03c9d-132">Signal the event in the overlapped structure so a thread can synchronize on the event and be woken when the operation completes.</span></span>
-   <span data-ttu-id="03c9d-133">Ponga en cola el IRP en el APC pendiente del subproceso para que el subproceso ejecute la rutina APC cuando entre en un estado de espera de alerta y vuelva de la operación de espera con un estado que indique que ejecutó una o más rutinas APC.</span><span class="sxs-lookup"><span data-stu-id="03c9d-133">Queue the IRP to the thread's pending APC so that the thread will execute the APC routine when it enters an alertable wait state and return from the wait operation with a status indicating that it executed one or more APC routines.</span></span>
-   <span data-ttu-id="03c9d-134">Pone en cola el IRP en un puerto de finalización de e/s, donde lo ejecutará el siguiente subproceso que espera en el puerto de finalización.</span><span class="sxs-lookup"><span data-stu-id="03c9d-134">Queue the IRP to an I/O completion port, where it will be executed by the next thread that waits on the completion port.</span></span>

<span data-ttu-id="03c9d-135">Los subprocesos que esperan en un puerto de finalización de e/s no esperan en un estado de alerta.</span><span class="sxs-lookup"><span data-stu-id="03c9d-135">Threads that wait on an I/O completion port do not wait in an alertable state.</span></span> <span data-ttu-id="03c9d-136">Por lo tanto, si esos subprocesos emiten IRP que se establecen para completarse como APC en el subproceso, esas finalizaciones de IPC no se realizarán de manera oportuna; solo se producirán si el subproceso recoge una solicitud del puerto de finalización de e/s y, a continuación, entra en una espera de alerta.</span><span class="sxs-lookup"><span data-stu-id="03c9d-136">Therefore, if those threads issue IRPs that are set to complete as APCs to the thread, those IPC completions will not occur in a timely manner; they will occur only if the thread picks up a request from the I/O completion port and then happens to enter an alertable wait.</span></span>

## <a name="related-topics"></a><span data-ttu-id="03c9d-137">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="03c9d-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="03c9d-138">Usar un temporizador que se debe esperar con una llamada a procedimiento asincrónica</span><span class="sxs-lookup"><span data-stu-id="03c9d-138">Using a Waitable Timer with an Asynchronous Procedure Call</span></span>](using-a-waitable-timer-with-an-asynchronous-procedure-call.md)
</dt> </dl>

 

 
