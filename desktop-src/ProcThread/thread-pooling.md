---
description: Hay muchas aplicaciones que crean subprocesos que invierten mucho tiempo en el estado de inactividad en espera de que se produzca un evento.
ms.assetid: a5e52080-35d4-47f5-9050-90889e3bf2f8
title: Agrupación de subprocesos
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcf3565401dc57b077e333043861d42b683e810c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "103909666"
---
# <a name="thread-pooling"></a><span data-ttu-id="90a56-103">Agrupación de subprocesos</span><span class="sxs-lookup"><span data-stu-id="90a56-103">Thread Pooling</span></span>

<span data-ttu-id="90a56-104">Hay muchas aplicaciones que crean subprocesos que invierten mucho tiempo en el estado de inactividad en espera de que se produzca un evento.</span><span class="sxs-lookup"><span data-stu-id="90a56-104">There are many applications that create threads that spend a great deal of time in the sleeping state waiting for an event to occur.</span></span> <span data-ttu-id="90a56-105">Otros subprocesos pueden entrar en un estado de inactividad que solo se activa periódicamente para sondear un cambio o actualizar la información de estado.</span><span class="sxs-lookup"><span data-stu-id="90a56-105">Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="90a56-106">La *agrupación de subprocesos* permite usar subprocesos de forma más eficaz al proporcionar a la aplicación un grupo de subprocesos de trabajo administrados por el sistema.</span><span class="sxs-lookup"><span data-stu-id="90a56-106">*Thread pooling* enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="90a56-107">Al menos un subproceso supervisa el estado de todas las operaciones de espera en cola en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="90a56-107">At least one thread monitors the status of all wait operations queued to the thread pool.</span></span> <span data-ttu-id="90a56-108">Cuando se ha completado una operación de espera, un subproceso de trabajo del grupo de subprocesos ejecuta la función de devolución de llamada correspondiente.</span><span class="sxs-lookup"><span data-stu-id="90a56-108">When a wait operation has completed, a worker thread from the thread pool executes the corresponding callback function.</span></span>

<span data-ttu-id="90a56-109">En este tema se describe la API de grupo de subprocesos original.</span><span class="sxs-lookup"><span data-stu-id="90a56-109">This topic describes the original thread pool API.</span></span> <span data-ttu-id="90a56-110">La API de grupo de subprocesos introducida en Windows Vista es más sencilla, más confiable, tiene un mejor rendimiento y proporciona más flexibilidad a los desarrolladores.</span><span class="sxs-lookup"><span data-stu-id="90a56-110">The thread pool API introduced in Windows Vista is simpler, more reliable, has better performance, and provides more flexibility for developers.</span></span> <span data-ttu-id="90a56-111">Para obtener información sobre la API de grupo de subprocesos actual, consulte [grupos de subprocesos](thread-pools.md).</span><span class="sxs-lookup"><span data-stu-id="90a56-111">For information on the current thread pool API, see [Thread Pools](thread-pools.md).</span></span>

<span data-ttu-id="90a56-112">También puede poner en cola los elementos de trabajo que no están relacionados con una operación de espera en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="90a56-112">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="90a56-113">Para solicitar que un subproceso del grupo de subprocesos controle un elemento de trabajo, llame a la función [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) .</span><span class="sxs-lookup"><span data-stu-id="90a56-113">To request that a work item be handled by a thread in the thread pool, call the [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) function.</span></span> <span data-ttu-id="90a56-114">Esta función toma un parámetro de la función a la que llamará el subproceso seleccionado en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="90a56-114">This function takes a parameter to the function that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="90a56-115">No hay ninguna manera de cancelar un elemento de trabajo una vez que se ha puesto en la cola.</span><span class="sxs-lookup"><span data-stu-id="90a56-115">There is no way to cancel a work item after it has been queued.</span></span>

<span data-ttu-id="90a56-116">[Temporizador:](../sync/timer-queues.md) los temporizadores de cola y [las operaciones de espera registradas](../sync/wait-functions.md) también usan el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="90a56-116">[Timer-queue timers](../sync/timer-queues.md) and [registered wait operations](../sync/wait-functions.md) also use the thread pool.</span></span> <span data-ttu-id="90a56-117">Sus funciones de devolución de llamada se ponen en cola en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="90a56-117">Their callback functions are queued to the thread pool.</span></span> <span data-ttu-id="90a56-118">También puede usar la función [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) para publicar operaciones de e/s asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="90a56-118">You can also use the [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) function to post asynchronous I/O operations.</span></span> <span data-ttu-id="90a56-119">Al completarse la e/s, un subproceso del grupo de subprocesos ejecuta la devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="90a56-119">On completion of the I/O , the callback is executed by a thread pool thread.</span></span>

<span data-ttu-id="90a56-120">El grupo de subprocesos se crea la primera vez que se llama a [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) o [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), o cuando un temporizador de cola de temporizador o una operación de espera registrada pone en cola una función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="90a56-120">The thread pool is created the first time you call [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) or [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), or when a timer-queue timer or registered wait operation queues a callback function.</span></span> <span data-ttu-id="90a56-121">De forma predeterminada, el número de subprocesos que se pueden crear en el grupo de subprocesos es aproximadamente 500.</span><span class="sxs-lookup"><span data-stu-id="90a56-121">By default, the number of threads that can be created in the thread pool is about 500.</span></span> <span data-ttu-id="90a56-122">Cada subproceso utiliza el tamaño de pila predeterminado y se ejecuta con la prioridad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="90a56-122">Each thread uses the default stack size and runs at the default priority.</span></span>

<span data-ttu-id="90a56-123">Hay dos tipos de subprocesos de trabajo en el grupo de subprocesos: e/s y no e/s.</span><span class="sxs-lookup"><span data-stu-id="90a56-123">There are two types of worker threads in the thread pool: I/O and non-I/O.</span></span> <span data-ttu-id="90a56-124">Un *subproceso de trabajo de e/s* es un subproceso que espera en un estado de espera de alerta.</span><span class="sxs-lookup"><span data-stu-id="90a56-124">An *I/O worker thread* is a thread that waits in an alertable wait state.</span></span> <span data-ttu-id="90a56-125">Los elementos de trabajo se ponen en cola para los subprocesos de trabajo de e/s como llamadas a procedimiento asincrónico (APC).</span><span class="sxs-lookup"><span data-stu-id="90a56-125">Work items are queued to I/O worker threads as asynchronous procedure calls (APC).</span></span> <span data-ttu-id="90a56-126">Debe poner en cola un elemento de trabajo en un subproceso de trabajo de e/s si debe ejecutarse en un subproceso que espera en un estado de alerta.</span><span class="sxs-lookup"><span data-stu-id="90a56-126">You should queue a work item to an I/O worker thread if it should be executed in a thread that waits in an alertable state.</span></span>

<span data-ttu-id="90a56-127">Un *subproceso de trabajo que no es de e/s* espera en los puertos de finalización de e/s.</span><span class="sxs-lookup"><span data-stu-id="90a56-127">A *non-I/O worker thread* waits on I/O completion ports.</span></span> <span data-ttu-id="90a56-128">El uso de subprocesos de trabajo que no son de e/s es más eficaz que el uso de subprocesos de trabajo de e/s.</span><span class="sxs-lookup"><span data-stu-id="90a56-128">Using non-I/O worker threads is more efficient than using I/O worker threads.</span></span> <span data-ttu-id="90a56-129">Por lo tanto, debe usar subprocesos de trabajo que no sean de e/s siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="90a56-129">Therefore, you should use non-I/O worker threads whenever possible.</span></span> <span data-ttu-id="90a56-130">Tanto las operaciones de e/s como los subprocesos de trabajo que no son de e/s no salen si hay solicitudes de e/s asincrónicas pendientes.</span><span class="sxs-lookup"><span data-stu-id="90a56-130">Both I/O and non-I/O worker threads do not exit if there are pending asynchronous I/O requests.</span></span> <span data-ttu-id="90a56-131">Los elementos de trabajo que inician solicitudes de finalización de e/s asincrónicas pueden usar ambos tipos de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="90a56-131">Both types of threads can be used by work items that initiate asynchronous I/O completion requests.</span></span> <span data-ttu-id="90a56-132">Sin embargo, evite publicar solicitudes de finalización de e/s asincrónicas en subprocesos de trabajo que no son de e/s si pueden tardar mucho tiempo en completarse.</span><span class="sxs-lookup"><span data-stu-id="90a56-132">However, avoid posting asynchronous I/O completion requests in non-I/O worker threads if they could take a long time to complete.</span></span>

<span data-ttu-id="90a56-133">Para usar la agrupación de subprocesos, los elementos de trabajo y todas las funciones a las que llaman deben ser seguros para el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="90a56-133">To use thread pooling, the work items and all the functions they call must be thread-pool safe.</span></span> <span data-ttu-id="90a56-134">Una función segura no supone que el subproceso que ejecuta es un subproceso dedicado o persistente.</span><span class="sxs-lookup"><span data-stu-id="90a56-134">A safe function does not assume that the thread executing it is a dedicated or persistent thread.</span></span> <span data-ttu-id="90a56-135">En general, debe evitar el uso de [almacenamiento local de subprocesos](thread-local-storage.md) o hacer una llamada asincrónica que requiera un subproceso persistente, como la función [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) .</span><span class="sxs-lookup"><span data-stu-id="90a56-135">In general, you should avoid using [thread local storage](thread-local-storage.md) or making an asynchronous call that requires a persistent thread, such as the [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) function.</span></span> <span data-ttu-id="90a56-136">Sin embargo, se puede llamar a estas funciones en un subproceso dedicado (creado por la aplicación) o poner en cola en un subproceso de trabajo persistente (mediante [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) con la \_ opción WT EXECUTEINPERSISTENTTHREAD).</span><span class="sxs-lookup"><span data-stu-id="90a56-136">However, such functions can be called on a dedicated thread (created by the application) or queued to a persistent worker thread (using [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) with the WT\_EXECUTEINPERSISTENTTHREAD option).</span></span>

## <a name="related-topics"></a><span data-ttu-id="90a56-137">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="90a56-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="90a56-138">E/s de alertas</span><span class="sxs-lookup"><span data-stu-id="90a56-138">Alertable I/O</span></span>](../fileio/alertable-i-o.md)
</dt> <dt>

[<span data-ttu-id="90a56-139">Llamadas a procedimientos asincrónicos</span><span class="sxs-lookup"><span data-stu-id="90a56-139">Asynchronous Procedure Calls</span></span>](../sync/asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="90a56-140">Puertos de finalización de e/s</span><span class="sxs-lookup"><span data-stu-id="90a56-140">I/O Completion Ports</span></span>](../fileio/i-o-completion-ports.md)
</dt> <dt>

[<span data-ttu-id="90a56-141">Grupos de subprocesos</span><span class="sxs-lookup"><span data-stu-id="90a56-141">Thread Pools</span></span>](thread-pools.md)
</dt> </dl>

 

 
