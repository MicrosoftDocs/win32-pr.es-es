---
description: Muestras y asignadores
ms.assetid: 1fbea741-f29a-4815-9885-94ca9cf4bb95
title: Muestras y asignadores
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6f9132ff2c70b5ade63f8853b5c03bacb7a25371
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/06/2021
ms.locfileid: "104552810"
---
# <a name="samples-and-allocators"></a><span data-ttu-id="e2777-103">Muestras y asignadores</span><span class="sxs-lookup"><span data-stu-id="e2777-103">Samples and Allocators</span></span>

<span data-ttu-id="e2777-104">Cuando un PIN entrega datos multimedia a otro PIN, no pasa un puntero directo al búfer de memoria.</span><span class="sxs-lookup"><span data-stu-id="e2777-104">When a pin delivers media data to another pin, it does not pass a direct pointer to the memory buffer.</span></span> <span data-ttu-id="e2777-105">En su lugar, proporciona un puntero a un objeto COM que administra la memoria.</span><span class="sxs-lookup"><span data-stu-id="e2777-105">Instead, it delivers a pointer to a COM object that manages the memory.</span></span> <span data-ttu-id="e2777-106">Este objeto, denominado *ejemplo multimedia*, expone la interfaz [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="e2777-106">This object, called a *media sample*, exposes the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="e2777-107">El PIN receptor accede al búfer de memoria llamando a métodos de **IMediaSample** , como [**IMediaSample:: GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample::FUL**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize)y [**IMediaSample:: GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span><span class="sxs-lookup"><span data-stu-id="e2777-107">The receiving pin accesses the memory buffer by calling **IMediaSample** methods, such as [**IMediaSample::GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample::GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize), and [**IMediaSample::GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span></span>

<span data-ttu-id="e2777-108">Los ejemplos siempre viajan hacia abajo, desde la clavija de salida a la clavija de entrada.</span><span class="sxs-lookup"><span data-stu-id="e2777-108">Samples always travel downstream, from output pin to input pin.</span></span> <span data-ttu-id="e2777-109">En el modelo de entrada, el PIN de salida proporciona una muestra llamando a [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) en el PIN de entrada.</span><span class="sxs-lookup"><span data-stu-id="e2777-109">In the push model, the output pin delivers a sample by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the input pin.</span></span> <span data-ttu-id="e2777-110">El PIN de entrada procesará los datos sincrónicamente (es decir, completamente dentro del método de **recepción** ) o los procesará de forma asincrónica en un subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="e2777-110">The input pin will either process the data synchronously (that is, completely inside the **Receive** method), or process it asynchronously on a worker thread.</span></span> <span data-ttu-id="e2777-111">El PIN de entrada puede bloquearse dentro del método de **recepción** , si tiene que esperar recursos.</span><span class="sxs-lookup"><span data-stu-id="e2777-111">The input pin is allowed to block within the **Receive** method, if it needs to wait for resources.</span></span>

<span data-ttu-id="e2777-112">Otro objeto COM, denominado *allocator*, es responsable de la creación y administración de los ejemplos de multimedia.</span><span class="sxs-lookup"><span data-stu-id="e2777-112">Another COM object, called an *allocator*, is responsible for creating and managing media samples.</span></span> <span data-ttu-id="e2777-113">Los asignadores exponen la interfaz [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="e2777-113">Allocators expose the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="e2777-114">Cada vez que un filtro necesita un ejemplo multimedia con un búfer vacío, llama al método [**IMemAllocator:: getBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , que devuelve un puntero al ejemplo.</span><span class="sxs-lookup"><span data-stu-id="e2777-114">Whenever a filter needs a media sample with an empty buffer, it calls the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, which returns a pointer to the sample.</span></span> <span data-ttu-id="e2777-115">Cada conexión de PIN comparte un asignador.</span><span class="sxs-lookup"><span data-stu-id="e2777-115">Every pin connection shares one allocator.</span></span> <span data-ttu-id="e2777-116">Cuando dos patillas se conectan, deciden qué filtro proporcionará el asignador.</span><span class="sxs-lookup"><span data-stu-id="e2777-116">When two pins connect, they decide which filter will provide the allocator.</span></span> <span data-ttu-id="e2777-117">Los pin también establecen propiedades en el asignador, como el número de búferes y el tamaño de cada búfer.</span><span class="sxs-lookup"><span data-stu-id="e2777-117">The pins also set properties on the allocator, such as the number of buffers and the size of each buffer.</span></span> <span data-ttu-id="e2777-118">(Para obtener más información, vea [cómo los filtros conectan](how-filters-connect.md) y [negocian los asignadores](negotiating-allocators.md)).</span><span class="sxs-lookup"><span data-stu-id="e2777-118">(For details, see [How Filters Connect](how-filters-connect.md) and [Negotiating Allocators](negotiating-allocators.md).)</span></span>

<span data-ttu-id="e2777-119">En la ilustración siguiente se muestran las relaciones entre el asignador, los ejemplos multimedia y el filtro.</span><span class="sxs-lookup"><span data-stu-id="e2777-119">The following illustration shows the relationships among the allocator, the media samples, and the filter.</span></span>

![ejemplos de medios y asignadores](images/mediasamples.png)

<span data-ttu-id="e2777-121">**Recuentos de referencias de ejemplo multimedia**</span><span class="sxs-lookup"><span data-stu-id="e2777-121">**Media Sample Reference Counts**</span></span>

<span data-ttu-id="e2777-122">Un asignador crea un grupo finito de ejemplos.</span><span class="sxs-lookup"><span data-stu-id="e2777-122">An allocator creates a finite pool of samples.</span></span> <span data-ttu-id="e2777-123">En cualquier momento, algunos ejemplos pueden estar en uso, mientras que otros están disponibles para las llamadas de **getBuffer** .</span><span class="sxs-lookup"><span data-stu-id="e2777-123">At any time, some samples may be in use, while others are available for **GetBuffer** calls.</span></span> <span data-ttu-id="e2777-124">El asignador utiliza el recuento de referencias para realizar un seguimiento de los ejemplos.</span><span class="sxs-lookup"><span data-stu-id="e2777-124">The allocator uses reference counting to keep track of the samples.</span></span> <span data-ttu-id="e2777-125">El método **getBuffer** devuelve un ejemplo con un recuento de referencias de 1.</span><span class="sxs-lookup"><span data-stu-id="e2777-125">The **GetBuffer** method returns a sample with a reference count of 1.</span></span> <span data-ttu-id="e2777-126">Si el recuento de referencias llega a cero, el ejemplo vuelve al grupo del asignador, donde se puede usar en la siguiente llamada a **getBuffer** .</span><span class="sxs-lookup"><span data-stu-id="e2777-126">If the reference count goes to zero, the sample goes back into the allocator's pool, where it can be used in the next **GetBuffer** call.</span></span> <span data-ttu-id="e2777-127">Siempre que el recuento de referencias se mantenga por encima de cero, el ejemplo no está disponible para **getBuffer**.</span><span class="sxs-lookup"><span data-stu-id="e2777-127">As long as the reference count remains above zero, the sample is not available to **GetBuffer**.</span></span> <span data-ttu-id="e2777-128">Si cada ejemplo que pertenece al asignador está en uso, el método **getBuffer** se bloquea hasta que haya una muestra disponible.</span><span class="sxs-lookup"><span data-stu-id="e2777-128">If every sample belonging to the allocator is in use, the **GetBuffer** method blocks until a sample becomes available.</span></span>

<span data-ttu-id="e2777-129">Por ejemplo, supongamos que un PIN de entrada recibe un ejemplo.</span><span class="sxs-lookup"><span data-stu-id="e2777-129">For example, suppose that an input pin receives a sample.</span></span> <span data-ttu-id="e2777-130">Si procesa el ejemplo sincrónicamente, dentro del método **Receive** , no incrementa el recuento de referencias.</span><span class="sxs-lookup"><span data-stu-id="e2777-130">If it processes the sample synchronously, inside the **Receive** method, it does not increment the reference count.</span></span> <span data-ttu-id="e2777-131">Una vez que **Receive** devuelve, la clavija de salida libera el ejemplo, el recuento de referencias llega a cero y el ejemplo vuelve al grupo del asignador.</span><span class="sxs-lookup"><span data-stu-id="e2777-131">After **Receive** returns, the output pin releases the sample, the reference count goes to zero, and the sample returns to the allocator's pool.</span></span> <span data-ttu-id="e2777-132">Por otro lado, si el PIN de entrada procesa el ejemplo en un subproceso de trabajo, incrementa el recuento de referencias antes de que se abandone el método de **recepción** .</span><span class="sxs-lookup"><span data-stu-id="e2777-132">On the other hand, if the input pin processes the sample on a worker thread, it increments the reference count before leaving the **Receive** method.</span></span> <span data-ttu-id="e2777-133">Ahora, el recuento de referencias es 2.</span><span class="sxs-lookup"><span data-stu-id="e2777-133">The reference count is now 2.</span></span> <span data-ttu-id="e2777-134">Cuando el PIN de salida libera el ejemplo, el recuento llega a 1; el ejemplo todavía no vuelve al grupo.</span><span class="sxs-lookup"><span data-stu-id="e2777-134">When the output pin releases the sample, the count goes to 1; the sample does not yet return to the pool.</span></span> <span data-ttu-id="e2777-135">Una vez que el subproceso de trabajo se realiza con el ejemplo, llama a **Release** para liberar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="e2777-135">After the worker thread is done with the sample, it calls **Release** to free the sample.</span></span> <span data-ttu-id="e2777-136">Ahora el ejemplo vuelve al grupo.</span><span class="sxs-lookup"><span data-stu-id="e2777-136">Now the sample returns to the pool.</span></span>

<span data-ttu-id="e2777-137">Cuando un PIN recibe un ejemplo, puede copiar los datos en otro ejemplo o puede modificar el ejemplo original y entregarlo al siguiente filtro.</span><span class="sxs-lookup"><span data-stu-id="e2777-137">When a pin receives a sample, it can copy the data to another sample, or it can modify the original sample and deliver that one to the next filter.</span></span> <span data-ttu-id="e2777-138">Potencialmente, un ejemplo puede viajar a la longitud completa del gráfico, y cada filtro llama a **AddRef** y **Release** a su vez.</span><span class="sxs-lookup"><span data-stu-id="e2777-138">Potentially, a sample can travel the entire length of the graph, each filter calling **AddRef** and **Release** in turn.</span></span> <span data-ttu-id="e2777-139">Por lo tanto, el PIN de salida nunca debe volver a usar un ejemplo después de llamar a **Receive**, ya que un filtro de nivel inferior puede estar usando el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="e2777-139">Therefore, the output pin must never re-use a sample after it calls **Receive**, because a downstream filter may be using the sample.</span></span> <span data-ttu-id="e2777-140">El PIN de salida siempre debe llamar a **getBuffer** para obtener un nuevo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="e2777-140">The output pin must always call **GetBuffer** to get a new sample.</span></span>

<span data-ttu-id="e2777-141">Este mecanismo reduce la cantidad de asignación de memoria, ya que los filtros vuelven a usar los mismos búferes.</span><span class="sxs-lookup"><span data-stu-id="e2777-141">This mechanism reduces the amount of memory allocation, because filters re-use the same buffers.</span></span> <span data-ttu-id="e2777-142">También impide que los filtros escriban accidentalmente sobre los datos que no se han procesado, porque el asignador mantiene una lista de ejemplos disponibles.</span><span class="sxs-lookup"><span data-stu-id="e2777-142">It also prevents filters from accidentally writing over data that has not been processed, because the allocator maintains a list of available samples.</span></span>

<span data-ttu-id="e2777-143">Un filtro puede utilizar asignadores independientes para la entrada y la salida.</span><span class="sxs-lookup"><span data-stu-id="e2777-143">A filter can use separate allocators for input and output.</span></span> <span data-ttu-id="e2777-144">Podría hacer esto si expande los datos de entrada (por ejemplo, descomprimiendo).</span><span class="sxs-lookup"><span data-stu-id="e2777-144">It might do this if it expands the input data (for example, by decompressing it).</span></span> <span data-ttu-id="e2777-145">Si el resultado no es mayor que la entrada, un filtro podría procesar los datos en su lugar, sin copiarlos en un nuevo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="e2777-145">If the output is no larger than the input, a filter might process the data in place, without copying it to a new sample.</span></span> <span data-ttu-id="e2777-146">En ese caso, dos o más conexiones de PIN pueden compartir un asignador.</span><span class="sxs-lookup"><span data-stu-id="e2777-146">In that case, two or more pin connections can share one allocator.</span></span>

<span data-ttu-id="e2777-147">**Confirmación y desconfirmación de asignadores**</span><span class="sxs-lookup"><span data-stu-id="e2777-147">**Committing and Decommitting Allocators**</span></span>

<span data-ttu-id="e2777-148">Cuando un filtro crea primero un asignador, el asignador no ha reservado ningún búfer de memoria.</span><span class="sxs-lookup"><span data-stu-id="e2777-148">When a filter first creates an allocator, the allocator has not reserved any memory buffers.</span></span> <span data-ttu-id="e2777-149">En este momento, se producirá un error en todas las llamadas al método **getBuffer** .</span><span class="sxs-lookup"><span data-stu-id="e2777-149">At this point, any calls to the **GetBuffer** method will fail.</span></span> <span data-ttu-id="e2777-150">Cuando se inicia el streaming, el PIN de salida llama a [**IMemAllocator:: commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), que confirma el asignador, lo que hace que se asigne memoria.</span><span class="sxs-lookup"><span data-stu-id="e2777-150">When streaming starts, the output pin calls [**IMemAllocator::Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), which commits the allocator, causing it to allocate memory.</span></span> <span data-ttu-id="e2777-151">Ahora, los pin pueden llamar a **getBuffer**.</span><span class="sxs-lookup"><span data-stu-id="e2777-151">Pins can now call **GetBuffer**.</span></span>

<span data-ttu-id="e2777-152">Cuando se detiene el streaming, el PIN llama a [**IMemAllocator::D ecommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), que anula la confirmación del asignador.</span><span class="sxs-lookup"><span data-stu-id="e2777-152">When streaming stops, the pin calls [**IMemAllocator::Decommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), which decommits the allocator.</span></span> <span data-ttu-id="e2777-153">Se producirá un error en todas las llamadas subsiguientes a **getBuffer** hasta que se confirme de nuevo el asignador.</span><span class="sxs-lookup"><span data-stu-id="e2777-153">All subsequent calls to **GetBuffer** fail until the allocator is committed again.</span></span> <span data-ttu-id="e2777-154">Además, si alguna llamada a **getBuffer** está bloqueada actualmente a la espera de un ejemplo, devolverá inmediatamente un código de error.</span><span class="sxs-lookup"><span data-stu-id="e2777-154">Also, if any calls to **GetBuffer** are currently blocked waiting for a sample, they immediately return a failure code.</span></span> <span data-ttu-id="e2777-155">El método de **desconfirmación** puede liberar o no la memoria, en función de la implementación.</span><span class="sxs-lookup"><span data-stu-id="e2777-155">The **Decommit** method may or may not free the memory, depending on the implementation.</span></span> <span data-ttu-id="e2777-156">Por ejemplo, la clase [**CMemAllocator**](cmemallocator.md) espera hasta que su método de destructor libere memoria.</span><span class="sxs-lookup"><span data-stu-id="e2777-156">For example, the [**CMemAllocator**](cmemallocator.md) class waits until its destructor method to free memory.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e2777-157">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="e2777-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e2777-158">Flujo de datos en el gráfico de filtros</span><span class="sxs-lookup"><span data-stu-id="e2777-158">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 
