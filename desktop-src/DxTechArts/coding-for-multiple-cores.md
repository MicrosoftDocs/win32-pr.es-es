---
title: Codificación para varios núcleos en Xbox 360 y Windows
description: En este tema se proporcionan consejos sobre cómo empezar a trabajar con la programación multiproceso.
ms.assetid: 661f13a6-c73d-8513-2bad-0ef9d1a361a0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 75899dacdfba829fc1a83e9393e6aa58574c9f30
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/21/2020
ms.locfileid: "104421603"
---
# <a name="coding-for-multicore-on-xbox-360-and-windows"></a><span data-ttu-id="c3c9b-103">Codificación para varios núcleos en Xbox 360 y Windows</span><span class="sxs-lookup"><span data-stu-id="c3c9b-103">Coding for multicore on Xbox 360 and Windows</span></span>

<span data-ttu-id="c3c9b-104">Durante años, el rendimiento de los procesadores ha aumentado de forma oportuna, y los juegos y otros programas han aprovechado las ventajas de este aumento de la capacidad sin tener que hacer nada especial.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-104">For years the performance of processors has increased steadily, and games and other programs have reaped the benefits of this increasing power without having to do anything special.</span></span>

<span data-ttu-id="c3c9b-105">Las reglas han cambiado.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-105">The rules have changed.</span></span> <span data-ttu-id="c3c9b-106">El rendimiento de los núcleos de procesador único ahora está aumentando muy lentamente, en caso de que haya.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-106">The performance of single processor cores is now increasing very slowly, if at all.</span></span> <span data-ttu-id="c3c9b-107">Sin embargo, la potencia de la informática disponible en un equipo o consola típicos sigue creciendo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-107">However, the computing power available in a typical computer or console continues to grow.</span></span> <span data-ttu-id="c3c9b-108">La diferencia es que la mayor parte de esta mejora del rendimiento ahora proviene de tener varios núcleos de procesador en un solo equipo, a menudo en un solo chip.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-108">The difference is that most of this performance gain now comes from having multiple processor cores in a single machine, often in a single chip.</span></span> <span data-ttu-id="c3c9b-109">La CPU Xbox 360 tiene tres núcleos de procesador en un chip y, aproximadamente, el 70 por ciento de los procesadores de PC vendidos en 2006 eran de varios núcleos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-109">The Xbox 360 CPU has three processor cores on one chip, and roughly 70 percent of PC processors sold in 2006 were multi-core.</span></span>

<span data-ttu-id="c3c9b-110">Los aumentos en la potencia de procesamiento disponible son tan drásticos como en el pasado, pero ahora los desarrolladores tienen que escribir código multiproceso para poder usar esta capacidad.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-110">The increases in available processing power are just as dramatic as in the past, but now developers have to write multithreaded code in order to use this power.</span></span> <span data-ttu-id="c3c9b-111">La programación multiproceso aporta nuevos desafíos de diseño y programación.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-111">Multi-threaded programming brings with it new design and programming challenges.</span></span> <span data-ttu-id="c3c9b-112">En este tema se proporcionan consejos sobre cómo empezar a trabajar con la programación multiproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-112">This topic gives some advice on how to get started with multithreaded programming.</span></span>

## <a name="the-importance-of-good-design"></a><span data-ttu-id="c3c9b-113">La importancia de un buen diseño</span><span class="sxs-lookup"><span data-stu-id="c3c9b-113">The Importance of Good Design</span></span>

<span data-ttu-id="c3c9b-114">Un buen diseño de programas multiproceso es fundamental, pero puede ser muy difícil.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-114">Good multithreaded program design is critical, but it can be very difficult.</span></span> <span data-ttu-id="c3c9b-115">Si mueve sus principales sistemas de juegos a distintos subprocesos, probablemente encontrará que cada subproceso dedica la mayor parte del tiempo esperando a los demás subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-115">If you haphazardly move your major game systems onto different threads, you will likely find that each thread spends most of its time waiting on the other threads.</span></span> <span data-ttu-id="c3c9b-116">Este tipo de diseño conduce a una mayor complejidad y a un esfuerzo de depuración importante, sin apenas aumento de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-116">This type of design leads to increased complexity and significant debugging effort, with virtually no performance gain.</span></span>

<span data-ttu-id="c3c9b-117">Cada vez que los subprocesos tienen que sincronizar o compartir datos, existe la posibilidad de daños en los datos, la sobrecarga de la sincronización, los interbloqueos y la complejidad.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-117">Every time that threads have to synchronize or share data there is the potential for data corruption, synchronization overhead, deadlocks, and complexity.</span></span> <span data-ttu-id="c3c9b-118">Por lo tanto, el diseño multiproceso debe documentar claramente cada sincronización y punto de comunicación, y debe minimizar estos puntos tanto como sea posible.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-118">Therefore, your multithreaded design needs to clearly document every synchronization and communication point, and it should minimize such points as much as possible.</span></span> <span data-ttu-id="c3c9b-119">Si los subprocesos necesitan comunicarse, el esfuerzo de codificación aumentará, lo que puede reducir la productividad si afecta demasiado código fuente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-119">Where threads need to communicate, coding effort will increase, which can lower productivity if it affects too much source code.</span></span>

<span data-ttu-id="c3c9b-120">El objetivo de diseño más sencillo para el multithreading es dividir el código en partes independientes grandes.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-120">The simplest design goal for multithreading is to break up the code into large independent pieces.</span></span> <span data-ttu-id="c3c9b-121">Si, a continuación, restringe estas partes para que se comuniquen unas pocas veces por fotograma, verá un aumento significativo del multithreading, sin complejidad excesiva.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-121">If you then restrict these pieces to communicating just a few times per frame, you will see significant speedup from multithreading, without undue complexity.</span></span>

## <a name="typical-threaded-tasks"></a><span data-ttu-id="c3c9b-122">Tareas de subprocesos típicas</span><span class="sxs-lookup"><span data-stu-id="c3c9b-122">Typical Threaded Tasks</span></span>

<span data-ttu-id="c3c9b-123">Algunos tipos de tareas han demostrado someterse a la depuración de subprocesos independientes.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-123">A few types of tasks have proven amenable to being put onto separate threads.</span></span> <span data-ttu-id="c3c9b-124">La lista siguiente no pretende ser exhaustiva, pero debe aportar algunas ideas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-124">The following list is not intended to be exhaustive, but should give some ideas.</span></span>

### <a name="rendering"></a><span data-ttu-id="c3c9b-125">Representación</span><span class="sxs-lookup"><span data-stu-id="c3c9b-125">Rendering</span></span>

<span data-ttu-id="c3c9b-126">La representación, que puede incluir recorrer el gráfico de escena o, posiblemente, llamar solo a las funciones D3D, suele tener en cuenta un 50 por ciento o más de tiempo de CPU.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-126">Rendering — which may include walking the scene graph or, possibly, only calling D3D functions — often accounts for 50 percent or more of CPU time.</span></span> <span data-ttu-id="c3c9b-127">Por lo tanto, el traslado de la representación a otro subproceso puede tener ventajas significativas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-127">Therefore, moving rendering to another thread can have significant benefits.</span></span> <span data-ttu-id="c3c9b-128">El subproceso de actualización puede rellenar algún tipo de búfer de descripción de representación, que puede procesar el subproceso de representación.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-128">The update thread can fill in some sort of render description buffer, which the rendering thread can then process.</span></span>

<span data-ttu-id="c3c9b-129">El subproceso de actualización del juego siempre es un fotograma por delante del subproceso de representación, lo que significa que toma dos fotogramas antes de que las acciones del usuario se muestren en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-129">The game update thread is always one frame ahead of the render thread, which means that it takes two frames before user actions show up on the screen.</span></span> <span data-ttu-id="c3c9b-130">Aunque esta mayor latencia puede ser un problema, la mayor velocidad de fotogramas de la división de la carga de trabajo generalmente mantiene la latencia total aceptable.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-130">Although this increased latency can be a problem, the increased frame rate from splitting up the workload generally keeps the total latency acceptable.</span></span>

<span data-ttu-id="c3c9b-131">En la mayoría de los casos, toda la representación se realiza en un único subproceso, pero es un subproceso diferente de la actualización del juego.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-131">In most cases all rendering is still done on a single thread, but it is a different thread from the game update.</span></span>

<span data-ttu-id="c3c9b-132">La \_ marca multiproceso D3DCREATE se usa a veces para permitir la representación en un subproceso y la creación de recursos en otros subprocesos; esta marca se omite en Xbox 360 y debe evitar usarla en Windows.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-132">The D3DCREATE\_MULTITHREADED flag is sometimes used to allow rendering on one thread and resource creation on other threads; this flag is ignored on Xbox 360, and you should avoid using it on Windows.</span></span> <span data-ttu-id="c3c9b-133">En Windows, la especificación de esta marca obliga a D3D a gastar una cantidad significativa de tiempo en la sincronización, lo que ralentiza el subproceso de representación.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-133">On Windows, specifying this flag forces D3D to spend a significant amount of time on synchronization, thus slowing down the render thread.</span></span>

### <a name="file-decompression"></a><span data-ttu-id="c3c9b-134">Descompresión de archivos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-134">File Decompression</span></span>

<span data-ttu-id="c3c9b-135">Los tiempos de carga siempre son demasiado largos y el streaming de datos en memoria sin afectar a la velocidad de fotogramas puede ser desafiante.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-135">Load times are always too long, and streaming data into memory without affecting the frame rate can be challenging.</span></span> <span data-ttu-id="c3c9b-136">Si todos los datos se comprimen agresivamente en el disco, es menos probable que la velocidad de transferencia de datos del disco duro o del disco óptico sea un factor limitador.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-136">If all data is aggressively compressed on disc, then data transfer speed from the hard drive or optical disc is less likely to be a limiting factor.</span></span> <span data-ttu-id="c3c9b-137">En un procesador de un solo subproceso, normalmente no hay suficiente tiempo de procesador disponible para la compresión a fin de ayudar a los tiempos de carga.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-137">On a single-threaded processor, there is usually not enough processor time available for compression to help load times.</span></span> <span data-ttu-id="c3c9b-138">Sin embargo, en un sistema con varios procesadores, la descompresión de archivos utiliza ciclos de CPU que de otro modo se desperdiciarían; mejora los tiempos de carga y el streaming; y ahorra espacio en el disco.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-138">On a multiprocessor system, however, file decompression uses CPU cycles that would otherwise be wasted; it improves load times and streaming; and it saves space on the disc.</span></span>

<span data-ttu-id="c3c9b-139">No utilice la descompresión de archivos como reemplazo de procesamiento que se debe realizar durante la producción.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-139">Do not use file decompression as a replacement for processing that should be done during production.</span></span> <span data-ttu-id="c3c9b-140">Por ejemplo, si se dedica un subproceso adicional al análisis de datos XML durante la carga de nivel, no se utiliza multithreading para mejorar la experiencia del jugador.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-140">For instance, if you devote an extra thread to parsing XML data during level loading, you are not using multithreading to improve the player's experience.</span></span>

<span data-ttu-id="c3c9b-141">Al usar un subproceso de descompresión de archivos, debe seguir usando e/s asincrónica de archivos y lecturas grandes para maximizar la eficacia de la lectura de datos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-141">When using a file decompression thread, you should still use asynchronous file I/O and large reads in order to maximize data-reading efficiency.</span></span>

### <a name="graphics-fluff"></a><span data-ttu-id="c3c9b-142">Gráficos desenfadados</span><span class="sxs-lookup"><span data-stu-id="c3c9b-142">Graphics Fluff</span></span>

<span data-ttu-id="c3c9b-143">Hay muchos niceties gráficos que mejoran el aspecto del juego pero no son estrictamente necesarios.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-143">There are many graphical niceties that improve the look of the game but aren't strictly necessary.</span></span> <span data-ttu-id="c3c9b-144">Esto incluye cosas como animaciones en la nube generadas por procedimientos, simulaciones de tela y pelo, ondas de procedimiento, vegetación de procedimientos, más partículas o física sin juegos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-144">These include things like procedurally generated cloud animations, cloth and hair simulations, procedural waves, procedural vegetation, more particles, or non-gameplay physics.</span></span>

<span data-ttu-id="c3c9b-145">Dado que estos efectos no afectan al juego, no causan problemas de sincronización complicados; pueden sincronizarse con otros subprocesos una vez por fotograma o con menos frecuencia.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-145">Because these effects don't affect gameplay, they don't cause tricky synchronization problems—they can synchronize with the other threads once per frame or less often.</span></span> <span data-ttu-id="c3c9b-146">Además, en juegos para Windows estos efectos pueden agregar valor para los jugadores con CPU de varios núcleos, mientras que se omiten de forma silenciosa en equipos de un solo núcleo, lo que proporciona una manera sencilla de escalar a través de una amplia gama de funcionalidades.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-146">Additionally, on games for Windows these effects can add value for gamers with multicore CPUs, while silently being omitted on single-core computers, thus giving an easy way of scaling across a wide range of capabilities.</span></span>

### <a name="physics"></a><span data-ttu-id="c3c9b-147">Física</span><span class="sxs-lookup"><span data-stu-id="c3c9b-147">Physics</span></span>

<span data-ttu-id="c3c9b-148">A menudo, no se puede colocar la física en un subproceso independiente para ejecutarse en paralelo con la actualización del juego, ya que la actualización del juego normalmente requiere inmediatamente los resultados de los cálculos físicos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-148">Physics often cannot be put onto a separate thread to run in parallel with the game update because the game update usually requires the results of the physics calculations immediately.</span></span> <span data-ttu-id="c3c9b-149">La alternativa para la física multithreading es ejecutarla en varios procesadores.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-149">The alternative for multithreading physics is to run it on multiple processors.</span></span> <span data-ttu-id="c3c9b-150">Aunque esto se puede hacer, es una tarea compleja que requiere un acceso frecuente a las estructuras de datos compartidas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-150">Although this can be done, it is a complex task requiring frequent access to shared data structures.</span></span> <span data-ttu-id="c3c9b-151">Si puede mantener la carga de trabajo física lo suficientemente baja como para caber en el subproceso principal, el trabajo será más sencillo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-151">If you can keep your physics workload low enough to fit on the main thread, your job will be simpler.</span></span>

<span data-ttu-id="c3c9b-152">Están disponibles las bibliotecas que admiten la ejecución de física en varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-152">Libraries that support running physics on multiple threads are available.</span></span> <span data-ttu-id="c3c9b-153">Sin embargo, esto puede dar lugar a un problema: cuando el juego se está ejecutando física, usa muchos subprocesos, pero el resto del tiempo usa pocos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-153">However, this can lead to a problem: when your game is running physics, it uses many threads, but the rest of the time it uses few.</span></span> <span data-ttu-id="c3c9b-154">La ejecución de la física en varios subprocesos requerirá abordar esto para que la carga de trabajo se distribuya uniformemente a través del marco.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-154">Running physics on multiple threads will require addressing this so that the workload is distributed evenly over the frame.</span></span> <span data-ttu-id="c3c9b-155">Si escribe un motor físico multiproceso, debe prestar especial atención a todas las estructuras de datos, los puntos de sincronización y el equilibrio de carga.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-155">If you write a multithreaded physics engine, you must pay careful attention to all of your data structures, synchronization points, and load balancing.</span></span>

## <a name="example-multithreaded-designs"></a><span data-ttu-id="c3c9b-156">Diseños multiproceso de ejemplo</span><span class="sxs-lookup"><span data-stu-id="c3c9b-156">Example Multithreaded Designs</span></span>

<span data-ttu-id="c3c9b-157">Los juegos para Windows deben ejecutarse en equipos con un número diferente de núcleos de CPU.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-157">Games for Windows need to run on computers with different numbers of CPU cores.</span></span> <span data-ttu-id="c3c9b-158">La mayoría de las máquinas de juegos todavía tienen un solo núcleo, aunque el número de máquinas con dos núcleos crece rápidamente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-158">Most game machines still have only one core, although the number of two-core machines is growing rapidly.</span></span> <span data-ttu-id="c3c9b-159">Un juego típico para Windows podría interrumpir su carga de trabajo en un subproceso para su actualización y representación, con subprocesos de trabajo opcionales para agregar funcionalidad adicional.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-159">A typical game for Windows might break its workload into one thread for update and rendering, with optional worker threads for adding extra functionality.</span></span> <span data-ttu-id="c3c9b-160">Además, es probable que se utilicen algunos subprocesos en segundo plano para realizar operaciones de e/s de archivos y redes.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-160">In addition, some background threads for doing file I/O and networking would probably be used.</span></span> <span data-ttu-id="c3c9b-161">En la figura 1 se muestran los subprocesos, junto con los puntos de transferencia de datos principales.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-161">Figure 1 shows the threads, together with the main data transfer points.</span></span>

<span data-ttu-id="c3c9b-162">**Figura 1. Diseño de subprocesos en un juego para Windows**</span><span class="sxs-lookup"><span data-stu-id="c3c9b-162">**Figure 1. Threading design in a game for Windows**</span></span>

![diseño de subprocesos en un juego para Windows](images/coding-for-multiple-cores-1.gif)

<span data-ttu-id="c3c9b-164">Un juego de Xbox 360 típico puede usar subprocesos de software intensivos de CPU adicionales, por lo que podría dividir su carga de trabajo en un subproceso de actualización, un subproceso de representación y tres subprocesos de trabajo, como se muestra en la figura 2.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-164">A typical Xbox 360 game can use additional CPU-intensive software threads, so it might break up its workload into an update thread, rendering thread, and three worker threads, as shown in Figure 2.</span></span>

<span data-ttu-id="c3c9b-165">**Figura 2. Diseño de subprocesos en un juego para Xbox 360**</span><span class="sxs-lookup"><span data-stu-id="c3c9b-165">**Figure 2. Threading design in a game for Xbox 360**</span></span>

![diseño de subprocesos en un juego para Xbox 360](images/coding-for-multiple-cores-2.gif)

<span data-ttu-id="c3c9b-167">A excepción de las operaciones de e/s de archivos y las redes, todas estas tareas tienen el potencial de ser lo suficientemente intensivo de la CPU como para beneficiarse de su propio subproceso de hardware.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-167">With the exception of file I/O and networking, these tasks all have the potential to be CPU-intensive enough to benefit from being on their own hardware thread.</span></span> <span data-ttu-id="c3c9b-168">Estas tareas también tienen la posibilidad de ser lo suficientemente independientes como para que puedan ejecutarse en todo un marco sin comunicarse.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-168">These tasks also have the potential to be independent enough that they can run for an entire frame without communicating.</span></span>

<span data-ttu-id="c3c9b-169">El subproceso de actualización del juego administra la entrada del controlador, AI y física, y prepara instrucciones para los otros cuatro subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-169">The game update thread manages controller input, AI, and physics, and prepares instructions for the other four threads.</span></span> <span data-ttu-id="c3c9b-170">Estas instrucciones se colocan en búferes propiedad del subproceso de actualización del juego, por lo que no se requiere ninguna sincronización a medida que se generan las instrucciones.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-170">These instructions are placed into buffers owned by the game update thread, so no synchronization is required as the instructions are generated.</span></span>

<span data-ttu-id="c3c9b-171">Al final del marco, el subproceso de actualización del juego entrega los búferes de instrucciones a los otros cuatro subprocesos y, a continuación, comienza a trabajar en el siguiente fotograma, rellenando otro conjunto de búferes de instrucciones.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-171">At the end of the frame, the game update thread hands off the instruction buffers to the four other threads, and then starts working on the next frame, filling in another set of instruction buffers.</span></span>

<span data-ttu-id="c3c9b-172">Dado que los subprocesos de actualización y representación funcionan en lógico entre sí, sus búferes de comunicación son simplemente de doble búfer: en un momento dado, el subproceso de actualización está llenando un búfer mientras el subproceso de representación está leyendo desde el otro.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-172">Because the update and rendering threads work in lockstep with each other, their communication buffers are simply double buffered: at any given time, the update thread is filling one buffer while the render thread is reading from the other.</span></span>

<span data-ttu-id="c3c9b-173">Los otros subprocesos de trabajo no están necesariamente asociados a la velocidad de fotogramas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-173">The other worker threads are not necessarily tied to the frame rate.</span></span> <span data-ttu-id="c3c9b-174">La descompresión de un fragmento de datos puede tardar mucho menos que un fotograma o puede llevar muchos fotogramas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-174">Decompressing a piece of data may take much less than a frame, or it may take many frames.</span></span> <span data-ttu-id="c3c9b-175">Incluso es posible que no sea necesario ejecutar la simulación de tela y pelo exactamente en la velocidad de fotogramas, ya que es posible que las actualizaciones menos frecuentes sean bastante aceptables.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-175">Even the cloth and hair simulation may not need to run exactly at the frame rate because less frequent updates may be quite acceptable.</span></span> <span data-ttu-id="c3c9b-176">Por lo tanto, estos tres subprocesos necesitan estructuras de datos diferentes para comunicarse con el subproceso de actualización y el subproceso de representación.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-176">Therefore, these three threads need different data structures to communicate with the update thread and the render thread.</span></span> <span data-ttu-id="c3c9b-177">Cada una de ellas necesita una cola de entrada que puede contener solicitudes de trabajo y el subproceso de representación necesita una cola de datos que pueda contener los resultados generados por los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-177">They each need an input queue that can hold work requests, and the render thread needs a data queue that can hold the results produced by the threads.</span></span> <span data-ttu-id="c3c9b-178">Al final de cada fotograma, el subproceso de actualización agregará un bloque de solicitudes de trabajo a las colas de subprocesos de trabajo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-178">At the end of each frame the update thread will add a block of work requests to worker threads' queues.</span></span> <span data-ttu-id="c3c9b-179">La adición a la lista solo una vez por fotograma garantiza que el subproceso de actualización minimice la sobrecarga de sincronización.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-179">Adding to the list just once per frame ensures that the update thread minimizes the synchronization overhead.</span></span> <span data-ttu-id="c3c9b-180">Cada uno de los subprocesos de trabajo extrae las asignaciones de la cola de trabajo lo más rápido posible, mediante un bucle que tiene un aspecto similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="c3c9b-180">Each of the worker threads pulls assignments from the work queue as quickly as it can, using a loop that looks something like this:</span></span>


```C++
for(;;)
{
    while( WorkQueueNotEmpty() )
    {
        RemoveWorkItemFromWorkQueue();
        ProcessWorkItem();
        PutResultInDataQueue();
    }
    WaitForSingleObject( hWorkSemaphore ); 
}
```



<span data-ttu-id="c3c9b-181">Dado que los datos van de los subprocesos de actualización a los subprocesos de trabajo y, a continuación, al subproceso de representación, puede haber un retraso de tres o más fotogramas antes de que algunas acciones lo hagan en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-181">Because the data goes from the update threads to the worker threads and then to the render thread, there can be a delay of three or more frames before some actions make it to the screen.</span></span> <span data-ttu-id="c3c9b-182">Sin embargo, si asigna tareas tolerantes a la latencia a los subprocesos de trabajo, esto no debería ser un problema.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-182">However, if you assign latency-tolerant tasks to the worker threads, then this should not be a problem.</span></span>

<span data-ttu-id="c3c9b-183">Un diseño alternativo sería tener varios subprocesos de trabajo que dibujan desde la misma cola de trabajo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-183">An alternate design would be to have several worker threads all drawing from the same work queue.</span></span> <span data-ttu-id="c3c9b-184">Esto daría un equilibrio de carga automático y haría más probable que todos los subprocesos de trabajo estuvieran ocupados.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-184">This would give automatic load balancing and would make it more likely that all of the worker threads would stay busy.</span></span>

<span data-ttu-id="c3c9b-185">El subproceso de actualización del juego debe tener cuidado de no dar demasiado trabajo a los subprocesos de trabajo o, de lo contrario, las colas de trabajo pueden crecer continuamente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-185">The game update thread must take care to not give too much work to the worker threads, or else the work queues may continuously grow.</span></span> <span data-ttu-id="c3c9b-186">La forma en que el subproceso de actualización administra esto depende del tipo de tareas que realicen los subprocesos de trabajo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-186">How the update thread manages this depends on what sort of tasks the worker threads are doing.</span></span>

## <a name="simultaneous-multithreading-and-number-of-threads"></a><span data-ttu-id="c3c9b-187">Multithreading simultáneo y número de subprocesos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-187">Simultaneous Multithreading and Number of Threads</span></span>

<span data-ttu-id="c3c9b-188">Todos los subprocesos no se crean igual.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-188">All threads are not created equal.</span></span> <span data-ttu-id="c3c9b-189">Dos subprocesos de hardware pueden estar en chips independientes, en el mismo chip o incluso en el mismo núcleo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-189">Two hardware threads might be on separate chips, on the same chip, or even on the same core.</span></span> <span data-ttu-id="c3c9b-190">La configuración más importante para que los programadores de juegos conozcan es dos subprocesos de hardware en un núcleo: tecnología multithreading (SMT) simultánea o tecnología de Hyper-Threading (tecnología HT).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-190">The most important configuration for game programmers to be aware of is two hardware threads on one core—Simultaneous Multi-Threading (SMT) or Hyper-Threading Technology (HT Technology).</span></span>

<span data-ttu-id="c3c9b-191">Los subprocesos de la tecnología SMT o HT comparten los recursos del núcleo de CPU.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-191">SMT or HT Technology threads share the resources of the CPU core.</span></span> <span data-ttu-id="c3c9b-192">Dado que comparten las unidades de ejecución, la velocidad máxima desde la ejecución de dos subprocesos en lugar de uno suele ser de 10 a 20 por ciento, en lugar del 100 por ciento que es posible desde dos subprocesos de hardware independientes.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-192">Because they share the execution units, the maximum speedup from running two threads instead of one is typically 10 to 20 percent, instead of the 100 percent that is possible from two independent hardware threads.</span></span>

<span data-ttu-id="c3c9b-193">Los subprocesos más importantes de la tecnología SMT o HT comparten la instrucción L1 y las cachés de datos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-193">More significantly, SMT or HT Technology threads share the L1 instruction and data caches.</span></span> <span data-ttu-id="c3c9b-194">Si sus patrones de acceso a memoria son incompatibles, pueden acabar luchando en la memoria caché y producir muchos errores de caché.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-194">If their memory access patterns are incompatible, they can end up fighting over the cache and causing many cache misses.</span></span> <span data-ttu-id="c3c9b-195">En el peor de los casos, el rendimiento total del núcleo de CPU se puede reducir realmente cuando se ejecuta un segundo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-195">In the worst case, the total performance for the CPU core can actually decrease when a second thread is run.</span></span> <span data-ttu-id="c3c9b-196">En Xbox 360, se trata de un problema bastante sencillo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-196">On Xbox 360, this is a fairly simple problem.</span></span> <span data-ttu-id="c3c9b-197">La configuración de la consola Xbox 360 es conocida: tres núcleos de CPU, cada uno con dos subprocesos de hardware, y los desarrolladores asignan los subprocesos de software a subprocesos de CPU específicos y pueden medir para ver si su diseño de subprocesos les proporciona un rendimiento adicional.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-197">The configuration of the Xbox 360 is known—three CPU cores each with two hardware threads—and developers assign their software threads to specific CPU threads and can measure to see whether their threading design gives them extra performance.</span></span>

<span data-ttu-id="c3c9b-198">En Windows, la situación es más complicada.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-198">On Windows, the situation is more complicated.</span></span> <span data-ttu-id="c3c9b-199">El número de subprocesos y su configuración variarán de un equipo a un equipo, y la determinación de la configuración es complicada.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-199">The number of threads and their configuration will vary from computer to computer, and determining the configuration is complicated.</span></span> <span data-ttu-id="c3c9b-200">La función [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) proporciona información acerca de la relación entre distintos subprocesos de hardware, y esta función está disponible en Windows Vista, Windows 7 y Windows XP SP3.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-200">The function [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) gives information about the relationship between different hardware threads, and this function is available on Windows Vista, Windows 7, and Windows XP SP3.</span></span> <span data-ttu-id="c3c9b-201">Por lo tanto, por ahora tiene que usar la instrucción CPUID y los algoritmos proporcionados por Intel y AMD para decidir el número de subprocesos "reales" que tiene disponibles.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-201">Therefore, for now you have to use the CPUID instruction and the algorithms given by Intel and AMD in order to decide how many "real" threads you have available.</span></span> <span data-ttu-id="c3c9b-202">Vea las referencias para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-202">See the references for more information.</span></span>

<span data-ttu-id="c3c9b-203">El ejemplo CoreDetection en el SDK de DirectX contiene código de ejemplo que usa la función [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) o la instrucción CPUID para devolver la topología de núcleo de CPU.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-203">The CoreDetection sample in the DirectX SDK contains sample code that uses the [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) function or the CPUID instruction to return the CPU core topology.</span></span> <span data-ttu-id="c3c9b-204">La instrucción CPUID se utiliza si **GetLogicalProcessorInformation** no se admite en la plataforma actual.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-204">The CPUID instruction is used if **GetLogicalProcessorInformation** is not supported on the current platform.</span></span> <span data-ttu-id="c3c9b-205">CoreDetection se puede encontrar en las siguientes ubicaciones:</span><span class="sxs-lookup"><span data-stu-id="c3c9b-205">CoreDetection can be found in the following locations:</span></span>

<dl> <dt>

<span data-ttu-id="c3c9b-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Fuentes</span><span class="sxs-lookup"><span data-stu-id="c3c9b-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Source:</span></span>
</dt> <dd>

<span data-ttu-id="c3c9b-207">Raíz del SDK de *DirectX* \\ Ejemplos de \\ C++ \\ varios \\ CoreDetection</span><span class="sxs-lookup"><span data-stu-id="c3c9b-207">*DirectX SDK root*\\Samples\\C++\\Misc\\CoreDetection</span></span>

</dd> <dt>

<span data-ttu-id="c3c9b-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Ejecutable</span><span class="sxs-lookup"><span data-stu-id="c3c9b-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Executable:</span></span>
</dt> <dd>

<span data-ttu-id="c3c9b-209">Raíz del SDK de *DirectX* \\ Ejemplos deCoreDetection.exe de \\ C++ \\ Misc \\ \\</span><span class="sxs-lookup"><span data-stu-id="c3c9b-209">*DirectX SDK root*\\Samples\\C++\\Misc\\Bin\\CoreDetection.exe</span></span>

</dd> </dl>

<span data-ttu-id="c3c9b-210">La suposición más segura es que no haya más de un subproceso con un uso intensivo de la CPU por núcleo de CPU.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-210">The safest assumption is to have no more than one CPU-intensive thread per CPU core.</span></span> <span data-ttu-id="c3c9b-211">Tener más subprocesos con un uso intensivo de la CPU que los núcleos de CPU ofrece poca o ninguna ventaja, y aporta la sobrecarga y complejidad adicionales de los subprocesos adicionales.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-211">Having more CPU-intensive threads than CPU cores gives little or no benefits, and brings the extra overhead and complexity of additional threads.</span></span>

## <a name="creating-threads"></a><span data-ttu-id="c3c9b-212">Crear subprocesos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-212">Creating Threads</span></span>

<span data-ttu-id="c3c9b-213">La creación de subprocesos es una operación bastante sencilla, pero hay muchos errores posibles.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-213">Creating threads is a fairly simple operation, but there are many potential errors.</span></span> <span data-ttu-id="c3c9b-214">En el código siguiente se muestra la forma adecuada de crear un subproceso, esperar a que finalice y, a continuación, limpiar.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-214">The code below shows the proper way of creating a thread, waiting for it to terminate, and then cleaning up.</span></span>


```C++
const int stackSize = 65536;
HANDLE hThread = (HANDLE)_beginthreadex( 0, stackSize,
            ThreadFunction, 0, 0, 0 );
// Do work on main thread here.
// Wait for child thread to complete
WaitForSingleObject( hThread, INFINITE );
CloseHandle( hThread );

...

unsigned __stdcall ThreadFunction( void* data )
{
#if _XBOX_VER >= 200
    // On Xbox 360 you must explicitly assign
    // software threads to hardware threads.
    XSetThreadProcessor( GetCurrentThread(), 2 );
#endif
    // Do child thread work here.
    return 0;
}
```



<span data-ttu-id="c3c9b-215">Al crear un subproceso, tiene la opción de especificar el tamaño de la pila para el subproceso secundario, o bien especificar cero, en cuyo caso el subproceso secundario heredará el tamaño de la pila del subproceso primario.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-215">When you create a thread, you have the option to specify the stack size for the child thread, or specify zero, in which case the child thread will inherit the parent thread's stack size.</span></span> <span data-ttu-id="c3c9b-216">En la consola Xbox 360, donde las pilas están confirmadas totalmente cuando se inicia el subproceso, si se especifica cero, se puede desperdiciar una cantidad considerable de memoria, ya que muchos subprocesos secundarios no necesitarán tanta pila como el elemento primario.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-216">On Xbox 360, where stacks are fully committed when the thread starts, specifying zero can waste significant memory, because many child threads will not need as much stack as the parent.</span></span> <span data-ttu-id="c3c9b-217">En Xbox 360 también es importante que el tamaño de la pila sea un múltiplo de 64 KB.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-217">On Xbox 360 it is also important that the stack size be a multiple of 64-KB.</span></span>

<span data-ttu-id="c3c9b-218">Si usa la función [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) para crear subprocesos, el tiempo de ejecución de C/C++ (CRT) no se inicializará correctamente en Windows.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-218">If you use the [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) function to create threads, then the C/C++ runtime (CRT) will not get properly initialized on Windows.</span></span> <span data-ttu-id="c3c9b-219">En su lugar, se recomienda usar la función [**\_ BEGINTHREADEX**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) de CRT.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-219">We recommend that you use the CRT [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) function instead.</span></span>

<span data-ttu-id="c3c9b-220">El valor devuelto de [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) o [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) es un identificador de subproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-220">The return value from [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) or [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) is a thread handle.</span></span> <span data-ttu-id="c3c9b-221">Este subproceso se puede usar para esperar a que el subproceso secundario finalice, lo que es mucho más sencillo y mucho más eficaz que girar en un bucle que comprueba el estado del subproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-221">This thread can be used to wait for the child thread to terminate, which is much simpler and much more efficient than spinning in a loop checking the thread status.</span></span> <span data-ttu-id="c3c9b-222">Para esperar a que el subproceso finalice, simplemente llame a [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) con el identificador del subproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-222">To wait for the thread to terminate, simply call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) with the thread handle.</span></span>

<span data-ttu-id="c3c9b-223">Los recursos para el subproceso no se liberarán hasta que el subproceso haya finalizado y se haya cerrado el identificador del subproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-223">The resources for the thread will not be freed until the thread has terminated and the thread handle has been closed.</span></span> <span data-ttu-id="c3c9b-224">Por lo tanto, es importante cerrar el identificador del subproceso con [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) cuando haya terminado.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-224">Therefore, it is important to close the thread handle with [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) when you are finished with it.</span></span> <span data-ttu-id="c3c9b-225">Si va a esperar a que el subproceso termine con [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), asegúrese de no cerrar el identificador hasta después de que se haya completado la espera.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-225">If you will be waiting for the thread to terminate with [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), be sure to not close the handle until after the wait has completed.</span></span>

<span data-ttu-id="c3c9b-226">En Xbox 360, debe asignar de forma explícita los subprocesos de software a un subproceso de hardware determinado mediante **XSetThreadProcessor**.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-226">On Xbox 360, you must explicitly assign software threads to a particular hardware thread by using **XSetThreadProcessor**.</span></span> <span data-ttu-id="c3c9b-227">De lo contrario, todos los subprocesos secundarios permanecerán en el mismo subproceso de hardware que el elemento primario.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-227">Otherwise, all child threads will stay on the same hardware thread as the parent.</span></span> <span data-ttu-id="c3c9b-228">En Windows, puede usar [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) para recomendar al sistema operativo en qué subprocesos de hardware se debe ejecutar el subproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-228">On Windows, you can use [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) to strongly suggest to the operating system which hardware threads your thread should run on.</span></span> <span data-ttu-id="c3c9b-229">Por lo general, esta técnica debe evitarse en Windows, ya que no sabe qué otros procesos podrían estar en ejecución en el sistema.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-229">This technique should generally be avoided on Windows since you don't know what other processes might be running on the system.</span></span> <span data-ttu-id="c3c9b-230">Normalmente es mejor permitir que el programador de Windows asigne los subprocesos a los subprocesos de hardware inactivos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-230">It is typically better to let the Windows scheduler assign your threads to idle hardware threads.</span></span>

<span data-ttu-id="c3c9b-231">La creación de subprocesos es una operación costosa.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-231">Creating threads is an expensive operation.</span></span> <span data-ttu-id="c3c9b-232">Los subprocesos deben crearse y destruirse con poca frecuencia.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-232">Threads should be created and destroyed rarely.</span></span> <span data-ttu-id="c3c9b-233">Si desea crear y destruir subprocesos con frecuencia, use un grupo de subprocesos que esperan trabajo en su lugar.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-233">If you find yourself wanting to create and destroy threads frequently, use a pool of threads that wait around for work instead.</span></span>

## <a name="synchronizing-threads"></a><span data-ttu-id="c3c9b-234">Sincronizar subprocesos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-234">Synchronizing Threads</span></span>

<span data-ttu-id="c3c9b-235">Para que varios subprocesos funcionen juntos, debe ser capaz de sincronizar los subprocesos, pasar mensajes y solicitar acceso exclusivo a los recursos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-235">For multiple threads to work together, you must be able to synchronize threads, pass messages, and request exclusive access to resources.</span></span> <span data-ttu-id="c3c9b-236">Windows y Xbox 360 disponen de un amplio conjunto de primitivas de sincronización.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-236">Windows and Xbox 360 come with a rich set of synchronization primitives.</span></span> <span data-ttu-id="c3c9b-237">Para obtener detalles completos sobre estas primitivas de sincronización, consulte la documentación de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-237">For full details on these synchronization primitives, see the platform documentation.</span></span>

### <a name="exclusive-access"></a><span data-ttu-id="c3c9b-238">Acceso exclusivo</span><span class="sxs-lookup"><span data-stu-id="c3c9b-238">Exclusive Access</span></span>

<span data-ttu-id="c3c9b-239">Obtener acceso exclusivo a un recurso, una estructura de datos o una ruta de código es una necesidad común.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-239">Gaining exclusive access to a resource, data structure, or code path is a common need.</span></span> <span data-ttu-id="c3c9b-240">Una opción para obtener acceso exclusivo es una exclusión mutua, cuyo uso típico se muestra aquí.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-240">One option for gaining exclusive access is a mutex, whose typical usage is shown here.</span></span>


```C++
// Initialize
HANDLE mutex = CreateMutex( 0, FALSE, 0 );

// Use
void ManipulateSharedData()
{
    WaitForSingleObject( mutex, INFINITE );
    // Manipulate stuff...
    ReleaseMutex( mutex );
}

// Destroy
CloseHandle( mutex );
The kernel guarantees that, for a particular mutex, only one thread at a time can 
acquire it.
The main disadvantage to mutexes is that they are relatively expensive to acquire 
and release. A faster alternative is a critical section.
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection( &cs );

// Use
void ManipulateSharedData()
{
    EnterCriticalSection( &cs );
    // Manipulate stuff...
    LeaveCriticalSection( &cs );
}

// Destroy
DeleteCriticalSection( &cs );
```



<span data-ttu-id="c3c9b-241">Las secciones críticas tienen una semántica similar a las exclusiones mutuas, pero se pueden usar para sincronizar solo dentro de un proceso, no entre procesos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-241">Critical sections have similar semantics to mutexes, but they can be used to synchronize only within a process, not between processes.</span></span> <span data-ttu-id="c3c9b-242">Su principal ventaja es que se ejecutan aproximadamente veinte veces más rápido que las exclusiones mutuas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-242">Their main advantage is that they execute roughly twenty times faster than mutexes.</span></span>

### <a name="events"></a><span data-ttu-id="c3c9b-243">Events</span><span class="sxs-lookup"><span data-stu-id="c3c9b-243">Events</span></span>

<span data-ttu-id="c3c9b-244">Si dos subprocesos (quizás un subproceso de actualización y un subproceso de representación) toman turnos usando un par de búferes de descripción de representación, necesitan una manera de indicar cuándo se realizan con su búfer determinado.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-244">If two threads—perhaps an update thread and a render thread—are taking turns using a pair of render description buffers, they need a way to indicate when they are done with their particular buffer.</span></span> <span data-ttu-id="c3c9b-245">Esto puede realizarse asociando un evento (asignado con [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) con cada búfer.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-245">This can be done by associating an event (allocated with [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) with each buffer.</span></span> <span data-ttu-id="c3c9b-246">Cuando un subproceso se realiza con un búfer, puede usar [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) para indicar Esto y, a continuación, puede llamar a [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) en el evento de otro búfer.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-246">When a thread is done with a buffer, it can use [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) to signal this, and can then call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) on the other buffer's event.</span></span> <span data-ttu-id="c3c9b-247">Esta técnica extrapola con facilidad al almacenamiento en búfer triple de los recursos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-247">This technique extrapolates easily to triple buffering of resources.</span></span>

### <a name="semaphores"></a><span data-ttu-id="c3c9b-248">Semáforos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-248">Semaphores</span></span>

<span data-ttu-id="c3c9b-249">Un semáforo se utiliza para controlar el número de subprocesos que se pueden ejecutar y se utiliza normalmente para implementar colas de trabajo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-249">A semaphore is used to control how many threads can be running and is commonly used to implement work queues.</span></span> <span data-ttu-id="c3c9b-250">Un subproceso agrega trabajo a una cola y usa [**ReleaseSemaphore (**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) cada vez que agrega un nuevo elemento a la cola.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-250">One thread adds work to a queue and uses [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) whenever it adds a new item to the queue.</span></span> <span data-ttu-id="c3c9b-251">Esto permite liberar un subproceso de trabajo del grupo de subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-251">This allows one worker thread to be released from the pool of waiting threads.</span></span> <span data-ttu-id="c3c9b-252">Los subprocesos de trabajo simplemente llaman a [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)y cuando devuelven que saben que hay un elemento de trabajo en la cola para ellos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-252">The worker threads just call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and when it returns they know there is a work item in the queue for them.</span></span> <span data-ttu-id="c3c9b-253">Además, se debe usar una sección crítica u otra técnica de sincronización para garantizar el acceso seguro a la cola de trabajo compartida.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-253">In addition, a critical section or other synchronization technique must be used in order to guarantee safe access to the shared work queue.</span></span>

### <a name="avoid-suspendthread"></a><span data-ttu-id="c3c9b-254">Evitar SuspendThread</span><span class="sxs-lookup"><span data-stu-id="c3c9b-254">Avoid SuspendThread</span></span>

<span data-ttu-id="c3c9b-255">A veces, cuando desea que un subproceso detenga lo que está haciendo, es tentador usar [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) en lugar de los primitivos de sincronización correctos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-255">Sometimes when you want a thread to stop what it is doing, it is tempting to use [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) instead of the correct synchronization primitives.</span></span> <span data-ttu-id="c3c9b-256">Esta es siempre mala idea y puede conducir fácilmente a interbloqueos y otros problemas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-256">This is always a bad idea and can easily lead to deadlocks and other problems.</span></span> <span data-ttu-id="c3c9b-257">**SuspendThread** también interactúa incorrectamente con el depurador de Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-257">**SuspendThread** also interacts badly with the Visual Studio debugger.</span></span> <span data-ttu-id="c3c9b-258">Evite **SuspendThread**.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-258">Avoid **SuspendThread**.</span></span> <span data-ttu-id="c3c9b-259">En su lugar, use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="c3c9b-259">Use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) instead.</span></span>

### <a name="waitforsingleobject-and-waitformultipleobjects"></a><span data-ttu-id="c3c9b-260">WaitForSingleObject y WaitForMultipleObjects</span><span class="sxs-lookup"><span data-stu-id="c3c9b-260">WaitForSingleObject and WaitForMultipleObjects</span></span>

<span data-ttu-id="c3c9b-261">La función [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) es la función de sincronización que se usa con más frecuencia.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-261">The function [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) is the most commonly used synchronization function.</span></span> <span data-ttu-id="c3c9b-262">Sin embargo, a veces desea que un subproceso espere hasta que se cumplan varias condiciones simultáneamente o hasta que se cumpla una de las condiciones.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-262">However, sometimes you want a thread to wait until several conditions are simultaneously satisfied, or until one of a set of conditions are satisfied.</span></span> <span data-ttu-id="c3c9b-263">En este caso, debe usar [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-263">In this case, you should use [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

### <a name="interlocked-functions-and-lockless-programming"></a><span data-ttu-id="c3c9b-264">Funciones interbloqueadas y programación de bloqueos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-264">Interlocked Functions and Lockless Programming</span></span>

<span data-ttu-id="c3c9b-265">Existe una familia de funciones para realizar operaciones sencillas seguras para subprocesos sin usar bloqueos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-265">There is a family of functions for performing simple thread-safe operations without using locks.</span></span> <span data-ttu-id="c3c9b-266">Se trata de la familia de funciones entrelazada, como [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-266">These are the Interlocked family of functions, such as [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span></span> <span data-ttu-id="c3c9b-267">Estas funciones, además de otras técnicas con una configuración cuidadosa de marcas, se conocen como programación no bloqueada.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-267">These functions, plus other techniques using careful setting of flags, are together known as lockless programming.</span></span> <span data-ttu-id="c3c9b-268">La programación con bloqueo puede ser muy difícil de hacer correctamente y es mucho más difícil en Xbox 360 que en Windows.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-268">Lockless programming can be extremely tricky to do correctly, and is substantially more difficult on Xbox 360 than on Windows.</span></span>

<span data-ttu-id="c3c9b-269">Para obtener más información sobre la programación sin bloqueos, consulte consideraciones sobre la [programación sin bloqueos para Xbox 360 y Microsoft Windows](./lockless-programming.md).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-269">For more information about programming without locks, see [Lockless Programming Considerations for Xbox 360 and Microsoft Windows](./lockless-programming.md).</span></span>

### <a name="minimizing-synchronization"></a><span data-ttu-id="c3c9b-270">Minimizar la sincronización</span><span class="sxs-lookup"><span data-stu-id="c3c9b-270">Minimizing Synchronization</span></span>

<span data-ttu-id="c3c9b-271">Algunos métodos de sincronización son más rápidos que otros.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-271">Some synchronization methods are faster than others.</span></span> <span data-ttu-id="c3c9b-272">Sin embargo, en lugar de optimizar el código mediante la elección de las técnicas de sincronización más rápidas posibles, suele ser mejor sincronizar con menos frecuencia.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-272">However, rather than optimizing your code by choosing the fastest synchronization techniques possible, it is usually better to synchronize less often.</span></span> <span data-ttu-id="c3c9b-273">Esto es más rápido que la sincronización con demasiada frecuencia y hace que sea más fácil de depurar código más sencillo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-273">This is faster than synchronizing too frequently, and it makes for simpler code that is easier to debug.</span></span>

<span data-ttu-id="c3c9b-274">Algunas operaciones, como la asignación de memoria, pueden tener que usar primitivas de sincronización para que funcionen correctamente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-274">Some operations, such as memory allocation, may have to use synchronization primitives in order to work correctly.</span></span> <span data-ttu-id="c3c9b-275">Por lo tanto, el hecho de realizar asignaciones frecuentes desde el montón compartido predeterminado producirá una sincronización frecuente, lo que eliminará algún rendimiento.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-275">Therefore, doing frequent allocations from the default shared heap will result in frequent synchronization, which will waste some performance.</span></span> <span data-ttu-id="c3c9b-276">Evitar las asignaciones frecuentes o el uso de montones por subproceso (mediante \_ el montón no \_ SERIALIZE si usa HeapCreate) puede evitar esta sincronización oculta.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-276">Avoiding frequent allocations or using per-thread heaps (using HEAP\_NO\_SERIALIZE if you use HeapCreate) can avoid this hidden synchronization.</span></span>

<span data-ttu-id="c3c9b-277">Otra causa de la sincronización oculta es D3DCREATE \_ MULTIthreaded, lo que hace que D3D en Windows use la sincronización en muchas operaciones.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-277">Another cause of hidden synchronization is D3DCREATE\_MULTITHREADED, which causes D3D on Windows to use synchronization on many operations.</span></span> <span data-ttu-id="c3c9b-278">(La marca se omite en la consola Xbox 360).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-278">(The flag is ignored on Xbox 360.)</span></span>

<span data-ttu-id="c3c9b-279">Los datos por subproceso, también conocidos como almacenamiento local de subprocesos, pueden ser una forma importante de evitar la sincronización.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-279">Per-thread data, also known as thread local storage, can be an important way of avoiding synchronization.</span></span> <span data-ttu-id="c3c9b-280">Visual C++ permite declarar variables globales como por subproceso con la sintaxis de **\_ \_ declspec (Thread)** .</span><span class="sxs-lookup"><span data-stu-id="c3c9b-280">Visual C++ allows you to declare global variables as being per-thread with the **\_\_declspec(thread)** syntax.</span></span>


```C++
__declspec( thread ) int tls_i = 1;
```



<span data-ttu-id="c3c9b-281">Esto proporciona a cada subproceso del proceso su propia copia de TLS \_ i, a la que se puede hacer referencia de forma segura y eficaz sin necesidad de sincronización.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-281">This gives each thread in the process its own copy of tls\_i, which can be referenced safely and efficiently without requiring synchronization.</span></span>

<span data-ttu-id="c3c9b-282">La técnica **\_ \_ declspec (Thread)** no funciona con archivos dll cargados dinámicamente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-282">The **\_\_declspec(thread)** technique does not work with dynamically loaded DLLs.</span></span> <span data-ttu-id="c3c9b-283">Si usa archivos dll cargados dinámicamente, tendrá que usar la familia de funciones TLSAlloc para implementar el almacenamiento local de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-283">If you use dynamically loaded DLLs, you will need to use the TLSAlloc family of functions to implement thread local storage.</span></span>

## <a name="destroying-threads"></a><span data-ttu-id="c3c9b-284">Destruir subprocesos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-284">Destroying Threads</span></span>

<span data-ttu-id="c3c9b-285">La única manera segura de destruir un subproceso es hacer que el propio subproceso salga, ya sea devolviendo desde la función de subproceso principal o haciendo que el subproceso llame a [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) o [**\_ endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-285">The only safe way to destroy a thread is to have the thread itself exit, either by returning from the main thread function or by having the thread call [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) or [**\_endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span></span> <span data-ttu-id="c3c9b-286">Si se crea un subproceso con [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), debe usar **\_ endthreadex** o volver de la función de subproceso principal, ya que el uso de **ExitThread** no liberará correctamente los recursos de CRT.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-286">If a thread is created with [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), then it should use **\_endthreadex** or return from the main thread function, since using **ExitThread** won't properly free CRT resources.</span></span> <span data-ttu-id="c3c9b-287">Nunca llame a la función [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) , porque el subproceso no se limpiará correctamente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-287">Never call the [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) function, because the thread will not be properly cleaned up.</span></span> <span data-ttu-id="c3c9b-288">Los subprocesos siempre deben confirmar Suicide; nunca deben ser murdered.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-288">Threads should always commit suicide—they should never be murdered.</span></span>

## <a name="openmp"></a><span data-ttu-id="c3c9b-289">OpenMP</span><span class="sxs-lookup"><span data-stu-id="c3c9b-289">OpenMP</span></span>

<span data-ttu-id="c3c9b-290">OpenMP es una extensión de lenguaje para agregar multithreading al programa mediante el uso de pragmas para guiar al compilador en ejecutar bucles en paralelo.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-290">OpenMP is a language extension for adding multithreading to your program by using pragmas to guide the compiler in parallelizing loops.</span></span> <span data-ttu-id="c3c9b-291">OpenMP es compatible con Visual C++ 2005 en Windows y Xbox 360 y se puede usar junto con la administración de subprocesos manual.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-291">OpenMP is supported by Visual C++ 2005 on Windows and Xbox 360 and can be used in conjunction with manual thread management.</span></span> <span data-ttu-id="c3c9b-292">OpenMP puede ser una manera cómoda de subprocesos de parte del código, pero no es probable que sea la solución ideal, especialmente en el caso de juegos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-292">OpenMP can be a convenient way to multithread parts of your code, but is unlikely to be the ideal solution, especially for games.</span></span> <span data-ttu-id="c3c9b-293">OpenMP puede ser más aplicable a tareas de producción de ejecución más prolongada, como el procesamiento de material gráfico y otros recursos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-293">OpenMP may be more applicable to longer-running production tasks such as processing art and other resources.</span></span> <span data-ttu-id="c3c9b-294">Para obtener más información, consulte la documentación de Visual C++ o vaya al [sitio web](https://www.openmp.org/)de OpenMP.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-294">For more information, see the Visual C++ documentation or go to the OpenMP [website](https://www.openmp.org/).</span></span>

## <a name="profiling"></a><span data-ttu-id="c3c9b-295">Generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="c3c9b-295">Profiling</span></span>

<span data-ttu-id="c3c9b-296">La generación de perfiles multiproceso es importante.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-296">Multithreaded profiling is important.</span></span> <span data-ttu-id="c3c9b-297">Es fácil terminar con paradas largas en las que los subprocesos están esperando entre sí.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-297">It is easy to end up with long stalls where threads are waiting on each other.</span></span> <span data-ttu-id="c3c9b-298">Estas paradas pueden ser difíciles de encontrar y diagnosticar.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-298">These stalls can be difficult to find and diagnose.</span></span> <span data-ttu-id="c3c9b-299">Para ayudar a identificarlos, considere la posibilidad de agregar instrumentación a las llamadas de sincronización.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-299">To help identify them, consider adding instrumentation to your synchronization calls.</span></span> <span data-ttu-id="c3c9b-300">Un generador de perfiles de muestreo también puede ayudar a identificar estos problemas, ya que puede registrar información de temporización sin modificarlo sustancialmente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-300">A sampling profiler can also help identify these problems because it can record timing information without substantially altering it.</span></span>

## <a name="timing"></a><span data-ttu-id="c3c9b-301">Control de tiempo</span><span class="sxs-lookup"><span data-stu-id="c3c9b-301">Timing</span></span>

<span data-ttu-id="c3c9b-302">La instrucción RDTSC es una manera de obtener información de tiempo precisa en Windows.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-302">The rdtsc instruction is one way to get accurate timing information on Windows.</span></span> <span data-ttu-id="c3c9b-303">Desafortunadamente, RDTSC tiene varios problemas que lo convierten en una buena opción para su título de envío.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-303">Unfortunately, rdtsc has multiple problems that make it a poor choice for your shipping title.</span></span> <span data-ttu-id="c3c9b-304">Los contadores de RDTSC no se sincronizan necesariamente entre las CPU, por lo que cuando el subproceso se mueve entre subprocesos de hardware, puede obtener grandes diferencias positivas o negativas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-304">The rdtsc counters are not necessarily synchronized between CPUs, so when your thread moves between hardware threads you may get large positive or negative differences.</span></span> <span data-ttu-id="c3c9b-305">En función de la configuración de administración de energía, la frecuencia con la que se incrementa el contador de RDTSC también puede cambiar mientras se ejecuta el juego.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-305">Depending on power management settings, the frequency at which the rdtsc counter increments may also change as your game runs.</span></span> <span data-ttu-id="c3c9b-306">Para evitar estas dificultades, debe preferir [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) y [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) para la temporización de alta precisión en el juego de envío.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-306">To avoid these difficulties, you should prefer [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) for high-precision timing in your shipping game.</span></span> <span data-ttu-id="c3c9b-307">Para obtener más información sobre el tiempo, vea [procesadores de control de tiempo y multinúcleo](./game-timing-and-multicore-processors.md).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-307">For more information about timing, see [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md).</span></span>

## <a name="debugging"></a><span data-ttu-id="c3c9b-308">Depuración</span><span class="sxs-lookup"><span data-stu-id="c3c9b-308">Debugging</span></span>

<span data-ttu-id="c3c9b-309">Visual Studio es totalmente compatible con la depuración multiproceso para Windows y Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-309">Visual Studio fully supports multithreaded debugging for Windows and Xbox 360.</span></span> <span data-ttu-id="c3c9b-310">La ventana subprocesos de Visual Studio permite cambiar entre subprocesos para ver las diferentes pilas de llamadas y variables locales.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-310">The Visual Studio threads window lets you switch between threads in order to see the different call stacks and local variables.</span></span> <span data-ttu-id="c3c9b-311">La ventana subprocesos también permite inmovilizar y reanudar subprocesos concretos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-311">The threads window also lets you freeze and thaw particular threads.</span></span>

<span data-ttu-id="c3c9b-312">En Xbox 360, puede usar la metavariable **\@ hwthread** en la ventana Inspección para mostrar el subproceso de hardware en el que se está ejecutando el subproceso de software seleccionado actualmente.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-312">On Xbox 360, you can use the **\@hwthread** meta-variable in the watch window to show the hardware thread on which the currently selected software thread is running.</span></span>

<span data-ttu-id="c3c9b-313">La ventana subprocesos es más fácil de usar si se denominan los subprocesos de forma significativa.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-313">The threads window is easier to use if you name your threads meaningfully.</span></span> <span data-ttu-id="c3c9b-314">Visual Studio y otros depuradores de Microsoft le permiten asignar nombres a los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-314">Visual Studio and other Microsoft debuggers allow you to name your threads.</span></span> <span data-ttu-id="c3c9b-315">Implemente la siguiente función **SetThreadName** y llámela desde cada subproceso a medida que se inicia.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-315">Implement the following **SetThreadName** function and call it from each thread as it starts up.</span></span>


```C++
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

void SetThreadName( DWORD dwThreadID, LPCSTR szThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = szThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0,
                    sizeof(info) / sizeof(DWORD),
            (DWORD*)&info );
    }
    __except( EXCEPTION_CONTINUE_EXECUTION ) {
    }
}

// Example usage:
SetThreadName(-1, "Main thread");
```



<span data-ttu-id="c3c9b-316">El depurador de kernel (KD) y WinDBG también admiten la depuración multiproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-316">The kernel debugger (KD) and WinDBG also support multithreaded debugging.</span></span>

## <a name="testing"></a><span data-ttu-id="c3c9b-317">Prueba</span><span class="sxs-lookup"><span data-stu-id="c3c9b-317">Testing</span></span>

<span data-ttu-id="c3c9b-318">La programación multiproceso puede ser complicada y algunos errores multiproceso solo se muestran con poca frecuencia, lo que dificulta la búsqueda y la corrección.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-318">Multithreaded programming can be tricky, and some multithreaded bugs show up only rarely, making them difficult to find and fix.</span></span> <span data-ttu-id="c3c9b-319">Una de las mejores formas de vaciarlas es realizar pruebas en una amplia gama de equipos, especialmente en aquellos con cuatro o más procesadores.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-319">One of the best ways to flush them out is to test on a wide range of computers, particularly those with four or more processors.</span></span> <span data-ttu-id="c3c9b-320">El código multiproceso que funciona perfectamente en un equipo con un solo subproceso puede producir un error al instante en un equipo con cuatro procesadores.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-320">Multithreaded code that works perfectly on a single-threaded computer may fail instantly on a four-processor computer.</span></span> <span data-ttu-id="c3c9b-321">Las características de rendimiento y temporización de las CPU AMD e Intel pueden variar considerablemente, por lo que debe asegurarse de realizar pruebas en equipos con varios procesadores basados en CPU de ambos proveedores.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-321">The performance and timing characteristics of AMD and Intel CPUs can vary substantially, so be sure to test on multiprocessor computers based on CPUs from both vendors.</span></span>

## <a name="windows-vista-and-windows-7-improvements"></a><span data-ttu-id="c3c9b-322">Mejoras en Windows Vista y Windows 7</span><span class="sxs-lookup"><span data-stu-id="c3c9b-322">Windows Vista and Windows 7 Improvements</span></span>

<span data-ttu-id="c3c9b-323">En el caso de los juegos que tienen como destino las versiones más recientes de Windows, hay una serie de API que pueden simplificar la creación de aplicaciones multiproceso escalables.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-323">For games targeting the newer versions of Windows, there are a number of APIs that can simplify the creation of scalable multithreaded applications.</span></span> <span data-ttu-id="c3c9b-324">Esto es especialmente cierto con la nueva API ThreadPool y algunas primitivas syncrhonziation adicionales (variables de condición, el bloqueo ligero de lectura/escritura y una inicialización única).</span><span class="sxs-lookup"><span data-stu-id="c3c9b-324">This is particularly true with the new ThreadPool API and some additional syncrhonziation primitives (condition variables, the slim read/writer lock, and one-time initialization).</span></span> <span data-ttu-id="c3c9b-325">Puede encontrar información general sobre estas tecnologías en los siguientes artículos de MSDN Magazine:</span><span class="sxs-lookup"><span data-stu-id="c3c9b-325">You can find an overview of these technologies in the following MSDN Magazine articles:</span></span>

-   [<span data-ttu-id="c3c9b-326">Mejorar la escalabilidad con las nuevas API de grupo de subprocesos</span><span class="sxs-lookup"><span data-stu-id="c3c9b-326">Improve Scalability With New Thread Pool APIs</span></span>](/archive/msdn-magazine/2007/october/pooled-threads-improve-scalability-with-new-thread-pool-apis)
-   [<span data-ttu-id="c3c9b-327">Primitivas de sincronización nuevas en Windows Vista</span><span class="sxs-lookup"><span data-stu-id="c3c9b-327">Synchronization Primitives New To Windows Vista</span></span>](/archive/msdn-magazine/2007/june/concurrency-synchronization-primitives-new-to-windows-vista)

<span data-ttu-id="c3c9b-328">Las aplicaciones que usan [las características de Direct3D 11](../direct3d11/direct3d-11-features.md) en estos sistemas operativos también pueden aprovechar las ventajas del nuevo diseño para la creación de objetos simultáneos y las listas de comandos de contexto diferidos para una mejor escalabilidad para la representación multiproceso.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-328">Applications using [Direct3D 11 Features](../direct3d11/direct3d-11-features.md) on these operating systems can also take advantage of the new design for concurrent object creation and deferred context command lists for better scalability for multithreaded rendering.</span></span>

## <a name="summary"></a><span data-ttu-id="c3c9b-329">Resumen</span><span class="sxs-lookup"><span data-stu-id="c3c9b-329">Summary</span></span>

<span data-ttu-id="c3c9b-330">Con un diseño cuidadoso que minimiza las interacciones entre los subprocesos, puede obtener mejoras de rendimiento importantes de la programación multiproceso sin agregar una complejidad excesiva al código.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-330">With careful design that minimizes the interactions between threads, you can get substantial performance gains from multithreaded programming without adding excessive complexity to your code.</span></span> <span data-ttu-id="c3c9b-331">Esto permitirá que el código de juego se ponga en marcha la siguiente ola de mejoras del procesador y ofrezca experiencias de juego cada vez más atractivas.</span><span class="sxs-lookup"><span data-stu-id="c3c9b-331">This will let your game code ride the next wave of processor improvements and deliver ever more compelling gaming experiences.</span></span>

## <a name="references"></a><span data-ttu-id="c3c9b-332">Referencias</span><span class="sxs-lookup"><span data-stu-id="c3c9b-332">References</span></span>

-   <span data-ttu-id="c3c9b-333">Jim Beveridge & Robert Weiner, *aplicaciones multithreading en Win32*, Addison-Wesley, 1997</span><span class="sxs-lookup"><span data-stu-id="c3c9b-333">Jim Beveridge & Robert Weiner, *Multithreading Applications in Win32*, Addison-Wesley, 1997</span></span>
-   <span data-ttu-id="c3c9b-334">Chuck Walbourn, [procesadores de temporización y varios núcleos](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span><span class="sxs-lookup"><span data-stu-id="c3c9b-334">Chuck Walbourn, [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span></span>
-   <span data-ttu-id="c3c9b-335">Biblioteca de MSDN: [ **GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span><span class="sxs-lookup"><span data-stu-id="c3c9b-335">MSDN Library: [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span></span>
-   [<span data-ttu-id="c3c9b-336">OpenMP</span><span class="sxs-lookup"><span data-stu-id="c3c9b-336">OpenMP</span></span>](https://www.openmp.org/)

 

 