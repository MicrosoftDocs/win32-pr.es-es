---
description: Copiar y obtener acceso a los datos de recursos (Direct3D 10)
ms.assetid: 34fd4d15-ee64-4acf-967d-a4afb6f26329
title: Copiar y obtener acceso a los datos de recursos (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 38bd075585ee3123e163075a50b06b53a77a214c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "103807538"
---
# <a name="copying-and-accessing-resource-data-direct3d-10"></a><span data-ttu-id="eaded-103">Copiar y obtener acceso a los datos de recursos (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="eaded-103">Copying and Accessing Resource Data (Direct3D 10)</span></span>

<span data-ttu-id="eaded-104">Ya no es necesario pensar en los recursos que se crean en la memoria de vídeo o en la memoria del sistema.</span><span class="sxs-lookup"><span data-stu-id="eaded-104">It is no longer necessary to think about resources as being created in either video memory or system memory.</span></span> <span data-ttu-id="eaded-105">O si el tiempo de ejecución debe administrar la memoria.</span><span class="sxs-lookup"><span data-stu-id="eaded-105">Or whether or not the runtime should manage the memory.</span></span> <span data-ttu-id="eaded-106">Gracias a la arquitectura del nuevo WDDM (modelo de controladores de pantalla de Windows), las aplicaciones ahora crean recursos de Direct3D 10 con diferentes marcas de [**uso**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) para indicar el modo en que la aplicación pretende usar los datos de recursos.</span><span class="sxs-lookup"><span data-stu-id="eaded-106">Thanks to the architecture of the new WDDM (Windows Display Driver Model), applications now create Direct3D 10 resources with different [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) flags to indicate how the application intends on using the resource data.</span></span> <span data-ttu-id="eaded-107">El nuevo modelo de controlador virtualiza la memoria que usan los recursos; después, se convierte en responsabilidad del sistema operativo/controlador/administrador de memoria para colocar recursos en el área de memoria más eficaz posible, dado el uso esperado.</span><span class="sxs-lookup"><span data-stu-id="eaded-107">The new driver model virtualizes the memory used by resources; it then becomes the responsibility of the operating system/driver/memory manager to place resources in the most performant area of memory possible given the expected usage.</span></span>

<span data-ttu-id="eaded-108">El caso predeterminado es que los recursos estén disponibles para la GPU.</span><span class="sxs-lookup"><span data-stu-id="eaded-108">The default case is for resources to be available to the GPU.</span></span> <span data-ttu-id="eaded-109">Por supuesto, supongamos que hay ocasiones en las que los datos de recursos deben estar disponibles para la CPU.</span><span class="sxs-lookup"><span data-stu-id="eaded-109">Of course, having said that, there are times when the resource data needs to be available to the CPU.</span></span> <span data-ttu-id="eaded-110">Copiar los datos de recursos para que el procesador adecuado pueda acceder a él sin afectar al rendimiento requiere cierto conocimiento de cómo funcionan los métodos de la API.</span><span class="sxs-lookup"><span data-stu-id="eaded-110">Copying resource data around so that the appropriate processor can access it without impacting performance requires some knowledge of how the API methods work.</span></span>

-   [<span data-ttu-id="eaded-111">Copiar datos de recursos</span><span class="sxs-lookup"><span data-stu-id="eaded-111">Copying Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)
-   [<span data-ttu-id="eaded-112">Acceso a los datos de recursos</span><span class="sxs-lookup"><span data-stu-id="eaded-112">Accessing Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)

## <a name="copying-resource-data"></a><span data-ttu-id="eaded-113">Copiar datos de recursos</span><span class="sxs-lookup"><span data-stu-id="eaded-113">Copying Resource Data</span></span>

<span data-ttu-id="eaded-114">Los recursos se crean en memoria cuando Direct3D ejecuta una llamada a Create.</span><span class="sxs-lookup"><span data-stu-id="eaded-114">Resources are created in memory when Direct3D executes a Create call.</span></span> <span data-ttu-id="eaded-115">Se pueden crear en la memoria de vídeo, en la memoria del sistema o en cualquier otro tipo de memoria.</span><span class="sxs-lookup"><span data-stu-id="eaded-115">They can be created in video memory, system memory, or any other kind of memory.</span></span> <span data-ttu-id="eaded-116">Dado que el modelo de controlador WDDM virtualiza esta memoria, las aplicaciones ya no necesitan realizar un seguimiento del tipo de recursos de memoria que se crea en.</span><span class="sxs-lookup"><span data-stu-id="eaded-116">Since WDDM driver model virtualizes this memory, applications no longer need to keep track of what kind of memory resources are created in.</span></span>

<span data-ttu-id="eaded-117">Lo ideal es que todos los recursos se encuentren en la memoria de vídeo para que la GPU pueda tener acceso inmediato a ellos.</span><span class="sxs-lookup"><span data-stu-id="eaded-117">Ideally, all resources would be located in video memory so that the GPU can have immediate access to them.</span></span> <span data-ttu-id="eaded-118">Sin embargo, a veces es necesario que la CPU Lea los datos de recursos o que la GPU tenga acceso a los datos de recursos en los que se ha escrito la CPU.</span><span class="sxs-lookup"><span data-stu-id="eaded-118">However, it is sometimes necessary for the CPU to read the resource data or for the GPU to access resource data the CPU has written to.</span></span> <span data-ttu-id="eaded-119">Direct3D 10 controla estos escenarios diferentes solicitando a la aplicación que especifique un uso y, a continuación, ofrece varios métodos para copiar los datos de recursos cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="eaded-119">Direct3D 10 handles these different scenarios by requesting the application specify a usage, and then offers several methods for copying resource data when necessary.</span></span>

<span data-ttu-id="eaded-120">En función de cómo se haya creado el recurso, no siempre es posible tener acceso directamente a los datos subyacentes.</span><span class="sxs-lookup"><span data-stu-id="eaded-120">Depending on how the resource was created, it is not always possible to directly access the underlying data.</span></span> <span data-ttu-id="eaded-121">Esto puede significar que los datos de recursos se deben copiar desde el recurso de origen a otro recurso al que pueda acceder el procesador adecuado.</span><span class="sxs-lookup"><span data-stu-id="eaded-121">This may mean that the resource data must be copied from the source resource to another resource that is accessible by the appropriate processor.</span></span> <span data-ttu-id="eaded-122">En términos de Direct3D 10, los recursos predeterminados a los que se puede acceder directamente a través de la GPU, se puede acceder directamente a los recursos dinámicos y de ensayo mediante la CPU.</span><span class="sxs-lookup"><span data-stu-id="eaded-122">In terms of Direct3D 10, default resources can be accessed directly by the GPU, dynamic and staging resources can be directly accessed by the CPU.</span></span>

<span data-ttu-id="eaded-123">Una vez creado un recurso, no se puede cambiar su [**uso**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) .</span><span class="sxs-lookup"><span data-stu-id="eaded-123">Once a resource has been created, its [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) cannot be changed.</span></span> <span data-ttu-id="eaded-124">En su lugar, copie el contenido de un recurso a otro recurso que se creó con un uso diferente.</span><span class="sxs-lookup"><span data-stu-id="eaded-124">Instead, copy the contents of one resource to another resource that was created with a different usage.</span></span> <span data-ttu-id="eaded-125">Direct3D 10 proporciona esta funcionalidad con tres métodos diferentes.</span><span class="sxs-lookup"><span data-stu-id="eaded-125">Direct3D 10 provides this functionality with three different methods.</span></span> <span data-ttu-id="eaded-126">Los dos primeros métodos ( [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) y [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) están diseñados para copiar los datos de recursos de un recurso a otro.</span><span class="sxs-lookup"><span data-stu-id="eaded-126">The first two methods( [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) are designed to copy resource data from one resource to another.</span></span> <span data-ttu-id="eaded-127">El tercer método ([**ID3D10Device:: UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) está diseñado para copiar datos de la memoria en un recurso.</span><span class="sxs-lookup"><span data-stu-id="eaded-127">The third method ([**ID3D10Device::UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) is designed to copy data from memory to a resource.</span></span>

<span data-ttu-id="eaded-128">Hay dos tipos principales de recursos: asignable y no asignable.</span><span class="sxs-lookup"><span data-stu-id="eaded-128">There are two main kinds of resources: mappable and non-mappable.</span></span> <span data-ttu-id="eaded-129">Los recursos creados con usos dinámicos o de almacenamiento provisional son asignables, mientras que los recursos creados con usos predeterminados o inmutables no son asignables.</span><span class="sxs-lookup"><span data-stu-id="eaded-129">Resources created with dynamic or staging usages are mappable, while resources created with default or immutable usages are non-mappable.</span></span>

<span data-ttu-id="eaded-130">La copia de datos entre recursos no asignables es muy rápida porque es el caso más común y se ha optimizado para que funcione correctamente.</span><span class="sxs-lookup"><span data-stu-id="eaded-130">Copying data among non-mappable resources is very fast because this is the most common case and has been optimized to perform well.</span></span> <span data-ttu-id="eaded-131">Dado que la CPU no puede acceder directamente a estos recursos, se optimizan para que la GPU pueda manipularlos rápidamente.</span><span class="sxs-lookup"><span data-stu-id="eaded-131">Since these resources are not directly accessible by the CPU, they are optimized so that the GPU can manipulate them quickly.</span></span>

<span data-ttu-id="eaded-132">La copia de datos entre recursos que se van a asignar es más problemática porque el rendimiento dependerá del uso con el que se creó el recurso.</span><span class="sxs-lookup"><span data-stu-id="eaded-132">Copying data among mappable resources is more problematic because the performance will depend on the usage the resource was created with.</span></span> <span data-ttu-id="eaded-133">Por ejemplo, la GPU puede leer un recurso dinámico bastante rápidamente, pero no puede escribir en ellos, y la GPU no puede leer ni escribir directamente en los recursos de ensayo.</span><span class="sxs-lookup"><span data-stu-id="eaded-133">For example, the GPU can read a dynamic resource fairly quickly but cannot write to them, and the GPU cannot read or write to staging resources directly.</span></span>

<span data-ttu-id="eaded-134">Las aplicaciones que deseen copiar datos de un recurso con uso predeterminado en un recurso con uso de almacenamiento provisional (para permitir que la CPU Lea los datos, es decir, el problema de readback de GPU) deben hacerlo con precaución.</span><span class="sxs-lookup"><span data-stu-id="eaded-134">Applications that wish to copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data -- i.e. the GPU readback problem) must do so with care.</span></span> <span data-ttu-id="eaded-135">Consulte [acceso a los datos de recursos](#copying-and-accessing-resource-data-direct3d-10) para obtener más información sobre este último caso.</span><span class="sxs-lookup"><span data-stu-id="eaded-135">See [Accessing Resource Data](#copying-and-accessing-resource-data-direct3d-10) for more details on this last case.</span></span>

## <a name="accessing-resource-data"></a><span data-ttu-id="eaded-136">Acceso a los datos de recursos</span><span class="sxs-lookup"><span data-stu-id="eaded-136">Accessing Resource Data</span></span>

<span data-ttu-id="eaded-137">El acceso a un recurso requiere la asignación del recurso; la asignación básicamente significa que la aplicación está intentando conceder a la CPU acceso a la memoria.</span><span class="sxs-lookup"><span data-stu-id="eaded-137">Accessing a resource requires mapping the resource; mapping essentially means the application is trying to give the CPU access to memory.</span></span> <span data-ttu-id="eaded-138">El proceso de asignación de un recurso para que la CPU pueda acceder a la memoria subyacente puede producir cuellos de botella en el rendimiento y, por este motivo, se debe tener cuidado en cómo y cuándo realizar esta tarea.</span><span class="sxs-lookup"><span data-stu-id="eaded-138">The process of mapping a resource so that the CPU can access the underlying memory can cause some performance bottlenecks and for this reason, care must be taken as to how and when to perform this task.</span></span>

<span data-ttu-id="eaded-139">El rendimiento puede triturarse en una detención si la aplicación intenta asignar un recurso en el momento equivocado.</span><span class="sxs-lookup"><span data-stu-id="eaded-139">Performance can grind to a halt if the application tries to map a resource at the wrong time.</span></span> <span data-ttu-id="eaded-140">Si la aplicación intenta obtener acceso a los resultados de una operación antes de que finalice esa operación, se producirá una detención de canalización.</span><span class="sxs-lookup"><span data-stu-id="eaded-140">If the application tries to access the results of an operation before that operation is finished, a pipeline stall will occur.</span></span>

<span data-ttu-id="eaded-141">La realización de una operación de asignación en el momento equivocado podría provocar una caída importante del rendimiento al forzar la sincronización de la GPU y la CPU entre sí.</span><span class="sxs-lookup"><span data-stu-id="eaded-141">Performing a map operation at the wrong time could potentially cause a severe drop in performance by forcing the GPU and the CPU to synchronize with each other.</span></span> <span data-ttu-id="eaded-142">Esta sincronización se realizará si la aplicación desea tener acceso a un recurso antes de que la GPU termine de copiarlo en un recurso que la CPU puede asignar.</span><span class="sxs-lookup"><span data-stu-id="eaded-142">This synchronization will occur if the application wants to access a resource before the GPU is finished copying it into a resource the CPU can map.</span></span>

<span data-ttu-id="eaded-143">La CPU solo puede leer los recursos creados con la \_ marca de \_ almacenamiento provisional uso de D3D10.</span><span class="sxs-lookup"><span data-stu-id="eaded-143">The CPU can only read from resources created with the D3D10\_USAGE\_STAGING flag.</span></span> <span data-ttu-id="eaded-144">Dado que los recursos creados con esta marca no se pueden establecer como salidas de la canalización, si la CPU desea leer los datos de un recurso generado por la GPU, se deben copiar los datos en un recurso creado con la marca de ensayo.</span><span class="sxs-lookup"><span data-stu-id="eaded-144">Since resources created with this flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU, the data must be copied to a resource created with the staging flag.</span></span> <span data-ttu-id="eaded-145">Para ello, la aplicación puede usar los métodos [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) o [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) para copiar el contenido de un recurso en otro.</span><span class="sxs-lookup"><span data-stu-id="eaded-145">The application may do this by using the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods to copy the contents of one resource to another.</span></span> <span data-ttu-id="eaded-146">A continuación, la aplicación puede obtener acceso a este recurso mediante una llamada al método de asignación adecuado.</span><span class="sxs-lookup"><span data-stu-id="eaded-146">The application can then gain access to this resource by calling the appropriate Map method.</span></span> <span data-ttu-id="eaded-147">Cuando ya no se necesita el acceso al recurso, la aplicación debe llamar al método de desasignación correspondiente.</span><span class="sxs-lookup"><span data-stu-id="eaded-147">When access to the resource is no longer needed, the application should then call the corresponding Unmap method.</span></span> <span data-ttu-id="eaded-148">Por ejemplo, [**ID3D10Texture2D:: Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) y [**ID3D10Texture2D::**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap)desasignar.</span><span class="sxs-lookup"><span data-stu-id="eaded-148">For example, [**ID3D10Texture2D::Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) and [**ID3D10Texture2D::Unmap**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span></span> <span data-ttu-id="eaded-149">Los diferentes métodos de asignación devuelven algunos valores específicos en función de las marcas de entrada.</span><span class="sxs-lookup"><span data-stu-id="eaded-149">The different Map methods return some specific values depending on the input flags.</span></span> <span data-ttu-id="eaded-150">Para obtener más información, consulte la [**sección asignar comentarios**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) .</span><span class="sxs-lookup"><span data-stu-id="eaded-150">See [**Map Remarks section**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) for details.</span></span>

> [!Note]  
> <span data-ttu-id="eaded-151">Cuando la aplicación llama al método Map, recibe un puntero a los datos de recursos a los que se tiene acceso.</span><span class="sxs-lookup"><span data-stu-id="eaded-151">When the application calls the Map method, it receives a pointer to the resource data to access.</span></span> <span data-ttu-id="eaded-152">El tiempo de ejecución garantiza que el puntero tenga una alineación específica, en función del [nivel de característica](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span><span class="sxs-lookup"><span data-stu-id="eaded-152">The runtime ensures that the pointer has a specific alignment, depending on [feature level](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span></span> <span data-ttu-id="eaded-153">En el [**nivel de característica de D3D \_ \_ \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) y superior, el puntero se alinea con 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="eaded-153">For [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) and higher, the pointer is aligned to 16 bytes.</span></span> <span data-ttu-id="eaded-154">Para inferior al [**nivel de característica de D3D \_ \_ \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), el puntero se alinea con 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="eaded-154">For lower than [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), the pointer is aligned to 4 bytes.</span></span> <span data-ttu-id="eaded-155">La alineación de 16 bytes permite que la aplicación realice operaciones optimizadas para [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))en los datos de forma nativa, sin necesidad de realinear ni copiar.</span><span class="sxs-lookup"><span data-stu-id="eaded-155">The 16-byte alignment allows the application to perform [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))-optimized operations on the data natively, without realignment or copy.</span></span>

 

### <a name="performance-considerations"></a><span data-ttu-id="eaded-156">Consideraciones de rendimiento</span><span class="sxs-lookup"><span data-stu-id="eaded-156">Performance Considerations</span></span>

<span data-ttu-id="eaded-157">Es mejor pensar en un equipo como un equipo que se ejecuta como una arquitectura paralela con dos tipos principales de procesadores: una o más CPU y una o varias GPU.</span><span class="sxs-lookup"><span data-stu-id="eaded-157">It is best to think of a PC as a machine running as a parallel architecture with two main types of processors: one or more CPU's and one or more GPU's.</span></span> <span data-ttu-id="eaded-158">Como en cualquier arquitectura paralela, el mejor rendimiento se consigue cuando cada procesador está programado con suficientes tareas para evitar que se inactivo y cuando el trabajo de un procesador no está esperando el trabajo de otro.</span><span class="sxs-lookup"><span data-stu-id="eaded-158">As in any parallel architecture, the best performance is achieved when each processor is scheduled with enough tasks to prevent it from going idle and when the work of one processor is not waiting on the work of another.</span></span>

<span data-ttu-id="eaded-159">El escenario del peor de los casos para el paralelismo de GPU/CPU es la necesidad de forzar a un procesador a esperar los resultados del trabajo realizado por otro.</span><span class="sxs-lookup"><span data-stu-id="eaded-159">The worst-case scenario for GPU/CPU parallelism is the need to force one processor to wait for the results of work done by another.</span></span> <span data-ttu-id="eaded-160">Direct3D 10 intenta quitar este costo al hacer que los métodos [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) y [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) sean asíncronos; la copia no se ha ejecutado necesariamente en el momento en que el método vuelve.</span><span class="sxs-lookup"><span data-stu-id="eaded-160">Direct3D 10 tries to remove this cost by making the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods asynchronous; the copy has not necessarily executed by the time the method returns.</span></span> <span data-ttu-id="eaded-161">La ventaja de esto es que la aplicación no paga el costo de rendimiento de copiar realmente los datos hasta que la CPU tenga acceso a los datos, que es cuando se llama a Map.</span><span class="sxs-lookup"><span data-stu-id="eaded-161">The benefit of this is that the application does not pay the performance cost of actually copying the data until the CPU accesses the data, which is when Map is called.</span></span> <span data-ttu-id="eaded-162">Si se llama al método de asignación después de que los datos se hayan copiado realmente, no se produce ninguna pérdida de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="eaded-162">If the Map method is called after the data has actually been copied, no performance loss occurs.</span></span> <span data-ttu-id="eaded-163">Por otro lado, si se llama al método Map antes de que se copien los datos, se producirá una detención de la canalización.</span><span class="sxs-lookup"><span data-stu-id="eaded-163">On the other hand, if the Map method is called before the data has been copied, then a pipeline stall will occur.</span></span>

<span data-ttu-id="eaded-164">Las llamadas asincrónicas en Direct3D 10 (que son la mayoría de los métodos, y especialmente las llamadas de representación) se almacenan en lo que se denomina un búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="eaded-164">Asynchronous calls in Direct3D 10 (which are the vast majority of methods, and especially rendering calls) are stored in what is called a command buffer.</span></span> <span data-ttu-id="eaded-165">Este búfer es interno del controlador de gráficos y se usa para procesar por lotes las llamadas al hardware subyacente, de modo que el cambio costoso del modo de usuario al modo kernel en Microsoft Windows se produce lo más poco posible.</span><span class="sxs-lookup"><span data-stu-id="eaded-165">This buffer is internal to the graphics driver and is used to batch calls to the underlying hardware so that the costly switch from user mode to kernel mode in Microsoft Windows occurs as rarely as possible.</span></span>

<span data-ttu-id="eaded-166">El búfer de comandos se vacía, con lo que se produce un cambio de modo de usuario/kernel en una de estas cuatro situaciones, que son las siguientes.</span><span class="sxs-lookup"><span data-stu-id="eaded-166">The command buffer is flushed, thus causing a user/kernel mode switch, in one of four situations, which are as follows.</span></span>

1.  <span data-ttu-id="eaded-167">Se llama a [**present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) .</span><span class="sxs-lookup"><span data-stu-id="eaded-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) is called.</span></span>
2.  <span data-ttu-id="eaded-168">Se llama a [**ID3D10Device:: Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) .</span><span class="sxs-lookup"><span data-stu-id="eaded-168">[**ID3D10Device::Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) is called.</span></span>
3.  <span data-ttu-id="eaded-169">El búfer de comandos está lleno; su tamaño es dinámico y está controlado por el sistema operativo y el controlador de gráficos.</span><span class="sxs-lookup"><span data-stu-id="eaded-169">The command buffer is full; its size is dynamic and is controlled by the Operating System and the graphics driver.</span></span>
4.  <span data-ttu-id="eaded-170">La CPU requiere acceso a los resultados de un comando que espera para ejecutarse en el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="eaded-170">The CPU requires access to the results of a command waiting to execute in the command buffer.</span></span>

<span data-ttu-id="eaded-171">De las cuatro situaciones anteriores, el número cuatro es el más importante para el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="eaded-171">Of the four situations above, number four is the most critical to performance.</span></span> <span data-ttu-id="eaded-172">Si la aplicación emite una llamada a [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) o [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) , esta llamada se pone en cola en el búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="eaded-172">If the application issues a [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) call, this call is queued in the command buffer.</span></span> <span data-ttu-id="eaded-173">Si la aplicación intenta asignar el recurso de almacenamiento provisional que era el destino de la llamada de copia antes de que se haya vaciado el búfer de comandos, se producirá una detención de canalización porque no solo se debe ejecutar la llamada al método de copia, pero también se deben ejecutar todos los demás comandos almacenados en búfer del búfer de comandos.</span><span class="sxs-lookup"><span data-stu-id="eaded-173">If the application then tries to map the staging resource that was the target of the copy call before the command buffer has been flushed, a pipeline stall will occur because not only does the Copy method call need to execute, but all other buffered commands in the command buffer must execute as well.</span></span> <span data-ttu-id="eaded-174">Esto hará que la GPU y la CPU se sincronicen porque la CPU estará esperando para tener acceso al recurso de almacenamiento provisional mientras la GPU está vacía el búfer de comandos y, por último, rellenando el recurso que necesita la CPU.</span><span class="sxs-lookup"><span data-stu-id="eaded-174">This will cause the GPU and CPU to synchronize because the CPU will be waiting to access the staging resource while the GPU is emptying the command buffer and finally filling the resource the CPU needs.</span></span> <span data-ttu-id="eaded-175">Una vez que la GPU finalice la copia, la CPU comenzará a acceder al recurso de almacenamiento provisional, pero durante este tiempo, la GPU estará inactiva.</span><span class="sxs-lookup"><span data-stu-id="eaded-175">Once the GPU finishes the copy, the CPU will begin accessing the staging resource, but during this time, the GPU will be sitting idle.</span></span>

<span data-ttu-id="eaded-176">Al hacerlo con frecuencia en tiempo de ejecución, se degradará considerablemente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="eaded-176">Doing this frequently at runtime will severely degrade performance.</span></span> <span data-ttu-id="eaded-177">Por ese motivo, la asignación de recursos creados con uso predeterminado debe realizarse con cuidado.</span><span class="sxs-lookup"><span data-stu-id="eaded-177">For that reason, mapping of resources created with default usage should be done with care.</span></span> <span data-ttu-id="eaded-178">La aplicación debe esperar el tiempo suficiente para que el búfer de comandos se vacíe y, por lo tanto, todos esos comandos terminen de ejecutarse antes de intentar asignar el recurso de almacenamiento provisional correspondiente.</span><span class="sxs-lookup"><span data-stu-id="eaded-178">The application needs to wait long enough for the command buffer to be emptied and thus have all of those commands finish executing before it tries to map the corresponding staging resource.</span></span> <span data-ttu-id="eaded-179">¿Cuánto tiempo debe esperar la aplicación?</span><span class="sxs-lookup"><span data-stu-id="eaded-179">How long should the application wait?</span></span> <span data-ttu-id="eaded-180">Al menos dos fotogramas, ya que esto permitirá que el paralelismo entre las CPU y la GPU se aproveche de forma máxima.</span><span class="sxs-lookup"><span data-stu-id="eaded-180">At least two frames because this will enable parallelism between the CPU(s) and the GPU to be maximally leveraged.</span></span> <span data-ttu-id="eaded-181">La forma en que funciona la GPU es que mientras la aplicación procesa el fotograma N mediante el envío de llamadas al búfer de comandos, la GPU está ocupada ejecutando las llamadas del fotograma anterior, N-1.</span><span class="sxs-lookup"><span data-stu-id="eaded-181">The way the GPU works is that while the application is processing frame N by submitting calls to the command buffer, the GPU is busy executing the calls from the previous frame, N-1.</span></span>

<span data-ttu-id="eaded-182">Por lo tanto, si una aplicación desea asignar un recurso que se origina en la memoria de vídeo y llama a [**ID3D10Device:: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) o [**ID3D10Device:: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) en el fotograma n, esta llamada comenzará realmente a ejecutarse en el marco n + 1 cuando la aplicación envíe llamadas para el siguiente fotograma.</span><span class="sxs-lookup"><span data-stu-id="eaded-182">So if an application wants to map a resource that originates in video memory and calls [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) at frame N, this call will actually begin to execute at frame N+1, when the application is submitting calls for the next frame.</span></span> <span data-ttu-id="eaded-183">La copia debe finalizar cuando la aplicación está procesando el fotograma N + 2.</span><span class="sxs-lookup"><span data-stu-id="eaded-183">The copy should be finished when the application is processing frame N+2.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="eaded-184">Fotograma</span><span class="sxs-lookup"><span data-stu-id="eaded-184">Frame</span></span></th>
<th><span data-ttu-id="eaded-185">Estado de la GPU/CPU</span><span class="sxs-lookup"><span data-stu-id="eaded-185">GPU/CPU Status</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="eaded-186">N</span><span class="sxs-lookup"><span data-stu-id="eaded-186">N</span></span></td>
<td><ul>
<li><span data-ttu-id="eaded-187">Los problemas de CPU representan llamadas para el marco actual.</span><span class="sxs-lookup"><span data-stu-id="eaded-187">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="eaded-188">N + 1</span><span class="sxs-lookup"><span data-stu-id="eaded-188">N+1</span></span></td>
<td><ul>
<li><span data-ttu-id="eaded-189">GPU que ejecuta llamadas enviadas desde la CPU durante el fotograma N.</span><span class="sxs-lookup"><span data-stu-id="eaded-189">GPU executing calls sent from CPU during frame N.</span></span></li>
<li><span data-ttu-id="eaded-190">Los problemas de CPU representan llamadas para el marco actual.</span><span class="sxs-lookup"><span data-stu-id="eaded-190">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="eaded-191">N + 2</span><span class="sxs-lookup"><span data-stu-id="eaded-191">N+2</span></span></td>
<td><ul>
<li><span data-ttu-id="eaded-192">GPU terminó de ejecutar llamadas enviadas desde la CPU durante el fotograma N. resultados listos.</span><span class="sxs-lookup"><span data-stu-id="eaded-192">GPU finished executing calls sent from CPU during frame N. Results ready.</span></span></li>
<li><span data-ttu-id="eaded-193">GPU que ejecuta llamadas enviadas desde la CPU durante el fotograma N + 1.</span><span class="sxs-lookup"><span data-stu-id="eaded-193">GPU executing calls sent from CPU during frame N+1.</span></span></li>
<li><span data-ttu-id="eaded-194">Los problemas de CPU representan llamadas para el marco actual.</span><span class="sxs-lookup"><span data-stu-id="eaded-194">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="eaded-195">N + 3</span><span class="sxs-lookup"><span data-stu-id="eaded-195">N+3</span></span></td>
<td><ul>
<li><span data-ttu-id="eaded-196">GPU terminó de ejecutar llamadas enviadas desde la CPU durante el fotograma N + 1.</span><span class="sxs-lookup"><span data-stu-id="eaded-196">GPU finished executing calls sent from CPU during frame N+1.</span></span> <span data-ttu-id="eaded-197">Resultados listos.</span><span class="sxs-lookup"><span data-stu-id="eaded-197">Results ready.</span></span></li>
<li><span data-ttu-id="eaded-198">GPU que ejecuta llamadas enviadas desde la CPU durante el fotograma N + 2.</span><span class="sxs-lookup"><span data-stu-id="eaded-198">GPU executing calls sent from CPU during frame N+2.</span></span></li>
<li><span data-ttu-id="eaded-199">Los problemas de CPU representan llamadas para el marco actual.</span><span class="sxs-lookup"><span data-stu-id="eaded-199">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="eaded-200">N + 4</span><span class="sxs-lookup"><span data-stu-id="eaded-200">N+4</span></span></td>
<td><span data-ttu-id="eaded-201">...</span><span class="sxs-lookup"><span data-stu-id="eaded-201">...</span></span></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="eaded-202">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="eaded-202">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="eaded-203">Recursos (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="eaded-203">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
