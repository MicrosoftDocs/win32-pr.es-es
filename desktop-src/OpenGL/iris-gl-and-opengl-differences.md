---
title: Diferencias de IRIS GL y OpenGL
description: Diferencias de IRIS GL y OpenGL
ms.assetid: 1682bcbb-3bfb-4ea3-9ba9-4f4654238169
keywords:
- OpenGL, diferencias de la contabilidad de IRIS
- Migración de la contabilidad de IRIS, diferencias de OpenGL
- portabilidad de IRIS GL, diferencias de OpenGL
- trasladar a OpenGL desde IRIS GL, diferencias de IRIS GL
- Exportación de OpenGL desde IRIS GL, diferencias de la contabilidad de IRIS
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6276eb56cf73df6cbdfc115fe67d55452b13bbc
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/16/2019
ms.locfileid: "104356985"
---
# <a name="iris-gl-and-opengl-differences"></a><span data-ttu-id="def8d-108">Diferencias de IRIS GL y OpenGL</span><span class="sxs-lookup"><span data-stu-id="def8d-108">IRIS GL and OpenGL Differences</span></span>

<span data-ttu-id="def8d-109">En este apéndice se enumeran las diferencias entre OpenGL y IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="def8d-109">This appendix lists the differences between OpenGL and IRIS GL.</span></span> <span data-ttu-id="def8d-110">Se proporciona un término para cada diferencia, seguido de una descripción.</span><span class="sxs-lookup"><span data-stu-id="def8d-110">A term for each difference is given, followed by a description.</span></span>



|                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="def8d-111">ajuste de acumulación</span><span class="sxs-lookup"><span data-stu-id="def8d-111">accumulation wrapping</span></span>                | <span data-ttu-id="def8d-112">La operación de búfer de acumulación de OpenGL no se define cuando los valores de componente superan 1,0 o se quitan por debajo de 1,0.</span><span class="sxs-lookup"><span data-stu-id="def8d-112">The OpenGL accumulation buffer operation is not defined when component values exceed 1.0 or drop below 1.0.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="def8d-113">líneas suavizadas</span><span class="sxs-lookup"><span data-stu-id="def8d-113">antialiased lines</span></span>                    | <span data-ttu-id="def8d-114">Líneas con suavizado de OpenGL.</span><span class="sxs-lookup"><span data-stu-id="def8d-114">OpenGL stipples antialiased lines.</span></span> <span data-ttu-id="def8d-115">IRIS GL no lo hace.</span><span class="sxs-lookup"><span data-stu-id="def8d-115">IRIS GL does not.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="def8d-116">arc</span><span class="sxs-lookup"><span data-stu-id="def8d-116">arc</span></span>                                  | <span data-ttu-id="def8d-117">OpenGL admite los arcos en su biblioteca de utilidades.</span><span class="sxs-lookup"><span data-stu-id="def8d-117">OpenGL supports arcs in its utility library.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="def8d-118">listas de atributos</span><span class="sxs-lookup"><span data-stu-id="def8d-118">attribute lists</span></span>                      | <span data-ttu-id="def8d-119">Los atributos insertados por IRIS GL pushattributes difieren de cualquiera de los conjuntos de atributos insertados por el glPushAttrib de OpenGL.</span><span class="sxs-lookup"><span data-stu-id="def8d-119">The attributes pushed by the IRIS GL pushattributes differ from any of the attribute sets pushed by the OpenGL glPushAttrib .</span></span> <span data-ttu-id="def8d-120">No obstante, dado que todos los Estados de OpenGL se pueden volver a leer, puede implementar cualquier semántica de extracción/pop deseada mediante OpenGL.</span><span class="sxs-lookup"><span data-stu-id="def8d-120">Since all OpenGL states can be read back, however, you can implement any desired push/pop semantics using OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="def8d-121">escalado de textura automática</span><span class="sxs-lookup"><span data-stu-id="def8d-121">automatic texture scaling</span></span>            | <span data-ttu-id="def8d-122">La interfaz de textura de OpenGL no admite el escalado automático de imágenes a las dimensiones de potencia de dos.</span><span class="sxs-lookup"><span data-stu-id="def8d-122">The OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions.</span></span> <span data-ttu-id="def8d-123">Sin embargo, GLU admite el escalado de imágenes.</span><span class="sxs-lookup"><span data-stu-id="def8d-123">However, the GLU supports image scaling.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="def8d-124">bbox</span><span class="sxs-lookup"><span data-stu-id="def8d-124">bbox</span></span>                                 | <span data-ttu-id="def8d-125">OpenGL no admite la ejecución condicional de listas de presentación.</span><span class="sxs-lookup"><span data-stu-id="def8d-125">OpenGL doesn't support conditional execution of display lists.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="def8d-126">callfunc</span><span class="sxs-lookup"><span data-stu-id="def8d-126">callfunc</span></span>                             | <span data-ttu-id="def8d-127">OpenGL no admite la devolución de llamada de listas de visualización.</span><span class="sxs-lookup"><span data-stu-id="def8d-127">OpenGL doesn't support callback from display lists.</span></span> <span data-ttu-id="def8d-128">Tenga en cuenta que IRIS GL no admite esta funcionalidad, cuando el cliente y el servidor están en distintas plataformas.</span><span class="sxs-lookup"><span data-stu-id="def8d-128">Note that IRIS GL doesn't support this functionality either, when client and server are on different platforms.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="def8d-129">circle</span><span class="sxs-lookup"><span data-stu-id="def8d-129">circle</span></span>                               | <span data-ttu-id="def8d-130">OpenGL admite círculos con el GLU.</span><span class="sxs-lookup"><span data-stu-id="def8d-130">OpenGL supports circles with the GLU.</span></span> <span data-ttu-id="def8d-131">En OpenGL, los círculos y los arcos (discos y discos parciales) pueden tener huecos.</span><span class="sxs-lookup"><span data-stu-id="def8d-131">In OpenGL both circles and arcs (disks and partial disks) can have holes.</span></span> <span data-ttu-id="def8d-132">Además, puede cambiar la subdivisión de las primitivas en OpenGL, cuyas normales de superficie están disponibles para la iluminación.</span><span class="sxs-lookup"><span data-stu-id="def8d-132">In addition, you can change subdivision of the primitives in OpenGL, whose surface normals are available for lighting.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="def8d-133">borrar opciones</span><span class="sxs-lookup"><span data-stu-id="def8d-133">clear options</span></span>                        | <span data-ttu-id="def8d-134">En realidad, OpenGL borra los búferes.</span><span class="sxs-lookup"><span data-stu-id="def8d-134">OpenGL actually clears buffers.</span></span> <span data-ttu-id="def8d-135">No se aplican las operaciones de píxeles especificadas actualmente, como blending y logicop, independientemente de sus modos.</span><span class="sxs-lookup"><span data-stu-id="def8d-135">It doesn't apply currently specified pixel operations, such as blending and logicop, regardless of their modes.</span></span> <span data-ttu-id="def8d-136">Para borrar el uso de estas características, debe representar un polígono de tamaño de ventana.</span><span class="sxs-lookup"><span data-stu-id="def8d-136">To clear using such features, you must render a window-size polygon.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="def8d-137">líneas cerradas</span><span class="sxs-lookup"><span data-stu-id="def8d-137">closed lines</span></span>                         | <span data-ttu-id="def8d-138">OpenGL representa todas las líneas con alias de un solo ancho, de modo que las líneas colindantes no compartan ningún píxel.</span><span class="sxs-lookup"><span data-stu-id="def8d-138">OpenGL renders all single-width aliased lines such that abutting lines share no pixels.</span></span> <span data-ttu-id="def8d-139">Esto significa que no se dibuja el último píxel de una línea independiente.</span><span class="sxs-lookup"><span data-stu-id="def8d-139">This means that the last pixel of an independent line is not drawn.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="def8d-140">marca de color/normal</span><span class="sxs-lookup"><span data-stu-id="def8d-140">color/normal flag</span></span>                    | <span data-ttu-id="def8d-141">La iluminación de OpenGL está habilitada o deshabilitada explícitamente.</span><span class="sxs-lookup"><span data-stu-id="def8d-141">OpenGL lighting is explicitly enabled or disabled.</span></span> <span data-ttu-id="def8d-142">Cuando está habilitada, es efectiva independientemente del orden en que se especifican los colores y las normales.</span><span class="sxs-lookup"><span data-stu-id="def8d-142">When enabled, it is effective regardless of the order in which colors and normals are specified.</span></span> <span data-ttu-id="def8d-143">No se puede habilitar ni deshabilitar la iluminación entre los comandos OpenGL glBegin y glEnd.</span><span class="sxs-lookup"><span data-stu-id="def8d-143">You cannot enable or disable lighting between OpenGL glBegin and glEnd commands.</span></span> <span data-ttu-id="def8d-144">Para deshabilitar la iluminación entre glBegin y glEnd, especifique cero ambiente de reflexión, difuso y reflejo, y después establezca la emisión de materiales en el color deseado.</span><span class="sxs-lookup"><span data-stu-id="def8d-144">To disable lighting between glBegin and glEnd, specify zero ambient, diffuse, and specular material reflectance, and then set the material emission to the desired color.</span></span>                                                                                                                                                                                                                                                            |
| <span data-ttu-id="def8d-145">polígonos cóncavos</span><span class="sxs-lookup"><span data-stu-id="def8d-145">concave polygons</span></span>                     | <span data-ttu-id="def8d-146">La API de OpenGL básica no controla los polígonos cóncavos, pero el GLU admite la descomposición de los contornos cóncavos que no se intersecan en triángulos.</span><span class="sxs-lookup"><span data-stu-id="def8d-146">The core OpenGL API doesn't handle concave polygons, but the GLU supports decomposing concave, non-self-intersecting contours into triangles.</span></span> <span data-ttu-id="def8d-147">Estos triángulos se pueden dibujar inmediatamente o devolver.</span><span class="sxs-lookup"><span data-stu-id="def8d-147">These triangles can either be drawn immediately or returned.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="def8d-148">color calculado actual</span><span class="sxs-lookup"><span data-stu-id="def8d-148">current computed color</span></span>               | <span data-ttu-id="def8d-149">OpenGL no es equivalente a un color calculado actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-149">OpenGL has no equivalent to a current computed color.</span></span> <span data-ttu-id="def8d-150">Si usa OpenGL como motor de iluminación, puede usar los comentarios para obtener los colores generados por los cálculos de iluminación.</span><span class="sxs-lookup"><span data-stu-id="def8d-150">If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="def8d-151">posición de los gráficos actuales</span><span class="sxs-lookup"><span data-stu-id="def8d-151">current graphics position</span></span>            | <span data-ttu-id="def8d-152">OpenGL no mantiene una posición de gráficos actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-152">OpenGL doesn't maintain a current graphics position.</span></span> <span data-ttu-id="def8d-153">Los comandos de la contabilidad de IRIS que dependen de la posición actual de los gráficos, como las líneas relativas y los polígonos, no se incluyen en OpenGL.</span><span class="sxs-lookup"><span data-stu-id="def8d-153">IRIS GL commands that depend on current graphics position, such as relative lines and polygons, are not included in OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="def8d-154">curvas</span><span class="sxs-lookup"><span data-stu-id="def8d-154">curves</span></span>                               | <span data-ttu-id="def8d-155">OpenGL no admite curvas GL de IRIS.</span><span class="sxs-lookup"><span data-stu-id="def8d-155">OpenGL does not support IRIS GL curves.</span></span> <span data-ttu-id="def8d-156">Se recomienda el uso de curvas de NURBS.</span><span class="sxs-lookup"><span data-stu-id="def8d-156">Use of NURBS curves is recommended.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="def8d-157">acaquís/enlaces</span><span class="sxs-lookup"><span data-stu-id="def8d-157">defs/binds</span></span>                           | <span data-ttu-id="def8d-158">OpenGL no tiene el concepto de objetos de materiales, claros o de texturas; solo las propiedades material, Light y Texture.</span><span class="sxs-lookup"><span data-stu-id="def8d-158">OpenGL doesn't have the concept of material, light, or texture objects; only of material, light, and texture properties.</span></span> <span data-ttu-id="def8d-159">Sin embargo, puede usar listas de visualización para crear sus propios objetos.</span><span class="sxs-lookup"><span data-stu-id="def8d-159">You can use display lists to create their own objects, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="def8d-160">depthcue</span><span class="sxs-lookup"><span data-stu-id="def8d-160">depthcue</span></span>                             | <span data-ttu-id="def8d-161">OpenGL no proporciona compatibilidad directa con cueing de profundidad, pero su compatibilidad con la niebla es una funcionalidad más general que puede usar fácilmente para emular la función Depthcue de la contabilidad de IRIS.</span><span class="sxs-lookup"><span data-stu-id="def8d-161">OpenGL provides no direct support for depth cueing, but its fog support is a more general capability that you can easily use to emulate the IRIS GL depthcue function.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="def8d-162">edición de la lista de visualización</span><span class="sxs-lookup"><span data-stu-id="def8d-162">display list editing</span></span>                 | <span data-ttu-id="def8d-163">Las listas de visualización de OpenGL no se pueden editedonly crear ni destruir.</span><span class="sxs-lookup"><span data-stu-id="def8d-163">OpenGL display lists can't be editedonly created and destroyed.</span></span> <span data-ttu-id="def8d-164">No obstante, dado que puede especificar nombres de lista de visualización, puede volver a definir listas de visualización individuales en una jerarquía.</span><span class="sxs-lookup"><span data-stu-id="def8d-164">Because you can specify display list names, however, you can redefine individual display lists in a hierarchy.</span></span> <span data-ttu-id="def8d-165">Las listas de visualización de OpenGL están diseñadas para el almacenamiento en caché de datos, no para la administración de bases de datos.</span><span class="sxs-lookup"><span data-stu-id="def8d-165">OpenGL display lists are designed for data caching, not for database management.</span></span> <span data-ttu-id="def8d-166">Se garantiza que se almacenan en el servidor en entornos cliente/servidor, por lo que no están limitados por el ancho de banda de red durante la ejecución.</span><span class="sxs-lookup"><span data-stu-id="def8d-166">They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.</span></span> <span data-ttu-id="def8d-167">Se puede llamar a las listas de visualización de OpenGL entre los comandos glBegin y glEnd, por lo que la jerarquía de la lista de presentación puede ser suficientemente adecuada para que se pueda editar.</span><span class="sxs-lookup"><span data-stu-id="def8d-167">OpenGL display lists can be called between glBegin and glEnd commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.</span></span>                                                                                              |
| <span data-ttu-id="def8d-168">comprobación de errores</span><span class="sxs-lookup"><span data-stu-id="def8d-168">error checking</span></span>                       | <span data-ttu-id="def8d-169">OpenGL comprueba los errores con más detenimiento que IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="def8d-169">OpenGL checks for errors more carefully than IRIS GL.</span></span> <span data-ttu-id="def8d-170">Por ejemplo, todas las funciones OpenGL que no se aceptan entre glBegin y glEnd se detectan como errores y no tienen ningún otro efecto.</span><span class="sxs-lookup"><span data-stu-id="def8d-170">For example, all OpenGL functions that are not accepted between glBegin and glEnd are detected as errors, and have no other effect.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="def8d-171">valores devueltos de error</span><span class="sxs-lookup"><span data-stu-id="def8d-171">error return values</span></span>                  | <span data-ttu-id="def8d-172">Cuando un comando OpenGL que devuelve un valor detecta un error, siempre devuelve cero.</span><span class="sxs-lookup"><span data-stu-id="def8d-172">When an OpenGL command that returns a value detects an error, it always returns zero.</span></span> <span data-ttu-id="def8d-173">Los comandos OpenGL que devuelven datos a través de punteros pasados no realizan ningún cambio en el contenido de la matriz si se detecta un error.</span><span class="sxs-lookup"><span data-stu-id="def8d-173">OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="def8d-174">efectos secundarios de error</span><span class="sxs-lookup"><span data-stu-id="def8d-174">error side effects</span></span>                   | <span data-ttu-id="def8d-175">Cuando un comando OpenGL produce un error, su único efecto secundario es actualizar la marca de error al valor adecuado.</span><span class="sxs-lookup"><span data-stu-id="def8d-175">When an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value.</span></span> <span data-ttu-id="def8d-176">No se realiza ningún otro cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="def8d-176">No other state changes are made.</span></span> <span data-ttu-id="def8d-177">(Una excepción es la salida \_ De \_ error de memoria, que es fatal).</span><span class="sxs-lookup"><span data-stu-id="def8d-177">(An exception is the OUT\_OF\_MEMORY error, which is fatal.)</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="def8d-178">feedback</span><span class="sxs-lookup"><span data-stu-id="def8d-178">feedback</span></span>                             | <span data-ttu-id="def8d-179">Los comentarios están normalizados en OpenGL, por lo que no cambian de equipo a equipo.</span><span class="sxs-lookup"><span data-stu-id="def8d-179">Feedback is standardized in OpenGL so it doesn't change from machine to machine.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="def8d-180">fuentes y cadenas</span><span class="sxs-lookup"><span data-stu-id="def8d-180">fonts and strings</span></span>                    | <span data-ttu-id="def8d-181">OpenGL requiere que los glifos de caracteres se manipulen como listas de visualización individuales.</span><span class="sxs-lookup"><span data-stu-id="def8d-181">OpenGL requires character glyphs to be manipulated as individual display lists.</span></span> <span data-ttu-id="def8d-182">Proporciona una función de llamada de lista de presentación que acepta una lista de nombres de listas de visualización, cada uno de los cuales se representa como 1, 2 o 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="def8d-182">It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes.</span></span> <span data-ttu-id="def8d-183">La función glCallLists agrega un desplazamiento especificado por separado a cada nombre de lista de presentación antes de la llamada, lo que permite que las listas de nombres de lista de presentación se traten como cadenas.</span><span class="sxs-lookup"><span data-stu-id="def8d-183">The glCallLists function adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings.</span></span> <span data-ttu-id="def8d-184">Este mecanismo proporciona toda la funcionalidad de las fuentes de la contabilidad de IRIS y mucho más.</span><span class="sxs-lookup"><span data-stu-id="def8d-184">This mechanism provides all the functionality of IRIS GL fonts, and considerably more.</span></span> <span data-ttu-id="def8d-185">Por ejemplo, los caracteres compuestos de triángulos se pueden manipular fácilmente.</span><span class="sxs-lookup"><span data-stu-id="def8d-185">For example, characters comprised of triangles can be easily manipulated.</span></span>                                                                                                                  |
| <span data-ttu-id="def8d-186">frontbuffer</span><span class="sxs-lookup"><span data-stu-id="def8d-186">frontbuffer</span></span>                          | <span data-ttu-id="def8d-187">IRIS GL tiene reglas complejas para la representación en el búfer frontal en el modo de búfer único.</span><span class="sxs-lookup"><span data-stu-id="def8d-187">IRIS GL has complex rules for rendering to the front buffer in single buffer mode.</span></span> <span data-ttu-id="def8d-188">OpenGL controla la representación en el búfer frontal de una manera sencilla.</span><span class="sxs-lookup"><span data-stu-id="def8d-188">OpenGL handles rendering to the front buffer in a straightforward way.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="def8d-189">polígonos huecos</span><span class="sxs-lookup"><span data-stu-id="def8d-189">hollow polygons</span></span>                      | <span data-ttu-id="def8d-190">Puede usar la capacidad de la galería de símbolos de OpenGL para representar polígonos huecos.</span><span class="sxs-lookup"><span data-stu-id="def8d-190">You can use the OpenGL stencil capacity to render hollow polygons.</span></span> <span data-ttu-id="def8d-191">OpenGL no es compatible con otros medios para crear polígonos huecos.</span><span class="sxs-lookup"><span data-stu-id="def8d-191">OpenGL doesn't support other means for creating hollow polygons.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="def8d-192">fijación de índices</span><span class="sxs-lookup"><span data-stu-id="def8d-192">index clamping</span></span>                       | <span data-ttu-id="def8d-193">Siempre que sea posible, OpenGL trata los índices de color y de estarcido como campos de bits en lugar de números.</span><span class="sxs-lookup"><span data-stu-id="def8d-193">Where possible, OpenGL treats color and stencil indexes as bit fields rather than numbers.</span></span> <span data-ttu-id="def8d-194">Por lo tanto, los índices se enmascaran, en lugar de estar fijados, en el intervalo admitido de fotogramas.</span><span class="sxs-lookup"><span data-stu-id="def8d-194">Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="def8d-195">colores enteros</span><span class="sxs-lookup"><span data-stu-id="def8d-195">integer colors</span></span>                       | <span data-ttu-id="def8d-196">Los componentes de color de entero con signo (rojo, verde, azul o alfa) se asignan de manera lineal a los puntos flotantes para que el entero más negativo se asigne a 1,0 y el entero más positivo se asigne a 1,0.</span><span class="sxs-lookup"><span data-stu-id="def8d-196">Signed integer color components (red, green, blue, or alpha) are mapped in linear fashion to floating points so that the most negative integer maps to 1.0 and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="def8d-197">Esta asignación se produce cuando se especifica el color antes de que OpenGL Reemplace el color actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-197">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span> <span data-ttu-id="def8d-198">Los componentes de color de entero sin signo se asignan linealmente a los puntos flotantes para que 0 se asigne a 0,0 y el entero más grande se asigne a 1,0.</span><span class="sxs-lookup"><span data-stu-id="def8d-198">Unsigned integer color components are mapped linearly to floating points so that 0 maps to 0.0 and the largest integer maps to 1.0.</span></span> <span data-ttu-id="def8d-199">Esta asignación se produce cuando se especifica el color antes de que OpenGL Reemplace el color actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-199">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span>                                                                                                                                               |
| <span data-ttu-id="def8d-200">normales de entero</span><span class="sxs-lookup"><span data-stu-id="def8d-200">integer normals</span></span>                      | <span data-ttu-id="def8d-201">Los componentes normales de enteros se asignan igual que los componentes de color firmados.</span><span class="sxs-lookup"><span data-stu-id="def8d-201">Integer normal components are mapped just like signed color components.</span></span> <span data-ttu-id="def8d-202">El número entero más negativo se asigna a 1,0 y el entero más positivo se asigna a 1,0.</span><span class="sxs-lookup"><span data-stu-id="def8d-202">The most negative integer maps to 1.0, and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="def8d-203">fragmentos de píxeles.</span><span class="sxs-lookup"><span data-stu-id="def8d-203">pixel fragments.</span></span> <span data-ttu-id="def8d-204">Los píxeles dibujados por glDrawPixels o glCopyPixels siempre se rasterizan y se convierten en fragmentos.</span><span class="sxs-lookup"><span data-stu-id="def8d-204">Pixels drawn by glDrawPixels or glCopyPixels are always rasterized and converted to fragments.</span></span> <span data-ttu-id="def8d-205">Los fragmentos resultantes tienen texturas, térmicas, de profundidad, de mezcla, etc., como si se hubieran generado a partir de puntos geométricos.</span><span class="sxs-lookup"><span data-stu-id="def8d-205">The resulting fragments are textured, fogged, depth buffered, blended, and so on, just as if they were generated from geometric points.</span></span> <span data-ttu-id="def8d-206">Los datos de fragmento que no proporcionan los píxeles de origen se amplían de la posición de la trama actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-206">Fragment data that isn't provided by the source pixels is augmented from the current raster position.</span></span> <span data-ttu-id="def8d-207">Por ejemplo, RGBA píxeles toman las coordenadas Z y Texture de la posición de la trama.</span><span class="sxs-lookup"><span data-stu-id="def8d-207">For example, RGBA pixels take the raster position Z and texture coordinates.</span></span> <span data-ttu-id="def8d-208">Los píxeles de profundidad toman las coordenadas color y Texture de la posición de la trama.</span><span class="sxs-lookup"><span data-stu-id="def8d-208">Depth pixels take the raster position color and texture coordinates.</span></span> |
| <span data-ttu-id="def8d-209">invarianza</span><span class="sxs-lookup"><span data-stu-id="def8d-209">invariance</span></span>                           | <span data-ttu-id="def8d-210">OpenGL garantiza una coherencia determinada que no es de IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="def8d-210">OpenGL guarantees a certain consistency that IRIS GL doesn't.</span></span> <span data-ttu-id="def8d-211">Por ejemplo, OpenGL garantiza que las secuencias de código idénticas enviadas al mismo sistema, que solo difieran en la función de fusión especificada, generarán los mismos fragmentos de píxeles.</span><span class="sxs-lookup"><span data-stu-id="def8d-211">For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the specified blending function, will generate the same pixel fragments.</span></span> <span data-ttu-id="def8d-212">(Los fragmentos difieren, sin embargo, si la combinación está habilitada y, a continuación, deshabilitada).</span><span class="sxs-lookup"><span data-stu-id="def8d-212">(The fragments differ, however, if blending is enabled and then disabled.)</span></span>                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="def8d-213">ecuación de iluminación</span><span class="sxs-lookup"><span data-stu-id="def8d-213">lighting equation</span></span>                    | <span data-ttu-id="def8d-214">La ecuación de iluminación de OpenGL difiere ligeramente de la ecuación de GL de IRIS.</span><span class="sxs-lookup"><span data-stu-id="def8d-214">The OpenGL lighting equation differs slightly from the IRIS GL equation.</span></span> <span data-ttu-id="def8d-215">OpenGL admite atenuación independiente para cada fuente de luz, en lugar de una sola atenuación para todas las fuentes de luz como IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="def8d-215">OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources like IRIS GL.</span></span> <span data-ttu-id="def8d-216">OpenGL ajusta la ecuación para que las contribuciones de la iluminación ambiente, difuso y difuminado estén atenuadas.</span><span class="sxs-lookup"><span data-stu-id="def8d-216">OpenGL adjusts the equation so that ambient, diffuse, and specular lighting contributions are all attenuated.</span></span> <span data-ttu-id="def8d-217">Además, OpenGL le permite especificar colores independientes para las intensidades ambiente, difuso y especular de las fuentes de luz, así como para el ambiente, la reflexión difusa y la reflexión especular de los materiales.</span><span class="sxs-lookup"><span data-stu-id="def8d-217">Also, OpenGL allows you to specify separate colors for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials.</span></span> <span data-ttu-id="def8d-218">Todos los colores de la luz y el material de OpenGL incluyen alfa.</span><span class="sxs-lookup"><span data-stu-id="def8d-218">All OpenGL light and material colors include alpha.</span></span> <span data-ttu-id="def8d-219">Al establecer el exponente especular en cero no se anula la iluminación especular en OpenGL.</span><span class="sxs-lookup"><span data-stu-id="def8d-219">Setting the specular exponent to zero does not defeat specular lighting in OpenGL.</span></span>    |
| <span data-ttu-id="def8d-220">mapw</span><span class="sxs-lookup"><span data-stu-id="def8d-220">mapw</span></span>                                 | <span data-ttu-id="def8d-221">Las utilidades OpenGL admiten la asignación entre coordenadas de objetos y ventanas.</span><span class="sxs-lookup"><span data-stu-id="def8d-221">OpenGL utilities support mapping between object and window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="def8d-222">modo de matriz</span><span class="sxs-lookup"><span data-stu-id="def8d-222">matrix mode</span></span>                          | <span data-ttu-id="def8d-223">En el caso de las funciones de Ortho, ortho2, Perspective y Window de IRIS en una matriz determinada, todas las operaciones de matriz de OpenGL funcionan en la matriz actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-223">Where the IRIS GL ortho, ortho2, perspective, and window functions operate on a particular matrix, all OpenGL matrix operations work on the current matrix.</span></span> <span data-ttu-id="def8d-224">Todas las operaciones de matriz de OpenGL excepto glLoadIdentity y glLoadMatrix multiplican la matriz actual en lugar de reemplazarla (como Ortho, ortho2, Perspective y Window en la contabilidad de IRIS).</span><span class="sxs-lookup"><span data-stu-id="def8d-224">All OpenGL matrix operations except glLoadIdentity and glLoadMatrix multiply the current matrix rather than replacing it (as do ortho, ortho2, perspective, and window in the IRIS GL).</span></span>                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="def8d-225">mapas automáticos, generación automática</span><span class="sxs-lookup"><span data-stu-id="def8d-225">mipmaps, automatic generation</span></span>        | <span data-ttu-id="def8d-226">La interfaz de textura OpenGL no admite la generación automática de imágenes MIP.</span><span class="sxs-lookup"><span data-stu-id="def8d-226">The OpenGL texture interface does not support automatic generation of mipmap images.</span></span> <span data-ttu-id="def8d-227">Sin embargo, GLU admite la generación automática de imágenes MIP para las texturas 1-D y 2D.</span><span class="sxs-lookup"><span data-stu-id="def8d-227">However, the GLU supports the automatic generation of mipmap images for both 1-D and 2-D textures.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="def8d-228">Move/Draw/PMove/pdraw/PCLOS</span><span class="sxs-lookup"><span data-stu-id="def8d-228">move/draw/pmove/pdraw/pclos</span></span>          | <span data-ttu-id="def8d-229">OpenGL solo admite gráficos de estilo Begin/end, ya que no mantiene una posición de gráficos actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-229">OpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position.</span></span> <span data-ttu-id="def8d-230">No obstante, OpenGL acepta la especificación de parámetros escalares de los comandos de movimiento y dibujo antiguos para todos los comandos relacionados con los vértices.</span><span class="sxs-lookup"><span data-stu-id="def8d-230">The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="def8d-231">modo mprojection</span><span class="sxs-lookup"><span data-stu-id="def8d-231">mprojection mode</span></span>                     | <span data-ttu-id="def8d-232">IRIS GL no transforma Geometry por la matriz MODELVIEW en modo de matriz de proyección.</span><span class="sxs-lookup"><span data-stu-id="def8d-232">IRIS GL doesn't transform geometry by the modelview matrix while in projection matrix mode.</span></span> <span data-ttu-id="def8d-233">OpenGL siempre transforma por el MODELVIEW y la matriz de proyección, independientemente del modo de matriz.</span><span class="sxs-lookup"><span data-stu-id="def8d-233">OpenGL always transforms by both the modelview and the projection matrix, regardless of matrix mode.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="def8d-234">dibujo de varios búferes</span><span class="sxs-lookup"><span data-stu-id="def8d-234">multi-buffer drawing</span></span>                 | <span data-ttu-id="def8d-235">OpenGL se representa individualmente en cada búfer de color, en lugar de calcular un valor de color único y nuevo basado en el contenido de un búfer de color y escribirlo en todos los búferes de color habilitados, como lo hace IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="def8d-235">OpenGL renders to each color buffer individually, rather than computing a single, new, color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL does.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="def8d-236">NURBS</span><span class="sxs-lookup"><span data-stu-id="def8d-236">NURBS</span></span>                                | <span data-ttu-id="def8d-237">OpenGL admite NURBS con una combinación de funcionalidad básica (evaluadores) y soporte GLU.</span><span class="sxs-lookup"><span data-stu-id="def8d-237">OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support.</span></span> <span data-ttu-id="def8d-238">Se admiten todas las funcionalidades de NURBS GL de IRIS.</span><span class="sxs-lookup"><span data-stu-id="def8d-238">All IRIS GL NURBS capabilities are supported.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="def8d-239">modo de polígono anterior</span><span class="sxs-lookup"><span data-stu-id="def8d-239">old polygon mode</span></span>                     | <span data-ttu-id="def8d-240">Los polígonos OpenGL con alias siempre se muestran con puntos.</span><span class="sxs-lookup"><span data-stu-id="def8d-240">Aliased OpenGL polygons are always point-sampled.</span></span> <span data-ttu-id="def8d-241">El modo de compatibilidad de polígono de la contabilidad de IRIS, donde los píxeles fuera del perímetro del polígono se incluyen en su rasterización, no se admite.</span><span class="sxs-lookup"><span data-stu-id="def8d-241">IRIS GL's polygon compatibility mode, where pixels outside the polygon perimeter are included in its rasterization, is not supported.</span></span> <span data-ttu-id="def8d-242">Si el código utiliza este modo de polígono, es probable que se trate de rectángulos.</span><span class="sxs-lookup"><span data-stu-id="def8d-242">If your code uses this polygon mode, it is probably for rectangles.</span></span> <span data-ttu-id="def8d-243">Los rectángulos de modo poligonal antiguos aparecen un píxel más ancho y superior.</span><span class="sxs-lookup"><span data-stu-id="def8d-243">Old polygon mode rectangles appear one pixel wider and higher.</span></span>                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="def8d-244">formatos de color empaquetados</span><span class="sxs-lookup"><span data-stu-id="def8d-244">packed color formats</span></span>                 | <span data-ttu-id="def8d-245">OpenGL acepta colores como componentes de 8 bits, pero estos componentes se tratan como una matriz de bytes en lugar de como bytes empaquetados en palabras más grandes.</span><span class="sxs-lookup"><span data-stu-id="def8d-245">OpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words.</span></span> <span data-ttu-id="def8d-246">Al animar la indexación de matrices en lugar de desplazarse, OpenGL promueve la programación invariable de endian.</span><span class="sxs-lookup"><span data-stu-id="def8d-246">By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.</span></span> <span data-ttu-id="def8d-247">Del mismo modo que IRIS GL acepta colores empaquetados para la representación geométrica y en píxeles, OpenGL acepta matrices de componentes de color para la representación geométrica y en píxeles.</span><span class="sxs-lookup"><span data-stu-id="def8d-247">Just as IRIS GL accepts packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.</span></span>                                                                                                                                                                                                                                                              |
| <span data-ttu-id="def8d-248">revisiones</span><span class="sxs-lookup"><span data-stu-id="def8d-248">patches</span></span>                              | <span data-ttu-id="def8d-249">OpenGL no es compatible con las revisiones GL de IRIS.</span><span class="sxs-lookup"><span data-stu-id="def8d-249">OpenGL doesn't support IRIS GL patches.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="def8d-250">writemask de color por bits</span><span class="sxs-lookup"><span data-stu-id="def8d-250">per-bit color writemask</span></span>              | <span data-ttu-id="def8d-251">Los componentes de color de writemasks de OpenGL habilitan o deshabilitan los cambios en todo el componente (rojo, verde, azul o alfa), no en bits individuales de componentes.</span><span class="sxs-lookup"><span data-stu-id="def8d-251">OpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components.</span></span> <span data-ttu-id="def8d-252">Sin embargo, tenga en cuenta que los writemasks por bit se admiten tanto para índices de color como para índices de estarcido.</span><span class="sxs-lookup"><span data-stu-id="def8d-252">Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="def8d-253">profundidad por bits writemask</span><span class="sxs-lookup"><span data-stu-id="def8d-253">per-bit depth writemask</span></span>              | <span data-ttu-id="def8d-254">Los componentes de OpenGL writemasks para profundidad habilitan o deshabilitan los cambios en todo el componente, no en los bits individuales del componente de profundidad.</span><span class="sxs-lookup"><span data-stu-id="def8d-254">OpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="def8d-255">elegir</span><span class="sxs-lookup"><span data-stu-id="def8d-255">pick</span></span>                                 | <span data-ttu-id="def8d-256">La biblioteca de utilidades OpenGL incluye compatibilidad para generar una matriz de picking.</span><span class="sxs-lookup"><span data-stu-id="def8d-256">The OpenGL Utility library includes support for generating a pick matrix.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="def8d-257">coordenadas de píxeles</span><span class="sxs-lookup"><span data-stu-id="def8d-257">pixel coordinates</span></span>                    | <span data-ttu-id="def8d-258">En OpenGL y IRIS GL, el origen del sistema de coordenadas de una ventana está en la esquina inferior izquierda.</span><span class="sxs-lookup"><span data-stu-id="def8d-258">In both OpenGL and IRIS GL, the origin of a window's coordinate system is at its lower left corner.</span></span> <span data-ttu-id="def8d-259">OpenGL coloca el origen en la esquina inferior izquierda de este píxel, sin embargo, mientras que IRIS GL lo coloca en el centro del píxel inferior izquierdo.</span><span class="sxs-lookup"><span data-stu-id="def8d-259">OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL places it at the center of the lower left pixel.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="def8d-260">zoom de píxeles</span><span class="sxs-lookup"><span data-stu-id="def8d-260">pixel zoom</span></span>                           | <span data-ttu-id="def8d-261">Los factores de zoom negativos de OpenGL reflejan la posición actual de los gráficos.</span><span class="sxs-lookup"><span data-stu-id="def8d-261">OpenGL negative zoom factors reflect about the current graphics position.</span></span> <span data-ttu-id="def8d-262">IRIS GL no define el funcionamiento de los factores de zoom negativos y, en su lugar, proporciona la reflexión de derecha \_ a \_ izquierda y \_ de arriba a \_ abajo pixmodes.</span><span class="sxs-lookup"><span data-stu-id="def8d-262">IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT\_TO\_LEFT and TOP\_TO\_BOTTOM reflection pixmodes.</span></span> <span data-ttu-id="def8d-263">Estos modos de reflexión reflejan en su lugar, en lugar de sobre la posición de la trama actual.</span><span class="sxs-lookup"><span data-stu-id="def8d-263">These reflection modes reflect in place, rather than about the current raster position.</span></span> <span data-ttu-id="def8d-264">OpenGL no define los modos de reflexión.</span><span class="sxs-lookup"><span data-stu-id="def8d-264">OpenGL doesn't define reflection modes.</span></span>                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="def8d-265">pixmode</span><span class="sxs-lookup"><span data-stu-id="def8d-265">pixmode</span></span>                              | <span data-ttu-id="def8d-266">Las transferencias de píxeles de OpenGL funcionan en componentes de color individuales, en lugar de en grupos empaquetados de componentes de 4 8 bits como el de IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="def8d-266">OpenGL pixel transfers operate on individual color components, rather than on packed groups of four 8-bit components as does IRIS GL.</span></span> <span data-ttu-id="def8d-267">Aunque OpenGL proporciona mucha más capacidad de píxeles que IRIS GL, no admite construcciones de color empaquetadas y no permite reasignar los componentes de color (rojo a verde, rojo a azul, etc.) durante las operaciones de copia de píxeles.</span><span class="sxs-lookup"><span data-stu-id="def8d-267">While OpenGL provides substantially more pixel capability than IRIS GL, it doesn't support packed color constructs, and it doesn't enable color components to be reassigned (red to green, red to blue, and so on) during pixel copy operations.</span></span>                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="def8d-268">POLF/poli</span><span class="sxs-lookup"><span data-stu-id="def8d-268">polf/poly</span></span>                            | <span data-ttu-id="def8d-269">OpenGL no proporciona compatibilidad directa con las listas de vértices que no sean listas de visualización.</span><span class="sxs-lookup"><span data-stu-id="def8d-269">OpenGL provides no direct support for vertex lists other than display lists.</span></span> <span data-ttu-id="def8d-270">Sin embargo, las funciones como POLF y poli se pueden implementar fácilmente mediante la API de OpenGL.</span><span class="sxs-lookup"><span data-stu-id="def8d-270">Functions like polf and poly can be implemented easily using the OpenGL API, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="def8d-271">vértice de la provocación de polígono</span><span class="sxs-lookup"><span data-stu-id="def8d-271">polygon provoking vertex</span></span>             | <span data-ttu-id="def8d-272">Los polígonos de la contabilidad de IRIS con sombreado plano toman el color del último vértice especificado, mientras que los polígonos de OpenGL toman el color del primer vértice especificado.</span><span class="sxs-lookup"><span data-stu-id="def8d-272">Flat shaded IRIS GL polygons take the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="def8d-273">punteado de polígono</span><span class="sxs-lookup"><span data-stu-id="def8d-273">polygon stipple</span></span>                      | <span data-ttu-id="def8d-274">With IRIS GL el patrón punteado de polígono es relativo a la pantalla.</span><span class="sxs-lookup"><span data-stu-id="def8d-274">With IRIS GL the polygon stipple pattern is relative to the screen.</span></span> <span data-ttu-id="def8d-275">Con OpenGL, es relativo a una ventana.</span><span class="sxs-lookup"><span data-stu-id="def8d-275">With OpenGL it is relative to a window.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="def8d-276">recuento de vértices de polígono</span><span class="sxs-lookup"><span data-stu-id="def8d-276">polygon vertex count</span></span>                 | <span data-ttu-id="def8d-277">No hay ningún límite en el número de vértices entre glBegin y glEnd con OpenGL, incluso para glBegin (POLYGON).</span><span class="sxs-lookup"><span data-stu-id="def8d-277">There is no limit to the number of vertices between glBegin and glEnd with OpenGL, even for glBegin(POLYGON ).</span></span> <span data-ttu-id="def8d-278">Con IRIS GL, los polígonos se limitan a no más de 255 vértices.</span><span class="sxs-lookup"><span data-stu-id="def8d-278">With IRIS GL, polygons are limited to no more than 255 vertices.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="def8d-279">readdisplay</span><span class="sxs-lookup"><span data-stu-id="def8d-279">readdisplay</span></span>                          | <span data-ttu-id="def8d-280">Leer píxeles fuera de los límites de la ventana es correctamente una funcionalidad del sistema de ventanas, en lugar de una capacidad de representación.</span><span class="sxs-lookup"><span data-stu-id="def8d-280">Reading pixels outside window boundaries is properly a window system capability, rather than a rendering capability.</span></span> <span data-ttu-id="def8d-281">Use las funciones de Windows para reemplazar el comando IRIS GL readdisplay.</span><span class="sxs-lookup"><span data-stu-id="def8d-281">Use Windows functions to replace the IRIS GL readdisplay command.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="def8d-282">relativa Move/Draw/PMove/pdraw/PCLOS</span><span class="sxs-lookup"><span data-stu-id="def8d-282">relative move/draw/pmove/pdraw/pclos</span></span> | <span data-ttu-id="def8d-283">OpenGL no mantiene una posición de gráficos actual y, por tanto, no admite operaciones de vértices relativas.</span><span class="sxs-lookup"><span data-stu-id="def8d-283">OpenGL doesn't maintain a current graphics position, and therefore doesn't support relative vertex operations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="def8d-284">RGBA logicop ()</span><span class="sxs-lookup"><span data-stu-id="def8d-284">RGBA logicop()</span></span>                       | <span data-ttu-id="def8d-285">OpenGL no admite operaciones lógicas en búferes RGBA.</span><span class="sxs-lookup"><span data-stu-id="def8d-285">OpenGL does not support logical operations on RGBA buffers.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="def8d-286">sbox()</span><span class="sxs-lookup"><span data-stu-id="def8d-286">sbox()</span></span>                               | <span data-ttu-id="def8d-287">SBOX es un primitivo de rectángulo de contabilidad de IRIS que está bien definido solo si se transforma sin giro.</span><span class="sxs-lookup"><span data-stu-id="def8d-287">sbox is an IRIS GL rectangle primitive that is well-defined only if transformed without rotation.</span></span> <span data-ttu-id="def8d-288">Está diseñado para representarse más rápido que los rectángulos estándar.</span><span class="sxs-lookup"><span data-stu-id="def8d-288">It is designed to be rendered faster than standard rectangles.</span></span> <span data-ttu-id="def8d-289">Aunque OpenGL no es compatible con este tipo de primitiva, se puede optimizar para representar rectángulos muy rápidamente cuando las matrices y otros modos están en los Estados que simplifican los cálculos.</span><span class="sxs-lookup"><span data-stu-id="def8d-289">While OpenGL doesn't support such a primitive, it can be tuned to render rectangles very quickly when the matrices and other modes are in states that simplify calculations.</span></span>                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="def8d-290">argumentos escalares</span><span class="sxs-lookup"><span data-stu-id="def8d-290">scalar arguments</span></span>                     | <span data-ttu-id="def8d-291">Todos los comandos OpenGL que se aceptan entre glBegin y glEnd tienen puntos de entrada que aceptan argumentos escalares.</span><span class="sxs-lookup"><span data-stu-id="def8d-291">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept scalar arguments.</span></span> <span data-ttu-id="def8d-292">Por ejemplo, glColor4f (rojo, verde, azul, alfa).</span><span class="sxs-lookup"><span data-stu-id="def8d-292">For example, glColor4f (red, green, blue, alpha ).</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="def8d-293">tijera</span><span class="sxs-lookup"><span data-stu-id="def8d-293">scissor</span></span>                              | <span data-ttu-id="def8d-294">La función glScissor de OpenGL no realiza un seguimiento de la ventanilla.</span><span class="sxs-lookup"><span data-stu-id="def8d-294">The OpenGL glScissor function doesn't track the viewport.</span></span> <span data-ttu-id="def8d-295">El comando de ventanilla GL de IRIS actualiza automáticamente el scrmask.</span><span class="sxs-lookup"><span data-stu-id="def8d-295">The IRIS GL viewport command automatically updates the scrmask.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="def8d-296">scrbox()</span><span class="sxs-lookup"><span data-stu-id="def8d-296">scrbox()</span></span>                             | <span data-ttu-id="def8d-297">OpenGL no es compatible con el cálculo del cuadro de límite.</span><span class="sxs-lookup"><span data-stu-id="def8d-297">OpenGL doesn't support bounding box computation.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="def8d-298">scrsubdivide()</span><span class="sxs-lookup"><span data-stu-id="def8d-298">scrsubdivide()</span></span>                       | <span data-ttu-id="def8d-299">OpenGL no admite la subdivisión de la pantalla.</span><span class="sxs-lookup"><span data-stu-id="def8d-299">OpenGL doesn't support screen subdivision.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="def8d-300">modo de matriz única</span><span class="sxs-lookup"><span data-stu-id="def8d-300">single matrix mode</span></span>                   | <span data-ttu-id="def8d-301">OpenGL siempre mantiene dos matrices: ModelView y proyección.</span><span class="sxs-lookup"><span data-stu-id="def8d-301">OpenGL always maintains two matrices: ModelView and Projection.</span></span> <span data-ttu-id="def8d-302">Aunque una implementación de OpenGL puede consolidar estos en una matriz única por motivos de rendimiento, siempre debe presentar el modelo de dos matrices al programador.</span><span class="sxs-lookup"><span data-stu-id="def8d-302">While an OpenGL implementation can consolidate these into a single matrix for performance reasons, it must always present the two-matrix model to the programmer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| <span data-ttu-id="def8d-303">modo de subpíxeles</span><span class="sxs-lookup"><span data-stu-id="def8d-303">subpixel mode</span></span>                        | <span data-ttu-id="def8d-304">La representación de OpenGL es el modo de positionedsubpixel de subpíxeles siempre activado.</span><span class="sxs-lookup"><span data-stu-id="def8d-304">All OpenGL rendering is subpixel positionedsubpixel mode is always on.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="def8d-305">swaptmesh()</span><span class="sxs-lookup"><span data-stu-id="def8d-305">swaptmesh()</span></span>                          | <span data-ttu-id="def8d-306">OpenGL no admite la funcionalidad swaptmesh.</span><span class="sxs-lookup"><span data-stu-id="def8d-306">OpenGL doesn't support the swaptmesh capability.</span></span> <span data-ttu-id="def8d-307">Ofrece dos tipos de mallas triangulares, sin embargo: uno que se corresponda con el comportamiento predeterminado de la franja de IRIS y otro que se corresponda con la llamada a swaptmesh antes del tercer y todos los vértices posteriores al usar IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="def8d-307">It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling swaptmesh prior to the third and all subsequent vertices when using IRIS GL.</span></span>                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="def8d-308">argumentos vectoriales</span><span class="sxs-lookup"><span data-stu-id="def8d-308">vector arguments</span></span>                     | <span data-ttu-id="def8d-309">Todos los comandos OpenGL que se aceptan entre glBegin y glEnd tienen puntos de entrada que aceptan argumentos vectoriales.</span><span class="sxs-lookup"><span data-stu-id="def8d-309">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept vector arguments.</span></span> <span data-ttu-id="def8d-310">Por ejemplo, glColor4fv.</span><span class="sxs-lookup"><span data-stu-id="def8d-310">For example, glColor4fv .</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="def8d-311">administración de ventanas</span><span class="sxs-lookup"><span data-stu-id="def8d-311">window management</span></span>                    | <span data-ttu-id="def8d-312">OpenGL no incluye ningún comando del sistema de Windows.</span><span class="sxs-lookup"><span data-stu-id="def8d-312">OpenGL includes no window system commands.</span></span> <span data-ttu-id="def8d-313">Siempre se admite como una extensión de una ventana o sistema operativo que incluye funcionalidad para el dispositivo y el control de ventana.</span><span class="sxs-lookup"><span data-stu-id="def8d-313">It is always supported as an extension to a window or operating system that includes capability for device and window control.</span></span> <span data-ttu-id="def8d-314">Cada extensión proporciona un mecanismo específico del sistema para crear, destruir y manipular contextos de representación de OpenGL.</span><span class="sxs-lookup"><span data-stu-id="def8d-314">Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts.</span></span> <span data-ttu-id="def8d-315">Por ejemplo, la extensión OpenGL para el sistema de ventana X (GLX) incluye aproximadamente 10 comandos para este fin.</span><span class="sxs-lookup"><span data-stu-id="def8d-315">For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.</span></span> <span data-ttu-id="def8d-316">OpenGL no implementa los comandos de la contabilidad de IRIS, como gconfig y DrawMode.</span><span class="sxs-lookup"><span data-stu-id="def8d-316">IRIS GL commands such as gconfig and drawmode are not implemented by OpenGL.</span></span>                                                                                                                                                                            |
| <span data-ttu-id="def8d-317">desplazamiento de la ventana</span><span class="sxs-lookup"><span data-stu-id="def8d-317">window offset</span></span>                        | <span data-ttu-id="def8d-318">IRIS GL devuelve la ventanilla y las posiciones de caracteres en la pantalla, en lugar de las coordenadas de la ventana.</span><span class="sxs-lookup"><span data-stu-id="def8d-318">IRIS GL returns viewport and character positions in screen, rather than window, coordinates.</span></span> <span data-ttu-id="def8d-319">OpenGL siempre usa coordenadas de ventana.</span><span class="sxs-lookup"><span data-stu-id="def8d-319">OpenGL always uses window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="def8d-320">representación en z</span><span class="sxs-lookup"><span data-stu-id="def8d-320">z rendering</span></span>                          | <span data-ttu-id="def8d-321">OpenGL no admite la representación de colores en el búfer de profundidad.</span><span class="sxs-lookup"><span data-stu-id="def8d-321">OpenGL doesn't support rendering colors to the depth buffer.</span></span> <span data-ttu-id="def8d-322">Permite otros búferes de color, que se pueden implementar con la misma memoria que se usa para los búferes de profundidad en otras configuraciones de ventana.</span><span class="sxs-lookup"><span data-stu-id="def8d-322">It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurations.</span></span> <span data-ttu-id="def8d-323">Sin embargo, estos búferes de color adicionales no pueden compartir memoria con el búfer de profundidad en una configuración única.</span><span class="sxs-lookup"><span data-stu-id="def8d-323">But these additional color buffers cannot share memory with the depth buffer in any single configuration.</span></span>                                                                                                                                                                                                                                                                                                                                          |



 

 

 




