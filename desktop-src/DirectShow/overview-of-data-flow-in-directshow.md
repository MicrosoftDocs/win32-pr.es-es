---
description: Información general sobre el flujo de datos en DirectShow
ms.assetid: a1b30592-5106-44f5-8ee0-577573670167
title: Información general sobre el flujo de datos en DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5a34444991d6cba62026935f5ec2d7aa4eba77
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/06/2021
ms.locfileid: "104495448"
---
# <a name="overview-of-data-flow-in-directshow"></a><span data-ttu-id="752a0-103">Información general sobre el flujo de datos en DirectShow</span><span class="sxs-lookup"><span data-stu-id="752a0-103">Overview of Data Flow in DirectShow</span></span>

<span data-ttu-id="752a0-104">En esta sección se ofrece una amplia información general sobre cómo funciona el flujo de datos en DirectShow.</span><span class="sxs-lookup"><span data-stu-id="752a0-104">This section gives a broad overview of how data flow works in DirectShow.</span></span> <span data-ttu-id="752a0-105">Los detalles se pueden encontrar en otras secciones de la documentación de.</span><span class="sxs-lookup"><span data-stu-id="752a0-105">Details can be found in other sections of the documentation.</span></span>

<span data-ttu-id="752a0-106">Los datos se almacenan en búferes, que son simplemente matrices de bytes.</span><span class="sxs-lookup"><span data-stu-id="752a0-106">Data is held in buffers, which are simply arrays of bytes.</span></span> <span data-ttu-id="752a0-107">Cada búfer está incluido en un objeto COM denominado *ejemplo multimedia*, que implementa la interfaz [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="752a0-107">Each buffer is wrapped by a COM object called a *media sample*, which implements the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="752a0-108">Los ejemplos se crean mediante otro tipo de objeto, denominado allocator, que implementa la interfaz [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="752a0-108">Samples are created by another type of object, called an allocator, which implements the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="752a0-109">Se asigna un asignador para cada conexión de PIN, aunque dos o más conexiones de PIN pueden compartir el mismo asignador.</span><span class="sxs-lookup"><span data-stu-id="752a0-109">An allocator is assigned for every pin connection, although two or more pin connections might share the same allocator.</span></span> <span data-ttu-id="752a0-110">En la imagen siguiente se ilustra este proceso.</span><span class="sxs-lookup"><span data-stu-id="752a0-110">The following image illustrates this process.</span></span>

![búferes, muestras y asignadores](images/dataflow.png)

<span data-ttu-id="752a0-112">Cada asignador crea un grupo de muestras de medios y asigna los búferes para cada ejemplo.</span><span class="sxs-lookup"><span data-stu-id="752a0-112">Each allocator creates a pool of media samples and allocates the buffers for each sample.</span></span> <span data-ttu-id="752a0-113">Cada vez que un filtro necesita rellenar un búfer con datos, solicita un ejemplo del asignador mediante una llamada a [**IMemAllocator:: getBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="752a0-113">Whenever a filter needs to fill a buffer with data, it requests a sample from the allocator by calling [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="752a0-114">Si el asignador tiene algún ejemplo que no está siendo utilizado por otro filtro, el método **getBuffer** vuelve inmediatamente con un puntero al ejemplo.</span><span class="sxs-lookup"><span data-stu-id="752a0-114">If the allocator has any samples that are not currently in use by another filter, the **GetBuffer** method returns immediately with a pointer to the sample.</span></span> <span data-ttu-id="752a0-115">Si todos los ejemplos del asignador están en uso, el método se bloquea hasta que haya una muestra disponible.</span><span class="sxs-lookup"><span data-stu-id="752a0-115">If all of the allocator's samples are in use, the method blocks until a sample becomes available.</span></span> <span data-ttu-id="752a0-116">Cuando el método devuelve un ejemplo, el filtro coloca los datos en el búfer, establece las marcas adecuadas en el ejemplo (normalmente incluida una marca de tiempo) y entrega el ejemplo de nivel inferior.</span><span class="sxs-lookup"><span data-stu-id="752a0-116">When the method does return a sample, the filter puts data into the buffer, sets the appropriate flags on the sample (typically including a time stamp), and delivers the sample downstream.</span></span>

<span data-ttu-id="752a0-117">Cuando un filtro de representador recibe un ejemplo, comprueba la marca de tiempo y lo mantiene en el ejemplo hasta que el reloj de referencia del gráfico de filtro indica que se deben representar los datos.</span><span class="sxs-lookup"><span data-stu-id="752a0-117">When a renderer filter receives a sample, it checks the time stamp and holds onto the sample until the filter graph's reference clock indicates that the data should be rendered.</span></span> <span data-ttu-id="752a0-118">Una vez que el filtro representa los datos, libera el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="752a0-118">After the filter renders the data, it releases the sample.</span></span> <span data-ttu-id="752a0-119">El ejemplo no vuelve al grupo de muestras del asignador hasta que el recuento de referencias del ejemplo es cero, lo que significa que cada filtro ha liberado el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="752a0-119">The sample does not go back into the allocator's pool of samples until the sample's reference count is zero, meaning that every filter has released the sample.</span></span> <span data-ttu-id="752a0-120">En la imagen siguiente se ilustra este proceso.</span><span class="sxs-lookup"><span data-stu-id="752a0-120">The following image illustrates this process.</span></span>

![descodificador esperando un ejemplo de medios libres](images/dataflow2.png)

<span data-ttu-id="752a0-122">El filtro de nivel superior puede ejecutarse antes que el representador; es decir, podría rellenar los búferes más rápido de lo que el representador los consume.</span><span class="sxs-lookup"><span data-stu-id="752a0-122">The upstream filter might run ahead of the renderer — that is, it might fill buffers faster than the renderer consumes them.</span></span> <span data-ttu-id="752a0-123">Aun así, los ejemplos no se representarán pronto, ya que el representador los conserva hasta el momento de la presentación.</span><span class="sxs-lookup"><span data-stu-id="752a0-123">Even so, samples do not get rendered early, because the renderer holds each until its presentation time.</span></span> <span data-ttu-id="752a0-124">Además, el filtro de nivel superior no sobrescribirá los búferes accidentalmente, porque **GetSample** solo devuelve ejemplos que, de otro modo, no se usan.</span><span class="sxs-lookup"><span data-stu-id="752a0-124">Moreover, the upstream filter will not overwrite buffers accidentally, because **GetSample** only returns samples that are not otherwise in use.</span></span> <span data-ttu-id="752a0-125">El número de muestras en el grupo del asignador determina la cantidad por la que se puede ejecutar el filtro de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="752a0-125">The amount by which the upstream filter can run ahead is determined by the number of samples in the allocator's pool.</span></span>

<span data-ttu-id="752a0-126">En el diagrama anterior solo se muestra un asignador, pero normalmente hay varios asignadores por secuencia.</span><span class="sxs-lookup"><span data-stu-id="752a0-126">The previous diagram only shows one allocator, but typically there are several allocators per stream.</span></span> <span data-ttu-id="752a0-127">Por lo tanto, cuando el representador libera un ejemplo, puede tener un efecto en cascada.</span><span class="sxs-lookup"><span data-stu-id="752a0-127">Thus, when the renderer releases a sample, it can have a cascading effect.</span></span> <span data-ttu-id="752a0-128">En el diagrama siguiente se muestra una situación en la que un descodificador contiene un fotograma de vídeo comprimido mientras espera a que el representador libere un ejemplo.</span><span class="sxs-lookup"><span data-stu-id="752a0-128">The following diagram shows a situation where a decoder holds a compressed video frame while it waits for the renderer to release a sample.</span></span> <span data-ttu-id="752a0-129">Un filtro del analizador también está esperando a que el descodificador publique un ejemplo.</span><span class="sxs-lookup"><span data-stu-id="752a0-129">A parser filter is also waiting for the decoder to release a sample.</span></span>

![dos filtros que esperan ejemplos](images/dataflow3.png)

<span data-ttu-id="752a0-131">Cuando el representador libera su ejemplo, la llamada pendiente del descodificador a **getBuffer** devuelve.</span><span class="sxs-lookup"><span data-stu-id="752a0-131">When the renderer releases its sample, the decoder's pending call to **GetBuffer** returns.</span></span> <span data-ttu-id="752a0-132">A continuación, el descodificador puede descodificar el fotograma de vídeo comprimido y liberar el ejemplo que estaba manteniendo, lo que desbloquea la llamada de **getBuffer** pendiente del analizador.</span><span class="sxs-lookup"><span data-stu-id="752a0-132">The decoder can then decode the compressed video frame and release the sample it was holding, thereby unblocking the parser's pending **GetBuffer** call.</span></span>

## <a name="related-topics"></a><span data-ttu-id="752a0-133">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="752a0-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="752a0-134">Flujo de datos en el gráfico de filtros</span><span class="sxs-lookup"><span data-stu-id="752a0-134">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



