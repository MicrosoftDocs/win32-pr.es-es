---
title: Enlaces en DirectML
description: En DirectML, el enlace hace referencia a los datos adjuntos de los recursos a la canalización para que la GPU los use durante la inicialización y la ejecución de los operadores de aprendizaje automático.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: a04bf0bcc63fff810604e3db72fe507cc10040f5
ms.sourcegitcommit: db89157e3be911fdce2e543e99faa31fb2403bc8
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2020
ms.locfileid: "104549118"
---
# <a name="binding-in-directml"></a><span data-ttu-id="9cfcd-103">Enlaces en DirectML</span><span class="sxs-lookup"><span data-stu-id="9cfcd-103">Binding in DirectML</span></span>

<span data-ttu-id="9cfcd-104">En DirectML, el *enlace* hace referencia a los datos adjuntos de los recursos a la canalización para que la GPU los use durante la inicialización y la ejecución de los operadores de aprendizaje automático.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-104">In DirectML, *binding* refers to the attachment of resources to the pipeline for the GPU to use during the initialization and execution of your machine learning operators.</span></span> <span data-ttu-id="9cfcd-105">Estos recursos pueden ser, por ejemplo, los de entrada y salida, así como los recursos temporales o persistentes que necesita el operador.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-105">These resources can be input and output tensors, for example, as well as any temporary or persistent resources that the operator needs.</span></span>

<span data-ttu-id="9cfcd-106">En este tema se tratan los detalles conceptuales y procedimentales del enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-106">This topic addresses the conceptual and procedural details of binding.</span></span> <span data-ttu-id="9cfcd-107">Se recomienda leer completamente la documentación de las API a las que llama, incluidos los parámetros y las notas.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-107">We recommend that you also fully read the documentation for the APIs that you call, including parameters and Remarks.</span></span>

## <a name="important-ideas-in-binding"></a><span data-ttu-id="9cfcd-108">Ideas importantes en el enlace</span><span class="sxs-lookup"><span data-stu-id="9cfcd-108">Important ideas in binding</span></span>

<span data-ttu-id="9cfcd-109">La lista de pasos siguientes contiene una descripción de alto nivel de las tareas relacionadas con el enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-109">The list of steps below contain a high-level description of binding-related tasks.</span></span> <span data-ttu-id="9cfcd-110">Debe seguir estos pasos cada vez que [ejecute un redistribuible](/windows/desktop/api/directml/nn-directml-idmldispatchable), &mdash; un reenviador es un inicializador de operador o un operador compilado.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-110">You need to follow these steps each time you execute a [dispatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)&mdash;a dispatchable is either an operator initializer or a compiled operator.</span></span> <span data-ttu-id="9cfcd-111">En estos pasos se presentan las ideas, estructuras y métodos importantes implicados en el enlace DirectML.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-111">These steps introduce the important ideas, structures, and methods involved in DirectML binding.</span></span>

<span data-ttu-id="9cfcd-112">Las secciones siguientes de este tema profundizan y explican con más detalle estas tareas de enlace, con fragmentos de código ilustrativos tomados del ejemplo de código de la [aplicación DirectML mínima](dml-min-app.md) .</span><span class="sxs-lookup"><span data-stu-id="9cfcd-112">Subsequent sections in this topic dig deeper and explain these binding tasks in more detail, with illustrative code snippets taken from the [minimal DirectML application](dml-min-app.md) code example.</span></span>

- <span data-ttu-id="9cfcd-113">Llame a [**IDMLDispatchable:: GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) en el distribuidor para determinar cuántos descriptores necesita y también sus necesidades de recursos temporales o persistentes.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-113">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) on the dispatchable to determine how many descriptors it needs, and also its temporary/persistent resource needs.</span></span>
- <span data-ttu-id="9cfcd-114">Cree un montón de descriptores de Direct3D 12 lo suficientemente grande para los descriptores y enlácelo a la canalización.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-114">Create a Direct3D 12 descriptor heap large enough for the descriptors, and bind it to the pipeline.</span></span>
- <span data-ttu-id="9cfcd-115">Llame a [**IDMLDevice:: CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) para crear una tabla de enlace de DirectML que represente los recursos enlazados a la canalización.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-115">Call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create a DirectML binding table to represent the resources bound to the pipeline.</span></span> <span data-ttu-id="9cfcd-116">Utilice la estructura [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) para describir la tabla de enlace, incluido el subconjunto de los descriptores a los que apunta en el montón de descriptores.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-116">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the subset of the descriptors that it points to in the descriptor heap.</span></span>
- <span data-ttu-id="9cfcd-117">Cree recursos temporales o persistentes como recursos de búfer de Direct3D 12, los describe con [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) y [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) estructuras y agréguelos a la tabla de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-117">Create temporary/persistent resources as Direct3D 12 buffer resources, describe them with [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) and [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structures, and add them to the binding table.</span></span>
- <span data-ttu-id="9cfcd-118">Si el distribuidor es un operador compilado, cree un búfer de elementos tensores como un recurso de búfer de Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-118">If the dispatchable is a compiled operator, then create a buffer of tensor elements as a Direct3D 12 buffer resource.</span></span> <span data-ttu-id="9cfcd-119">Rellénelo o cárguelo, describa el **DML_BUFFER_BINDING** y **DML_BINDING_DESC** estructuras y agréguelo a la tabla de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-119">Populate/upload it, describe it with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and add it to the binding table.</span></span>
- <span data-ttu-id="9cfcd-120">Pase la tabla de enlace como un parámetro al llamar a [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-120">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

## <a name="retrieve-the-binding-properties-of-a-dispatchable"></a><span data-ttu-id="9cfcd-121">Recuperar las propiedades de enlace de un reenviador</span><span class="sxs-lookup"><span data-stu-id="9cfcd-121">Retrieve the binding properties of a dispatchable</span></span>

<span data-ttu-id="9cfcd-122">En la estructura de [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) se describen las necesidades de enlace de un operador que se debe reenviar (inicializador de operador o compilado).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-122">The [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) structure describes the binding needs of a dispatchable (operator initializer or compiled operator).</span></span> <span data-ttu-id="9cfcd-123">Estas propiedades relacionadas con el enlace incluyen el número de descriptores que se deben enlazar al distribuidor, así como el tamaño en bytes de cualquier recurso temporal o persistente que necesite.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-123">These binding-related properties include the number of descriptors that you should bind to the dispatchable, as well as the size in bytes of any temporary and/or persistent resource that it needs.</span></span>

> [!NOTE]
> <span data-ttu-id="9cfcd-124">Incluso en el caso de varios operadores del mismo tipo, no realice suposiciones sobre ellos que tengan los mismos requisitos de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-124">Even for multiple operators of the same type, don't make assumptions about them having the same binding requirements.</span></span> <span data-ttu-id="9cfcd-125">Consulte las propiedades de enlace para cada inicializador y operador que cree.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-125">Query the binding properties for every initializer and operator that you create.</span></span>

<span data-ttu-id="9cfcd-126">Llame a [**IDMLDispatchable:: GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) para recuperar un **DML_BINDING_PROPERTIES**.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-126">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) to retrieve a **DML_BINDING_PROPERTIES**.</span></span>

```cppwinrt
winrt::com_ptr<::IDMLCompiledOperator> dmlCompiledOperator;
// Code to create and compile a DirectML operator goes here.

DML_BINDING_PROPERTIES executeDmlBindingProperties{
    dmlCompiledOperator->GetBindingProperties()
};

winrt::com_ptr<::IDMLOperatorInitializer> dmlOperatorInitializer;
// Code to create a DirectML operator initializer goes here.

DML_BINDING_PROPERTIES initializeDmlBindingProperties{
    dmlOperatorInitializer->GetBindingProperties()
};

UINT descriptorCount = ...
```

<span data-ttu-id="9cfcd-127">El `descriptorCount` valor que se recupera aquí determina el tamaño (mínimo) del montón descriptor y la tabla de enlace que se crea en los dos pasos siguientes.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-127">The `descriptorCount` value that you retrieve here determines the (minimum) size of the descriptor heap and of the binding table that you create in the next two steps.</span></span>

<span data-ttu-id="9cfcd-128">**DML_BINDING_PROPERTIES** también contiene un `TemporaryResourceSize` miembro, que es el tamaño mínimo, en bytes, del recurso temporal que se debe enlazar a la tabla de enlace para este objeto que se puede distribuir.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-128">**DML_BINDING_PROPERTIES** also contains a `TemporaryResourceSize` member, which is the minimum size in bytes of the temporary resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="9cfcd-129">Un valor de cero significa que no se requiere un recurso temporal.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-129">A value of zero means that a temporary resource is not required.</span></span>

<span data-ttu-id="9cfcd-130">Y un `PersistentResourceSize` miembro, que es el tamaño mínimo, en bytes, del recurso persistente que se debe enlazar a la tabla de enlace para este objeto que se puede distribuir.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-130">And a `PersistentResourceSize` member, which is the minimum size in bytes of the persistent resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="9cfcd-131">Un valor de cero significa que no se requiere un recurso persistente.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-131">A value of zero means that a persistent resource is not required.</span></span> <span data-ttu-id="9cfcd-132">Se debe proporcionar un recurso persistente, si es necesario, durante la inicialización de un operador compilado (donde se enlaza como salida del inicializador de operador), así como durante la ejecución.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-132">A persistent resource, if one is needed, must be supplied during initialization of a compiled operator (where it is bound as an output of the operator initializer) as well as during execution.</span></span> <span data-ttu-id="9cfcd-133">Hay más información sobre esto más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-133">There's more about this later in this topic.</span></span> <span data-ttu-id="9cfcd-134">Solo los operadores compilados tienen recursos persistentes: los inicializadores de operador siempre devuelven un valor de 0 para este miembro.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-134">Only compiled operators have persistent resources—operator initializers always return a value of 0 for this member.</span></span>

<span data-ttu-id="9cfcd-135">Si llama a **IDMLDispatchable:: GetBindingProperties** en un inicializador de operador tanto antes como después de una llamada a [**IDMLOperatorInitializer:: RESET**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), no se garantiza que los dos conjuntos de propiedades de enlace recuperadas sean idénticos.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-135">If you call **IDMLDispatchable::GetBindingProperties** on an operator initializer both before and after a call to [**IDMLOperatorInitializer::Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), then the two sets of binding properties retrieved are not guaranteed to be identical.</span></span>

## <a name="describe-create-and-bind-a-descriptor-heap"></a><span data-ttu-id="9cfcd-136">Describir, crear y enlazar un montón de descriptores</span><span class="sxs-lookup"><span data-stu-id="9cfcd-136">Describe, create, and bind a descriptor heap</span></span>

<span data-ttu-id="9cfcd-137">En lo que respecta a los descriptores, su responsabilidad comienza y termina con el montón del descriptor.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-137">In terms of descriptors, your responsibility begins and ends with the descriptor heap itself.</span></span> <span data-ttu-id="9cfcd-138">DirectML se encarga de la creación y administración de los descriptores dentro del montón que se proporciona.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-138">DirectML itself takes care of creating and managing the descriptors inside of the heap that you provide.</span></span>

<span data-ttu-id="9cfcd-139">Por lo tanto, use una estructura de [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) para describir un montón lo suficientemente grande como para el número de descriptores que necesita el distribuidor.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-139">So, use a [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) structure to describe a heap large enough for the number of descriptors that the dispatchable needs.</span></span> <span data-ttu-id="9cfcd-140">A continuación, créelo con [**ID3D12Device:: CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-140">Then create it with [**ID3D12Device::CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span></span> <span data-ttu-id="9cfcd-141">Y, por último, llame a [**ID3D12GraphicsCommandList:: SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) para enlazar el montón de descriptores a la canalización.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-141">And, lastly, call [**ID3D12GraphicsCommandList::SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) to bind your descriptor heap to the pipeline.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12DescriptorHeap> d3D12DescriptorHeap;

D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription{};
descriptorHeapDescription.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
descriptorHeapDescription.NumDescriptors = descriptorCount;
descriptorHeapDescription.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

winrt::check_hresult(
    d3D12Device->CreateDescriptorHeap(
        &descriptorHeapDescription,
        _uuidof(d3D12DescriptorHeap),
        d3D12DescriptorHeap.put_void()
    )
);

std::array<ID3D12DescriptorHeap*, 1> d3D12DescriptorHeaps{ d3D12DescriptorHeap.get() };
d3D12GraphicsCommandList->SetDescriptorHeaps(
    static_cast<UINT>(d3D12DescriptorHeaps.size()),
    d3D12DescriptorHeaps.data()
);
```

## <a name="describe-and-create-a-binding-table"></a><span data-ttu-id="9cfcd-142">Describir y crear una tabla de enlace</span><span class="sxs-lookup"><span data-stu-id="9cfcd-142">Describe and create a binding table</span></span>

<span data-ttu-id="9cfcd-143">Una tabla de enlace de DirectML representa los recursos que se enlazan a la canalización para que los utilice un distribuidor.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-143">A DirectML binding table represents the resources that you bind to the pipeline for a dispatchable to use.</span></span> <span data-ttu-id="9cfcd-144">Esos recursos podrían ser los de entrada y salida (u otros parámetros) para un operador, o bien pueden ser varios recursos persistentes y temporales con los que funciona un distribuidor.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-144">Those resources could be input and output tensors (or other parameters) for an operator, or they could be various persistent and temporary resources that a dispatchable works with.</span></span>

<span data-ttu-id="9cfcd-145">Use la estructura [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) para describir la tabla de enlace, incluido el distribuidor para el que la tabla de enlace representará los enlaces y el intervalo de descriptores (del montón de descriptores que acaba de crear) al que desea que haga referencia la tabla de enlace (y en el que DirectML puede escribir descriptores).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-145">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the dispatchable for which the binding table will represent the bindings, and the range of descriptors (from the descriptor heap that you just created) that you wish the binding table to refer to (and into which DirectML may write descriptors).</span></span> <span data-ttu-id="9cfcd-146">El `descriptorCount` valor (una de las propiedades de enlace que se recuperaron en el primer paso) nos indica qué tamaño mínimo es, en descriptores, de la tabla de enlace necesaria para el objeto que se debe enviar.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-146">The `descriptorCount` value (one of the binding properties that we retrieved in the first step) tells us what minimum size is, in descriptors, of the binding table required for the dispatchable object.</span></span> <span data-ttu-id="9cfcd-147">En este caso, usamos ese valor para indicar el número máximo de descriptores que DirectML puede escribir en nuestro montón, desde el inicio de los controladores de la CPU y del descriptor de GPU suministrados.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-147">Here, we use that value to indicate the maximum number of descriptors that DirectML is permitted to write into our heap, from the start of both the supplied CPU and GPU descriptor handles.</span></span>

<span data-ttu-id="9cfcd-148">Después, llame a [**IDMLDevice:: CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) para crear la tabla de enlace DirectML.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-148">Then call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create the DirectML binding table.</span></span> <span data-ttu-id="9cfcd-149">En pasos posteriores, después de haber creado más recursos para el distribuidor, agregaremos esos recursos a la tabla de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-149">In later steps, after we've created further resources for the dispatchable, we'll add those resources to the binding table.</span></span>

<span data-ttu-id="9cfcd-150">En lugar de pasar una **DML_BINDING_TABLE_DESC** a esta llamada, puede pasar `nullptr` , que indica una tabla de enlace vacía.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-150">Instead of passing a **DML_BINDING_TABLE_DESC** to this call, you can pass `nullptr`, indicating an empty binding table.</span></span>

```cppwinrt
DML_BINDING_TABLE_DESC dmlBindingTableDesc{};
dmlBindingTableDesc.Dispatchable = dmlOperatorInitializer.get();
dmlBindingTableDesc.CPUDescriptorHandle = d3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.GPUDescriptorHandle = d3D12DescriptorHeap->GetGPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.SizeInDescriptors = descriptorCount;

winrt::com_ptr<::IDMLBindingTable> dmlBindingTable;
winrt::check_hresult(
    dmlDevice->CreateBindingTable(
        &dmlBindingTableDesc,
        __uuidof(dmlBindingTable),
        dmlBindingTable.put_void()
    )
);
```

<span data-ttu-id="9cfcd-151">El orden en el que DirectML escribe descriptores en el montón no está especificado, por lo que la aplicación debe tener cuidado de no sobrescribir los descriptores ajustados por la tabla de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-151">The order in which DirectML writes descriptors into the heap is unspecified, so your application must take care not to overwrite the descriptors wrapped by the binding table.</span></span> <span data-ttu-id="9cfcd-152">Los identificadores de descriptor de CPU y de GPU proporcionados pueden provienen de montones diferentes; sin embargo, es responsabilidad de la aplicación asegurarse de que todo el intervalo de descriptor al que hace referencia el identificador del descriptor de CPU se copia en el intervalo al que hace referencia el identificador de descriptor de GPU antes de la ejecución mediante esta tabla de enlace</span><span class="sxs-lookup"><span data-stu-id="9cfcd-152">The supplied CPU and GPU descriptor handles may come from different heaps, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span> <span data-ttu-id="9cfcd-153">El montón descriptor desde el que se proporcionan los identificadores debe tener el tipo **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-153">The descriptor heap from which the handles are supplied must have type **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span></span> <span data-ttu-id="9cfcd-154">Además, el montón al que hace referencia `GPUDescriptorHandle` debe ser un montón de descriptores visible del sombreador.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-154">Additionally, the heap referred to by the `GPUDescriptorHandle` must be a shader-visible descriptor heap.</span></span>

<span data-ttu-id="9cfcd-155">Puede restablecer una tabla de enlace para quitar todos los recursos que haya agregado a ella, al mismo tiempo que cambia cualquier propiedad establecida en su **DML_BINDING_TABLE_DESC** inicial (para encapsular un nuevo intervalo de descriptores o para volver a utilizarlo para otro que se pueda enviar).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-155">You can reset a binding table to remove any resources that you've added to it, while at the same time changing any property that you set on its initial **DML_BINDING_TABLE_DESC** (to wrap a new range of descriptors, or to re-use it for a different dispatchable).</span></span> <span data-ttu-id="9cfcd-156">Solo tiene que realizar los cambios en la estructura de la descripción y llamar a [**IDMLBindingTable:: RESET**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-156">Just make the changes to the description structure, and call [**IDMLBindingTable::Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span></span>

```cppwinrt
dmlBindingTableDesc.Dispatchable = pIDMLCompiledOperator.get();

winrt::check_hresult(
    pIDMLBindingTable->Reset(
        &dmlBindingTableDesc
    )
);
```

## <a name="describe-and-bind-any-temporarypersistent-resources"></a><span data-ttu-id="9cfcd-157">Describir y enlazar los recursos temporales o persistentes</span><span class="sxs-lookup"><span data-stu-id="9cfcd-157">Describe and bind any temporary/persistent resources</span></span>

<span data-ttu-id="9cfcd-158">La estructura de **DML_BINDING_PROPERTIES** que hemos rellenado al [recuperar las propiedades de enlace](#retrieve-the-binding-properties-of-a-dispatchable) de nuestro redistribuible contiene el tamaño en bytes de cualquier recurso temporal o persistente que necesite el distribuidor.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-158">The **DML_BINDING_PROPERTIES** structure that we populated when we [retrieved the binding properties](#retrieve-the-binding-properties-of-a-dispatchable) of our dispatchable contains the size in bytes of any temporary and/or persistent resource that the dispatchable needs.</span></span> <span data-ttu-id="9cfcd-159">Si alguno de estos tamaños es distinto de cero, cree un recurso de búfer de Direct3D 12 y agréguelo a la tabla de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-159">If either of these sizes is non-zero, then create a Direct3D 12 buffer resource and add it to the binding table.</span></span>

<span data-ttu-id="9cfcd-160">En el ejemplo de código siguiente, se crea un recurso temporal ( `temporaryResourceSize` bytes de tamaño) para el que se pudo enviar.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-160">In the code example below, we create a temporary resource (`temporaryResourceSize` bytes in size) for the dispatchable.</span></span> <span data-ttu-id="9cfcd-161">Se describe cómo se desea enlazar el recurso y, después, se agrega ese enlace a la tabla de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-161">We describe how we wish to bind the resource, and then we add that binding to the binding table.</span></span>

<span data-ttu-id="9cfcd-162">Como estamos enlazando un único recurso de búfer, se describe nuestro enlace con una estructura de [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) .</span><span class="sxs-lookup"><span data-stu-id="9cfcd-162">Since we're binding a single buffer resource, we describe our binding with a [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) structure.</span></span> <span data-ttu-id="9cfcd-163">En esa estructura, se especifica el recurso de búfer de Direct3D 12 (el recurso debe tener [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)de dimensión), así como un desplazamiento y tamaño en el búfer.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-163">In that structure, we specify the Direct3D 12 buffer resource (the resource must have dimension [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), as well as an offset-and-size into the buffer.</span></span> <span data-ttu-id="9cfcd-164">También es posible describir un enlace para una matriz de búferes (en lugar de para un único búfer) y la estructura de [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) existe para ese propósito.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-164">It's also possible to describe a binding for an array of buffers (rather than for a single buffer), and the [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) structure exists for that purpose.</span></span>

<span data-ttu-id="9cfcd-165">Para abstraer la distinción entre un enlace de búfer y un enlace de matriz de búfer, usamos la estructura de  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) .</span><span class="sxs-lookup"><span data-stu-id="9cfcd-165">To abstract away the distinction between a buffer binding and a buffer array binding, we use the  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structure.</span></span> <span data-ttu-id="9cfcd-166">Puede establecer el `Type` miembro del **DML_BINDING_DESC** en [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) o **DML_BINDING_TYPE_BUFFER_ARRAY**.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-166">You can set the `Type` member of the **DML_BINDING_DESC** to either [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) or **DML_BINDING_TYPE_BUFFER_ARRAY**.</span></span> <span data-ttu-id="9cfcd-167">Además, puede establecer el `Desc` miembro para que apunte a un **DML_BUFFER_BINDING** o a un **DML_BUFFER_ARRAY_BINDING**, dependiendo de `Type` .</span><span class="sxs-lookup"><span data-stu-id="9cfcd-167">And you can then set the `Desc` member to point to either a **DML_BUFFER_BINDING** or to a **DML_BUFFER_ARRAY_BINDING**, depending on `Type`.</span></span>

<span data-ttu-id="9cfcd-168">Estamos tratando con el recurso temporal en este ejemplo, por lo que lo agregaremos a la tabla de enlace con una llamada a [**IDMLBindingTable:: BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-168">We're dealing with the temporary resource in this example, so we add it to the binding table with a call to [**IDMLBindingTable::BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span></span>

```cppwinrt
D3D12_HEAP_PROPERTIES defaultHeapProperties{ CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT) };
winrt::com_ptr<::ID3D12Resource> temporaryBuffer;

D3D12_RESOURCE_DESC temporaryBufferDesc{ CD3DX12_RESOURCE_DESC::Buffer(temporaryResourceSize) };
winrt::check_hresult(
    d3D12Device->CreateCommittedResource(
        &defaultHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &temporaryBufferDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        __uuidof(temporaryBuffer),
        temporaryBuffer.put_void()
    )
);

DML_BUFFER_BINDING bufferBinding{ temporaryBuffer.get(), 0, temporaryResourceSize };
DML_BINDING_DESC bindingDesc{ DML_BINDING_TYPE_BUFFER, &bufferBinding };
dmlBindingTable->BindTemporaryResource(&bindingDesc);
```

<span data-ttu-id="9cfcd-169">Un recurso temporal (si es necesario) es la memoria temporal que se usa internamente durante la ejecución del operador, por lo que no es necesario preocuparse por su contenido.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-169">A temporary resource (if one is needed) is scratch memory that's used internally during the execution of the operator, so you don't need to be concerned with its contents.</span></span> <span data-ttu-id="9cfcd-170">No es necesario que lo mantenga una vez que se haya completado la llamada a [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) en la GPU.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-170">Nor do you need to keep it around after your call to [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) has completed on the GPU.</span></span> <span data-ttu-id="9cfcd-171">Esto significa que la aplicación puede liberar o sobrescribir el recurso temporal entre los envíos del operador compilado.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-171">This means that your application may release or overwrite the temporary resource in between dispatches of the compiled operator.</span></span> <span data-ttu-id="9cfcd-172">El intervalo de búfer proporcionado que se va a enlazar como el recurso temporal debe estar alineado con el desplazamiento de inicio en [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-172">The supplied buffer range to be bound as the temporary resource must have its start offset aligned to [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="9cfcd-173">El tipo del montón subyacente del búfer debe ser **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-173">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

<span data-ttu-id="9cfcd-174">Sin embargo, si el distribuidor informa de un tamaño distinto de cero para su recurso persistente de larga duración, el procedimiento es ligeramente diferente.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-174">If the dispatchable reports a non-zero size for its more long-lived persistent resource, though, then the procedure is a little different.</span></span> <span data-ttu-id="9cfcd-175">Debe crear un búfer y describir un enlace siguiendo el mismo patrón que se mostró anteriormente.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-175">You should create a buffer and describe a binding following the same pattern as shown above.</span></span> <span data-ttu-id="9cfcd-176">Pero agréguelo a la tabla de enlace del inicializador del operador con una llamada a [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), porque es el trabajo del inicializador del operador para inicializar el recurso persistente.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-176">But add it to your operator initializer's binding table with a call to [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), because it's the operator initializer's job to initialize the persistent resource.</span></span> <span data-ttu-id="9cfcd-177">A continuación, agréguelo a la tabla de enlace del operador compilada con una llamada a [**IDMLBindingTable:: BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-177">Then add it to your compiled operator's binding table with a call to [**IDMLBindingTable::BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span></span> <span data-ttu-id="9cfcd-178">Vea el ejemplo de código de la [aplicación DirectML mínima](dml-min-app.md) para ver este flujo de trabajo en acción.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-178">See the [minimal DirectML application](dml-min-app.md) code example to see this workflow in action.</span></span> <span data-ttu-id="9cfcd-179">El contenido y la duración del recurso persistente deben persistir siempre que el operador compilado lo tenga.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-179">The persistent resource's contents and lifetime must persist as long as the compiled operator does.</span></span> <span data-ttu-id="9cfcd-180">Es decir, si un operador requiere un recurso persistente, la aplicación debe proporcionarlo durante la inicialización y, a continuación, proporcionarlo también a todas las ejecuciones futuras del operador sin modificar su contenido.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-180">That is, if an operator requires a persistent resource, then your application must supply it during initialization and subsequently also supply it to all future executes of the operator without modifying its contents.</span></span> <span data-ttu-id="9cfcd-181">El recurso persistente normalmente lo usa DirectML para almacenar tablas de búsqueda u otros datos de larga duración que se calculan durante la inicialización de un operador y se reutilizan en futuras ejecuciones de ese operador.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-181">The persistent resource is typically used by DirectML to store lookup tables or other long-lived data that is computed during initialization of an operator and reused on future executions of that operator.</span></span> <span data-ttu-id="9cfcd-182">El intervalo de búfer proporcionado que se va a enlazar como búfer persistente debe estar alineado con el desplazamiento de inicio en [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-182">The supplied buffer range to be bound as the persistent buffer must have its start offset aligned to [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="9cfcd-183">El tipo del montón subyacente del búfer debe ser **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-183">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

## <a name="describe-and-bind-any-tensors"></a><span data-ttu-id="9cfcd-184">Describir y enlazar los diez</span><span class="sxs-lookup"><span data-stu-id="9cfcd-184">Describe and bind any tensors</span></span>

<span data-ttu-id="9cfcd-185">Si está tratando con un operador compilado (en lugar de con un inicializador de operador), debe enlazar los recursos de entrada y salida (para los de decenas y otros parámetros) a la tabla de enlace del operador.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-185">If you're dealing with a compiled operator (rather than with an operator initializer), then you need to bind input and output resources (for tensors and other parameters) to the operator's binding table.</span></span> <span data-ttu-id="9cfcd-186">El número de enlaces debe coincidir exactamente con el número de entradas del operador, incluidos los de decenas opcionales.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-186">The number of bindings must exactly match the number of inputs of the operator, including optional tensors.</span></span> <span data-ttu-id="9cfcd-187">Los diez idiomas de entrada y salida determinados y otros parámetros que un operador toma se documentan en el tema correspondiente a ese operador (por ejemplo, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-187">The particular input and output tensors and other parameters that an operator takes are documented in the topic for that operator (for example, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span></span>

<span data-ttu-id="9cfcd-188">Un recurso tensores es un búfer que contiene los valores individuales de los elementos de tensores.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-188">A tensor resource is a buffer that contains the individual element values of the tensor.</span></span> <span data-ttu-id="9cfcd-189">Puede cargar y leer este tipo de búfer a/desde la GPU mediante las técnicas de Direct3D 12 normales ([cargar recursos](/windows/desktop/direct3d12/uploading-resources) y [leer datos a través de un búfer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-189">You upload and read back such a buffer to/from the GPU using the regular Direct3D 12 techniques ([Upload resources](/windows/desktop/direct3d12/uploading-resources) and [Read back data via a buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span></span> <span data-ttu-id="9cfcd-190">Vea el ejemplo de código de la [aplicación DirectML mínima](dml-min-app.md) para ver estas técnicas en acción.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-190">See the [minimal DirectML application](dml-min-app.md) code example to see these techniques in action.</span></span>

<span data-ttu-id="9cfcd-191">Por último, describa los enlaces de recursos de entrada y salida con estructuras **DML_BUFFER_BINDING** y **DML_BINDING_DESC** y, a continuación, agréguelos a la tabla de enlace del operador compilado con llamadas a [**IDMLBindingTable:: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) y [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-191">Lastly, describe your input and output resource bindings with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and then add them to the compiled operator's binding table with calls to [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span> <span data-ttu-id="9cfcd-192">Cuando se llama a un método \**IDMLBindingTable: \* : Bind* _, DirectML escribe uno o más descriptores en el intervalo de descriptores de la CPU.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-192">When you call an \**IDMLBindingTable::Bind\** _ method, DirectML writes one or more descriptors into the range of CPU descriptors.</span></span>

```cppwinrt
DML_BUFFER_BINDING inputBufferBinding{ inputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC inputBindingDesc{ DML_BINDING_TYPE_BUFFER, &inputBufferBinding };
dmlBindingTable->BindInputs(1, &inputBindingDesc);

DML_BUFFER_BINDING outputBufferBinding{ outputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC outputBindingDesc{ DML_BINDING_TYPE_BUFFER, &outputBufferBinding };
dmlBindingTable->BindOutputs(1, &outputBindingDesc);
```

<span data-ttu-id="9cfcd-193">Uno de los pasos para crear un operador DirectML (vea [_ *IDMLDevice:: CreateOperator* \*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) es declarar una o varias estructuras [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) para describir los búferes de datos tensores que el operador toma y devuelve.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-193">One of the steps in creating a DirectML operator (see [_ *IDMLDevice::CreateOperator*\*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) is to declare one or more [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) structures to describe the tensor data buffers that the operator takes and returns.</span></span> <span data-ttu-id="9cfcd-194">Además del tipo y el tamaño del búfer de tensores, puede especificar la marca de [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) opcionalmente.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-194">As well as the tensor buffer's type and size, you can optionally specify the [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) flag.</span></span>

<span data-ttu-id="9cfcd-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indica que los datos de tensores deben ser propiedad y administrados por DirectML.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indicates that the tensor data should be owned and managed by DirectML.</span></span> <span data-ttu-id="9cfcd-196">DirectML realiza una copia de los datos de tensores durante la inicialización del operador y lo almacena en el recurso persistente.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-196">DirectML makes a copy of the tensor data during initialization of the operator, and stores it in the persistent resource.</span></span> <span data-ttu-id="9cfcd-197">Esto permite a DirectML realizar el cambio de formato de los datos de tensores en formularios más eficaces.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-197">This allows DirectML to perform reformatting of the tensor data into other, more efficient forms.</span></span> <span data-ttu-id="9cfcd-198">La configuración de esta marca puede aumentar el rendimiento, pero normalmente solo es útil para los que no cambian los datos durante la vigencia del operador (por ejemplo, los diez pesos).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-198">Setting this flag may increase performance, but it's typically only useful for tensors whose data doesn't change for the lifetime of the operator (for example, weight tensors).</span></span> <span data-ttu-id="9cfcd-199">Y la marca solo se puede usar en los idiomas de entrada.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-199">And the flag may only be used on input tensors.</span></span> <span data-ttu-id="9cfcd-200">Cuando la marca se establece en una descripción de tensores determinada, el tensores correspondiente debe estar enlazado a la tabla de enlace durante la inicialización del operador y no durante la ejecución (lo que producirá un error).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-200">When the flag is set on a particular tensor description, the corresponding tensor must be bound to the binding table during operator initialization, and not during execution (which will result in an error).</span></span> <span data-ttu-id="9cfcd-201">Es lo contrario del comportamiento predeterminado (el comportamiento sin la marca de DML_TENSOR_FLAG_OWNED_BY_DML), donde se espera que el tensores esté enlazado durante la ejecución y no durante la inicialización.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-201">That's the opposite of the default behavior (the behavior without the DML_TENSOR_FLAG_OWNED_BY_DML flag), where the tensor is expected to be bound during execution, and not during initialization.</span></span> <span data-ttu-id="9cfcd-202">Cuando se proporcionan los datos de tensores a un inicializador de operador, es válido enlazar una carga en lugar de un montón predeterminado, ya que DirectML realiza una copia de los datos.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-202">When you supply the tensor data to an operator initializer, it's legal to bind an UPLOAD rather than a DEFAULT heap, because DirectML makes a copy of the data.</span></span> <span data-ttu-id="9cfcd-203">En todos los demás casos, todos los recursos enlazados a DirectML deben ser recursos del montón predeterminados.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-203">In all other cases, all resources bound to DirectML must be DEFAULT heap resources.</span></span>

<span data-ttu-id="9cfcd-204">Para obtener más información, vea [**IDMLBindingTable:: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) y [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-204">For more info, see [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span>

## <a name="execute-the-dispatchable"></a><span data-ttu-id="9cfcd-205">Ejecutar el distribuidor</span><span class="sxs-lookup"><span data-stu-id="9cfcd-205">Execute the dispatchable</span></span>

<span data-ttu-id="9cfcd-206">Pase la tabla de enlace como un parámetro al llamar a [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-206">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

<span data-ttu-id="9cfcd-207">Cuando se usa la tabla de enlace durante una llamada a **IDMLCommandRecorder:: RecordDispatch**, DirectML enlaza los descriptores de GPU correspondientes a la canalización.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-207">When you use the binding table during a call to **IDMLCommandRecorder::RecordDispatch**, DirectML binds the corresponding GPU descriptors to the pipeline.</span></span> <span data-ttu-id="9cfcd-208">No es necesario que los identificadores de descriptor de CPU y GPU señalen a las mismas entradas en un montón de descriptores; sin embargo, es responsabilidad de la aplicación asegurarse de que todo el intervalo de descriptor al que hace referencia el identificador de descriptor de CPU se copia en el intervalo al que hace referencia el identificador de descriptor de GPU antes de la ejecución</span><span class="sxs-lookup"><span data-stu-id="9cfcd-208">The CPU and GPU descriptor handles aren't required to point to the same entries in a descriptor heap, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12GraphicsCommandList> d3D12GraphicsCommandList;
// Code to create a Direct3D 12 command list goes here.

winrt::com_ptr<::IDMLCommandRecorder> dmlCommandRecorder;
// Code to create a DirectML command recorder goes here.

dmlCommandRecorder->RecordDispatch(
    d3D12GraphicsCommandList.get(),
    dmlOperatorInitializer.get(),
    dmlBindingTable.get()
);
```

<span data-ttu-id="9cfcd-209">Por último, cierre la lista de comandos de Direct3D 12 y envíelo para su ejecución como lo haría con cualquier otra lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-209">Finally, close your Direct3D 12 command list, and submit it for execution as you would any other command list.</span></span>

<span data-ttu-id="9cfcd-210">Antes de la ejecución de **RecordDispatch** en la GPU, debe pasar todos los recursos enlazados al estado **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** , o a un estado que se pueda promover implícitamente a **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, como **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-210">Prior to execution of **RecordDispatch** on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="9cfcd-211">Una vez finalizada esta llamada, los recursos permanecen en el estado **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="9cfcd-211">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="9cfcd-212">La única excepción a esto se debe a que los montones de carga están enlazados al ejecutar un inicializador de operador y mientras que uno o varios de los decenas tienen establecida la marca **DML_TENSOR_FLAG_OWNED_BY_DML** .</span><span class="sxs-lookup"><span data-stu-id="9cfcd-212">The only exception to this is for upload heaps bound when executing an operator initializer and while one or more tensors has the **DML_TENSOR_FLAG_OWNED_BY_DML** flag set.</span></span> <span data-ttu-id="9cfcd-213">En ese caso, los montones de carga enlazados a la entrada deben estar en el estado **D3D12_RESOURCE_STATE_GENERIC_READ** y permanecerán en ese estado, según lo requieran todos los montones de carga.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-213">In that case, any upload heaps bound for input must be in the **D3D12_RESOURCE_STATE_GENERIC_READ** state and will remain in that state, as required by all upload heaps.</span></span> <span data-ttu-id="9cfcd-214">Si no se estableció **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** al compilar el operador, se deben establecer todos los enlaces en la tabla de enlace antes de llamar a **RecordDispatch** , de lo contrario, el comportamiento es indefinido.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-214">If **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** was not set when compiling the operator, then all bindings must be set on the binding table before **RecordDispatch** is called, otherwise the behavior is undefined.</span></span> <span data-ttu-id="9cfcd-215">De lo contrario, si un operador admite el [enlace en tiempo](#optionally-specify-late-bound-operator-bindings)de ejecución, se puede diferir el enlace de los recursos hasta que la lista de comandos de Direct3D 12 se envíe a la cola de comandos para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-215">Otherwise, if an operator supports [late binding](#optionally-specify-late-bound-operator-bindings), then binding of resources may be deferred until the Direct3D 12 command list is submitted to the command queue for execution.</span></span>

<span data-ttu-id="9cfcd-216">**RecordDispatch** actúa lógicamente como una llamada a [**ID3D12GraphicsCommandList::D ispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-216">**RecordDispatch** acts logically like a call to [**ID3D12GraphicsCommandList::Dispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span></span> <span data-ttu-id="9cfcd-217">Como tal, las barreras de la vista de acceso no ordenada (UAV) son necesarias para garantizar el orden correcto si hay dependencias de datos entre los envíos.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-217">As such, unordered access view (UAV) barriers are necessary to ensure correct ordering if there are data dependencies between dispatches.</span></span> <span data-ttu-id="9cfcd-218">Este método no inserta barreras UAV en los recursos de entrada ni de salida.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-218">This method does not insert UAV barriers on input nor output resources.</span></span> <span data-ttu-id="9cfcd-219">La aplicación debe asegurarse de que se realicen las barreras UAV correctas en cualquier entrada si su contenido depende de una distribución ascendente, y en cualquier salida si hay envíos de nivel inferior que dependen de esas salidas.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-219">Your application must ensure that the correct UAV barriers are performed on any inputs if their contents depend on an upstream dispatch, and on any outputs if there are downstream dispatches that depend on those outputs.</span></span>

## <a name="lifetime-and-synchronization-of-descriptors-and-binding-table"></a><span data-ttu-id="9cfcd-220">Duración y sincronización de los descriptores y la tabla de enlace</span><span class="sxs-lookup"><span data-stu-id="9cfcd-220">Lifetime and synchronization of descriptors and binding table</span></span>

<span data-ttu-id="9cfcd-221">Un buen modelo mental de enlace en DirectML es que, en segundo plano, la propia tabla de enlace DirectML es crear y administrar descriptores de vista de acceso no ordenado (UAV) dentro del montón de descriptores que se proporciona.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-221">A good mental model of binding in DirectML is that behind the scenes the DirectML binding table itself is creating and managing unordered access view (UAV) descriptors inside the descriptor heap that you provide.</span></span> <span data-ttu-id="9cfcd-222">Por lo tanto, todas las reglas habituales de Direct3D 12 se aplican en torno a la sincronización del acceso a ese montón y a sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-222">So, all of the usual Direct3D 12 rules apply around synchronizing access to that heap and to its descriptors.</span></span> <span data-ttu-id="9cfcd-223">Es responsabilidad de la aplicación realizar una sincronización correcta entre el trabajo de CPU y GPU que usa una tabla de enlace.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-223">It's your application's responsibility to perform correct synchronization between the CPU and GPU work that uses a binding table.</span></span>

<span data-ttu-id="9cfcd-224">Una tabla de enlace no puede sobrescribir un descriptor mientras el descriptor está en uso (por ejemplo, por un marco anterior).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-224">A binding table can't overwrite a descriptor while the descriptor is in use (by a prior frame, for example).</span></span> <span data-ttu-id="9cfcd-225">Por lo tanto, si desea volver a usar un montón de descriptor ya enlazado (por ejemplo, llamando a Bind \* de nuevo en una tabla de enlace que apunte a él o sobrescribiendo el montón del descriptor manualmente), debe esperar a que el distribuidor que está utilizando actualmente el montón descriptor termine de ejecutarse en la GPU.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-225">So, if you want to reuse an already-bound descriptor heap (for example, by calling Bind\* again on a binding table that points to it, or by overwriting the descriptor heap manually), then you should wait for the dispatchable that's currently using the descriptor heap to finish executing on the GPU.</span></span> <span data-ttu-id="9cfcd-226">Una tabla de enlace no mantiene una referencia fuerte en el montón de descriptores en el que escribe, por lo que no debe liberar el montón de descriptor visible del sombreador de copia de seguridad hasta que todo el trabajo que usa esa tabla de enlace haya completado la ejecución en la GPU.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-226">A binding table doesn't maintain a strong reference on the descriptor heap that it writes into, so you mustn't release the backing shader-visible descriptor heap until all work using that binding table has completed execution on the GPU.</span></span>

<span data-ttu-id="9cfcd-227">Por otro lado, mientras que una tabla de enlace especifica y administra un montón de descriptores, la tabla no *contiene* ninguna de esa memoria.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-227">On the other hand, while a binding table does specify and manage a descriptor heap, the table doesn't itself *contain* any of that memory.</span></span> <span data-ttu-id="9cfcd-228">Por lo tanto, puede liberar o restablecer una tabla de enlace en cualquier momento después de haber llamado a [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) (no es necesario esperar a que la llamada se complete en la GPU, siempre y cuando los descriptores subyacentes sigan siendo válidos).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-228">So, you may release or reset a binding table any time after you've called [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) with it (you don't need to wait for that call to complete on the GPU, so long as the underlying descriptors remain valid).</span></span>

<span data-ttu-id="9cfcd-229">La tabla de enlace no mantiene referencias seguras en ningún recurso enlazado mediante la &mdash; aplicación debe asegurarse de que los recursos no se eliminen mientras la GPU los esté usando.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-229">The binding table doesn't keep strong references on any resources bound using it&mdash;your application must ensure that resources are not deleted while still in use by the GPU.</span></span> <span data-ttu-id="9cfcd-230">Además, una tabla de enlace no es segura para subprocesos &mdash; la aplicación no debe llamar a métodos de una tabla de enlace simultáneamente desde distintos subprocesos sin sincronización.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-230">Also, a binding table isn't thread safe&mdash;your application must not call methods on a binding table simultaneously from different threads without synchronization.</span></span>

<span data-ttu-id="9cfcd-231">Y tenga en cuenta que, en cualquier caso, el reenlace solo es necesario cuando se cambian los recursos que se enlazan.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-231">And consider that in any case rebinding is necessary only when you change which resources are bound.</span></span> <span data-ttu-id="9cfcd-232">Si no necesita cambiar los recursos enlazados, puede enlazar una vez al inicio y pasar la misma tabla de enlace cada vez que llame a **RecordDispatch**.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-232">If you don't need to change the bound resources, then you can bind once at startup, and pass the same binding table each time you call **RecordDispatch**.</span></span>

<span data-ttu-id="9cfcd-233">Para intercalar las cargas de trabajo de representación y aprendizaje automático, solo tiene que asegurarse de que las tablas de enlace de cada fotograma apunten a los intervalos del montón del descriptor que ya no se usan en la GPU.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-233">For interleaving machine learning and rendering workloads, just ensure that each frame's binding tables points to ranges of the descriptor heap that are not already in use on the GPU.</span></span>

## <a name="optionally-specify-late-bound-operator-bindings"></a><span data-ttu-id="9cfcd-234">Opcionalmente, especifique los enlaces de operador enlazados en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="9cfcd-234">Optionally specify late-bound operator bindings</span></span>

<span data-ttu-id="9cfcd-235">Si está tratando con un operador compilado (en lugar de con un inicializador de operador), tiene la opción de especificar el enlace en tiempo de ejecución para el operador.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-235">If you're dealing with a compiled operator (rather than with an operator initializer), then you have the option to specify late binding for the operator.</span></span> <span data-ttu-id="9cfcd-236">Sin enlace en tiempo de ejecución, debe establecer todos los enlaces en la tabla de enlace antes de grabar un operador en una lista de comandos.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-236">Without late binding, you must set all bindings on the binding table before you record an operator into a command list.</span></span> <span data-ttu-id="9cfcd-237">Con el enlace en tiempo de ejecución, puede establecer (o cambiar) enlaces en operadores que ya ha grabado en una lista de comandos, antes de que se envíen a la cola de comandos.</span><span class="sxs-lookup"><span data-stu-id="9cfcd-237">With late binding, you can set (or change) bindings on operators that you've already recorded into a command list, before it has been submitted to the command queue.</span></span>

<span data-ttu-id="9cfcd-238">Para especificar el enlace en tiempo de ejecución, llame a [**IDMLDevice:: CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) con un `flags` argumento de [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span><span class="sxs-lookup"><span data-stu-id="9cfcd-238">To specify late binding, call [**IDMLDevice::CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) with a `flags` argument of [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span></span>