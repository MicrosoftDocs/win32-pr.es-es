---
title: Diseño de interfaces remotas
description: Con la llegada del modelo de objetos de componentes distribuidos, es importante que la interfaz personalizada sea remota, incluso si piensa utilizarla solo en proceso.
ms.assetid: 2ee4d950-dfd5-4965-bd77-a600e878be59
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3502604d62e6a5129ca3e3538761722909c0198f
ms.sourcegitcommit: 85688bbfbe5b121bc05ddf112d54c23a469dfbc0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/29/2020
ms.locfileid: "103904377"
---
# <a name="designing-remotable-interfaces"></a><span data-ttu-id="bbd49-103">Diseño de interfaces remotas</span><span class="sxs-lookup"><span data-stu-id="bbd49-103">Designing Remotable Interfaces</span></span>

<span data-ttu-id="bbd49-104">Con la llegada del modelo de objetos de componentes distribuidos, es importante que la interfaz personalizada sea remota, incluso si piensa utilizarla solo en proceso.</span><span class="sxs-lookup"><span data-stu-id="bbd49-104">With the advent of the distributed component object model, it is important that your custom interface be remotable, even if you intend to use it in-process only.</span></span>

<span data-ttu-id="bbd49-105">MIDL es algo más que una manera de generar archivos de encabezado para las interfaces.</span><span class="sxs-lookup"><span data-stu-id="bbd49-105">MIDL is more than just a way to generate header files for your interfaces.</span></span> <span data-ttu-id="bbd49-106">Es un lenguaje de programación para la comunicación remota que le permite usar las interfaces en los límites del equipo, el proceso y el subproceso.</span><span class="sxs-lookup"><span data-stu-id="bbd49-106">It is a programming language for remoting that allows you to use your interfaces across machine, process, and thread boundaries.</span></span> <span data-ttu-id="bbd49-107">Esto significa que debe comprobar el comportamiento de las interfaces definidas por MIDL bajo esas condiciones antes de lanzar el programa a los clientes.</span><span class="sxs-lookup"><span data-stu-id="bbd49-107">This means that you need to verify the behavior of your MIDL-defined interfaces under those conditions before you release your program to customers.</span></span> <span data-ttu-id="bbd49-108">Si ha cometido un error en el IDL y la interfaz no se ha reparado correctamente, puede ser difícil solucionar ese error.</span><span class="sxs-lookup"><span data-stu-id="bbd49-108">If you made a mistake in your IDL and the interface is not remoted correctly, it can be difficult to remedy that mistake.</span></span> <span data-ttu-id="bbd49-109">Debe revisar la interfaz con un nuevo IID y dejar el anterior en por compatibilidad con versiones anteriores, o bien debe convertir todos los clientes y cada equipo servidor en todas partes al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="bbd49-109">Either you have to revise your interface with a new IID and leave the old one in for backward compatibility or you have to convert every client and every server machine everywhere at the same time.</span></span>

<span data-ttu-id="bbd49-110">Incluso si la interfaz nunca se va a usar fuera de proceso, se puede usar entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="bbd49-110">Even if your interface will never be used out-of-process, it may be used cross-thread.</span></span> <span data-ttu-id="bbd49-111">El peor problema de un archivo IDL no comprobado puede producirse para los servidores en proceso que no admiten varios apartamentos de un [solo subproceso](single-threaded-apartments.md)).</span><span class="sxs-lookup"><span data-stu-id="bbd49-111">The worst problem for an unchecked IDL file can arise for in-process servers that do not support multiple [single-threaded apartments](single-threaded-apartments.md)).</span></span> <span data-ttu-id="bbd49-112">Un servidor que no especifica un modelo de subprocesos es implícitamente de un solo subproceso.</span><span class="sxs-lookup"><span data-stu-id="bbd49-112">A server that does not specify a threading model is implicitly single-threaded.</span></span> <span data-ttu-id="bbd49-113">Todo lo marcado con un solo subproceso se fuerza al subproceso que primero llamó a [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) o a [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="bbd49-113">Everything marked single-threaded is forced over to the thread that first called [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) or [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="bbd49-114">Si algún otro subproceso era el que activó el objeto, todas las interfaces de ese servidor de un solo subproceso se deben volver a enviar al subproceso de activación, lo que puede dar lugar a una devolución de REGDB \_ E \_ IIDNOTREG en respuesta a una llamada a [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))).</span><span class="sxs-lookup"><span data-stu-id="bbd49-114">If some other thread was the one that activated the object, all the interfaces on that single-threaded server must be remoted back to the activating thread, which can result in a return of REGDB\_E\_IIDNOTREG in response to a call to [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))).</span></span> <span data-ttu-id="bbd49-115">A menos que pueda validar de forma absoluta que la interfaz está en proceso y que siempre se va a llamar en el mismo subproceso, se le llevará a cabo de forma remota en algún momento.</span><span class="sxs-lookup"><span data-stu-id="bbd49-115">Unless you can absolutely assert that your interface is both in-process and always going to be called on the same thread, you will get remoted at some time.</span></span>

<span data-ttu-id="bbd49-116">Por último, como diseñador de la interfaz, debe tener en cuenta el modo en que las aplicaciones cliente usarán la interfaz.</span><span class="sxs-lookup"><span data-stu-id="bbd49-116">Finally, as an interface designer, you need to consider how client applications will use your interface.</span></span> <span data-ttu-id="bbd49-117">Dos cosas, juntas, determinan si una interfaz será eficaz entre los límites del proceso y del equipo: la frecuencia de llamadas a métodos en el límite de la interfaz y la cantidad de datos que se van a transferir en una llamada al método determinada.</span><span class="sxs-lookup"><span data-stu-id="bbd49-117">Two things, together, determine whether an interface will be efficient across process and machine boundaries: the frequency of method calls across the interface boundary, and the amount of data to be transferred in a given method call.</span></span> <span data-ttu-id="bbd49-118">Aunque COM realiza llamadas entre procesos y entre redes transparentes para los programas, no puede hacer que las llamadas de alta frecuencia y alto ancho de banda sean eficaces en los espacios de direcciones.</span><span class="sxs-lookup"><span data-stu-id="bbd49-118">Although COM makes cross-process and cross-network calls transparent to programs, it cannot make high-frequency and high-bandwidth calls efficient across address spaces.</span></span> <span data-ttu-id="bbd49-119">En algunos casos, es más adecuado diseñar interfaces que normalmente se implementarán solo como servidores en proceso, mientras que otras interfaces son más adecuadas para el uso remoto.</span><span class="sxs-lookup"><span data-stu-id="bbd49-119">In some cases, it is more appropriate to design interfaces that will normally be implemented only as in-process servers while other interfaces are more appropriate for remote use.</span></span>

 

 




